---
title: 2的補數
date: 2025-06-20
keywords: c++, java, 2's complement
---
2的補數，把負數變成2進位0和1的方法。

電腦儲存負數也是儲存2的補數。

電腦計算的方式都是用2的補數來計算。

## 名詞介紹
|英文|中文|
|Sign-and-Magnitude|符號數值表示法|
|1's complement|1的補數|
|2's complement|2的補數|

### 符號數值表示法
「符號數值表示法」就是有正負號的二進位。

把最左邊的第1個bit當作正負號，1為負號，0為正號，剩下的bit就跟原本二進位一樣。

1的符號數值表示法 = 00000001

-1的符號數值表示法 = 10000001

### 1的補數
把「符號數值表示法」 \+ 1 = 1的補數

```
 00000001
+       1
-----------
 00000010
```

00000010 為1的補數。

### 2的補數
把1的補數，0與1互換，就是2的補數。

00000010
↓
11111101

把整數1 -> 1的補數 -> 2的補數 -> -1

以上+1變成-1的過程，電腦負數的計算與儲存，都是存2的補數。

## 正整數
正整數的符號數值表示法、1的補數與2的補數都跟二進位一樣，不用再轉換。

|三種表示法|二進位|
|符號數值表示法|與二進位一樣|
|2的補數|與二進位一樣|
|1的補數|與二進位一樣|


正整數最左邊第1個bit是0。

1 2進位 = <span class="markline">0</span>0000001

1 1的補數 = <span class="markline">0</span>0000001

1 2的補數 = <span class="markline">0</span>0000001

## 轉成2的補數
負數就是2的補數，負數不能再轉2的補數。

只有正整數才能轉2的補數。

要把正整數1變成負-1的過程如下:

1的二進位是00000001
↓
0與1互換
↓
11111110
↓
加1
↓
11111111

## 2的補數轉回有正負號的2進位
英文是Convert 2's complement to original binary

什麼時候要把2的補數轉回「有正負號的2進位」？

若計算結果是負數(最左邊第1個bit是1)，負數本身就是2的補數，但電腦只「顯示2進位」，所以要把2的補數轉回「符號數值表示法」。

如何轉回符號數值表示法？

以下是正整數變成負數(2的補數)的過程:

2進位 -> 0與1互換 -> 加1 -> 2的補數

2的補數轉回有正負號的2進位，倒回來計算，以下請注意箭頭方向。

有正負號的2進位 <- 最左邊第1個bit不變，其它0與1互換 <- 減1 <- 2的補數


2的補數 11111111
↓
減1
↓
1111110
↓
最左邊第1個bit不變，其它0與1互換
↓
10000001

<span class="markline">1</span>0000001

注意！左邊第1個bit是正負號，不是$ 2^{7} $，不要把它計算進去，0代表正整數，1代表負數。

後面7個bit才是代表數值。

### 範例1
{% highlight java linenos %}
System.out.println(~ 2);
{% endhighlight %}

2的2進位 = 00000010

\~ 運算子代表0與1互換。


00000010
↓
\~ 0與1互換
↓
11111101


11111101是一個負數，第1個bit是1，是2的補數。

2的補數要轉回「有正負號的2進位」，請注意以下箭頭方向。

有正負號的2進位 <- 最左邊第1個bit不變，其它0與1互換 <- 減1 <- 11111101(2的補數)


11111101
↓
2的補數減1
↓
11111100
↓
第1個bit不變，其它0與1互換
↓
1<span class="markline">0000011</span>

#### 程式碼
{% highlight java linenos %}
public class Test {
  public static void main(String[] args) {
    System.out.println(~ 2);
  }
}
{% endhighlight %}
```
-3
```
執行結果就是-3

## 2的補數變成程式
要如何寫2的補數的程式碼呢？

前一個例子的2的補數11111101

java程式碼
{% highlight java linenos %}
public class Test {
  public static void main(String[] args) {
    // 2的補數程式
    byte b = (byte) 0b11111101;
    // 會自動轉回有正負號的2進位
    System.out.println(b);
  }
}
{% endhighlight %}
```
-3
```

c++程式碼
{% highlight c++ linenos %}
#include <iostream>
using namespace std;
int main() {
  // 2的補數程式
  int8_t b = 0b11111101;
  // 會自動轉回有正負號的2進位
  cout << (int)b << endl;
  return 0;
}
{% endhighlight %}
```
-3
```

## 計算結果為正整數
以下計算結果為正整數，也就是左邊第1個bit是0，不用轉回有正負號的2進位，一開始我就有提到正整數的符號數值表示法、1的補數與2的補數都跟二進位一樣，不用再轉換。

{% highlight java linenos %}
System.out.println(~ -2);
{% endhighlight %}

2的2進位 = 00000010

以下是正整數變成負數的過程:

2進位 -> 0與1互換 -> 加1 -> 2的補數

00000010 -> 11111101 -> 11111110

|過程|轉變過程|
|:---|:-------|
|二進位|00000010|
|1的補數(\+1)|11111101|
|2的補數(0與1互換)|11111110|

得到-2(2的補數) = 11111110

\~ 運算子代表0與1互換，互換結果 = 00000001

|過程|轉變過程|
|:---|:-------|
|二進位|00000010|
|1的補數(\+1)|11111101|
|2的補數(0與1互換)|11111110|
|\~0與1互換|00000001|

00000001已經是正整數，左邊第1個bit是0，不用再反向操作，此為最終結果。

### 程式碼
{% highlight java linenos %}
public class Test {
  public static void main(String[] args) {
    System.out.println(~ -2);
  }
}
{% endhighlight %}
```
1
```

## 位元OR運算子計算
`|`位元OR運算子，有1則1。

{% highlight java linenos %}
  System.out.println(-2 | 3);
{% endhighlight %}

```
11111110 (-2)
00000011 (3)
---------
11111111 
```
or的結果為負數(2的補數)，第1個bit是1。

電腦顯示是2進位，要把2的補數轉回2進位，注意以下箭頭方法。

2進位 <- 最左邊第1個bit不變，其它0與1互換 <- 減1 <- 11111111 

|過程|轉變過程|
|:---|:-------|
|2的補數|11111111 |
|1的補數(減1)|11111110|
|2進位(0與1互換)|10000001|

{% highlight java linenos %}
public class Test {
  public static void main(String[] args) {
    System.out.println(-2 | 3);
  }
}
{% endhighlight %}
```
-1
```
執行結果為-1。

## 其它注意事項
### 0的二進位，1的補數，2的補數都一樣

0 2進位 = 00000000

0 1的補數 = 00000000

0 2的補數 = 00000000

### 8bit的-128
8bit的-128沒辦法轉回正整數二進位，因為8-bit 最大的正整數是127，8bit的負數都有對映的正數，但-128沒有。
{% highlight java linenos %}
public class Test {
  public static void main(String[] args) {
    // -128
    byte b = (byte) 0b10000000;
    System.out.println(b);
  }
}
{% endhighlight %}


C++可以有unsinged正整數，沒有負數。 

Java的數字都有正負號，沒有unsinged正整數。
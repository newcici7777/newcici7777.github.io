{"/pages/c/editor/xcode/": {
    "title": "Xcode",
    "keywords": "",
    "url": "/pages/c/editor/xcode/",
    "body": "輸入Project的名字 選擇要放置的位置，並點選New Folder 輸入新目錄的名稱 要勾不勾git自行決定，按create 點擊main，再按下執行的按鈕"
  },"/pages/jekyll/install/how_to_install_ruby/": {
    "title": "安裝 Ruby on Mac",
    "keywords": "",
    "url": "/pages/jekyll/install/how_to_install_ruby/",
    "body": "打開終端機，輸入下面指令 $brew install ruby 檢查安裝路徑 $brew list ruby homebrew安裝ruby的路徑列表，注意版號是否為3.0以上，目前是3.3.0。 /usr/local/Cellar/ruby/3.3.0/bin/bundle /usr/local/Cellar/ruby/3.3.0/bin/bundler /usr/local/Cellar/ruby/3.3.0/bin/erb /usr/local/Cellar/ruby/3.3.0/bin/gem /usr/local/Cellar/ruby/3.3.0/bin/irb /usr/local/Cellar/ruby/3.3.0/bin/racc /usr/local/Cellar/ruby/3.3.0/bin/rake /usr/local/Cellar/ruby/3.3.0/bin/rbs /usr/local/Cellar/ruby/3.3.0/bin/rdbg /usr/local/Cellar/ruby/3.3.0/bin/rdoc /usr/local/Cellar/ruby/3.3.0/bin/ri /usr/local/Cellar/ruby/3.3.0/bin/ruby /usr/local/Cellar/ruby/3.3.0/bin/syntax_suggest /usr/local/Cellar/ruby/3.3.0/bin/typeprof /usr/local/Cellar/ruby/3.3.0/include/ruby-3.3.0/ (191 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.3.3.dylib /usr/local/Cellar/ruby/3.3.0/lib/pkgconfig/ruby-3.3.pc /usr/local/Cellar/ruby/3.3.0/lib/ruby/ (4276 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.dylib /usr/local/Cellar/ruby/3.3.0/libexec/gembin/ (2 files) /usr/local/Cellar/ruby/3.3.0/share/emacs/site-lisp/ruby/ruby-style.el /usr/local/Cellar/ruby/3.3.0/share/man/ (4 files) /usr/local/Cellar/ruby/3.3.0/share/ri/ (15158 files) 檢查本機ruby的安裝的位置是否與homebrew一致。 $which ruby 我的mac顯示的位置是∶ /usr/bin/ruby 顯然是不一樣，修改環境變數。 $vi ~/.zshrc 添加homebrew 安裝ruby的路徑，注意!以下的位置是你的brew list ruby的路徑，不能直接拷貝我的。 export PATH=\"/usr/local/Cellar/ruby/3.3.0/bin:$PATH\" 修改完.zshrc檔案，在終端機執行以下指令。 $source ~/.zshrc 檢查ruby的路徑是否為homebrew安裝的路徑。 $which ruby"
  },"/pages/c/basic/charType/": {
    "title": "char字元",
    "keywords": "",
    "url": "/pages/c/basic/charType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long char char是正整數，雖然顯示是字元，但實際存放在記憶體位置的資料型態是整數。 char所對映的整數是顯示在瑩幕上的ASCII碼。https://zh.wikipedia.org/zh-tw/ASCII 若輸入單引號''包住的字元，編譯器會自動把單引號包住的字元轉成整數。 比如'a'，記憶體位址存放的十進位值是97，二進制是01100001 整數型態 占用Byte數量 數值範圍 格式符 輸出格式 char 1 0~127 %c 字元 char 1 0~127 %d 整數 字元變數設為數字。 程式碼 1 2 3 char c = 97; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 第一行，直接給整數到c變數。 執行結果 97 a 印出char可用%c格式字串或%d格式字串 1 2 3 char c = 'a'; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 執行結果 97 a int變數設為字元。 在c++中，可以直接給int變數賦值單引號''包住的字元 1 2 3 4 5 int main() { int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; c1 &lt;&lt; endl; return 0; } 執行結果 65 int轉型字元 想印出字元，就把int轉型成char 1 2 int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 執行結果 A 字元運算 也可字元加整數做運算。 1 2 int c1 = 'A' + 2; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 第一行，字元+2。 執行結果 c1=C 字元轉整數 參考https://zh.wikipedia.org/zh-tw/ASCII 字元 ascii code 0 48 1 49 2 50 3 51 4 52 5 53 6 54 7 55 8 56 9 57 字元'0'的ascii code為48 字元'0'到'9'的ascii code - 48 = 整數0到9 舉個例子，'9'的ascii code是57，'0'的ascii code為48， 57 - 48 = 整數9 而char屬於整數，可以直接用字元相減，'9' - '0' = 9 字元'0'到'9'減'0'，則會變成整數0-9。 1 2 3 4 int main() { int num = '9' - '0'; cout &lt;&lt; num &lt;&lt; endl; } 9 大小寫轉換 字元 ascii code 字元 ascii code a 97 A 65 b 98 B 66 c 99 C 67 d 100 D 68 e 101 E 69 f 102 F 70 從上表可以發現小寫的ascii code與大寫的ascii code中間的差距是32。 97 - 65 = 32 98 - 66 = 32 99 - 66 = 32 小寫轉大寫 1 2 char upper = 'a' - 32; cout &lt;&lt; upper &lt;&lt; endl; A 大寫轉小寫 1 2 char lower = 'A' + 32; cout &lt;&lt; lower &lt;&lt; endl; a 判斷字母區間 判斷0-9 1 2 char c = 'A'; if(c &lt; '0' || c &gt; '9') cout &lt;&lt; \"不是數字\" &lt;&lt; endl; 不是數字 判斷a-z 1 2 char c = 'A'; if(c &lt; 'a' || c &gt; 'z') cout &lt;&lt; \"不是小寫字母\" &lt;&lt; endl; 不是小寫字母 判斷A-Z 1 2 char c = 'a'; if(c &lt; 'A' || c &gt; 'Z') cout &lt;&lt; \"不是大寫字母\" &lt;&lt; endl; 不是大寫字母 跳脫字元 重要有以下幾種 Ascii碼 跳脫字元 描述 0 \\0 空，字元變數可設定0 9 \\t TAB鍵對齊 10 \\n 換行 13 \\r 移動到最前面 設定空字元 1 2 char c4 = 0; cout &lt;&lt; \"c4=\" &lt;&lt; c4 &lt;&lt; endl; 執行結果 c4= 關於斜線 因為\"與'與\\，被編譯器作為以下用途。 \"\"，把字串包起來。 ''，把字元包起來。 \\，換行\\n 所以不能直接使用\"與'與\\，必須加上\\“與\\‘與\\\\。 雙引號 1 2 3 char c2 = '\"'; cout &lt;&lt; \"c2=\" &lt;&lt; c2 &lt;&lt; endl; cout &lt;&lt; \"我說，\\\"跑!\\\"\" &lt;&lt; endl; 第1行，當作字元的雙引號，前面不用加斜線'\\\"'，直接寫雙引號就可以'\"'。 第3行，當作字串中的的雙引號，前面要加斜線。 執行結果 c2=\" 我說，\"跑!\" 單引號 1 2 3 char c3 = '\\''; cout &lt;&lt; \"c3=\" &lt;&lt; c3 &lt;&lt; endl; cout &lt;&lt; \"我說，'跑!'\" &lt;&lt; endl; 第1行，當作字元的單引號，前面要加斜線'\\''。 第3行，當作字串中的的單引號，前面不用加斜線。 執行結果 c3=' 我說，'跑!'"
  },"/pages/c/basic/printformat/": {
    "title": "整數與浮點數",
    "keywords": "",
    "url": "/pages/c/basic/printformat/",
    "body": "整數 整數資料型態 整數型態 占用Byte數量 格式字串 取值範圍 int 4 %d -2,147,483,648 至 2,147,483,647 unsinged int 4 %u 0 到 4,294,967,295 short 2 %hd -32,768 至 32,767 unsinged short 2 %hu 0 到 65,535 long 4 %ld -2,147,483,648 至 2,147,483,647 unsinged long 4 %ud 0 到 18,446,744,073,709,551,615 long long 8 %lld -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 unsinged long long 8 %llu 0 到 18,446,744,073,709,551,615 整數相除，去掉小數點，只留正數，不會四捨五入 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; 8/5 &lt;&lt; endl; 執行結果 8/5 = 1 運算式中有低資料型態與高資料型態，低資料型態會自動轉成高資料型態，不需要強制轉型。 1 2 3 4 char c7 = 97; int i1 = 25; long long llong1 = 150000000000; cout &lt;&lt; \"97 + 25 + 150000000000 = \" &lt;&lt; c7 + i1 + llong1 &lt;&lt; endl; 執行結果 97 + 25 + 150000000000 = 150000000122 等號(=)左邊是高資料型態，右邊是低資料型態，低資料型態會自動轉成高資料型態，不需要強制轉型。 1 2 3 char c7 = 97; int i2 = c7; cout &lt;&lt; \"i2 = \" &lt;&lt; i2 &lt;&lt; endl; 執行結果 i2 = 97 等號(=)左邊是整數，右邊是浮點數，浮點數小數點直接去掉，轉換成整數。 1 2 int i3 = 23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 等號(=)右邊超出範圍。 unsigned int最大的值是4294967295。 1 2 3 4 5 6 unsigned int ui1 = 4294967295; unsigned int ui2 = 4294967295 + 1; unsigned int ui3 = 4294967295 + 2; cout &lt;&lt; \"ui1 = \" &lt;&lt; ui1 &lt;&lt; endl; cout &lt;&lt; \"ui2 = \" &lt;&lt; ui2 &lt;&lt; endl; cout &lt;&lt; \"ui3 = \" &lt;&lt; ui3 &lt;&lt; endl; 執行結果 ui1 = 4294967295 ui2 = 0 ui3 = 1 unsigned int最大的值是4294967295，若超出的二進制會被去掉。 超出的二進制 二進制 十進制 輸出結果   11111111 11111111 11111111 11111111 4294967295 4294967295 00000001 00000000 00000000 00000000 00000000 4294967295 + 1 0 00000001 00000000 00000000 00000000 00000001 4294967295 + 2 1 強制轉型 使用強制轉型編譯器不會出現警告。 語法 (資料型態)值、變數、常數、運算式 1 2 int i3 = (int)23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 1 cout &lt;&lt; \"(double)8/5 = \" &lt;&lt; (double)8/5 &lt;&lt; endl; 執行結果 (double)8/5 = 1.6 括號的優先級別比較高 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; (double)(8/5) &lt;&lt; endl; 執行結果 8/5 = 1 以上程式碼先執行(8/5)，也就是整數相除會直接去掉小數點，變成1，1再轉成double資料型態。 整數資料型態都可以使用%d印出，只是印出的精準度不同。 浮點數 浮點數資料型態 有效數字是指準確度的數字，例如float，有7位數字會是正確的，超過7位以上，第8位以後就會不正確。 有效數字範圍:包含小數點前面與後面的所有數字。 浮點數型態 占用Byte數量 格式字串 有效數字範圍 float 4 %f 7位有效數字 double 8 %lf 15-16位有效數字 long double 不少於double %Lf 不少於double 數字有小數點就視為double資料型態 1 2 cout &lt;&lt; \"size of int = \" &lt;&lt; sizeof(8) &lt;&lt; endl; cout &lt;&lt; \"size of double = \" &lt;&lt; sizeof(8.0) &lt;&lt; endl; 執行結果 size of int = 4 size of double = 8 數字最後面有f視作float資料型態 1 cout &lt;&lt; \"size of float = \" &lt;&lt; sizeof(8.0f) &lt;&lt; endl; 執行結果 size of float = 4 float格式字串輸出 1 2 3 float f1 = 3.8f; printf(\"f1 = %f \\n\", f1); printf(\"f1 = %.2f \\n\", f1); 執行結果 f1 = 3.800000 f1 = 3.80 double格式字串輸出 1 2 3 4 float f1 = 3.8; double d1 = 3.8; printf(\"f1 = %f , d1 = %f , d1 = %lf\\n\", f1, d1, d1); printf(\"f1 = %.2f , d1 = %.2f , d1 = %.2lf\\n\", f1, d1, d1); 執行結果 f1 = 3.800000 , d1 = 3.800000 , d1 = 3.800000 f1 = 3.80 , d1 = 3.80 , d1 = 3.80 運算式中有浮點數，其它整數會自動轉型浮點數，不需要強制轉型。 1 cout &lt;&lt; \"8.0/5 = \" &lt;&lt; 8.0/5 &lt;&lt; endl; 執行結果 8/5 = 1.6 有效位數 float有效位數 1 2 float f1 = 123456789.123f;//float 有效數字範圍為7位 printf(\"f1 = %f \\n\", f1); 執行結果 f1 = 123456792.000000 從執行結果可以發現第8位以後數字就不正確。 double有效位數 1 2 double d1 = 123456789.123456789; printf(\"d1 = %lf \\n\", d1); 執行結果 d1 = 123456789.123457 從執行結果可以發現小數點第6位以後數字就不正確。 long dobule有效位數 1 2 long double Ld1 = 123456789.123456789; printf(\"Ld1 = %Lf \\n\", Ld1); 執行結果 Ld1 = 123456789.123457 從執行結果可以發現跟double的結果相同，long double取決於系統是Linux/Mac/Windows，會呈現不同結果。"
  },"/pages/c/basic/scope/": {
    "title": "變數可見範圍與生命週期",
    "keywords": "",
    "url": "/pages/c/basic/scope/",
    "body": "可見範圍(Scope)與生命週期(Lifetime) 區域變數 一對花括號{}包起來的就是程式碼區塊(block)或函式主體(Body)。程式碼區塊可以是if(){}或while(){}的程式碼區塊，但這篇要探討的是只有花括號{}包起來的程式碼區塊。 1 2 3 4 5 6 7 8 9 int main() { int var11 = 100; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 outer var11 = 100 第3行至第6行 在程式碼區塊中{}，所定義的變數都是區域變數，離開{}區塊就不能再讀取了，因為{}區塊中的區域變數已經被系統回收掉。可以想像{}就像是函式一樣。在函式中，函式中定義的變數都是區域變數，離開函式就不能被外部讀取區域變數，因為區域變數已經被系統回收了。 外部變數 在{}區塊中，可以讀取外部變數 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int var11 = 100; int var12 = 200; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; //在`{}`區塊中，可以讀取外部變數 cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 在程式區塊中{}無法讀取同名的外部變數 因為在{}區塊中，同名的外部變數會先被暫時隱藏，直到程式執行時離開{}區塊，區塊內的區域變數被系統回收掉，同名的變數就會將記憶體位置指向外部變數。 程式區塊中{}讀取跟區域變數同名的全域變數 使用::可以讀取全域變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //定義全域變數var11 int var11 = 100; int main() { //定義區域變數var11 int var12 = 200; { //印出區域變數var11 int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; //印出全域變數var11 cout &lt;&lt; \"outer var11 = \" &lt;&lt; ::var11 &lt;&lt; endl; } return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 for程式區塊中的區域變數 變數i的有效範圍，只有在{}程式區塊中，離開{}程式區塊，區域變數i就無法在外部讀取。 1 2 3 for(int i = 0; i &lt; 10; i++) { } 若要變數i也可以在外部使用，可把變數i放在外部。 1 2 3 4 int i = 0; for(; i &lt; 10; i++) { } cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; 執行結果 i = 10 虛擬碼 可以在程式區塊寫虛擬碼，進行驗證，作為之後正式的函式使用。 以下程式碼是在寫參數為指標，將指標宣告記憶體空間。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 { int** pp = &amp;p;//存放指標的位址，要用雙指標 *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } //印出p指標的位址，去p指標的記憶體位址取值，並印出來 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第6行，去雙指標pp的記憶體位址取值，取出來是p的指標記憶體位址，使用new來分配動態配置記憶體空間，並且設值”3”，動態配置完成會回傳記憶體位址，由指標去存位址。 執行結果 p=0x60000000c000,*p=3 虛擬碼執行成功後，將{}程式碼區塊移到main()函式之外，並宣告成函式。 1 2 3 4 5 6 7 8 9 10 11 void initMemory(int** pp) //存放指標的位址，要用雙指標 { *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 initMemory(&amp;p);//指標的位址傳入函式。 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 p=0x600000008030,*p=3"
  },"/pages/c/editor/cmake/": {
    "title": "Cmake on Mac",
    "keywords": "",
    "url": "/pages/c/editor/cmake/",
    "body": "前往下載Cmake 解壓好放在應用程式中 打開CMAKE 按照下圖，選擇Tool-&gt;How to Install For Command Line Use 將以下紅框的部分複製，打開終端機，貼上 貼上後再輸入以下指令 $which cmake 再輸入以下指令 $cmake --version 切記，把版本資訊記起來，如我的版本資訊是cmake version 3.27.5 在你所在.cpp的目錄下建立build目錄 跟build目錄同階層建立CMakeLists.txt的文件 在CMakeLists.txt的文件中輸入以下內容 //VERSION編號是之前查詢的 cmake_minimum_required(VERSION 3.27.5) //第一參數為Project名稱 //Project的版本是1.0.0 project(CPPLessons VERSION 1.0.0) //第一個參數是Project名稱 第二個參數為所使用的cpp add_executable(CPPLessons test.cpp Student.cpp) 建立檔案，依xcode為例，在工作列按滑鼠右鍵，選”New File” 依照下圖建立頭文件 再來建立cpp文件 記得不要勾選要建立頭文件 在test.cpp輸入以下內容 1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; #include \"test.h\" int main() { int a[] = {1,2,3,4}; printf(\"cmake test\"); int b[] = {7,8,9,100}; printf(\"cmake test2\"); return 0; } 打開終端機，進入build的目錄 輸入以下內容(要在build的目錄下做喔) cmake .. 產生以下資訊 輸入make make 輸入./CPPLessons 測試成功"
  },"/pages/c/editor/supportc11/": {
    "title": "Xcode支援C++11以上",
    "keywords": "",
    "url": "/pages/c/editor/supportc11/",
    "body": "選擇專案名 選擇Build Settings 選擇Apple Clang 選擇C++ Language Dialect"
  },"/pages/c/editor/vscode/": {
    "title": "VS on Mac",
    "keywords": "",
    "url": "/pages/c/editor/vscode/",
    "body": "可以參考其它人的影音檔。 https://www.youtube.com/watch?v=iIPST6HQgSc 參考文章 Visual Studio on macOS Using Clang in Visual Studio 若code.沒反應 code . is not working in on the command line for Visual Studio on OS X/Mac"
  },"/pages/c/template/class_template/": {
    "title": "類別模板",
    "keywords": "",
    "url": "/pages/c/template/class_template/",
    "body": "語法 宣告模板 宣告資料型態參數 資料型態參數名 逗號 template &lt; class T1 , class T2&gt; 宣告模板從關鍵字template開始，後接資料型態參數列表（template parameter list），資料型態參數是以class開頭，後接資料型態參數名(T1)。資料型態參數列表是用尖括號括住的一個資料型態參數或者多個資料型態參數，資料型態參數之間以逗號分隔。class也可以用typename互相替換。 宣告類別模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template &lt;class K, class V&gt; class MyMap{ public: MyMap(){} MyMap(K key1, V value1):key(key1),value(value1){} K getKey(){ return key; } V getValue(){ return value; } private: K key; V value; }; 第1行，template為類別模板宣告，&lt;class K, class V&gt;資料型態參數宣告(type parameter)。 第2行，類別模板的名稱為MyMap。 第5行，建構式，初始私有成員key與value。 第6行，取得私有成員key。 第9行，取得私有成員value。 第13行，私有成員key。 第14行，私有成員value。 使用類別模板 1 2 3 4 5 6 7 8 9 10 int main() { MyMap&lt;int,string&gt; myMap(3, \"test\"); cout &lt;&lt; \"myMap key=\" &lt;&lt; myMap.getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap value=\" &lt;&lt; myMap.getValue() &lt;&lt; endl; MyMap&lt;string, string&gt; *myMap_P1 = new MyMap&lt;string,string&gt;(\"abc\",\"def\"); cout &lt;&lt; \"myMap_P1 key=\" &lt;&lt; myMap_P1-&gt;getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap_P1 value=\" &lt;&lt; myMap_P1-&gt;getValue() &lt;&lt; endl; return 0; } 第2行，建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為int，V的資料型態為string，呼叫二個參數的建構式。 第3行，印出值。 第4行，印出值。 第6行，動態配置建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為string，V的資料型態為string，使用new動態配置建立物件，( “abc”,”def”)呼叫二個參數的建構式。 第7行，使用-&gt;印出值。 第8行，使用-&gt;印出值。"
  },"/pages/c/template/stack_template/": {
    "title": "Stack實作(int Array)",
    "keywords": "",
    "url": "/pages/c/template/stack_template/",
    "body": "Stack int陣列實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Stack{ private: int *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new int[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const int&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(int&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; 第3行，私有成員屬性items，資料型態為int指標，指向int陣列的第0筆位址。 第4行，私有成員屬性stacksize，資料型態為int，存放stack最大的容量。 第5行，私有成員屬性top，資料型態為int，記錄目前stack最頂端的index位置。 第8行，建構式，初始化成員stacksize與top。 第10行，動態配置int陣列。 第12行，解構式。 第13行，從記憶體回收items的空間。 第14行，將回收的空間指向null。 第20行，若top位置在0，表示為空。 第25行，若top位置在stacksize代表空間已滿。 第31行，函式是將item推入stack，參數為參考資料型態。 第33行，目前stack最頂端的index位置小於stack最大容量就做if的區塊。 第34行，先做items[top] = item的動作，再做top++的動作。 第42行，參數為參考資料型態，stack彈出頂端的值暫時放置的變數。 第44行，先將top–的動作，再做items[top]的動作。 使用Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } 第2行，建立stack物件，最大存放數量為5。 第3~7行，依序塞入1~5。 第8行，宣告暫時存放變數item。 第9行，若stack不為空就進入循環。 第10行，將stack的頂端拿出來，放在變數item。 第11行，印出item。 執行結果 item = 5 item = 4 item = 3 item = 2 item = 1 Stack typedef實作 將上面的程式修改成自定義資料型態DataType。以下有黃色的部分是有變更的程式碼。 typedef int DataType; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); DataType item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } Stack 模板實作 將上面的程式再修改成模板，以下有黃色的部分是有變更的程式碼。 template &lt;class DataType&gt; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack&lt;int&gt; myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; }"
  },"/pages/c/basic/typicalRange/": {
    "title": "資料型態範圍",
    "keywords": "",
    "url": "/pages/c/basic/typicalRange/",
    "body": "記憶體的最小單位為bit，每一個bit可以存0或1，32位元電腦的cpu有32個bit(4byte)的存放區塊可以存放記憶體位址。 位元bit與位元組byte bit正整數範圍 以下列出1到8個bit可以存放的最大正整數值與正整數範圍。 bit 組合 最大正整數(2進制) 最大正整數(10進制) 可以存放的正整數範圍 1 0/1 1 \\(2^1-1 = 1\\) 0-1 2 00/01/10/11 11 \\(2^2-1 = 3\\) 0-3 3 000/001/010/100/110/101/111 111 \\(2^3-1 = 7\\) 0-7 4 0000/0001/0010…1111 1111 \\(2^4-1 = 15\\) 0-15 5 00000/00001/…11111 11111 \\(2^5-1 = 31\\) 0-31 6 000000/000001/…111111 111111 \\(2^6-1 = 63\\) 0-63 7 0000000/0000001/…1111111 1111111 \\(2^7-1 = 127\\) 0-127 8 00000000/00000001/…11111111 11111111 \\(2^8-1 = 255\\) 0-255 byte正整數範圍 由上表可以推斷，1個byte由8個bit組成，可存放最大正整數為255，可以存放的正整數範圍從0-255，共256個數字。 以下列出1byte到4byte最大可存放的數字。 byte bit 最大正整數(10進制) 1byte 11111111 255 2byte 11111111 11111111 65535 3byte 11111111 11111111 11111111 16777216 4byte 11111111 11111111 11111111 11111111 4294967295 科學記號法顯示 byte bit 科學記號法 1byte 11111111 $2^8-1$ 2byte 11111111 11111111 $2^8 * 2^8 -1= 2^{8+8}-1 = 2 ^{16}-1 $ 3byte 11111111 11111111 11111111 $2^8 * 2^8 * 2^8-1 = 2^{8+8+8}-1$ 4byte 11111111 11111111 11111111 11111111 $2^8 * 2^8 * 2^8 * 2^8-1 = 2^{8+8+8+8}-1 = 2 ^{32}-1 $ 正負數 若資料型態是包含正負數，會將最大整數減半，一半分給正數，一半分給負數。最左邊的第1個bit就會變成正負號，0為正數，1為負數。負數的二進制顯示方式為把正數的二進制0和1互換，最後再加1。 正負數 二進位 正負數 01111111 127 10000001 -127 01111111 11111111 32767 10000000 00000001 -32768 01111111 11111111 11111111 8388607 10000000 00000000 00000001 -8388608 01111111 11111111 11111111 11111111 2147483647 10000000 00000000 00000000 00000001 -2147483648 正負數範圍 占用Byte數量 正負數範圍 1byte -128~127 2byte -32768~32767 3byte -8388608~8388607 4byte -2147483648~2147483647 unsinged正整數 unsigned代表沒有符號，所以只有正整數，不會有負號。 占用Byte數量 正數範圍 1byte 0~255 2byte 0~65535 3byte 0~16777216 4byte 0~4294967295"
  },"/pages/c/basic/boolType/": {
    "title": "bool",
    "keywords": "",
    "url": "/pages/c/basic/boolType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long 整數型態 占用Byte數量 數值範圍 格式字串 輸出格式 bool 1 0 1 %d 整數 0是false，非0為true。 1 2 3 bool b3 = '0'; bool b4 = 0; cout &lt;&lt; \"b3=\" &lt;&lt; b3 &lt;&lt; \",b4=\" &lt;&lt; b4 &lt;&lt; endl; 執行結果 b3=1,b4=0 可使用true跟false設定bool變數 編譯器會自動把true翻譯成整數1，false翻譯成整數0。 1 2 bool b1 = true, b2 = false; cout &lt;&lt; \"b1=\" &lt;&lt; b1 &lt;&lt; \",b2=\" &lt;&lt; b2 &lt;&lt; endl; 執行結果 b1=1,b2=0 bool整數運算 因為bool是整數，所以bool能做整數運算。但bool顯示出來只會是0或1，即便設的值是2，顯示出來的值仍是1。 1 2 3 4 bool b5 = 1; bool b6 = 2; cout &lt;&lt; \"b5 = \" &lt;&lt; b5 &lt;&lt; \", b6 = \" &lt;&lt; b6 &lt;&lt; endl; cout &lt;&lt; \"b5 + b6 = \" &lt;&lt; b5 + b6 &lt;&lt; endl; 執行結果 b5 = 1, b6 = 1 b5 + b6 = 2 cin只能輸0或1，不能輸入true或false 1 2 3 bool b7; cin &gt;&gt; b7; cout &lt;&lt; \"b7 = \" &lt;&lt; b7 &lt;&lt; endl; 執行結果 1 b7 = 1 執行結果 true b7 = 0 證明bool為整數 1 2 3 4 bool b8 = false; char* c5 = (char*)&amp;b8; *c5 = 8; cout &lt;&lt; \"b8 = \" &lt;&lt; b8 &lt;&lt; endl;"
  },"/pages/c/dynamicMemory/memoryLayout/": {
    "title": "記憶體配置",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memoryLayout/",
    "body": "記憶體起始與結束位址。 記憶體開始位址由下表最下方開始，記憶體結束位址在最上方。 開始與結束 位址高低 位址 結束 高 0xFFFFFFFF 0xFFFFFFFE 0xFFFFFFFD 0xFFFFFFFC &#8593; ...... ...... ...... ...... 低 0x00000004 0x00000002 0x00000001 開始0x00000000 記憶體區段 記憶體區段根據位址由高到低分別為Kernel, Stack, 尚位使用區域, Heap, bass, data, code。 位址高低 記憶體區塊 位址成長方向 儲存項目 高 Kernel 作業系統核心 &#8593; Stack &#8595; 區域變數 尚未使用區域 Heap &#8593; 動態配置記憶體 bss segment 未初始化全域變數, 靜態變數 data segment 已初始化全域變數, 靜態變數 低 code segment 常數與程式執行檔 作業系統核心 處理cpu記憶體Devices與應用程式運作。 stack(堆疊) 儲存區域變數的記憶體區塊 儲存區域變數與函式參數與函式傳回值，記憶體大小只有8M，記憶體位址成長的方向是向下成長。 Heap(堆積) 儲存動態配置變數的記憶體區塊 儲存由動態配置(new與malloc)產生的變數，記憶體大小取決電腦實體記憶體大小(可能8GB或更大)，記憶體位址成長的方向是向上成長。 bss segment 記憶體區塊 儲存未初始化全域變數與靜態變數。 data segment 記憶體區塊 儲存已初始化全域變數與靜態變數。 code segment 記憶體區塊 儲存常數與程式執行檔。 變數記憶體位址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;stdio.h&gt; const int global_x = 1; // 儲存於 code segment(常數) int global_y = 1; // 儲存於 data segment(已初始化全域變數） int global_z; // 儲存於 bss(未初始全域變數) int fun1(int param1) { // 儲存於 stack (函式參數) return param1; // 儲存於 stack (函式傳回值) } int main() { const static int x = 1; // 儲存於 code segment(常數) static int y = 1; // 儲存於 data segment(已初始化靜態變數） static int z; // 儲存於 bss(未初始靜態變數) int w = 1; // 儲存於 stack (區域變數) fun1(w); // 儲存於 heap (動態分配指標) char *buf = (char*) malloc(sizeof(char) * 100); // ... free(buf); int* p = new int(3); // 儲存於 heap (動態分配指標) delete p; return 0; } Stack 儲存在Stack的變數，變數離開有效範圍(Scope)後，會由系統自動回收記憶體位址。 Stack記憶體容量8M。 記憶體位址向下成長。 不會memory leak。 以下程式碼在函式中建立三個變數，並觀察三個變數的記憶體位址是由大至小遞減。證明記憶體位址向下成長。 1 2 3 4 5 6 7 8 void funcMemoryLocation() { int var1 = 10; int var2 = 20; int var3 = 30; cout &lt;&lt; \"va1 = \" &lt;&lt; (long long)&amp;var1 &lt;&lt; endl; cout &lt;&lt; \"va2 = \" &lt;&lt; (long long)&amp;var2 &lt;&lt; endl; cout &lt;&lt; \"va3 = \" &lt;&lt; (long long)&amp;var3 &lt;&lt; endl; } 執行結果 va1 = 140702053822444 va2 = 140702053822440 va3 = 140702053822436 Heap 儲存動態配置(new與malloc)產生的變數，由程式設計師手動回收記憶體位址，或待主程式生命周期結束後被系統回收記憶體位址。 Heap記憶體容量取決於電腦的記憶體大小。 記憶體位址向上遞增。 會memory leak。 以下程式碼動態分配建立三個變數，並觀察三個變數的記憶體位址是由小至大增長。證明動態分配記憶體位址向上成長。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int* p1 = new int(10); int* p2 = new int(20); int* p3 = new int(30); cout &lt;&lt; \"p1 address = \" &lt;&lt; (long long)p1 &lt;&lt; endl; cout &lt;&lt; \"p2 address = \" &lt;&lt; (long long)p2 &lt;&lt; endl; cout &lt;&lt; \"p3 address = \" &lt;&lt; (long long)p3 &lt;&lt; endl; delete p1; delete p2; delete p3; p1 = nullptr; p2 = nullptr; p3 = nullptr; return 0; } 執行結果 p1 address = 105553116315664 p2 address = 105553116315680 p3 address = 105553116315696 尚未使用區域 變數在Stack記憶體區塊，位址增長的方向是向下，變數在Heap記憶體區塊，位址增長的方向是向上，未避免Stack與Heap的記憶體位址成長時互相交疊，中間有一個區域是分隔Stack與Heap。"
  },"/pages/c/conversion/explicit/": {
    "title": "強制轉型",
    "keywords": "",
    "url": "/pages/c/conversion/explicit/",
    "body": "將等號(=)右邊的值強制轉型，明確告訴編譯器等號(=)右邊的值的資料型態。 1 int a = (int)8.3; 另一種強制轉型的方式，將值放在括號中()。 1 int a = int(8.3);"
  },"/pages/c/conversion/implicit/": {
    "title": "自動轉型",
    "keywords": "",
    "url": "/pages/c/conversion/implicit/",
    "body": "編譯器根據等號(=)左邊的變數資料型態，決定調用那個轉型函式。 1 int a = 8.3; 等號(=)左邊的變數資料型態是int，等號(=)右邊的值是double，編譯器根據等號(=)左邊的變數資料型態int，把等號(=)右邊的資料型態double轉成int。"
  },"/pages/c/pointer/pointer/": {
    "title": "指標基本觀念",
    "keywords": "",
    "url": "/pages/c/pointer/pointer/",
    "body": "變數位址 每個變數系統會分配”一塊”記憶體位址存放變數，位址通常是用16進制表示。 變數占用的記憶體大小，根據變數的資料型態決定。 假設有一個int資料型態的變數i，占用記憶體4 byte，變數i占的開始位址0x00000008至結束位址0x0000000B，總共占4Byte。 int i = 55; 記憶體開始與結束記憶體位址占用記憶體位址範圍 結束0xFFFFFFFF &#8593;...... 0x0000000E 0x0000000D 0x0000000C 0x0000000Bint i = 55; 0x0000000A 0x00000009 0x00000008 0x00000007 0x00000006 0x00000005 0x00000004 0x00000003 0x00000002 0x00000001 開始0x00000000 取出變數的開始記憶體位址 取位址運算子&amp; &amp;變數 在變數前面加上&amp;可以取出變數的開始記憶體位址，如上一個表格中的例子，變數i的開始位址是0x00000008。 1 2 3 4 5 6 7 int main() { int a = 0; double b = 10.5; cout &lt;&lt; \"變數a位址 = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"變數b位址 = \" &lt;&lt; &amp;b &lt;&lt; endl; return 0; } 執行結果 變數a位址 = 0x7ff7bfeff468 變數b位址 = 0x7ff7bfeff460 指標是一種變數，存放的內容是位址。 以下為宣告一個i1的整數變數，初始值為10。 1 int i1 = 10; 指標變數存放的內容是位址，以下為宣告一個p1的指標變數，存放i1的開始位址。 1 int* p1 = &amp;i1; 指標的大小8byte 指標變數的大小8byte，使用sizeof(指標變數)可以取得指標的大小，不管是什麼資料型態的指標，佔用記憶體的大小全部為8byte。 1 cout &lt;&lt; sizeof(p1) &lt;&lt; endl; 執行結果 8 位址放入指標變數 指標存放的內容是位址，所以要先取得變數的開始位址，再放入指標變數中，使用&amp;可以取得變數開始位址。 1 2 3 4 5 6 7 int main() { int i1 = 10; int* p1 = &amp;i1; cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; return 0; } 第2行，宣告i1整型變數。 第3行，宣告p1整型指標變數，使用取位址運算子&amp;，取出i1變數的記憶體開始位址，將位址放入p1指標。 第4行，印出i1的位址。 第5行，印出p1所存放的內容。 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 從執行結果可以發現，印出的結果是一樣。 宣告指標的各種寫法 宣告指標可以把*放置在變數前面或資料型態後面或資料型態與變數中間，以下都是正確的。 一行宣告一個指標 1 2 3 4 5 6 7 8 9 10 11 int main() { int i1 = 10; int *p1 = &amp;i1; //*在變數前面 int* p2 = &amp;i1; //*在資料型態後面 int * p3 = &amp;i1; //*在資料型態與變數中間 cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; \"p2存放的位址 =\" &lt;&lt; p2 &lt;&lt; endl; cout &lt;&lt; \"p3存放的位址 =\" &lt;&lt; p3 &lt;&lt; endl; return 0; } 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 p2存放的位址 =0x7ff7bfeff468 p3存放的位址 =0x7ff7bfeff468 一行同時宣告多個指標 1 2 3 4 5 6 7 #include &lt;iostream&gt; using namespace std; int main() { char* ptr1,* ptr2,* ptr3; char *ptr4, *ptr5, *ptr6; return 0; } 一行同時宣告指標與整數變數(容易搞混淆的宣告) 1 2 3 4 5 6 7 8 int* p4, num3; //p4是指標 p4 = &amp;ii; //num3為int資料型態的變數 num3 = 20; cout &lt;&lt; \"p4 位址=\" &lt;&lt; p4 &lt;&lt; endl; cout &lt;&lt; \"p4 值=\" &lt;&lt; *p4 &lt;&lt; endl; cout &lt;&lt; \"num3 值=\" &lt;&lt; num3 &lt;&lt; endl; 執行結果 p4 位址=0x7ff7bfdff274 p4 值=10 num3 值=20 取值運算子* 取值運算子*是取得位址中存放的值。指標存放位址，指標也就等於位址。 *指標 以上語法為，取出位址中存放的值，而指標就是位址。 1 2 3 4 5 6 int main() { int i1 = 10; int *p1 = &amp;i1; //將i1變數的位址存到p1指標變數 cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; //取出位址存放的值。 return 0; } 執行結果 取出p1位址的值 = 10 修改位址存放的值* *指標 = 修改的內容 把*放在指標變數前面，就可以在等於(=)後面放入要修改的內容。 1 2 3 4 5 6 7 8 9 10 int main() { int i1 = 10; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; int *p1 = &amp;i1; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; *p1 = 20; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; return 0; } 第6行，把*放在指標變數p1前面，等於(=)後面放入要修改的內容20。 執行結果 取出i1的值 = 10 取出p1位址的值 = 10 取出p1位址的值 = 20 指標資料型態要與值一致 指標是存放位址，不能存放不是位址的值，會編譯錯誤。 1 2 3 4 5 int main() { int i1 = 10; int *p1 = i1; return 0; } 第2行，i1變數是整數10。 第3行，把10塞入指標，因為指標是存放位址，不能放10這個整數，產生編譯錯誤。 印出位址 十六進制 以下的方式印不出char變數的位址。 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; &amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = a 使用(void*)就可以印出16進制的位址 (void*)指標變數 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = 0x7ff7bfeff46b 十進制 (long long)指標變數 因為int只有4byte，位址轉成int整數會超出範圍，使用long long 8byte，就不會有超出數值範圍的問題。 c語言 printf(\"%#x\",指標變數); 使用%#x格式字串就可印出16進制的記憶體位址。 程式碼範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int i1 = 10; int *p1 = &amp;i1; cout &lt;&lt; \"16進制 &amp;i1 = \" &lt;&lt; (void*)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"16進制 p1 = \" &lt;&lt; (void*)p1 &lt;&lt; endl; cout &lt;&lt; \"10進制 &amp;i1 = \" &lt;&lt; (long long)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"10進制 p1 = \" &lt;&lt; (long long)p1 &lt;&lt; endl; printf(\"c語言 &amp;i1 = %#x \\n\",&amp;i1); printf(\"c語言 p1 = %#x \\n\",p1); return 0; } 執行結果 16進制 &amp;i1 = 0x7ff7bfeff468 16進制 p1 = 0x7ff7bfeff468 10進制 &amp;i1 = 140702053823592 10進制 p1 = 140702053823592 c語言 &amp;i1 = 0xbfeff468 c語言 p1 = 0xbfeff468 指標資料型態 指標的資料型態要與記憶體位址中的內容相符。 1 2 3 4 int i = 10; int* p1 = &amp;i; double d = 15.5; double* p2 = &amp;d;"
  },"/pages/c/function/func_param/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/function/func_param/",
    "body": "Prerequisites: 引數 指標參數 函式的參數是指標，代表參數是位址。指標參數語法為資料型態* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是位址，代表可以透過取值運算子*,取出位址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(位址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //函式的參數是指標，代表參數是位址 void func1(int* param1) { //透過取值運算子*,取出位址存放的內容 cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; //使用`*指標 = 修改內容`，修改指標的內容 *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; //使用取位址運算子&amp;，取出var1變數的記憶體開始位址，將位址作為引數Argument傳進函式fun1() func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把位址&amp;var1傳進函式，下面的程式碼是先將位址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式傳回值 如果有一個功能要求函式返回多個值，只有一個函式傳回值根本不夠用，可以把參數作為傳回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include &lt;iostream&gt; using namespace std; //宣告Student類別 class Student { public: //Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} //取出name, mathScore, engScore, historyScore公有方法 string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: //私有成員屬性 string name; double mathScore; double engScore; double historyScore; }; //宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { //找出數學 英文 歷史最大的分數 if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { //建立3個學生物件，利用名字,數學英文歷史成績建立物件 Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; //宣告三個存最大數學 英文 歷史成績的指標 double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); //將Student陣列，陣列大小，最大數學 英文 歷史成績的指標傳入getMax函式 compare(studentArr, 3, mathMax, engMax, historyMax); //印出各科最大分數 cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; return 0; } 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/function/func_param_pointer/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/function/func_param_pointer/",
    "body": "Prerequisites: 引數 指標參數 傳指標是把原始變數的記憶體位址傳給呼叫的函式，傳指標的好處是函式可以存取原始變數。 函式的參數是指標，代表參數是位址。指標參數語法為資料型態* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是位址，代表可以透過取值運算子*,取出位址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(位址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //函式的參數是指標，代表參數是位址 void func1(int* param1) { //透過取值運算子*,取出位址存放的內容 cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; //使用`*指標 = 修改內容`，修改指標的內容 *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; //使用取位址運算子&amp;，取出var1變數的記憶體開始位址，將位址作為引數Argument傳進函式fun1() func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把位址&amp;var1傳進函式，下面的程式碼是先將位址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式傳回值 如果有一個功能要求函式返回多個值，只有一個函式傳回值根本不夠用，可以把參數作為傳回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include &lt;iostream&gt; using namespace std; //宣告Student類別 class Student { public: //Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} //取出name, mathScore, engScore, historyScore公有方法 string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: //私有成員屬性 string name; double mathScore; double engScore; double historyScore; }; //宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { //找出數學 英文 歷史最大的分數 if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { //建立3個學生物件，利用名字,數學英文歷史成績建立物件 Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; //宣告三個存最大數學 英文 歷史成績的指標 double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); //將Student陣列，陣列大小，最大數學 英文 歷史成績的指標傳入getMax函式 compare(studentArr, 3, mathMax, engMax, historyMax); //印出各科最大分數 cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; return 0; } 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/pointer/pointerConst/": {
    "title": "const與指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerConst/",
    "body": "以下二種十分容易混淆，而且十分難記。 Pointer to Const (const*) const右邊是星號* 代表指標位址中的內容是常數，常數不能修改，以下語法不能使用。 *指標 = 修改的內容 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int var1 = 10; //將var1的位址給指標變數p int const * p = &amp;var1; //p指標位址中的內容是常數，常數不能修改，所以不能使用*指標 = 修改的內容 //*p = 11; //印出var1的值與p指標位址中的值 cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=10,p=10 int const * p可以更改成const int* p，二者為一樣的意思，只要記得const右邊若先出現星號*而不是變數名，代表指標位址中的內容是常數，常數沒有辦法修改。 1 2 3 4 5 6 int main() { int var1 = 10; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第3行，int const * p可以更改成const int* p。 可以修改指標指向的記憶體位址 1 2 3 4 5 6 7 8 9 10 11 int main() { int var1 = 10; int var2 = 20; //將var1的位址給指標p const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; //將var2的位址給指標p p = &amp;var2; cout &lt;&lt; \"var2=\" &lt;&lt; var2 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=10,p=10 var2=20,p=20 Const Pointer (const 指標名) const右邊是指標名 代表指標名是常數，需要初始化常數名(初始化設位址)，不能再更改指標指向的記憶體位址。 1 2 3 4 5 6 7 8 9 10 11 int main() { int var1 = 10; int var2 = 11; //const右邊是指標名p，代表指標名p是常數，常數需要初始化，不能是nullptr，將var1的位址給指標p。 int* const p = &amp;var1; //將var2的位址給指標p，會編譯失敗，因為指標p是常數，不能被修改位址。 //p = &amp;var2; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 可以修改內容 可使用*指標 = 修改的內容修改指標位址的值，因為只有指標名是常數，不能變更初始位址，但指標位址中的內容並非常數，所以可以改變指標位址中的內容。 1 2 3 4 5 6 7 int main() { int var1 = 10; int* const p = &amp;var1; *p = 55; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=55,p=55"
  },"/pages/c/basic/simpleTraditionC/": {
    "title": "台陸指標相關名詞差異",
    "keywords": "",
    "url": "/pages/c/basic/simpleTraditionC/",
    "body": "文件相關 英文 台灣 大陸 head file 標頭檔案 頭文件 source file 原始檔案 源文件 STL 函式庫 庫函數 object file 目的檔 目標檔 binary file 機器語言指令 二進制檔案 linking 鏈結 鏈結 process id 進程 行程 資料型態相關 英文 台灣 大陸 Data 資料 數據 Data Type 資料型態 數據類型 typedef 類型別名 別名 int 整數 整型 char 字元 字符 string 字串 字符串 Byte 位元組 字節 bit 位元 位 %d %s 格式化字串或格式化數值輸出 占位符 escape sequence 跳脫字元或逸出字元 轉義字符 運算式相關 英文 台灣 大陸 Operator 運算子 運算符 condition 條件判斷式 表達式 For Loop 巢狀 嵌套 Code block 程式碼區塊 語句塊 Expression statements 運算式 表達式 assign = 指定或指派或設為 賦值 變數相關 英文 台灣 大陸 Variable 變數 變量 Constant 常數 常量 scope 生命周期，可見性，有效範圍 作用域 L-value 等號左邊 左值 R-value 等號右邊 右值 Local Variable 區域變數 局部變量 Global Variable 全域變數，外部變數 全局變量 Parameter 參數 形參 Argument 引數 實參 declaration 宣告 聲明 definition 定義 定義 #define 前置指令 宏 Preprocessor 前置處理器 預處理器 default 預設值 缺省 conversion 轉型 轉換 explicit conversion 強制轉型 顯示轉換或手動轉換 implicit conversion 自動轉型 隱式轉換 Temp Variable 臨時變數 臨時變量 陣列相關 英文 台灣 大陸 Array 陣列 數組 index 索引 下標 row 列 行 column 行 列 函式相關 英文 台灣 大陸 Function 函式 函數 callback 回呼函式 回調函數 return 函式傳回值 函數返回值 指標相關 英文 台灣 大陸 Pointer 指標 指針 pointer to pointer** 指標的指標，雙重指標，指指標 二級指針 Wild pointers   野指針 Dangling pointers   懸空指針 Pointer to Const   常量指針 Const Pointer   指針常量 *dereferences a pointer 取值運算子或間接運算子(indirection) 解引用運算符 &amp; 取位址運算子 取址運算符 &amp;reference variable 參考 引用 call by value 傳值 傳值 call by pointer 傳址 傳地址 call by reference 傳參考 傳引用 記憶體相關 英文 台灣 大陸 Memory 記憶體 內存 Dynamic memory allocation 動態配置記憶體 動態內存分配 free 記憶體回收 記憶體釋放 Stack 堆疊 棧 Heap 堆積 堆 資料結構相關 英文 台灣 大陸 struct 結構 結構體 Linked list 鏈結串列 鏈表 head node 首節點 頭節點 Queue 佇列 隊列 佇列front 前端 頭節點 佇列rear 後端 尾節點 iterator 疊代器 迭代器 物件相關 英文 台灣 大陸 Template 樣板 模板 constructor 建構式或建構子 構造方法 deconstructor 解構式或解構子 析構方法或析構函數 override 覆寫 重寫 overload 多載 重載 enum 列舉 枚舉 class 類別 類 member variable 成員屬性 成員變量 member function 成員方法 成員函數 ::scope resolution operator 範圍運算子 域作用符 Functor 物件函式 仿函數"
  },"/pages/c/dynamicMemory/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會回傳記憶體占用的開始位址。 資料型態* 指標變數 = new 資料型態(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"位址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"位址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 位址是 = 0x600000004010 位址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行回收，否則會產生memory leak，記憶體一直沒被回收，記憶體愈占愈多，最後就會當機。 回收記憶體位址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何位址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/pointer/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會回傳記憶體占用的開始位址。 資料型態* 指標變數 = new 資料型態(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"位址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"位址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 位址是 = 0x600000004010 位址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行回收，否則會產生memory leak，記憶體一直沒被回收，記憶體愈占愈多，最後就會當機。 回收記憶體位址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何位址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/nullptr/": {
    "title": "0 == nullptr == NULL",
    "keywords": "",
    "url": "/pages/c/pointer/nullptr/",
    "body": "nullptr代表沒有指向任何位址 如果對沒有指向任何位址的指標，也就是指標 = nullptr，對這個指標使用*取值運算子，試圖取出位址中的內容，編譯可以通過，但執行時將會出現錯誤。 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第7行，宣告指標p，沒有指向任何位址。 第8行，將指標p傳入函式。 第4行，將指標p使用*取值運算子試圖取出位址中的內容，但由於指標沒有指向任何位址，執行時會產生錯誤。 檢查nullptr 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { if(param1 == nullptr) return; cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第4行，判斷指標是不是沒有指向任何位址，若沒有指向任何位址，函式直接返回，不再往下執行。 delete nullptr delete nullptr 不會有編譯錯誤與執行錯誤，以下程式不會有任何錯誤。 1 2 3 4 5 int main() { int* p = nullptr; delete p; return 0; } NULL 在c的標準函式庫中stddef.h定義了常數NULL就是0與nullptr。 1 2 3 #define NULL 0 //since C++11 #define NULL nullptr 第1行定義常數NULL的值為0，代表沒有指向任何記憶空間 第3行，c++11以後，定義常數NULL為nullptr，代表沒有指向任何記憶空間 0 0，代表沒有指向任何記憶空間 以下為同名函式，但參數不同，一個為int資料型態，一個為int指標，呼叫函式(0)，呼叫的是參數為整數資料型態的函式。 1 2 3 4 5 6 7 8 9 10 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); return 0; } 執行結果 n = 0 轉型 把指標參數設為NULL，呼叫參數為指標的函式，以下這樣寫會出錯。 1 func3(NULL);//指標參數設為NULL 因為編譯不知道你的NULL是整數指標資料型態的NULL，轉型就可以編譯成功，以下三行都可以。 1 2 3 func3(nullptr); func3((int *)nullptr); func3(static_cast&lt;int *&gt;(nullptr)); 第1行，nullptr代表所有資料型態的NULL。 第2行，轉型int指標。 第3行，使用static_cast轉型成int指標，與上一行意思相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); func3((int *)NULL); func3(static_cast&lt;int *&gt;(NULL)); func3(nullptr); return 0; } 執行結果 n = 0 位址 = 0 位址 = 0 位址 = 0 nullptr位址為0 以下程式碼印出nullptr指標的位址，會印出0。 1 2 3 4 5 6 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; delete p; return 0; } 執行結果 0x0 nullptr記憶體位址 0x00000000-0x0000FFFF記憶體位址區間是放置nullptr指標，無法讀取這段記憶體位址區間。 原文 Each process’ virtual address space is split into partitions. On x86 32-Bit Windows, the partition of 0x00000000 - 0x0000FFFF (inclusive) is called NULL-Pointer Assignment Partition. This partition is set aside to help programmers catch NULL-pointer assignments. If a thread in your aprocess attempts to read from or write to a memory address in this partition, an access violoation is raised. 容易混淆寫法 1 2 3 4 int a = 0 ; int * p1 = 0 ; //right int * p2 = NULL ; //right int * p3 = a;//error 第1行定義整數資料型態的a變數，值為0 第2行定義p1指標沒有指向任何記憶體空間 第3行定義p2指標沒有指向任何記憶體空間 第4行錯誤，指標是存放位址，而不是值，不能把整數值0放進指標"
  },"/pages/c/pointer/pointerVoid/": {
    "title": "void*任何資料型態的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerVoid/",
    "body": "(void*)印出16進制的位址 使用(void*)就可以印出16進制的位址 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 變數c位址 = 0x7ff7bfeff46b 函式的參數為void*指標(位址) 函式的參數為void*指標，表示任何資料型態的指標(位址)都可以傳進函式，而且不需要轉型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //宣告printAddr的函式，參數資料型態為void*指標 void printAddr(void* p) { //印出位址 cout &lt;&lt; p &lt;&lt; endl; } int main() { int i = 10; //將整數i變數的位址傳入 printAddr(&amp;i); char c = 'a'; //將字元c變數的位址傳入 printAddr(&amp;c); double d = 150.222; //將浮點數d變數的位址傳入 printAddr(&amp;d); return 0; } 執行結果 0x7ff7bfeff468 0x7ff7bfeff467 0x7ff7bfeff458 函式傳回值為void*指標 表示可以回傳任何資料型態的指標(位址)，可以轉型成任何資料型態指標。 以下為malloc的回傳資料型態void指標(位址)，void指標可以轉成任何資料型態指標，參數size_t __size代表設定空間大小。 1 void* malloc(size_t __size) 使用方式 在heap區段，建立10 byte的記憶體空間，將回傳的位址轉成char資料型態的指標。 1 char *name = (char *)malloc(10);//10byte 在heap區段，建立1mb的記憶體空間，將回傳的位址轉成int資料型態的指標。 1 int *num = (int *)malloc(1 * 1024 * 1024);//1byte*1024 = 1kb -&gt;1kb*1024=1mb 不能對void*指標使用取值運算子* 不能對void*指標使用取值運算子*，需要轉換成其它資料型態的指標才可以使用取值運算子* 1 2 3 4 void printAddr(void* p) { //編譯失敗，不能對p指標使用取值運算子*，因為它是void*指標資料型態，必須轉型後才能對指標取出內容 cout &lt;&lt; *p &lt;&lt; endl; } 1 2 3 4 5 6 7 8 9 void printAddr(void* p) { //先將p指標轉型成char*指標，接著使用`取值運算子*`取出指標位址中的內容 cout &lt;&lt; *(char*)p &lt;&lt; endl; } int main() { char c = 'a'; printAddr(&amp;c); return 0; } 執行結果 a 函式的參數為void 函式的參數為void，代表不接受任何參數。 rand()產生亂數，以下為rand函式的定義，不接受任何參數，回傳int 1 int rand (void); 產生0-100的亂數 1 2 int num = rand()%100; printf(\"rand = %d \\n\", num);"
  },"/pages/c/pointer/wildPointer/": {
    "title": "指標位址是無效內容",
    "keywords": "",
    "url": "/pages/c/pointer/wildPointer/",
    "body": "回收記憶體後的指標 回收指標記憶體位址中的內容，但指標仍指在原本的位址上。 1 2 3 4 5 6 7 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x600000004060 記憶體回收後的位址 = 0x600000004060 如果對已經被回收(清空)的位址進行讀取，讀取的內容不知道是什麼。 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 第7行，讀取已回收記憶體的位址中的內容。 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x60000000c010 讀取位址內容 = -559038448 為避免上面的情況，回收完記憶體，要把記憶體位址設為nullptr 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; p = nullptr; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x0 未初始化的指標 1 2 3 4 5 int main() { int* p; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告未初始化的指標。 第3行,印出位址，印出不知道何處的位址。 執行結果 0x1e 建議把宣告指標要設初始值。 1 2 3 4 5 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告指標，初始化nullptr。 第3行,印出位址，印出0。 執行結果 0x0 函式返回區域變數位址 1 2 3 4 5 6 7 8 9 10 int* func() { int i = 10; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", &amp;i = \" &lt;&lt; &amp;i &lt;&lt; endl; return &amp;i; } int main() { int* p = func(); cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; \", p = \" &lt;&lt; p &lt;&lt; endl; return 0; } 第1行,宣告函式，返回指標。 第3行,印出區域變數i的值與位址。 第4行,返回變數i的位址。 第7行,宣告指標p，取得函式返回的位址。 第8行,印出函式返回的位址中的值，與位址。 執行結果 i = 10, &amp;i = 0x7ff7bfeff44c *p = 32760, p = 0x7ff7bfeff44c 由以上執行結果可以發現區域變數i的位址與返回的位址不同，而且值也不一樣。"
  },"/pages/c/function/functionPointer/": {
    "title": "函式指標",
    "keywords": "",
    "url": "/pages/c/function/functionPointer/",
    "body": "函式指標指向函式的記憶體位址，通過函式指標使用函式。 函式資料型態 函式資料型態是由函式的傳回值資料型態/參數資料型態/參數的數量所組成。 如果多個函式的傳回值資料型態/參數資料型態/參數的數量都一樣，代表這些函式是同一個資料型態。 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 bool func4(string param1); bool func5(string msg); bool func6(string name); 以下二個函式不是相同資料型態。 int func1(int code, string msg); bool func4(string param1); 以下三個函式的函式資料型態為 int (*pf1)(int,string)，其中pf1為函式指標的變數名，可以為任意名稱，名稱前面要有星號*，要用括號()包起來，int為傳回值資料型態，(int,string)為函式參數資料型態與參數數量。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式的函式資料型態為 bool (*pf2)(string)，其中pf2為函式指標的變數名，可以為任意名稱。 bool func4(string param1); bool func5(string msg); bool func6(string name); 宣告函式指標 1 2 3 4 5 6 7 8 9 10 int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { int (*pf1)(int,string); //宣告函式指標變數pf1 pf1 = func1; //將func1函式設給pf1函式指標變數 pf1(404, \"Page not found.\"); //使用函式指標pf1呼叫函式 return 0; } 第1行,宣告函式。 第6行,宣告函式指標變數pf1。 第7行,將func1函式設給pf1函式指標變數。 第8行,使用函式指標pf1呼叫函式。 執行結果 Err code = 404, msg = Page not found. typedef函式指標類型別名 typedef類型別名 語法 typedef 回傳值(*類型別名)(參數1,參數2,參數3 ...); 將前一個宣告函式指標的程式碼 1 int (*pf1)(int,string); 改成下方的程式碼，前面添加typedef，並把pf1改成Func1，Func1可以為任意名字，並放在程式的開頭。 1 typedef int (*Func1)(int,string); 修改完的程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; //宣告Func1類型別名 typedef int (*Func1)(int,string); int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { //宣告指標變數pf1為Func1類型 Func1 pf1; //宣告函式指標變數pf1 pf1 = func1; //函式指標變數pf1設定函式 pf1(404, \"Page not found.\");//使用函式指標pf1呼叫函式 return 0; } 執行結果 Err code = 404, msg = Page not found. 函式參數是函式指標 宣告函式print404Msg()，第一個參數為函式指標，函式的資料型態是傳回值為int，函式指標名為pf1，2個參數資料型態分別為int跟string。 1 2 3 void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } 第1行,宣告函式print404Msg()，第一個參數為函式指標，第二個參數為string資料型態。 第2行,使用函式指標pf1呼叫函式，並把404整數與msg的參數傳進函式。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 執行結果 Err code = 404, msg = Page not Found 函式參數是typedef函式指標類型別名 也可以使用typedef函式指標類型另取別名。 1 2 3 4 5 6 //宣告Func1類型別名 typedef int (*Func1)(int,string); //第一個參數資料型態為Func1 void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; typedef int (*Func1)(int,string); void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 函式指標應用 自定義二個函式指標類型別名 1 2 3 4 5 //宣告類型別名 //傳回值為void，別名為Success，參數資料型態char*指標 typedef void (*Success)(char*); //傳回值為void，別名為Failure，參數類型分別為int，char*指標 typedef void (*Failure)(int, char*); 1 2 3 4 5 6 void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } 第1行,宣告函式，傳回值與參數資料型態都符合函式指標類型別名Success 第4行,宣告函式，傳回值與參數資料型態都符合函式指標類型別名Failure 1 2 3 4 5 6 7 8 9 10 11 12 void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 第1行,宣告函式，第1個參數資料型態int，第2個參數函式指標類型別名Success，第3個參數函式指標類型別名Failure。 第3行,使用函式指標Success呼叫函式。 第5行,使用函式指標Failure呼叫函式，並傳入參數。 第9行,呼叫http函式，並把函式傳回值參數與自定義Success函式資料型態一樣的httpOk函式傳入。 第10行,呼叫http函式，並把函式傳回值參數與自定義Failure函式資料型態一樣的httpFailure函式傳入。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; //函式指標類型別名 typedef void (*Success)(char*); typedef void (*Failure)(int, char*); void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 執行結果 成功，結果:取得資料成功 失敗505，原因:網路連線有問題"
  },"/pages/c/array/array/": {
    "title": "陣列",
    "keywords": "",
    "url": "/pages/c/array/array/",
    "body": "初始化值 資料型態 陣列名[長度] = {值1, 值2, 值3 …}; 若值的數量比長度小，沒有在括號{}中的值預設為0。 1 2 3 4 5 6 7 int main() { int arr[10] = {0,1,2,3}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 資料型態 陣列名[] = {值1, 值2, 值3 …}; 陣列長度 陣列的長度可以用常數、運算式。 常數 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; //使用常數 const int ARR_MAX = 10; int main() { int arr[ARR_MAX] = {0,1,2,3}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 運算式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { double d = 10; //使用運算式設定陣列長度 int arr[sizeof(d)/2] = {0,1,2,3}; int size = sizeof(arr)/sizeof(int); cout &lt;&lt; \"arr size = \" &lt;&lt; size &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr size = 4 arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 陣列中有多少元素？ sizeof(陣列名) / sizeof(陣列資料型態) = 元素個數 sizeof(陣列名) 是取得這個陣列占記憶體的大小。 sizeof(資料型態) 是取得資料資料型態占的記憶體大小，如int占4byte，double占8byte，char占1byte。 陣列中每一個值都初始化為整數0 以下二種寫法都是一樣，初始化為整數0。 資料型態 陣列名[長度] = {0}; 資料型態 陣列名[長度] = {}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {0}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } int arr1[10] = {}; for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 arr1[0] = 0 arr1[1] = 0 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0 memset陣列清空 陣列中每個元素記憶體位址的值設為00000000。 void* memset(void *s, int c, size_t n); 參數1 : 陣列名 參數2 : 整數0 參數3 : 陣列記憶體大小 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } memset(arr, 0, sizeof(arr)); for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 0 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 memcpy() 複製陣列，記憶體內容複製 複製全部元素 陣列中全部的元素(來源陣列)複製到另一個大小相同的陣列(目標陣列)。 需要引入函式庫#include void* memcpy(void* dest, const void* src, size_t n) 參數1 : 目標陣列 參數2 : 來源陣列 參數3 : 陣列記憶體大小，或使用者自行定義要複製的byte。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 int arr1[sizeof(arr) / sizeof(int)]; memcpy(arr1, arr, sizeof(arr)); for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 arr1[4] = 5 arr1[5] = 6 arr1[6] = 7 arr1[7] = 8 arr1[8] = 9 arr1[9] = 10 複製部分元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 //元素全初始化為整數0 int arr1[sizeof(arr) / sizeof(int)] = {0}; //只複製arr陣列8byte的元素 //(8byte/每個元素是4byte)=2，只複製2個元素 memcpy(arr1, arr, 8); for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0"
  },"/pages/c/array/pointerToArray/": {
    "title": "一維陣列與指標",
    "keywords": "",
    "url": "/pages/c/array/pointerToArray/",
    "body": "陣列的記憶體位址是連續的。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; (long long) &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; (long long) &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; (long long) &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; (long long) &amp;array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4]地址 = \" &lt;&lt; (long long) &amp;array[4] &lt;&lt; endl; return 0; } 執行結果 array[0]地址 = 140702053823568 array[1]地址 = 140702053823572 array[2]地址 = 140702053823576 array[3]地址 = 140702053823580 array[4]地址 = 140702053823584 從以上的執行結果可以知道每個位址差距4byte，而且是連續的。 陣列名就是陣列第0個元素的記憶體位址 C++將陣列名視為陣列第0個元素的記憶體位址。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 從以上的執行結果可以知道印出陣列名與使用&amp;取址運算子+陣列名與印出陣列第0個元素位址的結果是一樣的。 陣列運算 陣列名 + 1 陣列名 + 1，位址移動的範圍取決於陣列的資料型態。 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 從以上的執行結果可以知道每次陣列名 + n，移動的位址n * 4byte(陣列的資料型態為int)。 陣列第n個元素的記憶體位址 = 陣列名 + n (&amp;陣列名 + 1) 若是(&amp;陣列名+1)，移動的是整個陣列的記憶體位置。 1 2 3 4 5 6 7 8 9 int main() { int arr[10]; cout &lt;&lt; \"arr位址=\" &lt;&lt; (long long)arr &lt;&lt; endl; //印出arr+1的位址 cout &lt;&lt; \"arr+1位址=\" &lt;&lt; (long long)(arr + 1) &lt;&lt; endl; //印出&amp;arr + 1的位址 cout &lt;&lt; \"&amp;arr + 1位址=\" &lt;&lt; (long long)(&amp;arr + 1) &lt;&lt; endl; return 0; } arr位址=140702053823552 arr+1位址=140702053823556 &amp;arr + 1位址=140702053823592 arr+1是從 arr的記憶體位址(140702053823552)移動4byte，移到140702053823556。 (&amp;arr+1)是移動陣列長度10*4byte = 40 byte，從140702053823552移到140702053823592。 陣列名[索引] 等同 *(陣列名 + 索引) 透過*取值運算子，可以取出記憶體位址存放的內容。 C++編譯器將陣列名[索引] 解釋為 *(陣列名 + 索引) arr[0]與*(arr + 0)是相同的意思，都是對陣列第0個元素的記憶體位址取出存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr值=\" &lt;&lt; *(arr) &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr+0值=\" &lt;&lt; *(arr+0) &lt;&lt; endl; //印出arr[1]的值 cout &lt;&lt; \"arr+1值=\" &lt;&lt; *(arr+1) &lt;&lt; endl; //印出arr[2]的值 cout &lt;&lt; \"arr+2值=\" &lt;&lt; *(arr+2) &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 arr值=10 arr+0值=10 arr+1值=100 arr+2值=200 指標指向陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //印出指標變數p，也就是印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 p指標內容 = 0x7ff7bfeff450 p指標內容為陣列名的地址。 指標運算與陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //指標變數p + 0，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //指標變數p + 1，印出第1個元素記憶體位址 cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //指標變數p + 2，印出第2個元素記憶體位址 cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //指標變數p + 3，印出第3個元素記憶體位址 cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 array[1]地址 = 0x7ff7bfeff454 array[2]地址 = 0x7ff7bfeff458 array[3]地址 = 0x7ff7bfeff45c p指標內容 = 0x7ff7bfeff450 p指標+0 = 0x7ff7bfeff450 p指標+1 = 0x7ff7bfeff454 p指標+2 = 0x7ff7bfeff458 p指標+3 = 0x7ff7bfeff45c 由以上的結果可知，指標 + 1 與 &amp;array[1]的結果是一樣的。 指標運算取值 透過*取值運算子，可以取出記憶體位址存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; //指標變數p + 0使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; //指標變數p + 1使用取值運算子，取出第1個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; //指標變數p + 2使用取值運算子，取出第2個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; //指標變數p + 3使用取值運算子，取出第3個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; //指標變數p + 4使用取值運算子，取出第4個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 *(指標 + 索引) 等同 指標[索引] C++編譯器將指標[索引] 解釋為 *(指標 + 索引) 指標就是存放記憶體位址，陣列名就是陣列第0個元素的記憶體位址，陣列名也是記憶體位址，所以陣列名[索引]等同記憶體位址[索引]，而指標是記憶體位址，等同記憶體位址[索引]，二者是相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; int* p = array; cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; //使用指標[索引]的方式，把記憶體位址存放的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引3] = \" &lt;&lt; p[3] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引4] = \" &lt;&lt; p[4] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 p指標[索引0] = 1 p指標[索引1] = 2 p指標[索引2] = 3 p指標[索引3] = 4 p指標[索引4] = 5 記憶體位址[索引] 等同 *(記憶體位址 + 索引) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //印出陣列名[索引2]的記憶體位址 cout &lt;&lt; \"記憶體位址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; //&amp;陣列名[索引2]，代表取出陣列名[索引2]的記憶體位址，使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址 = \" &lt;&lt; *(&amp;array[2]) &lt;&lt; endl; //&amp;陣列名[索引2]+0，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+0 = \" &lt;&lt; *(&amp;array[2] + 0) &lt;&lt; endl; //&amp;陣列名[索引2]+1，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+1 = \" &lt;&lt; *(&amp;array[2] + 1) &lt;&lt; endl; //&amp;陣列名[索引2]+2，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+2 = \" &lt;&lt; *(&amp;array[2] + 2) &lt;&lt; endl; //(&amp;陣列名[索引2])[0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引0] = \" &lt;&lt; (&amp;array[2])[0] &lt;&lt; endl; //(&amp;陣列名[索引2])[1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引1] = \" &lt;&lt; (&amp;array[2])[1] &lt;&lt; endl; //(&amp;陣列名[索引2])[2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引2] = \" &lt;&lt; (&amp;array[2])[2] &lt;&lt; endl; //取出陣列名[索引2]的記憶體位址指派給指標變數p int* p = &amp;array[2]; //指標[索引0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; //指標[索引1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; //指標[索引2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 3 *p指標+0 = 3 *p指標+1 = 4 *p指標+2 = 5 記憶體位址[索引0] = 3 記憶體位址[索引1] = 4 記憶體位址[索引2] = 5 p指標[索引0] = 3 p指標[索引1] = 4 p指標[索引2] = 5 陣列與指標與迴圈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); for(int i = 0; i &lt; size; i++) { //印出array[i]記憶體位址 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 記憶體位址 = \" &lt;&lt; &amp;array[i] &lt;&lt; endl; //印出array + i記憶體位址 cout &lt;&lt; \"array+\"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; array + i &lt;&lt; endl; //印出array[i]的值 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 的值 = \" &lt;&lt; array[i] &lt;&lt; endl; //印出*(array + i)的值 cout &lt;&lt; \"*(array+\"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(array + i) &lt;&lt; endl; } //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for(int i = 0; i &lt; size; i++) { //印出p + i的記憶體位址 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; p + i &lt;&lt; endl; //印出*(p + i)記憶體位址存放的值 cout &lt;&lt; \"*(p + \"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(p + i) &lt;&lt; endl; } return 0; } 執行結果 array[0] 記憶體位址 = 0x7ff7bfeff450 array+0 記憶體位址 = 0x7ff7bfeff450 array[0] 的值 = 1 *(array+0) 的值 = 1 array[1] 記憶體位址 = 0x7ff7bfeff454 array+1 記憶體位址 = 0x7ff7bfeff454 array[1] 的值 = 2 *(array+1) 的值 = 2 array[2] 記憶體位址 = 0x7ff7bfeff458 array+2 記憶體位址 = 0x7ff7bfeff458 array[2] 的值 = 3 *(array+2) 的值 = 3 array[3] 記憶體位址 = 0x7ff7bfeff45c array+3 記憶體位址 = 0x7ff7bfeff45c array[3] 的值 = 4 *(array+3) 的值 = 4 array[4] 記憶體位址 = 0x7ff7bfeff460 array+4 記憶體位址 = 0x7ff7bfeff460 array[4] 的值 = 5 *(array+4) 的值 = 5 p + 0 記憶體位址 = 0x7ff7bfeff450 *(p + 0) 的值 = 1 p + 1 記憶體位址 = 0x7ff7bfeff454 *(p + 1) 的值 = 2 p + 2 記憶體位址 = 0x7ff7bfeff458 *(p + 2) 的值 = 3 p + 3 記憶體位址 = 0x7ff7bfeff45c *(p + 3) 的值 = 4 p + 4 記憶體位址 = 0x7ff7bfeff460 *(p + 4) 的值 = 5 陣列與指標遞增遞減 指標++ int array[5] = {1,2,3,4,5}; int* p = array; 將陣列第0個元素的記憶體位址指定至指標變數p。 指標運算 記憶體位址 記憶體位址存放的值 p + 0 140702053823568 1 p + 1 140702053823572 2 p + 2 140702053823576 3 p + 3 140702053823580 4 p + 4 140702053823584 5 指標變數p指向的是一個整數資料型態(4byte)的地址，每一次p + 1，指標變數p就會移動4byte。 p++也就是等於 p = p + 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for(int i = 0; i &lt; size; i++) { //印出指標變數p的內容(指標存放的內容是記憶體位址) cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; (long long)p &lt;&lt; endl; //印出指標變數p記憶體位址存放的值 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 的值 = \" &lt;&lt; *p &lt;&lt; endl; //p = p + 1，指標變數移動4byte，將移動後的記憶體位址指派給指標變數p p++; } return 0; } 執行結果 p + 0 記憶體位址 = 140702053823568 p + 0 的值 = 1 p + 1 記憶體位址 = 140702053823572 p + 1 的值 = 2 p + 2 記憶體位址 = 140702053823576 p + 2 的值 = 3 p + 3 記憶體位址 = 140702053823580 p + 3 的值 = 4 p + 4 記憶體位址 = 140702053823584 p + 4 的值 = 5 *ptr++ 指標先取出記憶體位址存放的值，再往下一個位址移動。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for(int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*ptr++); } 執行結果 值= 10 值= 100 值= 200 *++ptr 指標先往下一個記憶體位址移動，再取出記憶體位址存放的值。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for(int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*++ptr); } 執行結果 值= 100 值= 200 值= 0 ptr--指標遞減 將指標指向前一個記憶體位址 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //取得陣列中最後一個值的記憶體位址 int *ptr = &amp;arr[2]; for(int i = 3; i &gt; 0; i--) { printf(\"arr[%d]:記憶體位址= %#x\\n\",i ,ptr); printf(\"arr[%d]:值= %d\\n\",i ,*ptr); //將指標指向前一個記憶體位址 ptr--; } 執行結果 arr[3]:記憶體位址= 0xbfdff37c arr[3]:值= 200 arr[2]:記憶體位址= 0xbfdff378 arr[2]:值= 100 arr[1]:記憶體位址= 0xbfdff374 arr[1]:值= 10 陣列名是常數，不可修改 指標變數p可以設為其它記憶體位址。 p = p + 1; p++; 陣列名無法再設為其它記憶體位址，以下的語法無法編譯成功。 array = array + 1; array++; 記憶體位址轉型 以下程式碼將字元陣列轉型成整數陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //宣告字元陣列 大小20byte char array[20]; //將字元陣列的記憶體空間轉型成整數資料型態的記憶體空間 //把轉型成整數型態的陣列[0]位址，指派給整數型態的指標變數p int* p = (int*)array; //sizeof(陣列名)取得陣列全部記憶體大小為20byte //再除以整數資料型態的大小sizeof(int) = 4byte int size = sizeof(array)/sizeof(int); cout &lt;&lt; \"size = \" &lt;&lt; size &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { p[i] = i;//修改記憶體位址中存放的值 //上面的寫法與下面的寫法是相同意思 //*(p + i) = i; } for(int i = 0; i &lt; size; i++) { //印出記憶體位址存放的值 cout &lt;&lt;\"*(p + \"&lt;&lt; i &lt;&lt;\") = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } 執行結果 *(p + 0) = 0 *(p + 1) = 1 *(p + 2) = 2 *(p + 3) = 3 *(p + 4) = 4 函式的參數為指向陣列的指標 參數的寫法有下面二種，因為傳入的參數是指標，對指標用sizeof(指標)，只會得到8byte，所以一定要傳入陣列的長度，或者把陣列的長度設為常數。 void func(int* arr, int len); 參數1，指標變數名arr。 參數2，陣列長度。 void func(int arr[], int len); 參數1，指標變數名arr[]，使用陣列表示法不代表是陣列，而是指標。 參數2，陣列長度。 以下程式碼為傳陣列給函式的寫法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; void func(int arr[], int len) { cout &lt;&lt; \"arr指標大小 = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; for(int i = 0; i &lt; len; i++) { //使用*(陣列名 + 索引)印出陣列元素，也可以使用陣列名[索引]的方式印出陣列元素 cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; *(arr + i) &lt;&lt; endl; } } int main() { int array[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; //參數1傳入陣列名，陣列名為陣列第0個元素的記憶體位址，參數2傳入陣列大小 func(array,sizeof(array)/sizeof(int)); } 執行結果 arr指標大小 = 8 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr[10] = 11 arr[11] = 12 arr[12] = 13 arr[13] = 14 arr[14] = 15"
  },"/pages/c/pointer/pointerArithmetic/": {
    "title": "指標運算",
    "keywords": "",
    "url": "/pages/c/pointer/pointerArithmetic/",
    "body": "指標 + 1，位址增減取決於記憶體位址中存放內容的資料型態。 為了方便看出來差異，以下的位址全轉型成long long長整數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; int main() { char c; //印出char的大小 cout &lt;&lt; \"sizeof(char) = \" &lt;&lt; sizeof(c) &lt;&lt; endl; //印出變數c的位址 cout &lt;&lt; \"c的地址 = \" &lt;&lt; (long long)&amp;c &lt;&lt; endl; //印出變數c的地址往後移動一格的位址，與變數c的位址相差為1byte cout &lt;&lt; \"c的地址 + 1 = \" &lt;&lt; (long long)(&amp;c + 1) &lt;&lt; endl; int i; //印出int的大小 cout &lt;&lt; \"sizeof(int) = \" &lt;&lt; sizeof(i) &lt;&lt; endl; //印出變數i的位址 cout &lt;&lt; \"i的地址 = \" &lt;&lt; (long long)&amp;i &lt;&lt; endl; //印出變數i的地址往後移動一格的位址與變數i的位址相差為4byte cout &lt;&lt; \"i的地址 + 1 = \" &lt;&lt; (long long)(&amp;i + 1) &lt;&lt; endl; double d; //印出double的大小 cout &lt;&lt; \"sizeof(double) = \" &lt;&lt; sizeof(d) &lt;&lt; endl; //印出變數d位址 cout &lt;&lt; \"d的地址 = \" &lt;&lt; (long long)&amp;d &lt;&lt; endl; //印出變數d的地址往後移動一格的位址，與變數d的位址相差為8byte cout &lt;&lt; \"d的地址 + 1 = \" &lt;&lt; (long long)(&amp;d + 1) &lt;&lt; endl; return 0; } 執行結果 sizeof(char) = 1 c的地址 = 140702053823595 c的地址 + 1 = 140702053823596 sizeof(int) = 4 i的地址 = 140702053823588 i的地址 + 1 = 140702053823592 sizeof(double) = 8 d的地址 = 140702053823576 d的地址 + 1 = 140702053823584"
  },"/pages/c/pointer/pointerToPointer/": {
    "title": "指標的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerToPointer/",
    "body": "Prerequisites: 引數 指標的指標，意思是指標的記憶體位址。 指標的位址 1 2 3 4 5 6 7 8 9 10 int main() { int i = 40; cout &lt;&lt; \"i的值 = \" &lt;&lt; i &lt;&lt; \"，i的位址 = \" &lt;&lt; &amp;i &lt;&lt; endl; int *p = &amp;i; cout &lt;&lt; \"指標p指向的位址 = \" &lt;&lt; p &lt;&lt; \"，指標p的位址 = \" &lt;&lt; &amp;p &lt;&lt; \"，指標p指向位址的值=\" &lt;&lt; *p &lt;&lt; endl; int **pp = &amp;p; cout &lt;&lt; \"指標pp指向的位址 = \" &lt;&lt; pp &lt;&lt; \"，指標pp的位址 = \" &lt;&lt; &amp;pp &lt;&lt; \"，指標pp指向的位址(p)指向的位址(i)=\" &lt;&lt; *pp &lt;&lt; endl; cout &lt;&lt; \"指標pp指向的位址(p)指向的位址(i)的值=\" &lt;&lt; **pp &lt;&lt; endl; return 0; } i的值 = 40，i的位址 = 0x7ff7bfeff468 指標p指向的位址 = 0x7ff7bfeff468，指標p的位址 = 0x7ff7bfeff460，指標p指向位址的值=40 指標pp指向的位址 = 0x7ff7bfeff460，指標pp的位址 = 0x7ff7bfeff458，指標pp指向的位址(p)指向的位址(i)=0x7ff7bfeff468 指標pp指向的位址(p)指向的位址(i)的值=40 其它程式碼解釋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { int i4 = 40; //宣告一個指標存i4的位址 int *p2 = &amp;i4; //將p2指標的位址傳給pp2 int **pp2 = &amp;p2; //1.把pp2存放的位址，使用取值運算子*，也就是指標p2的位址 //*pp2; //2.再把p2位址，使用取值運算子*，也就是40 //**pp2 printf(\"解出pp2的值:%d\\n\",**pp2); return 0; } 執行結果 解出pp2的值:40 函式參數為指標的指標 在函式中若要修改指標所指向的記憶體位址，就要用到指標的指標。 引數為指標的位址，函式參數宣告為指標資料型態** 指標變數，這樣才可以接收指標的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函數並嘗試對其進行修改，則對指標所做的更改不會反映回該函數外部。這是因為僅將指標的副本傳遞給函數。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函數內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變量，而原始指標保持不變。 函式語法 回傳型態 函式名(指標資料型態** 指標) { *指標 = 其它記憶體位址 } 呼叫函式語法 函式(&amp;指標位址) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &amp;global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &amp;var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 指標的指標與new 參考文章 參考指向指標與new new會返回動態配置記憶體的開始位址，將p_to_p使用*取值運算子修改p指向的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 指標是p_to_p，指向外部指標的位址 void initAddress(int** p_to_p){ //印出指向外部指標p的記憶體位址 cout &lt;&lt; \"Before p address = \" &lt;&lt; *p_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 //使用*取值運算子修改指標p指向的位址 *p_to_p = new int(10); //印出指向外部指標的記憶體位址與值 cout &lt;&lt; \"After p address= \" &lt;&lt; *p_to_p &lt;&lt; \",After p value = \" &lt;&lt; **p_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p的位址 initAddress(&amp;p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before p address = 0x0 After p address= 0x60000000c010,After p value = 10 == outside == outside pointer address = 0x60000000c010，outside pointer value = 10"
  },"/pages/c/array/dynamicArrays/": {
    "title": "陣列與動態配置記憶體",
    "keywords": "",
    "url": "/pages/c/array/dynamicArrays/",
    "body": "參考文件 new/delete 建立陣列記憶體位址 資料型態 *陣列名 = new 資料型態[長度]; new回傳值是陣列第0筆元素記憶體位址，由指標(*陣列名)接收回傳的記憶體位址。 記憶體回收 delete[] 指標變數; 不能使用sizeof() 因為陣列名是指標，使用sizeof(陣列名)只會回傳8btye 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int main() { //分配連續100個int的記憶體空間 int *arr_p = new int[100]; cout &lt;&lt; \"使用陣列索引:\" &lt;&lt; endl; //使用索引修改陣列的元素 for(int i = 0; i &lt; 100; i++) { arr_p[i] = i; } //使用索引印出陣列的元素 for(int i = 0; i &lt; 100; i++) { cout &lt;&lt; arr_p[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; cout &lt;&lt; \"使用指標:\" &lt;&lt; endl; //使用指標修改陣列的元素 for(int i = 0; i &lt; 100; i++) { *(arr_p + i) = i + 100; } //使用指標印出陣列的元素 for(int i = 0; i &lt; 100; i++) { cout &lt;&lt; *(arr_p + i) &lt;&lt; \",\"; } cout &lt;&lt; endl; //陣列記憶體回收 delete[] arr_p; //指標設為nullptr代表不指向任何記憶體位址 arr_p = nullptr; return 0; } 執行結果 使用陣列索引: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99, 使用指標: 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199, 陣列其它用法 全設為0 int *arr_p1 = new int[3](); 設定初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; int main() { //全設0 int *arr_p1 = new int[3](); // 0,0,0 //設初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 //用索引取值 cout &lt;&lt; arr_p1[0] &lt;&lt; \",\" &lt;&lt; arr_p1[1] &lt;&lt; \",\" &lt;&lt; arr_p1[2] &lt;&lt; endl; //用指標取值 cout &lt;&lt; *(arr_p2 + 0) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 1) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 2) &lt;&lt; endl; //記憶體回收 delete [] arr_p1; delete [] arr_p2; //指標設為不指向任何記憶體位址 arr_p1 = nullptr; arr_p2 = nullptr; return 0; } 執行結果 0,0,0 1,2,3"
  },"/pages/c/array/charArray/": {
    "title": "char 字串",
    "keywords": "",
    "url": "/pages/c/array/charArray/",
    "body": "空字元(null character) char字串必須以’\\0’做結尾，若不是’\\0’做結尾則稱為char陣列。 宣告字串，必須留1個字元，放結尾\\0，以下宣告最多可以放5個字元，而第6個字元則是放\\0。 char str[6]; 以下二種宣告是完全不同，一個是字串，一個是陣列。 1 2 3 4 5 6 7 8 //char字串 // \\0 代表結尾 char str1[6] = {'h','e','l','l','o','\\0'}; cout &lt;&lt; \"str1 長度 = \" &lt;&lt; strlen(str1) &lt;&lt; \",內容 = \" &lt;&lt; str1 &lt;&lt; endl; //char 陣列 char arr[6] = {'h','e','l','l','o','o'}; cout &lt;&lt; \"arr 長度 = \" &lt;&lt; strlen(arr) &lt;&lt; \",內容 = \" &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; \"arr sizeof = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; 執行結果 str1 長度 = 5,內容 = hello arr 長度 = 11,內容 = helloohello arr sizeof = 6 字串常數 注意!以下”“雙引號包住的字串是常數，編譯器會自動加上’\\0’作結尾，不用手動加’\\0’。 1 2 //字串常數 char str1[] = \"hello\" 字串常數宣告 以下程式碼，cstr1沒有初始化字串常數，執行程式時會從cstr1的記憶體位址開始輸出值，直到遇到記憶體位址的值為\\0(空字元)才會停止輸出，不會因為超過宣告字串的長度而停止印出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; int main() { char cstr1[21];//cstr1沒有初始化字串常數 //遇到記憶體位址的值為\\0(空字元)才會停止輸出 cout &lt;&lt; \"cstr1 長度 = \" &lt;&lt; strlen(cstr1) &lt;&lt; \",內容 = \" &lt;&lt; cstr1 &lt;&lt; endl; //以下結尾編譯器會自動加上\\0 char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; char cstr3[6] = \"hello\"; cout &lt;&lt; \"cstr3 長度 = \" &lt;&lt; strlen(cstr3) &lt;&lt; \",內容 = \" &lt;&lt; cstr3 &lt;&lt; endl; char cstr4[] = {\"hello\"}; cout &lt;&lt; \"cstr4 長度 = \" &lt;&lt; strlen(cstr4) &lt;&lt; \",內容 = \" &lt;&lt; cstr4 &lt;&lt; endl; char cstr5[6] = {\"hello\"}; cout &lt;&lt; \"cstr5 長度 = \" &lt;&lt; strlen(cstr5) &lt;&lt; \",內容 = \" &lt;&lt; cstr5 &lt;&lt; endl; char cstr6[6] {\"hello\"}; cout &lt;&lt; \"cstr6 長度 = \" &lt;&lt; strlen(cstr6) &lt;&lt; \",內容 = \" &lt;&lt; cstr6 &lt;&lt; endl; //設為nullptr char cstr7[6] = {0}; cout &lt;&lt; \"cstr7 長度 = \" &lt;&lt; strlen(cstr7) &lt;&lt; \",內容 = \" &lt;&lt; cstr7 &lt;&lt; endl; return 0; } 執行結果 cstr1 長度 = 6,內容 = p\\364\\357\\277\\367 cstr2 長度 = 5,內容 = hello cstr3 長度 = 5,內容 = hello cstr4 長度 = 5,內容 = hello cstr5 長度 = 5,內容 = hello cstr6 長度 = 5,內容 = hello cstr7 長度 = 0,內容 = 字串清空 使用memset，第二個參數設為0，代表把字串的記憶體位址的值全設為\\0。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; memset(cstr2,0,sizeof(cstr2)); cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } 執行結果 cstr2 長度 = 5,內容 = hello cstr2 長度 = 0,內容 = 字串拷貝 strcpy char * strcpy ( char * destination, const char * source ); 要從來源的字串，拷貝到目的字串。 參數1:目的字串(拷貝到那裡？) 參數2:來源字串(要拷貝的字串) 拷貝完成後，會自動在目的字串最後面加上\\0。 1 2 3 4 char c_str1[6] = {'h','e','l','\\0'}; char c_str4[20] = {'t','e'}; strcpy(c_str4, c_str1); cout &lt;&lt; \"c_str4:\" &lt;&lt; c_str4 &lt;&lt; endl; 執行結果 c_str4:hel 字串指標拷貝 strcpy 1 2 3 4 5 6 char* c_str1 = new char[100]; strcpy(c_str1, \"abcdefg\"); char* c_str2 = new char[100]; strcpy(c_str2, c_str1); cout &lt;&lt; \"c_str1 = \" &lt;&lt; c_str1 &lt;&lt; endl; cout &lt;&lt; \"c_str2 = \" &lt;&lt; c_str2 &lt;&lt; endl; c_str1 = abcdefg c_str2 = abcdefg 字串修改 不能使用等於=修改字串，以下語法會編譯錯誤。 1 2 char c_str1[6] = \"Hello\"; c_str1 = \"abc\"; 使用strcpy修改字串。 1 2 3 4 char c_str1[6] = \"Hello\"; cout &lt;&lt; \"Before = \" &lt;&lt; c_str1 &lt;&lt; endl; strcpy(c_str1,\"Dog\"); cout &lt;&lt; \"After = \" &lt;&lt; c_str1 &lt;&lt; endl; Before = Hello After = Dog 字元個數拷貝 strncpy char *strncpy(char *string1, const char *string2, size_t count); 參數1:目的字串(拷貝到那裡？) 參數2:來源字串(要拷貝的字串) 參數3:要拷貝多少個字元 若參數3(拷貝多少個字元)比參數2(來源字串長度)小，拷貝完成後，不會在參數1(目的字串)的結尾加上\\0。 1 2 3 4 5 6 7 8 9 10 11 12 13 char c_str4[10]; //拷貝2個字元至c_str4 strncpy(c_str4,\"hello\",2); cout &lt;&lt; \"c_str4[0] = \" &lt;&lt; c_str4[0] &lt;&lt; endl; cout &lt;&lt; \"c_str4[1] = \" &lt;&lt; c_str4[1] &lt;&lt; endl; cout &lt;&lt; \"c_str4[2] = \" &lt;&lt; c_str4[2] &lt;&lt; endl; cout &lt;&lt; \"c_str4[3] = \" &lt;&lt; c_str4[3] &lt;&lt; endl; cout &lt;&lt; \"c_str4[4] = \" &lt;&lt; c_str4[4] &lt;&lt; endl; cout &lt;&lt; \"c_str4[5] = \" &lt;&lt; c_str4[5] &lt;&lt; endl; cout &lt;&lt; \"c_str4[6] = \" &lt;&lt; c_str4[6] &lt;&lt; endl; cout &lt;&lt; \"c_str4[7] = \" &lt;&lt; c_str4[7] &lt;&lt; endl; cout &lt;&lt; \"c_str4[8] = \" &lt;&lt; c_str4[8] &lt;&lt; endl; cout &lt;&lt; \"c_str4[9] = \" &lt;&lt; c_str4[9] &lt;&lt; endl; 以下XCode可以正常執行，會在第2個字元以後補上\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = \u001e c_str4[3] = VS Code執行時，不會在第2個字元以後自動補\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = &amp; c_str4[3] = x00 c_str4[4] = x00 c_str4[5] = x00 c_str4[6] = x00 c_str4[7] = x00 c_str4[8] = x00 c_str4[9] = x00 若一開始把字串的記憶體位址的值全設為ascii code 0，就不會出現上述問題。 1 2 char c_str4[10] = {0}; strncpy(c_str4,\"hello\",2); 字串長度 strlen strlen()是計算字串中有幾個字元，不包含字串結尾\\0。 sizeof()是計算字串變數全部記憶體大小。 1 2 3 4 5 6 int main() { char c_str4[10] = \"hello!\"; cout &lt;&lt; \"c_str4 size:\" &lt;&lt; sizeof(c_str4) &lt;&lt; endl; cout &lt;&lt; \"c_str4長度:\" &lt;&lt; strlen(c_str4) &lt;&lt; endl; return 0; } c_str4 size:10 c_str4長度:6 字串連接 strcat 1 2 3 4 5 6 7 char c_str1[6] = {'h','e','l','\\0'}; //[]可為空 char c_str2[] = {'h','e','l','l','o','\\0'}; char c_str3[10]; char c_str4[20] = {'t','e'}; strcpy(c_str3, c_str1); cout &lt;&lt; \"c_str3 + c_str4 = \" &lt;&lt; strcat(c_str3,c_str4) &lt;&lt; endl; 執行結果 c_str3 + c_str4 = helte 字串比較 strcmp 二個字串，字元逐字元比較ascii code，直到比完或分出大小為止。 strcmp(s1,s2) s1==s2傳回0 1 2 3 4 5 6 int main() { char* s1 = \"abc\"; char* s2 = \"abc\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } 0 s1&gt;s2傳回正數ascii code 1 2 3 4 5 6 int main() { char* s1 = \"abc\"; char* s2 = \"ab\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } 99 s1&lt;s2傳回負數ascii code 1 2 3 4 5 6 int main() { char* s1 = \"ab\"; char* s2 = \"abc\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } -99 二維陣列字串 參考 二維陣列 印出禮拜一至禮拜天的英文字母 以下的例子是建立二維的字串，總共有7個字串，每個字串最大長度為10，Wednesday是最長字串，長度為9，加上\\0就等於10。 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; for(int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } Sunday Monday Tuesday Wednesday Thursday Friday Saturday 判斷數字，印出月份英文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //12個月 const int MAX_MONTH = 12; //最長字母September //9個字元+\\0 const int MAX = 10; int main() { char mon_arr[MAX_MONTH][MAX] = {\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"}; int month; cout &lt;&lt; \"請輸入數字月份(1~12):\"; cin &gt;&gt; month; //陣列索引介於0..11，所以要把month-1 cout &lt;&lt; mon_arr[month-1] &lt;&lt; endl; return 0; } 請輸入數字月份(1~12):12 December"
  },"/pages/c/array/qsort/": {
    "title": "qsort排序",
    "keywords": "",
    "url": "/pages/c/array/qsort/",
    "body": "qsort使用方法 void qsort ( void * base , size_t nitems , size_t size , int (* compar )( const void *, const void *)) 參數1，陣列名。 參數2，陣列大小。 參數3，陣列中每個元素的大小。 參數4，callback函式，判斷比大小的函式。 int compar( const void *p1, const void *p2) * 傳回值為int整數。 * 傳回值 &gt; 0 * p1會排在p2前面 * 傳回值 == 0 * p1與p2相等 * 傳回值 &lt; 0 * p1會排在p2後面 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int compare(const void* p1, const void* p2) { //void*指標代表接收任何資料型態的參數 //把void*指標轉成int*指標 int* pi1 = (int*) p1; int* pi2 = (int*) p2; //把pi1指標使用*取值運算子，取出pi1記憶體位址存放的值 //把pi2指標使用*取值運算子，取出pi2記憶體位址存放的值 //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回-1 if(*pi1 &lt; *pi2) return -1; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回0 else if(*pi1 == *pi2) return 0; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回1 //else if(*pi1 &gt; *pi2) else return 1; } int main() { //宣告大小為10的整數陣列 int arr[10] = {8,1,7,2,6,3,5,5,1,10}; //陣列大小 int size = sizeof(arr)/sizeof(int); //排序 qsort(arr, size, sizeof(int), compare); for(int i = 0; i &lt; size; i++) { //印出每個元素 cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 執行結果 1,1,2,3,5,5,6,7,8,10,"
  },"/pages/c/basic/typedef/": {
    "title": "typedef類型別名",
    "keywords": "",
    "url": "/pages/c/basic/typedef/",
    "body": "不同作業系統基本資料型態記憶體大小 C++建立不同作業系統(跨平台)可以支援的資料型態。 作業系統 short int long long long Linux 2byte 4byte 8byte 8byte Windows 2byte 4byte 4byte 8byte 由上表可以發現，Linux與Windows在long資料型態占用記憶體大小不同。 類型別名 為了解決long的資料型態在不同作業系統是不同記憶體大小，因此為類型取別名。 在寫程式時，資料型態使用類型別名，不再使用基本資料型態int，short，long，long long，避免不同作業系統資料型態記憶體大小不同的問題。 語法如下 typedef 資料型態 類型別名 Windows類型別名 以下程式碼 int16_t是short的類型別名 int32_t是int的類型別名 int64_t是long long的類型別名 1 2 3 4 //windows typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long long int64_t;//64位元整數 Linux類型別名 int16_t是short的類型別名 int32_t是int的類型別名 int64_t是long的類型別名 1 2 3 4 //Linux typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long int64_t;//64位元整數 size_t 無符號整數類型 在32位元電腦size_t是unsigned int的類型別名 在64位元電腦size_t是unsigned long long的類型別名 電腦 整數 byte數 範圍大小 32位元 unsigned int 4byte 0~4294967295 64位元 unsigned long long 8byte 0 到 18,446,744,073,709,551,615 由上表可以發現不同位元的電腦，C++顯示的整數型態不一樣。 32位元的size_t類型別名 size_t是unsigned int類型別名 1 typedef unsigned int size_t; 64位元的size_t類型別名 size_t是unsigned long long類型別名 1 typedef unsigned long long size_t;"
  },"/pages/c/dynamicMemory/nothrow/": {
    "title": "記憶體不足",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/nothrow/",
    "body": "std::nothrow 可以判斷若記憶體太小導致記憶體空間分配失數，會回傳nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int *arr = new (std::nothrow)int[10000000000000001]; if(arr == nullptr){ cout &lt;&lt; \"記憶體配置失敗\"; } else { arr[10000000000000001] = 100; delete[] arr; arr = nullptr; } return 0; } 執行結果 記憶體配置失敗"
  },"/pages/c/array/array2dimen/": {
    "title": "二維陣列",
    "keywords": "",
    "url": "/pages/c/array/array2dimen/",
    "body": "初始化 初始化方法1 1 2 3 4 5 6 7 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 初始化方法2 1 2 3 4 5 6 7 int arr[2][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; 初始化方法3 第1個[]中不用寫長度，第2個[]中要寫長度。 1 2 3 4 5 6 7 int arr[][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; C11之後不用有等號 1 int arr[][3]{1,2,3,4,5,6}; 以上印出結果都是一樣。 sizeof sizeof在二維陣列的使用方式是取出陣列占記憶體全部的byte。 以下的例子二維陣列有6個元素，每個元素是整數4byte，所以陣列占的記憶體大小為6*4 = 24 1 2 int arr[][3] {1,2,3,4,5,6}; cout &lt;&lt; \"arr size = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; arr size = 24 二維陣列轉成一維陣列 2維陣列記憶體位址是連續 把陣列名指派給指標，是把陣列[0][0]的記憶體位址指派給指標 使用指標把連續的記憶體位址中的值印出來。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;iostream&gt; using namespace std; int main() { //宣告陣列長度，初始化陣列全部元素為整數0 int arr[2][3] = {0}; //指派值到二維陣列 arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; //印出值 cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; //記憶體位址是連續 cout &lt;&lt; \"arr[0][0]位址 = \" &lt;&lt; (long long)&amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1]位址 = \" &lt;&lt; (long long)&amp;arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2]位址 = \" &lt;&lt; (long long)&amp;arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0]位址 = \" &lt;&lt; (long long)&amp;arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1]位址 = \" &lt;&lt; (long long)&amp;arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2]位址 = \" &lt;&lt; (long long)&amp;arr[1][2] &lt;&lt; endl; //因為記憶體位址都是連續的，把二維陣列[0][0]記憶體位址指派給指標p int* p = (int*)arr; //取得arr變數記憶體大小 int size = sizeof(arr) / sizeof(int); for(int i = 0; i &lt; size; i++) { //使用指標運算印出每個元素的值 cout &lt;&lt; \"*(p + \" &lt;&lt; i &lt;&lt; \") = \" &lt;&lt; *(p+i) &lt;&lt; \",\"; //使用索引方式印出值 cout &lt;&lt; \" [\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 arr[0][0]位址 = 140702053823568 arr[0][1]位址 = 140702053823572 arr[0][2]位址 = 140702053823576 arr[1][0]位址 = 140702053823580 arr[1][1]位址 = 140702053823584 arr[1][2]位址 = 140702053823588 *(p + 0) = 1, [0] = 1 *(p + 1) = 2, [1] = 2 *(p + 2) = 3, [2] = 3 *(p + 3) = 4, [3] = 4 *(p + 4) = 5, [4] = 5 *(p + 5) = 6, [5] = 6 從以上結果可以發現，記憶體位址的差距為4byte，而且是連續的。 可以使用指標把二維陣列轉成一維指標陣列，印出值。 指標指向二維陣列 二維陣列可以解釋為，一維陣列，裡面每一個元素又指向一維陣列。 宣告方式 資料類型 (*指標變數)[二維陣列每個元素所指向的一維陣列大小] = 二維陣列變數名; 使用二維陣列指標一定要把*指標變數用括號()包起來，因為有運算子優先順序的問題。 1 2 3 4 5 6 7 int main() { //[3]代表二維陣列每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; //[3]代表二維陣列每個元素是大小為3的一維陣列。 int (*p)[3] = arr; return 0; } 上一個程式碼例子 ，指標是指向二維陣列int[2][3]，無法轉成指向一維陣列的指標int*，所以要強制轉型成指向一維陣列的指標(int*)二維陣列變數名 以下程式碼原本指向一維陣列的指標，指向二維陣列會編譯錯誤。 //二維陣列 int arr[2][3] = {0}; //原本指向一維陣列的指標，直接指向二維陣列會編譯錯誤 int* p = arr; Cannot initialize a variable of type ‘int *’ with an lvalue of type ‘int[2][3]’ 二維陣列先轉成一維陣列，使用(int*)，再讓指標指向轉型成一維的陣列。 int arr[2][3] = {0}; int* p = (int*)arr; 二維陣列傳函式 方法有二種 指標方式 void func(int (*p)[3], int len); 陣列方式 void func(int p[][3], int len); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; void func(int (*p)[3], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; 3; j++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i][j] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } } int main() { //[3]代表每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; func(arr, 2); return 0; } p[0][0] = 1 p[0][0] = 2 p[0][0] = 3 p[1][1] = 4 p[1][1] = 5 p[1][1] = 6 指標指向三維陣列 宣告方式 資料類型 (*指標變數)[陣列個數][元素個數] = 三維陣列變數名; 三維陣列傳函式的方法有二種 指標方式 void func(int (*p)[2][3], int len); 陣列方式 void func(int p[][2][3], int len); 印出陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; void func(int (*p)[2][3], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; 2; j++) { for(int k = 0; k &lt; 3; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } } int main() { int arr[2][2][3] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; func(arr, 2); return 0; } p[0][0][0] = 1 p[0][0][1] = 2 p[0][0][2] = 3 p[0][1][0] = 4 p[0][1][1] = 5 p[0][1][2] = 6 p[1][0][0] = 7 p[1][0][1] = 8 p[1][0][2] = 9 p[1][1][0] = 10 p[1][1][1] = 11 p[1][1][2] = 12 修改陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &lt;iostream&gt; using namespace std; const int firstMax = 2; const int secondMax = 2; const int thirdMax = 3; void modifyArr(int p[][secondMax][thirdMax], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; secondMax; j++) { for(int k = 0; k &lt; thirdMax; k++) { //修改指標記憶體位址的值 p[i][j][k] += 10; } }// end of j }// end of i } void printArr(int (*p)[secondMax][thirdMax], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; secondMax; j++) { for(int k = 0; k &lt; thirdMax; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; }// end of j cout &lt;&lt; endl; }//end of i } int main() { int arr[firstMax][secondMax][thirdMax] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; modifyArr(arr, firstMax); printArr(arr, firstMax); return 0; } p[0][0][0] = 11 p[0][0][1] = 12 p[0][0][2] = 13 p[0][1][0] = 14 p[0][1][1] = 15 p[0][1][2] = 16 p[1][0][0] = 17 p[1][0][1] = 18 p[1][0][2] = 19 p[1][1][0] = 20 p[1][1][1] = 21 p[1][1][2] = 22"
  },"/pages/c/array/arrayOfPointers/": {
    "title": "指標陣列存放多個記憶體位址",
    "keywords": "",
    "url": "/pages/c/array/arrayOfPointers/",
    "body": "指標陣列 1 2 3 4 5 int i1 = 10; int i2 = 20; int i3 = 30; //宣告指標陣列存放3個記憶體位址 int *p_array[3] = {&amp;i1, &amp;i2, &amp;i3}; 取址與取值 方式有二種 指標方式 使用指標+i迴圈印出，用取值運算子*(p_array + i)取出記憶體位址，再把取出的記憶體位址再次使用*取值運算子，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i= %d的位置%#x, 值為%d\\n\",i, *(p_array + i), *(*(p_array + i))); } i= 0的位置0xbfeff3fc, 值為100 i= 1的位置0xbfeff3cc, 值為20 i= 2的位置0xbfeff3c8, 值為30 陣列方式 使用[索引]取出陣列存放的記憶體位址，再對記憶體位址使用取值運算子*，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i=%d的位置%#x, 值為%d\\n\",i, p_array[i], *p_array[i]); } 指標陣列存放多個字串常數位址 參考 指標陣列存放多個字串常數位址"
  },"/pages/c/array/pointerCharArr/": {
    "title": "char字串指標",
    "keywords": "",
    "url": "/pages/c/array/pointerCharArr/",
    "body": "字串常數 字串常數是包在二個雙引號之間”” \"http://www.google.com\" 以下皆為字串常數 例1 s指標指向字串常數，常數占在記憶體唯讀空間，常數是放在code segment 記憶體區塊，只能讀取，無法修改。 1 char * s = \"http://www.google.com\"; 例2 程式碼中的”abcdefg”是字串常數。 1 2 3 4 5 6 7 8 //使用new動態配置記憶體空間，new會傳回char陣列記憶體區塊的開始記憶體位址。 char* message = new char[100]; //把字串常數abcdefg拷貝至char陣列 strcpy(message, \"abcdefg\"); //記憶體回收 delete[] message; //將指標指向null，代表不指向任何記憶體位址 message = nullptr; 無法透過*取值運算子，把字串常數指派給指標 無法透過*取值運算子，把字串常數指派給指標，以下會編譯錯誤，只能使狦strcpy複製字串常數。 1 2 char* message = new char[100]; *message = \"abcdefg\";//編輯錯誤 字串常數記憶體大小 因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小，注意！strlen不包含結尾\\0的大小，所以計算記憶體空間要再+1，加上結尾\\0的大小 1 2 3 char* s = \"http://www.google.com\";//21個字元(不含結尾\\0) //因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小 size_t s_size = strlen(s) + 1;//strlen不包含結尾\\0的大小 字元陣列不是常數 字元陣列不是常數，以下寫法不是常數，是有占stack堆疊的記憶體空間 1 2 3 char s1[] = \"http://www.google.com\"; cout &lt;&lt; \"s1堆疊記憶體大小=\" &lt;&lt; sizeof(s1) &lt;&lt; endl; cout &lt;&lt; \"s1長度=\" &lt;&lt; strlen(s1) &lt;&lt; endl; s1記憶體大小=22 s1長度=21 指向字串常數的指標 參考 字串常數宣告 指標陣列++ 陣列名是常數，不可修改 以下程式分別為字串陣列與指標初始化字串常數，不可以使用字串陣列名++，因為陣列名是指向陣列記憶體的開始位址，到程式結束前都不會改變，陣列名是常數，就像我們不可能寫成7++的意思是一樣的，而指標是變數，變數就是可以改變值(在這裡是改變存放的記憶體位址)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //cstr1陣列名是記憶體起始位址 char cstr1[] = \"Hello World!\"; //cstr2是指標變數，指向字串常數\"Hello World!\" //常數是放在code segment 記憶體區塊，不可以使用指標指向常數記憶體位址 char* cstr2 = \"Hello World!\"; cout &lt;&lt; \"cstr1 = \" &lt;&lt; cstr1 &lt;&lt; endl; cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; //cstr1陣列名是記憶體起始位址，是常數，不可以++ //cstr1++; //指標是變數，可以修改 //指標原本指向起始位址\"H\"，++移動1byte，指標指向\"e\"的記憶體位址 cstr2++; //印出ello World!，直到遇到\\0結尾字元，就停止輸出 cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } cstr1 = Hello World! cstr2 = Hello World! cstr2 = ello World! 字串指標與函式 參考 空字元 strlen *ptr++ size_t 寫一個傳進指標的函式，函式是把來源字串(src)拷貝到目標字串(desc)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* *desc = *src; desc++;//指標往下一個位址移動，移動1byte src++;//指標往下一個位址移動，移動1byte } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的來源字串 char* src = \"Hello World!\"; //+1是為了加上結尾空字元\\0，strlen預設是不含\\0 size_t len = strlen(src) + 1; //拷貝的目標字串 char* desc = new char[len]; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; //記憶體釋放陣列 delete[] desc; //desc指標不指向任何記憶體位址 desc = nullptr; return 0; } desc = Hello World! 另一種寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* //desc與src指標往下一個位址移動，移動1byte *desc++ = *src++; } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } 指標字串拷貝 參考 字串拷貝-strcpy const右邊是星號 char * strcpy ( char * destination, const char * source ); 使用函式庫strcpy來進行字串拷貝，參數2指標前面有const，代表strcpy()函式不能修改source指標所指向的字元，因為指向的字元是常數，但可以改變指標src指向的位址。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; strcpy(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } desc = Hello World! 指標陣列存放多個字串常數位址 參考 指標陣列存放多個記憶體位址 二維陣列字串 之前二維陣列字串的範例中，定義陣列的大小是7個字串陣列，每個字串固定10byte，記憶體空間就會是70byte，但每個字母有長有短，就會造成記憶體空間上的浪費。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; //印出二維陣列字串的記憶體大小 //7個字串 * 每個字串最大長度10byte cout &lt;&lt; \"str size = \" &lt;&lt; sizeof(str) &lt;&lt; endl; for(int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } str size = 70 Sunday Monday Tuesday Wednesday Thursday Friday Saturday 使用指標陣列，存放多個字串常數的記憶體位址，每個字串常數都有起始記憶體位址，即字串常數的第一個字元的位址，就不用定義二維陣列大小去存放字元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //陣列裡的指標個數 int main() { //陣列存放7個指標，每個指標指向字串常數的第一個字元的位址 char *arr_ptrs[DAYS] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"};//字串指標陣列 //指標的固定大小是8byte，指標陣列存放7個指標，總共大小為8byte*7 cout &lt;&lt; \"arr_ptrs size = \" &lt;&lt; sizeof(arr_ptrs) &lt;&lt; endl; for(int i = 0; i &lt; DAYS; i++) cout &lt;&lt; arr_ptrs[i] &lt;&lt; endl; return 0; } arr_ptrs size = 56 Sunday Monday Tuesday Wednesday Thursday Friday Saturday"
  },"/pages/c/function/callByRef/": {
    "title": "函式傳參考",
    "keywords": "",
    "url": "/pages/c/function/callByRef/",
    "body": "Prerequisites: 參考 傳值與傳參考的程式碼幾乎一模一樣，差別只在於，傳值無法修改傳入的參數，傳值的意義在於不要讓函式修改傳入的參數，而傳參考是允許函式存取傳入的參數。 宣告 語法 函式回傳資料型態 函式名(資料型態&amp; 別名, ...); void callByRef(int&amp; param1, int&amp; param2); 參數宣告為資料型態&amp;，參數就變成別名，引數 就變成原始變數。 傳值 1 2 3 4 5 6 7 8 9 10 11 12 void callByValue(int param1, int param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByValue(i,j); cout &lt;&lt; \"callByValue:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByValue: i = 10, j = 20 傳參考 呼叫函式時，引數不用加&amp; callByRef(i,j); 1 2 3 4 5 6 7 8 9 10 11 12 void callByRef(int&amp; param1, int&amp; param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByRef(i,j); cout &lt;&lt; \"callByReference:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByReference: i = 100, j = 200 傳值與傳參考的差別 二者只有參數不同。 傳值 void callByValue(int param1, int param2) 傳參考 void callByRef(int&amp; param1, int&amp; param2)"
  },"/pages/c/reference/refToPointer/": {
    "title": "參考指向指標",
    "keywords": "",
    "url": "/pages/c/reference/refToPointer/",
    "body": "Prerequisites: 指標的指標 引數 參考指向指標，代表參考可以像指標一樣，使用*取值運算子，取出原指標指向的記憶體位址中的值，也可以修改原指標指向的記憶體位址中的值，或更改原指標指向的記憶體位址。 宣告參考 資料型態*&amp; 別名 = 原指標; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int i = 10; cout &lt;&lt; \"i address:\" &lt;&lt; &amp;i &lt;&lt; endl; int j = 100; cout &lt;&lt; \"j address:\" &lt;&lt; &amp;j &lt;&lt; endl; //宣告指標 int* ptr_i = &amp;i; //宣告參考 // 原指標指派給參考 int*&amp; ptr_ref = ptr_i; cout &lt;&lt; \"== Change value ==\" &lt;&lt; endl; cout &lt;&lt; \"Before i value:\" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"Before value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; //修改原指標指向的記憶體位址中的值 *ptr_ref = 20; cout &lt;&lt; \"After i value:\" &lt;&lt; i &lt;&lt; endl; //取出原指標指向的記憶體位址中的值 cout &lt;&lt; \"After value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; cout &lt;&lt; \"== Change address ==\" &lt;&lt; endl; cout &lt;&lt; \"Before address:\" &lt;&lt; ptr_ref &lt;&lt; endl; //更改原指標指向的記憶體位址 ptr_ref = &amp;j; cout &lt;&lt; \"after address:\" &lt;&lt; ptr_ref &lt;&lt; endl; return 0; i address:0x7ff7bfeff468 j address:0x7ff7bfeff464 == Change value == Before i value:10 Before value:10 After i value:20 After value:20 == Change address == Before address:0x7ff7bfeff468 after address:0x7ff7bfeff464 參考以下文章 https://www.geeksforgeeks.org/different-ways-to-use-const-with-reference-to-a-pointer-in-c/?ref=ml_lbp References to pointers is a modifiable value that’s used same as a normal pointer. (google翻譯)對指標的參考是一個可修改的值，其使用方式與普通指標相同。 函式參數為指向指標的參考 如果要在函式中修改指標指向的記憶體位址，就需要使用指標的指標，也可以使用參考。 引數為指標，函式參數宣告為指標資料型態*&amp; 別名，這樣才可以修改指標指向的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函數並嘗試對其進行修改，則對指標所做的更改不會反映回該函數外部。這是因為僅將指標的副本傳遞給函數。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函數內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變量，而原始指標保持不變。 語法 函式語法 回傳型態 函式名(資料型態*&amp; 別名) { 別名 = 其它記憶體位址 } 呼叫函式語法 函式(指標) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &amp;global_var; } int main() { int var = 1; int* pointer_to_var = &amp;var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 函式參數指標的指標與指標的別名程式差異 指標的別名 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &global_var; } int main() { int var = 1; int* pointer_to_var = &var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 指標的指標 int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 參考指向指標與new 參考文章 指標的指標與new new會返回動態配置記憶體的開始位址，將別名指向new返回的新位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 別名是ref_to_p，指向外部傳入的指標 void initAddress(int*&amp; ref_to_p){ //印出別名指向的記憶體位址 cout &lt;&lt; \"Before address = \" &lt;&lt; ref_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 ref_to_p = new int(10); //印出別名指向的記憶體位址 cout &lt;&lt; \"After address= \" &lt;&lt; ref_to_p &lt;&lt; \",After value = \" &lt;&lt; *ref_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p initAddress(p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before address = 0x0 After address= 0x600000004010,After value = 10 == outside == outside pointer address = 0x600000004010，outside pointer value = 10"
  },"/pages/c/reference/reference/": {
    "title": "參考",
    "keywords": "",
    "url": "/pages/c/reference/reference/",
    "body": "宣告方法 資料型態&amp; 參考別名 = 原始變數; 注意事項 宣告參考別名時，要初始化原始變數。 初始化後不可改變原始變數。 別名可以存取原始變數，參考別名與原始變數都是指向相同記憶體位址。 宣告 1 2 3 4 5 int i = 10;//原始變數 //宣告參考 int&amp; ref = i;//初始化原始變數，ref是i的別名 cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 由執行結果可知，i跟ref的記憶體位址相同，值也相同。 一定要初始化 以下的程式寫法會編譯錯誤，因為ref參考別名沒有初始化。 1 2 3 int i = 10;//原始變數 //宣告參考 int&amp; ref; 參考別名跟原始變數功能一樣，可以修改跟讀取記憶體內容。 參考別名跟原始變數都指向相同記憶體位址，所以可以做一樣的操作。 1 2 3 4 5 6 7 8 9 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; ref = 30; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 i的記憶體位址 = 0x7ff7bfeff468, i = 30 ref的記憶體位址 = 0x7ff7bfeff468, ref = 30 由執行結果可以發現修改ref參考別名，就等於修改變數i，i跟ref的值都變成30。 一個變數可以多個參考別名 1 2 3 4 5 6 7 8 9 10 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int&amp; ref2 = i; cout &lt;&lt; \"ref2的記憶體位址 = \" &lt;&lt; &amp;ref2 &lt;&lt; \", ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; int&amp; ref3 = i; cout &lt;&lt; \"ref3的記憶體位址 = \" &lt;&lt; &amp;ref3 &lt;&lt; \", ref3 = \" &lt;&lt; ref3 &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 ref2的記憶體位址 = 0x7ff7bfeff468, ref2 = 10 ref3的記憶體位址 = 0x7ff7bfeff468, ref3 = 10 各種寫法 &amp;只要介於資料型態與參考別名之間就可以，以下的宣告別名的方式都可以。 1 2 3 4 5 6 int i = 10;//原始變數 //宣告參考別名 int&amp;ref = i; int &amp;ref2 = i; int &amp; ref3 = i; int&amp; ref4 = i; 資料型態要一致，參考別名無強制轉型 以下是錯誤的參考別名宣告 1 2 3 int i = 10;//原始變數 //宣告參考別名 double&amp; ref = i; 原始變數i是int，無法轉成double的資料型態，也沒辦法像指標有強制轉型的功能。 初始化後不可改變原始變數 1 2 3 4 5 6 7 8 9 10 11 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int j = 20; ref = j; //將j變數 指派給 ref別名 cout &lt;&lt; \"j的記憶體位址 = \" &lt;&lt; &amp;j &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", i = \" &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; 上方的程式碼 int j = 20; ref = j; //將j變數的值 指派給 ref參考別名 以上意思並非把原始變數設為j，實際上是變數i修改成20，ref是變數i的參考別名，就等同於變數i，所以上述程式碼可以看成i = 20; 執行結果 i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 j的記憶體位址 = 0x7ff7bfeff45c, j = 20 ref的記憶體位址 = 0x7ff7bfeff468, i = 20 i的記憶體位址 = 0x7ff7bfeff468, i = 20 由執行結果可以發現，執行ref = j;參考別名j的記憶體位址跟i相同，但j的值變成20，i的值也變成20，修改ref就等同於修改i，所謂的參考別名就是給變數i另一個假名ref，但指向的都是相同記憶體位址。"
  },"/pages/c/basic/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/basic/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; }"
  },"/pages/c/basic/lvalue/": {
    "title": "等號左邊lvalue",
    "keywords": "",
    "url": "/pages/c/basic/lvalue/",
    "body": "等號左邊(lavlue)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 常數可以是字串常數、表達式。"
  },"/pages/c/c11/rvalue/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 區別方式 有名字一律為左值l-value，沒有名字一律為右值r-value 可以取得記憶體位址一律為左值，沒有辦法取得記憶體位址一律為右值 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; } 函式傳回值為物件的值 函式傳回值是值 以下的程式碼，main()和getStudente()都各別有存放回傳值student的記憶體位址，待getStudent()的student變數回傳給main()的student變數後，getStudent()的student變數的記憶體位址就會被釋放。 被記憶體釋放，不會被保留住的物件，也是右值r-value。 傳回物件 1 2 3 4 5 6 7 8 Student getStudent() { Student student; return student; } int main() { Student student = getStudent(); return 0; } 回傳值是臨時物件 臨時物件 臨時物件是右值。 臨時物件建立語法 類別名() Student() 1 2 3 4 5 6 7 Student getStudent() { return Student(); } int main() { Student student = getStudent(); return 0; }"
  },"/pages/c/c11/rvalue/constRef/": {
    "title": "const與參考",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/constRef/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 const參考 const參考可以放左值(l-value)，也可以放右值(r-value)，也可以放常數。 const參考放左值 1 2 3 4 5 6 7 int main() { // i 是l-value int i = 100; // 100 is r-value const int&amp; ref_i = i; cout &lt;&lt; \"ref_i = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_i = 100 const參考放右值 1 2 3 4 5 int main() { const int&amp; ref_r = 100; // 100 is r-value cout &lt;&lt; \"ref_r = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_r = 100 const參考放右值&amp;&amp;變數名 1 2 3 4 5 6 int main() { int&amp;&amp; r = 100; const int&amp; ref_r = r; cout &lt;&lt; \"ref_r = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_r = 100 const參考放常數名 1 2 3 4 5 6 7 int main() { //con 是常數 const int con = 100; const int&amp; ref = con; cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; return 0; } ref = 100 const參考放常數值 1 2 3 4 5 int main() { const int&amp; ref = 100; //100是常數 cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; return 0; } ref = 100 函式參數為const參考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void func(const int&amp; ref) { cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; } int main() { // i is l-value int i = 10; //l-value func(i); //r-value int&amp;&amp; r = 20; func(r); func(100);// 常數 100 , 100 is r-value func('A');// 常數 'A' , A is r-value return 0; } ref = 10 ref = 20 ref = 100 ref = 65"
  },"/pages/c/c11/rvalue/l_r_ref/": {
    "title": "l-value參考與r-value參考",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/l_r_ref/",
    "body": "Prerequisites: l-value與r-value l-value參考 l-value參考指向變數 1 2 3 4 5 6 7 8 9 int main() { int i = 10; int&amp; l_ref = i; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; l_ref = 55; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; return 0; } l-value ref = 10 === modify ref === l-value ref = 55 r-value參考 幫右值取名字 語法 右值資料型態&amp;&amp; 右值變數名 = 右值; int&amp;&amp; r_ref = 100; r-value參考指向數字 1 2 3 4 5 6 7 8 int main() { int&amp;&amp; r_ref = 100; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; r_ref = 1000; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; return 0; } r-value ref = 100 === modify ref === r-value ref = 1000 取出右值記憶體位址 右值取名字後，名字就變成左值，就可以取出記憶體位址。 1 2 3 4 5 int main() { int&amp;&amp; r = 10; cout &lt;&lt; \"r address = \" &lt;&lt; &amp;r &lt;&lt; endl; return 0; } r address = 0x7ff7bfeff45c 修改右值 右值取名字後，名字就變成左值，可以修改值。 1 2 3 4 5 6 int main() { //r-value int&amp;&amp; r = 10; cout &lt;&lt; \"Before r = \" &lt;&lt; r &lt;&lt; endl; r = 20; cout &lt;&lt; \"After r = \" &lt;&lt; r &lt;&lt; endl; Before r = 10 After r = 20 左值不能放在右值參考 以下程式碼會編譯錯誤 1 2 3 4 5 6 7 int main() { //l_val是l-value int l_val = 10; //定義右值參考 int&amp;&amp; r_val_ref = l_val; return 0; } 右值不能放在左值參考 以下程式碼會編譯錯誤 1 2 3 4 5 int main() { // 10 is r-value int&amp; l_val_ref = 10; return 0; } 函式參數為l-value參考 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; void func(int&amp; l_ref) { l_ref = 20; } int main() { int i = 10; cout &lt;&lt; \"before i = \" &lt;&lt; i &lt;&lt; endl; func(i); cout &lt;&lt; \"after i = \" &lt;&lt; i &lt;&lt; endl; return 0; } before i = 10 after i = 20 函式參數為r-value參考 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; void func(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func(1000); return 0; } r-value = 1000 引數與參數r-value參考資料型態不同 引數與參數的資料型態不同，若自動轉型可以轉成功，也可以使用r-value參考。 1 2 3 4 5 6 7 void func1(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func1('B'); return 0; } r-value = 66 函式回傳值為右值 臨時物件 語法 類別名&amp;&amp; 變數名 = 函式(); Student&amp;&amp; s1 = getStudent1(); 把右值取了名字，這個名字就是左值，可以做左值能做的事，比如存取物件成員變數，呼叫成員函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Student { public: string name; }; Student getStudent1() { Student s; s.name = \"Bill\"; return s; } Student getStudent2() { //臨時物件 return Student(); } int main() { Student&amp;&amp; s1 = getStudent1(); cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.name &lt;&lt; endl; Student&amp;&amp; s2 = getStudent2(); s2.name = \"Mary\"; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.name &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Mary"
  },"/pages/c/function/callByValue/": {
    "title": "函式傳值與回傳值",
    "keywords": "",
    "url": "/pages/c/function/callByValue/",
    "body": "Prerequisites: 引數 函式傳遞值 Call by value 解釋1 函式會建立新的變數將引數拷貝到新的變數，將新的變數作為參數，所以在函式對參數做的任何操作，實際上是對新的變數做操作，而不是對引數做操作。 解釋2 參數一進入函式，函式即建立新的變數保管這些參數值，同時新變數的資料型態完全吻合參數的資料型態，這種傳遞參數的方式會先把參數複製一份，稱為傳值呼叫(call by value)。 解釋3 以傳值方式傳遞參數的函式會建立一個與參數型態相同的變數，然後把參數的值複製到該變數，因此，函式不能存取原來的變數，僅能存取其拷貝值。當函式無須修改原來的變數值時，傳值的方法很實用，同時保證函式不會破壞原來的變數值。 以下程式碼是將引數x傳遞給函式setX()，將引數x拷貝到參數r，對參數r進行修改，並不會影嚮x引數。 1 2 3 4 5 6 7 8 9 10 11 12 //r為參數 void setX(int r){ r = 1000; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x為引數 setX(x); cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 10 函式傳回值是值 解釋1 以下的程式碼，main()和getValue()都各別有存放回傳值r的記憶體位址，待getValue()的r變數回傳給main()的r變數後，getValue()的r變數的記憶體位址就會被釋放。 解釋2 記憶體配置 函式會將傳回值拷貝到暫存器或stack中，然後再傳回拷貝到暫存器或stack中的值，接下來再把函式中區域變數記憶體釋放。 1 2 3 4 5 6 7 8 9 int getValue(){ int r = 1000; return r; } int main() { int r = getValue(); cout &lt;&lt; \"r = \" &lt;&lt; r &lt;&lt; endl; return 0; } r = 1000"
  },"/pages/c/function/func_return_ref/": {
    "title": "函式傳回值是參考",
    "keywords": "",
    "url": "/pages/c/function/func_return_ref/",
    "body": "Prerequisites: 傳參考 函式傳回值是值 若傳回值是參考別名，將不會拷貝傳回值到暫存器或stack。 函式宣告語法 資料型態&amp; 函式名(資料型態&amp; 參考別名) int&amp; getValue(int&amp; z); 函式呼叫方式 y是原始變數的參考別名。 資料型態&amp; 參考別名 = 函式(原始變數); int&amp; y = getValue(原始變數); 以下程式碼z與y都是x(原始變數)的參考別名，z與y與x三者都指向相同記憶體位址。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/reference/l_ref_func/": {
    "title": "等號左邊的函式",
    "keywords": "",
    "url": "/pages/c/reference/l_ref_func/",
    "body": "Prerequisites: 引數 函式傳回值是參考 函式傳回值是參考別名 以下程式碼是將全域變數x的參考別名作為傳回值。 1 2 3 4 5 6 //全域變數 int x = 10; //返回全域變數x的參考別名 int&amp; setX(){ return x; } 將setX() = 99可以視作為int&amp; x_ref = 99; 二者是相同意思。 1 setX() = 99; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 //全域變數 int x = 10; //返回全域變數x的參考 int&amp; setX(){ return x; } int main() { cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //將x全域變數參考，設值成99 setX() = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 不能傳回區域變數的參考 以下程式碼會出錯，因為區域變數x在函式結束的時候就會被系統記憶體釋放，無法作為參考。 1 2 3 4 int&amp; setX(){ int x = 10; return x; } 引數作為參考 以下程式碼將main()函式中的x變數傳進setX()的函式，並回傳x變數的匿名參考別名。 將x的參考設值99。 1 2 3 4 5 6 7 8 9 10 11 12 13 //回傳值為參考別名 //參數r為x的參考別名 int&amp; setX(int&amp; r){ return r; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x傳入函式，回傳x的參考 setX(x) = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 函式不想放在等號左邊 若不想被人修改傳回值，可將傳回值設為const，但函式呼叫者也需要加上const。 函式語法 const 資料型態&amp; 函式名(資料型態&amp; 原始變數); const int&amp; getValue(int&amp; z); 函式呼叫者 const 資料型態&amp; 別名 = 函式名(原始變數); const int&amp; y = getValue(x); 以下程式碼將編譯錯誤，函式無法放在等號左邊。 getValue(x) = 100; 以下為完整程式碼 1 2 3 4 5 6 7 8 9 10 11 const int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; const int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/struct/struct_def/": {
    "title": "定義結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_def/",
    "body": "想要建立只有資料的物件時，使用 struct；其他狀況一律使用 class。 結構是變數的集合，變數可以不是不同型態，例如有的是int，有的是float，結構中每一個變數都是該結構的成員。 定義結構有以下三種方式 方式1 宣告結構 關鍵字struct宣告，緊號於struct後的是結構名稱，變數的宣告都在大括號{}內，大括號{}結尾一定要加上分號; struct 結構名 { 變數宣告 }; 1 2 3 4 5 6 struct Student { //學生姓名 char* name; //學號 int id; }; 結構放置位置 放在main()上面，或者放在標頭檔。 定義結構變數 結構可想像成一種新的資料型態，int也是一種資料型態，定義結構變數會在記憶體配置空間。 結構名 變數名; 1 2 3 4 int main() { Student student; return 0; } 存取結構成員 存取方式有二種 點運算子 使用點運算子(dot operator)指派或修改結構成員的值。 1 2 3 Student student; student.name = \"Mary\"; student.id = 1; cout讀取結構成員。 1 2 cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; }; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 1 大括號 使用大括號修改結構。 結構名 = {值1,值2,值3, ...}; 1 student = {\"Bill\",2}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; }; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; \"Before:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; student = {\"Bill\",2}; cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 方式2 同時宣告結構與定義結構變數 在大括號的結尾輸入結構變數，在main()函數不用定義結構變數，直接使用結構變數。 struct 結構名{ 變數宣告 }結構變數; 1 2 3 4 5 6 struct Student { //學生姓名 char* name; //學號 int id; }student; 存取結構成員 在main()函數不用定義結構變數，直接使用結構變數。 1 2 3 4 5 6 7 int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; } student; int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 方式3 宣告結構 使用typedef(型別定義)關鍵字，後面緊跟著struct關鍵字，再來是大括號{}，變數的宣告在大括號{}中，結構名放在大括號結尾，最後加上分號;結束。 typedef struct { 變數宣告 } 結構名; 1 2 3 4 5 6 typedef struct { //學生姓名 char* name; //學號 int id; } Student; 定義結構變數 結構名 變數名; 1 Student student; 存取結構成員 與方式一相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; typedef struct { //學生姓名 char* name; //學號 int id; } Student; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; }"
  },"/pages/c/struct/struct_pointer/": {
    "title": "指標指向結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_pointer/",
    "body": "宣告指標 結構 指標變數 = 結構變數地址; Student *ptr = &amp;student; 存取結構成員 使用取值運算子 (*指標變數).成員 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"marry\", 1}; Student *ptr = &amp;student; cout &lt;&lt; \"姓名 : \" &lt;&lt; (*ptr).name &lt;&lt; endl; cout &lt;&lt; \"學號 : \" &lt;&lt; (*ptr).id &lt;&lt; endl; return 0; } 使用-&gt; 指標變數-&gt;成員 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"marry\", 1}; Student *ptr = &amp;student; cout &lt;&lt; \"姓名 : \" &lt;&lt; ptr-&gt;name &lt;&lt; endl; cout &lt;&lt; \"學號 : \" &lt;&lt; ptr-&gt;id &lt;&lt; endl; return 0; }"
  },"/pages/c/struct/struct_init/": {
    "title": "初始化結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_init/",
    "body": "使用大括號{}初始化 結構 變數名 = {值1, 值2 ...} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"Mary\", 1}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 1 定義結構時初始化 struct 結構名{ 變數宣告 }結構變數={值1, 值2 ...}; 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {\"Bill\", 2}; int main() { cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Bill 2 結構成員記憶體位址的值全初始化成00000000 方式1 {0}把成員初始化00000000。 struct 結構名{ 變數宣告 }結構變數={0}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {0}; int main() { return 0; } 結構 變數名 = {0} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {0}; return 0; } 方式2 只寫大括號也是把成員初始化00000000。 struct 結構名{ 變數宣告 }結構變數={}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {}; int main() { return 0; } 結構 變數名 = {} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {}; return 0; } 方式3 c11之徫可以省略等於= struct 結構名{ 變數宣告 }結構變數{}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student{}; int main() { return 0; } 結構 變數名{} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student{}; return 0; } 方式4 使用memset() memset(結構變數地址,0,sizeof(結構變數)); 1 2 3 4 5 int main() { Student student; memset(&amp;student, 0, sizeof(student)); return 0; }"
  },"/pages/c/struct/struct_array/": {
    "title": "結構陣列",
    "keywords": "",
    "url": "/pages/c/struct/struct_array/",
    "body": "Prerequisites: 陣列清空 陣列運算 結構陣列的宣告方式 結構 陣列名[陣列大小]; Student students[size]; 結構陣列指定元素 使用.運算子 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); strcpy(students[0].name,\"Bill\"); students[0].id = 1; strcpy(students[1].name,\"Mary\"); students[1].id = 2; strcpy(students[2].name,\"Jeff\"); students[2].id = 3; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; students[i].id; cout &lt;&lt; \", name = \" &lt;&lt; students[i].name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用大括號{} C++11以上才能使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); students[0] = {\"Bill\",1}; students[1] = {\"Mary\",2}; students[2] = {\"Jeff\",3}; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; students[i].id; cout &lt;&lt; \", name = \" &lt;&lt; students[i].name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用指標運算取值 使用箭頭-&gt;方式取值，括號()前面不需要加上星號* (陣列名 + 元素索引index)-&gt;結構成 1 (students+0)-&gt;id 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); students[0] = {\"Bill\",1}; students[1] = {\"Mary\",2}; students[2] = {\"Jeff\",3}; cout &lt;&lt; \"id = \" &lt;&lt; (students+0)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+0)-&gt;name &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; (students+i)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+i)-&gt;name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用指標運算指定值 *(陣列名 + 元素索引index) = {值1,值2, ...}; 1 2 3 *(students + 0) = {\"Bill\",1}; *(students + 1) = {\"Mary\",2}; *(students + 2) = {\"Jeff\",3}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); *(students + 0) = {\"Bill\",1}; *(students + 1) = {\"Mary\",2}; *(students + 2) = {\"Jeff\",3}; cout &lt;&lt; \"id = \" &lt;&lt; (students+0)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+0)-&gt;name &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; (students+i)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+i)-&gt;name &lt;&lt; endl; } return 0; }"
  },"/pages/c/struct/struct_char/": {
    "title": "結構與字串",
    "keywords": "",
    "url": "/pages/c/struct/struct_char/",
    "body": "Prerequisites: 字串常數 字串修改 字串指標 結構成員與char字串 以下結構成員name為char字串。 1 2 3 4 5 6 typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; 使用char字串，不能使用等於=指定值，以下語法將編譯錯誤。 1 student.name = \"Mary\"; 正確使用的方式是使用strcpy拷貝字串到char字串。 1 strcpy(student.name, \"Mary\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { Student student; //清空資料 //student記憶體位址的值全設為00000000 memset(&amp;student, 0, sizeof(student)); //姓名 strcpy(student.name, \"Mary\"); //學號 student.id = 100; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 100 結構成員與char字串指標 以下結構成員name為char字串指標。 1 2 3 4 5 6 typedef struct{ //學生姓名 char* name; //學號 int id; }Student; 使用char字串指標，可以使用等於=指定值。 1 student.name = \"Mary\"; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student; //清空資料 //student記憶體位址的值全設為00000000 memset(&amp;student, 0, sizeof(student)); //姓名 student.name = \"Mary\"; //學號 student.id = 100; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 100 結構成員與char字串與字串指標(c11) 使用大括號的方式，不管是字串或字串指標都可以用雙引號”“指定值。 1 student = {\"Mary\",\"桃園市XX區XX號\", 1}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //地址 char* address; //學號 int id; }Student; int main() { Student student; student = {\"Mary\",\"桃園市XX區XX號\", 1}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.address &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 桃園市XX區XX號 1 無法使用大括號修改單獨成員是字串陣列 以下的寫法會編譯錯誤 1 student.name = {\"Bill\"}; 必須使用strcpy修改單獨成員是字串陣列 1 strcpy(student.name, \"Bill\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //地址 char* address; //學號 int id; }Student; int main() { Student student; student = {\"Mary\",\"桃園市XX區XX號\", 1}; strcpy(student.name, \"Bill\"); cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.address &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Bill 桃園市XX區XX號 1"
  },"/pages/c/struct/arrayInStruct/": {
    "title": "結構中的陣列",
    "keywords": "",
    "url": "/pages/c/struct/arrayInStruct/",
    "body": "結構中定義陣列 定義成員score[3] 1 2 3 4 5 6 7 struct Student{ //學生姓名 char* name; //學號 int id; int score[3]; }; 初始化結構中的陣列 方式一 1 Student student = {\"Mary\", 1, {60,70,80}}; 方式二 1 Student student = {\"Mary\", 1, 60,70,80}; 存取結構中的陣列 修改的寫法 結構.成員[索引] = 值 1 2 3 student.score[0] = 50; student.score[1] = 60; student.score[2] = 70; 讀取寫法 cout &lt;&lt; 結構.成員[索引] &lt;&lt; endl; 1 2 3 for(int i = 0; i &lt; 3; i++) { cout &lt;&lt; \"score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt;student.score[i] &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; //結構中的陣列 int score[3]; }; int main() { //初始化 Student student = {\"Mary\", 1, 60,70,80}; //修改結構中的陣列 student.score[0] = 50; student.score[1] = 60; student.score[2] = 70; //印出陣列元素 for(int i = 0; i &lt; 3; i++) { cout &lt;&lt; \"score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt;student.score[i] &lt;&lt; endl; } return 0; } 傳遞結構中的陣列給函式 不管結構中的陣列是一維或多維，傳遞結構中的陣列給函式，函式參數都是指向結構的指標。 傳回值 函式名(結構指標* 指標變數名); void printParent(Student* student); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; const int PARENT_SIZE = 2; struct Student{ //學生姓名 char* name; //學號 int id; //定義二維陣列 char parent[PARENT_SIZE][100]; }; //函式參數是指向結構的指標 void printParent(Student* student) { for(int i = 0; i &lt; PARENT_SIZE; i++) { //因為是指標，所以存取成員使用-&gt; cout &lt;&lt; student-&gt;parent[i] &lt;&lt; endl; } } int main() { //初始化 Student student = {\"Mary\", 1, {\"Alice\",\"Bill\"}}; //把結構的位址傳入函式 printParent(&amp;student); return 0; } Alice Bill"
  },"/pages/c/struct/nestedStruct/": {
    "title": "巢狀結構",
    "keywords": "",
    "url": "/pages/c/struct/nestedStruct/",
    "body": "Prerequisites: 無法使用大括號修改單獨成員是字串陣列 巢狀結構指的是結構中還有結構。 定義巢狀結構 結構中的結構要先定義。 1 2 3 4 5 6 7 8 9 10 11 struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; 初始化巢狀結構 初始化方式有2種。 方式一 巢狀結構的值放進大括號中。 結構 變數名 = {值1,值2,巢狀值1,巢狀值2}; 1 Student student = {\"Mary\", 1,338, \"桃園市xxx\"}; 方式二 大括號中有大括號包著巢狀結構。 結構 變數名 = {值1,值2,{巢狀值1,巢狀值2}}; 1 Student student = {\"Mary\", 1,{338, \"桃園市xxx\"}}; 修改巢狀結構 方式有二種。 大括號 變數名 = {值1,值2,巢狀值1,巢狀值2}; 1 student = {\"Bill\", 2, 100, \"台北市xxx\"}; 點運算子 結構變數.巢狀結構成員 = {巢狀值1,巢狀值2}; 1 2 3 student.name = \"Jeff\"; student.id = 3; student.address = {300,\"新竹縣xxxx\"}; 單獨修改巢狀結構中的成員 若巢狀結構中的成員是字串，修改方式如下 1 strcpy(student.address.addr, \"新竹縣xxxx\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; int main() { Student student = {\"Mary\", 1, {338, \"桃園市xxx\"}}; student.name = \"Jeff\"; student.id = 3; student.address.zip = 300; strcpy(student.address.addr, \"新竹縣xxxx\"); cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; return 0; } After: Jeff 3 300 新竹縣xxxx 讀取巢狀結構成員 結構變數.巢狀結構成員.成員 student.address.zip 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; int main() { Student student = {\"Mary\", 1, {338, \"桃園市xxx\"}}; cout &lt;&lt; \"Before:\" &lt;&lt; endl; student = {\"Bill\", 2, 100, \"台北市xxx\"}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; student.name = \"Jeff\"; student.id = 3; student.address = {300,\"新竹縣xxxx\"}; cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; return 0; } Before: Bill 2 100 台北市xxx After: Jeff 3 300 新竹縣xxxx"
  },"/pages/c/dynamicMemory/memset/": {
    "title": "memset",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memset/",
    "body": "memset主要目的是把記憶體位址的內容(值)，設成00000000。 字串清空 資料型態為char，設成00000000，就等同設成\\0空字元(null character)，ascii code為0 陣列清空 結構清空 結構中指標清空 資料型態為指標，設成00000000，是把指標所指向的記憶體位址的內容(值)，設成00000000，等同於釋放記憶體空間，並非把指標的指向的位址改為00000000。"
  },"/pages/c/struct/pointerInStruct/": {
    "title": "結構中的指標",
    "keywords": "",
    "url": "/pages/c/struct/pointerInStruct/",
    "body": "Prerequisites: new/delete null 記憶體區間 memset與結構中的指標 要把結構中的指標釋放記憶體，光是把結構使用memset把結構記憶體的值全設為00000000是不夠的，因為只是把指標指向的位置指到00000000(null 記憶體區間)，原本指標指向的位置的值仍未清空成0，會造成記憶體洩露。 錯誤作法 memset(&amp;student, 0, sizeof(student)); 以下為錯誤作法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;iostream&gt; using namespace std; const int SCORE_MAX = 3; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 int *score; }; int main() { Student student; strcpy(student.name, \"Mary\"); student.id = 1; student.score = new int[SCORE_MAX]; for(int i = 0; i &lt; SCORE_MAX; i++) { student.score[i] = i; } //100 byte(name) + 4 byte(id) + 8 byte(*score指標) //總共占 112 byte記憶體大小 cout &lt;&lt; \"結構大小 = \" &lt;&lt; sizeof(student) &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; //將student.score的記憶體位址先暫存下來 int* pp = student.score; //將結構的成員全清成00000000 memset(&amp;student, 0, sizeof(student)); cout &lt;&lt; \"After memset :\" &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; cout &lt;&lt; \"原結構成員指標指向的記憶體位址 = \" &lt;&lt; pp &lt;&lt; endl; //原結構成員指標指向的記憶體位址中的值 for(int i = 0; i &lt; SCORE_MAX; i++) { cout &lt;&lt; \"student.score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; *(pp + i) &lt;&lt; endl; } return 0; } 結構大小 = 112 結構成員指標指向的記憶體位址 = 0x600000008040 After memset : 結構成員指標指向的記憶體位址 = 0x0 原結構成員指標指向的記憶體位址 = 0x600000008040 student.score[0] = 0 student.score[1] = 1 student.score[2] = 2 正確作法 memset(student.score, 0, sizeof(int)*SCORE_MAX); memset第3個參數不可以寫成成員指標，因為指標的記憶體大小永遠是8。 以下是錯誤寫法 memset(student.score, 0, sizeof(student.score)); 以下的作法才是真正做到結構中指標的記憶體釋放。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;iostream&gt; using namespace std; const int SCORE_MAX = 3; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 int *score; }; int main() { Student student; strcpy(student.name, \"Mary\"); student.id = 1; student.score = new int[SCORE_MAX]; for(int i = 0; i &lt; SCORE_MAX; i++) { student.score[i] = i; } //100 byte(name) + 4 byte(id) + 8 byte(*score指標) //總共占 112 byte記憶體大小 cout &lt;&lt; \"結構大小 = \" &lt;&lt; sizeof(student) &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; //將student.score的記憶體位址先暫存下來 int* pp = student.score; //將結構的成員指向的記憶體位址的值全清成00000000 memset(student.score, 0, sizeof(int)*SCORE_MAX); //將結構的成員全清成00000000 memset(&amp;student, 0, sizeof(student)); cout &lt;&lt; \"After memset :\" &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"原score成員的記憶體位址 = \" &lt;&lt; *pp &lt;&lt; endl; cout &lt;&lt; \"score成員的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; return 0; } 結構大小 = 112 結構成員指標指向的記憶體位址 = 0x600000004060 After memset : 原score成員的記憶體位址 = 0 score成員的記憶體位址 = 0x0 結構中的指標是自己 注意看結構Student中的指標指向的是Student結構，也就是結構中的指標是自已。 1 2 3 4 5 6 7 8 struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; 不能寫成以下的寫法，會編譯失敗。 1 2 3 4 5 6 7 8 struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student next; }; 以上設計這種結構是表示每一個學生都有一個指標，指向下一個學生。 學生A-&gt;學生B-&gt;學生C-&gt;學生D-&gt;null 初始化 初始化有三種方法 方式一 1 2 3 4 Student *student = new Student; strcpy(student-&gt;name, \"Mary\"); student-&gt;id = 1; student-&gt;next = nullptr; 方式二 1 Student *student = new Student({ \"Mary\", 1, nullptr}); 1 2 Student *student = nullptr; student = new Student({ \"Mary\", 1, nullptr}); 方式三 1 2 Student *student; *(student) = {1, \"Mary\", nullptr}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; int main() { Student *student = new Student({ \"Mary\", 1, nullptr}); return 0; }"
  },"/pages/c/struct/linked_list/": {
    "title": "鏈結串列",
    "keywords": "",
    "url": "/pages/c/struct/linked_list/",
    "body": "Prerequisites: 結構中的指標是自己 初始化頭節點/尾節點/暫存節點 1 2 3 4 5 6 //頭節點 Student *head = nullptr; //尾節點 Student *tail = nullptr; //暫存節點 Student *temp = nullptr; 建立節點 建立第一個節點 1 2 3 4 5 //建立第1個節點 temp = new Student({ \"Mary\", 1, nullptr}); //讓頭節點與尾節點全指向新分配的節點 head = tail = temp; 建立第二個節點 1 2 3 4 5 6 //建立第2個節點 temp = new Student({ \"Bill\", 2, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; 建立第三個節點 程式碼與前一個程式一樣。 1 2 3 4 5 6 //建立第3個節點 temp = new Student({ \"Eric\", 3, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; 遍歷鏈節串列 從頭節點開始，沿著next指標往後移動，直到next是nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 //遍歷鏈節串列 //從頭節點開始 //把頭節點指向temp指標 temp = head; //如果temp指標不是nullptr，就進去while while(temp != nullptr) { //印出姓名學號 cout &lt;&lt; \"id = \" &lt;&lt; temp-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; temp-&gt;name &lt;&lt; endl; //把temp指標移到下一個節點 temp = temp-&gt;next; } 刪除鏈節串列 從頭節點開始刪，沿著next指標往後移動，直到next是nullptr。 1 2 3 4 5 6 7 8 9 10 11 //刪除鏈節串列 //從頭節點開始刪除 //如果頭節點不為nullptr while(head != nullptr) { //頭節點先暫存到暫存節點 temp = head; //頭節點指標往後移動 head = head-&gt;next; //刪除暫存節點 delete temp; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; int main() { //頭節點 Student *head = nullptr; //尾節點 Student *tail = nullptr; //暫存節點 Student *temp = nullptr; //建立第1個節點 temp = new Student({ \"Mary\", 1, nullptr}); //讓頭節點與尾節點全指向新分配的節點 head = tail = temp; //建立第2個節點 temp = new Student({ \"Bill\", 2, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //建立第3個節點 temp = new Student({ \"Eric\", 3, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //建立第4個節點 temp = new Student({ \"Jeff\", 4, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //遍歷鏈節串列 //從頭節點開始 //把頭節點指向temp指標 temp = head; //如果temp指標不是nullptr，就進去while while(temp != nullptr) { //印出姓名學號 cout &lt;&lt; \"id = \" &lt;&lt; temp-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; temp-&gt;name &lt;&lt; endl; //把temp指標移到下一個節點 temp = temp-&gt;next; } //刪除鏈節串列 //從頭節點開始刪除 //如果頭節點不為nullptr while(head != nullptr) { //頭節點先暫存到暫存節點 temp = head; //頭節點指標往後移動 head = head-&gt;next; //刪除暫存節點 delete temp; } return 0; } id = 1, name = Mary id = 2, name = Bill id = 3, name = Eric id = 4, name = Jeff"
  },"/pages/c/string/string/": {
    "title": "string 字串",
    "keywords": "",
    "url": "/pages/c/string/string/",
    "body": "string陣列 判斷數字，印出月份英文 1 2 3 4 5 6 7 8 9 10 11 12 //12個月 const int MAX_MONTH = 12; int main() { string mon_arr[MAX_MONTH] = {\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"}; int month; cout &lt;&lt; \"請輸入數字月份(1~12):\"; cin &gt;&gt; month; //陣列索引介於0..11，所以要把month-1 cout &lt;&lt; mon_arr[month-1] &lt;&lt; endl; return 0; } 請輸入數字月份(1~12):1 January 清空 1 2 3 4 string name = \"Bill\"; cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; name.clear(); cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; name: Bill name:"
  },"/pages/c/basic/loop/": {
    "title": "迴圈",
    "keywords": "",
    "url": "/pages/c/basic/loop/",
    "body": "while while條件判斷式 while(條件判斷式) { 迴圈主體(the body of an iteration statement) } 條件判斷式為True，就進入迴圈主體，執行完迴圈主體，再回到條件判斷式，若為True，再進入迴圈主體，直到條件判斷式為False，就離開迴圈。 while初始運算式 while的初始運算式是在while之前先定義好。 int i = 0; while遞增運算式 若條件判斷式一直為True，就會成為無窮迴圈，所以需要有改變條件判斷式的方法，讓條件變為False，離開迴圈。使用遞增遞減運算式改變條件判斷式，遞增運算式定義在while迴圈中。 while (i &lt;= 100) { i++; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 int main() { //初始運算式 int i = 0; //條件判斷式 while (i &lt;= 10) { cout &lt;&lt; i &lt;&lt; endl; //遞增運算式 i++; } return 0; } 也可以簡化成一行。 1 2 3 4 5 6 int main() { int i = 0; while (true) cout &lt;&lt; i++ &lt;&lt; endl; return 0; } 0 1 2 3 4 5 6 7 8 9 10 while無窮迴圈1 若條件判斷式一直為True，就會成為無窮迴圈，無法離開循環。 若上述範例缺少遞增運算式，就會變成無窮迴圈一直執行迴圈主體無法停止。 1 2 3 while (i &lt;= 100) { //無窮迴圈 } while無窮迴圈2 若條件判斷式為true，就會成為無窮迴圈。 1 2 3 while (true) { //無窮迴圈 } break跳出迴圈 若符合特定條件，就離開迴圈。 以下程式碼是若sum &gt;= 5000就離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int sum = 0; while (true) { int input = 0; cout &lt;&lt; \"請輸入數字:\"; cin &gt;&gt; input; sum += input; if(sum &gt;= 5000) { break; } } cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; return 0; } 請輸入數字:1001 請輸入數字:1002 請輸入數字:1003 請輸入數字:1004 請輸入數字:1005 sum = 5015 continue 回到迴圈的條件判斷式 若符合特定條件，就直接回到迴圈的條件判斷式，後面的程式碼就不執行。 以下程式碼是印出1-50是5的倍數。 若不是5的倍數，直接回到迴圈的條件判斷式， 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int i = 1; while (i &lt;= 50) { if((i % 5) != 0) { i++; continue; } cout &lt;&lt; i &lt;&lt; endl; i++; } return 0; } 5 10 15 20 25 30 35 40 45 50 for for是while的變形。 條件判斷式與初始運算式與遞增運算式寫在同一行。 for(初始運算式;條件判斷式;遞增運算式) { } 以下程式碼印出5的倍數，遞增運算式是i = i + 5 1 2 3 4 5 6 int main() { for(int i = 0; i &lt;= 50; i = i + 5) { cout &lt;&lt; i &lt;&lt; endl; } return 0; } for初始運算式與遞增運算式 初始運算式可以寫在for之前。 1 2 3 4 5 6 7 8 int main() { //i寫在for之前 int i = 0; for(; i &lt;= 50; i = i + 5) { cout &lt;&lt; i &lt;&lt; endl; } return 0; } 初始運算式與遞增運算式可以有多個，用逗號分開，但條件判斷式只能一個。 1 2 3 4 5 6 7 int main() { for(int i = 0, j = 50; i &lt;= 50; i = i + 5, j = j - 5) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; } return 0; } 遞增運算式可以寫在迴圈主體中。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //初始運算式 定義在for之前 int i = 0, j = 50; for(; i &lt;= 50;) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", \"; cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; //遞增運算式寫在迴圈主體 i = i + 5; j = j - 5; } return 0; } i = 0, j = 50 i = 5, j = 45 i = 10, j = 40 i = 15, j = 35 i = 20, j = 30 i = 25, j = 25 i = 30, j = 20 i = 35, j = 15 i = 40, j = 10 i = 45, j = 5 i = 50, j = 0 for無窮迴圈 條件判斷式與初始運算式與遞增運算式都不寫的狀況下是無窮迴圈，需要使用break離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 int main() { int sum = 0; for(;;) { int input = 0; cout &lt;&lt; \"請輸入數字:\"; cin &gt;&gt; input; sum+=input; if(sum &gt;= 5000) break; } cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; return 0; } 請輸入數字:1000 請輸入數字:1000 請輸入數字:1000 請輸入數字:1001 請輸入數字:1002 sum = 5003"
  },"/pages/c/basic/strLen/": {
    "title": "取得字串長度",
    "keywords": "",
    "url": "/pages/c/basic/strLen/",
    "body": "Prerequisites: 空字元 字串清空 迴圈 實作strlen()函式 取得字串長度 陣列法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int length(char* str) { //初始值 int len = 0; //條件判斷式為字元不等於\\0，進入迴圈 for(;str[len] != 0; len++); return len; } int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; cout &lt;&lt; \"字串長度:\" &lt;&lt; length(str) &lt;&lt; endl; return 0; } 請輸入字串:abcde 字串長度:5 指標法1 1 2 3 4 5 6 7 8 9 10 11 12 13 int length(char* str) { int len = 0; //指標移到字串陣列[0]的位址 char *ptr = str; //判斷字元 while(*ptr != 0) { //位址往下一個陣列索引移動 ptr++; //記錄字串長度 len++; } return len; } 精簡版 1 2 3 4 5 6 int length(char* str) { int len = 0; char *ptr = str; while(*ptr++) len++; return len; } 指標法2 1 2 3 4 5 int length(char* str) { int len = 0; for(char *pos = str; *pos; pos++, len++); return len; } 遞迴法 1 2 3 4 5 6 7 8 9 int length(char* str) { //離開遞迴基本條件base case if(*str == 0) return 0; //若字元不為空字元，就執行以下程式碼 //指標往下個位址移動 str++; //類似迴圈len++ return length(str) + 1; } 印出字串 100次迴圈 1 2 3 4 5 6 7 8 9 10 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for(char *pos = str; *pos; pos++) cout &lt;&lt; *pos; cout &lt;&lt; endl; return 0; } 請輸入字串:abcdef abcdef 1000次迴圈 for執行100次 strlen()執行100次 100*100 = 1000次迴圈 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for(int i = 0; i &lt; strlen(str); i++) { cout &lt;&lt; str[i]; } cout &lt;&lt; endl; return 0; } 200次迴圈 將以上程式碼改善，把strlen移到初始運算式或定義在for迴圈之前，初始運算式只執行一次。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for(int i = 0, len = strlen(str); i &lt; len; i++) { cout &lt;&lt; str[i]; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/string/reverseStr/": {
    "title": "原地反轉字串",
    "keywords": "",
    "url": "/pages/c/string/reverseStr/",
    "body": "原地的意思是只在原本的陣列移動並反轉字串。 不額外建立其它記憶體空間。 思路如下 偶數字串 字串abcd從中間切一半，並頭尾向中間逐一進行交換。 ab cd a與d交換 b與c交換 奇數字串 字串abcde，中間值為c，除了c不用變，其它字母，頭尾向中間逐一進行交換。 ab c de a與e交換 b與d交換 程式碼 以abcde為例，長度為5，迴圈次數 5 / 2 = 2次 以下為互相交換的陣列索引 迴圈次數 i len-1-i 第1次 0 4 第2次 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for(int i = 0, len = strlen(str); i &lt; len/2; i++) { char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; } cout &lt;&lt; str &lt;&lt; endl; return 0; }"
  },"/pages/c/string/integerToStr/": {
    "title": "整數轉成字串",
    "keywords": "",
    "url": "/pages/c/string/integerToStr/",
    "body": "Prerequisites: 原地反轉字串 字元運算 思路 輸入1234 轉成'1234' 定義字元陣列 char result[20]; 定義索引 int index = 0; 步驟1 1234 % 10 = 4 1234 / 10 = 123 將餘數4轉成字元存入陣列 result[0] = 4 + '0'; 步驟2 123 % 10 = 3 123 / 10 = 12 將餘數3轉成字元存入陣列 result[1] = 3 + '0'; 步驟3 12 % 10 = 2 12 / 10 = 1 將餘數2轉成字元存入陣列 result[2] = 2 + '0'; 步驟4 1 % 10 = 1 1 / 10 = 0 將餘數1轉成字元存入陣列 result[3] = 1 + '0'; 翻轉字串 將'4321'轉成'1234' 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { int input = 0; cout &lt;&lt; \"請輸入整數:\"; cin &gt;&gt; input; char result[20]; memset(result, 0, sizeof(result)); //取餘數 int index = 0; while(input &gt; 0) { //將餘數轉成字元存入陣列 result[index++] = input % 10 + '0'; input = input / 10; } cout &lt;&lt; \"result : \" &lt;&lt; result &lt;&lt; endl; //翻轉 for(int i = 0, len = strlen(result); i &lt; len/2; i++) { char temp = result[i]; result[i] = result[len - 1 - i]; result[len - 1 - i] = temp; } cout &lt;&lt; \"Reverse result : \" &lt;&lt; result &lt;&lt; endl; return 0; } 請輸入整數:1234 result : 4321 Reverse result : 1234"
  },"/pages/c/string/stringCat/": {
    "title": "字串連結",
    "keywords": "",
    "url": "/pages/c/string/stringCat/",
    "body": "Prerequisites: 記憶體間隔計算 strcat 字串連結 1 memcpy(dest + strlen(dest), src, strlen(src) + 1); 假設dest字串為\"Hello\\0\"，strlen(dest)回傳5，不包含'\\0'。 dest + 5的意思是，指標往右移動5格。 dest字元 H e l l o \\0 移動前 ^           移動+5格           ^ 此時dest指標的位置在'\\0'。 假設src字串為\"World\\0\"， strlen(src) + 1是指要拷貝src全部字串， + 1是包含src的'\\0'也一併拷貝到dest。 從dest所在的指標位址開始拷貝src的字元。 dest字元 H e l l o \\0           移動前 ^                     移動+5格           ^           拷貝src           W o r l d \\0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //參數2因為是常數字串，所以型態為const char* char* myStrCat(char* dest,const char* src) { //拷貝src字串 memcpy(dest + strlen(dest), src, strlen(src) + 1); //返回dest開始位址 return dest; } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello\"); myStrCat(str,\"World\"); cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; return 0; } str = HelloWorld strncat 拷貝n個字元 memcpy(dest + len, src, n); 參數1 = dest + len 將位址移動到要拷貝的起始位址 參數2 = src 從src[0]位址開始拷貝字元 參數3 = n 拷貝幾個字元 目的字串 = Hello 來源字串 = World 拷貝個數 = 2 將來源字串Wo(二個字元)，接到Hello字串後面。 將目的字串位址移到最後面 dest字元 H e l l o \\0           移動前 ^                     移動+5           ^           將Wo連到目的字串(Hello)位址最後面 dest字元 H e l l o \\0           拷貝src           W o         連結完來源字串Wo後，在最後面加上空字元 *(dest + len + n) = 0; dest字元 H e l l o \\0           加上空字元           W o \\0       1 2 3 4 5 6 7 char* myStrNCat(char* dest,const char* src,const size_t n) { //先把dest字串的長度先存下來 size_t len = strlen(dest); memcpy(dest + len, src, n); *(dest + len + n) = 0;//將目的字串與拷貝的字串最後面添加結尾字元0 return dest; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 char* myStrNCat(char* dest,const char* src,const size_t n) { //先把dest字串的長度先存下來 size_t len = strlen(dest); memcpy(dest + len, src, n); *(dest + len + n) = 0; return dest; } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello\"); myStrNCat(str,\"World\",2); cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; return 0; }"
  },"/pages/c/string/stringCopy/": {
    "title": "字串拷貝",
    "keywords": "",
    "url": "/pages/c/string/stringCopy/",
    "body": "Prerequisites: 記憶體間隔計算 陣列法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { //i為dest陣列的索引 //j為src陣列的索引 int i = 0, j = 0; // 如果來源字串不為0就進入迴圈 while(src[j]) { //將src[j]的值給dest[i]，然後i++,j++ dest[i++] = src[j++]; } //將dest結尾放上空字元 dest[i] = 0; return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } name = Bill 指標法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { //若src的值不為空就進入迴圈 while(*src) { //將src的值指派給dest，接著指標往下個位址移動 *dest++ = *src++; } //將dest的值放上空字元 *dest = 0; return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } memcpy 將來源字串copy到目的字串，拷貝字數由參數3決定。 memcpy(目的字串, 來源字串, 要拷貝字數); strlen(src)回傳是不包含'\\0'的長度，所以再+1，才會把src的結尾'\\0'拷貝到目的字串。 1 2 3 4 5 6 7 8 9 10 11 12 13 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { memcpy(dest, src, strlen(src) + 1); return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } 改良式strncpy 傳統的strncpy，若n的長度小於src的長度，不會在dest結尾加上'\\0'。 所以改良式strncpy，不管n是不是小於src的長度，都會在結尾加上'\\0'。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //參數2因為是常數字串，所以型態為const char* char* myStrnCpy(char* dest,const char* src,const size_t n) { memcpy(dest, src, n); *(dest + n) = 0;//增加結尾符號 return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrnCpy(name,\"Bill\",2); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; }"
  },"/pages/c/string/stringToInt/": {
    "title": "字串轉成數字",
    "keywords": "",
    "url": "/pages/c/string/stringToInt/",
    "body": "思路 將`1234`轉成1234 定義int result = 0，作為乘數。 用迴圈遍歷字串 步驟1 input[0]是`1`，把`1`變成整數1。 '1' - '0' = 1 result = 0 (result * 10) + 1 = 1 result = 1 步驟2 input[1]是`2`，把`2`變成整數2。 '2' - '0' = 2 result = 1 (result * 10) + 2 = 12 result = 12 步驟3 input[2]是`3`，把`3`變成整數3。 '3' - '0' = 3 result = 12 (result * 10) + 3 = 123 result = 123 步驟4 input[3]是`4`，把`4`變成整數4。 '4' - '0' = 4 result = 123 (result * 10) + 4 = 1234 result = 1234 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char input[10]; memset(input, 0, sizeof(input)); cout &lt;&lt; \"請輸入整數:\"; cin &gt;&gt; input; int result = 0; for(int i = 0, len = strlen(input); i &lt; len; i++) { result = (result * 10) + input[i] - '0'; } cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } 請輸入整數:1234 result = 1234"
  },"/pages/c/basic/chrono/": {
    "title": "程式執行時間",
    "keywords": "",
    "url": "/pages/c/basic/chrono/",
    "body": "include chrono #include &lt;chrono&gt; 執行的程式碼，放入要計算執行效率的程式 1 2 3 4 5 6 7 8 9 10 11 12 //start 計時開始 //end 計時結束 std::chrono::steady_clock::time_point start,end; //dt 時間差 std::chrono::nanoseconds dt; start = chrono::steady_clock::now(); for(int i = 0;i &lt; 100000;i++) { 執行的程式碼 } end = chrono::steady_clock::now(); dt = end - start; cout &lt;&lt; \"執行\" &lt;&lt; (double)dt.count()/(1000 * 1000 * 1000) &lt;&lt; \"秒\" &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;chrono&gt; using namespace std; //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { memcpy(dest, src, strlen(src) + 1); return dest; } int main() { //start 計時開始 //end 計時結束 std::chrono::steady_clock::time_point start,end; //dt 時間差 std::chrono::nanoseconds dt; char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); //開始計時 start = chrono::steady_clock::now(); for(int i = 0;i &lt; 10000;i++) { myStrCpy(name, \"Bill\"); } end = chrono::steady_clock::now(); dt = end - start; cout &lt;&lt; \"執行\" &lt;&lt; (double)dt.count()/(1000 * 1000 * 1000) &lt;&lt; \"秒\" &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; }"
  },"/pages/c/string/strchr/": {
    "title": "字元搜尋",
    "keywords": "",
    "url": "/pages/c/string/strchr/",
    "body": "strchr從字串左邊搜尋字元 從字串左邊搜尋字元，回傳從左邊搜尋的第一個字元位址，並印出字元位址之後所有的字元。 搜尋字串 = Hello World! 搜尋字元 = W 搜尋結果 = World! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char* mystrchr(const char* s,int c) { //將s開始位址給p指標 //const char*轉成char*要強制轉型 char* p = (char *)s; //若p指標的值不為\\0就進入迴圈 while(*p) { //若為指標的值與字元是相同，代表找到 //傳回p的位址 if(*p == c) return p; p++;//位址往右移一位 } return 0;//找不到就回傳null的位址 } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello World!\"); char* p1 = mystrchr(str,'W'); if(p1 != 0) { cout &lt;&lt; \"p1 = \" &lt;&lt; p1 &lt;&lt; endl; } return 0; } p1 = World! strrchr從字串右邊搜尋字元 從字串右邊搜尋字元，回傳從右邊搜尋的第一個字元位址，並印出字元位址之後所有的字元。 搜尋字串 = Hello World! 搜尋字元 = o 搜尋結果 = orld! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 char* mystrrchr(const char* s,int c) { //將s開始位址給p指標 //const char*轉成char*要強制轉型 char* p = (char *)s; char* p1 = 0; //若p指標的值不為\\0就進入迴圈 while(*p) { //若為指標的值與字元是相同，代表找到 //p的位址放入p1中 if(*p == c) p1 = p; p++;//位址往右移一位 } return p1;//回傳p1最後的位址 } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello World!\"); char* p1 = mystrrchr(str,'o'); if(p1 != 0) { cout &lt;&lt; \"p1 = \" &lt;&lt; p1 &lt;&lt; endl; } return 0; } p1 = orld!"
  },"/pages/c/string/strcmp/": {
    "title": "字串比較",
    "keywords": "",
    "url": "/pages/c/string/strcmp/",
    "body": "strcmp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** 字串相等回傳0 str1字元&gt;str2字元 return 1 str1字元&lt;str2字元 return -1 **/ int mystrcmp(const char* str1,const char* str2) { //特別注意，使用while(true)，即便str1或str2是\\0也能比較 while(true){ //str1字元&gt;str2字元 if(*str1 &gt; *str2) return 1; //str1字元&lt;str2字元 if(*str1 &lt; *str2) return -1; //二個字元結尾相等 if(*str1 == 0 &amp;&amp; *str2 == 0) return 0; //比較下一個字元 str1++; str2++; } } int main() { cout &lt;&lt; mystrcmp(\"abc\",\"abcd\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"ab\",\"a\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"abc\",\"abc\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"\",\"a\") &lt;&lt; endl; return 0; } -1 1 0 -1 strncmp int mystrncmp(const char* str1,const char* str2,const size_t n) 第一個參數是比較字串1。 第二個參數是比較字串2。 第三個參數n是要比較多少字元，若n為2，比較字串1與字串2前2個字元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int mystrncmp(const char* str1,const char* str2,const size_t n) { int i = 0; while(i &lt; n){ //str1字元&gt;str2字元 if(*str1 &gt; *str2) return 1; //str1字元&lt;str2字元 if(*str1 &lt; *str2) return -1; //二個字元結尾相等 if(*str1 == 0 &amp;&amp; *str2 == 0) return 0; //比較下一個字元 str1++; str2++; i++; } //比較n次仍比較不出來，就回傳0 return 0; } int main() { cout &lt;&lt; mystrncmp(\"abc\",\"abcd\",2) &lt;&lt; endl; cout &lt;&lt; mystrncmp(\"ab\",\"a\",2) &lt;&lt; endl; cout &lt;&lt; mystrncmp(\"abc\",\"abc\",2) &lt;&lt; endl; return 0; } 0 1 0"
  },"/pages/c/string/strstr/": {
    "title": "字串搜尋",
    "keywords": "",
    "url": "/pages/c/string/strstr/",
    "body": "Prerequisites: 記憶體間隔計算 目的字串 hdhelhelloWor 搜尋字串 hello\\0 要在目的字串中找到搜尋字串的開始位置。 目的字串 h d h e l h e l l o W o r ^                         搜尋字串 h e l l o 0               ^                         目的字串 + 1 h d h e l h e l l o W o r   ^                       搜尋字串 + 1 h e l l o 0                 ^                       發現不一樣，指標退回。 目的字串 + 0 h d h e l h e l l o W o r ^                         搜尋字串 + 0 h e l l o 0               ^                         目的字串往右移動 + 1 h d h e l h e l l o W o r   ^                       搜尋字串 + 0   h e l l o 0               ^                       發現二邊指標的值不同。 目的字串往右移動一格 + 1 h d h e l h e l l o W o r     ^                     搜尋字串 + 0     h e l l o 0               ^                     發現與搜查字串第1個字元相同，開始比較 目的字串 + 1 h d h e l h e l l o W o r       ^                   搜尋字串 + 1     h e l l o 0                 ^                   目的字串 + 1 h d h e l h e l l o W o r         ^                 搜尋字串 + 1     h e l l o 0                   ^                 目的字串 + 1 h d h e l h e l l o W o r           ^               搜尋字串 + 1     h e l l o 0                     ^               發現不一樣，退回最初一開始比較的地方 目的字串 - 3 h d h e l h e l l o W o r     ^                     搜尋字串 - 3     h e l l o 0               ^                     目的字串往右移，與搜尋字串不一致 + 1 h d h e l h e l l o W o r       ^                   搜尋字串 + 0       h e l l o 0               ^                   目的字串往右移，與搜尋字串不一致 + 1 h d h e l h e l l o W o r         ^                 搜尋字串 + 0         h e l l o 0               ^                 目的字串往右移，與搜尋字串一致，開始比對。 + 1 h d h e l h e l l o W o r           ^               搜尋字串 + 0           h e l l o 0               ^               目的字串 + 1 h d h e l h e l l o W o r             ^             搜尋字串 + 1           h e l l o 0                 ^             目的字串 + 1 h d h e l h e l l o W o r               ^           搜尋字串 + 1           h e l l o 0                   ^           目的字串 + 1 h d h e l h e l l o W o r                 ^         搜尋字串 + 1           h e l l o 0                     ^         目的字串 + 1 h d h e l h e l l o W o r                   ^       搜尋字串 + 1           h e l l o 0                       ^       目的字串 + 1 h d h e l h e l l o W o r                     ^     搜尋字串 + 1           h e l l o 0                         ^     比對到搜尋字串\\0，代表已經搜尋到了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const char* mystrstr(const char *dest, const char *search) { //i為dest的索引 size_t i = 0; //j為serch的索引 size_t j = 0; //目的字串長度 size_t dlen = strlen(dest); //搜尋字串長度 size_t slen = strlen(search); //若i超過目的字串長度，代表都找不到 //若j超過搜尋字串長度，代表找到 while((i &lt; dlen) &amp;&amp; (j &lt; slen)) { //目的字元與搜索字元相等 if(dest[i] == search[j]) { i++;//指標往下個字元移動 j++;//指標往下個字元移動 } else { //不相等 i = i - j; //指標移到最開始的位址 j = 0; //搜尋字串的索引移到最前面 i++ ; //目的字串指標往下一個位址移動 } } //若j等於搜尋字串的長度代表找到 if(j == slen) return dest + (i - j); return 0;//尋找失敗 } int main() { const char* p1 = mystrstr(\"hdhelhelloWor\", \"hello\") ; if(p1 != 0) cout &lt;&lt; p1 &lt;&lt; endl; return 0; } helloWor"
  },"/pages/c/string/delstr/": {
    "title": "刪除字元",
    "keywords": "",
    "url": "/pages/c/string/delstr/",
    "body": "Prerequisites: 記憶體間隔計算 刪除右邊多的字元 刪除前字串:Hellloyyyoooyyy 刪除右邊有y的字母 刪除後字串:Hellloyyyooo 思路 添加flag，判斷找到右邊的字元，flag變成1，並記錄位置，但如果右邊字元後面仍有其它字母就把flag變成0。 第一次找到y，flag變1，並記錄位址。 H e l l l o y y y o o o y y y             1                             p                 發現後面有不是y的字母，flag變0。 H e l l l o y y y o o o y y y                   0                       p                 第二次找到y，flag變1，並記錄位址。 H e l l l o y y y o o o y y y                         1                             p     將記錄的位址變成'\\0'結尾空字元，也就是0。 H e l l l o y y y o o o 0 y y                         1                             p     當印出字串時看到有結尾空字元0，就會停止輸出。 印出結果 Hellloyyyooo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void deleterchr(char* str, const int c) { //判斷位址為null就返回 if(str == 0) return; //記錄位址的指標 char *p = 0; //false為0，true為1，預設為0 bool flag = false; //若字元不為空字元就進入迴圈 while(*str) { //如果字元的值等於要刪的字母 if(*str == c) { //如果flag為0，才能進來 if(!flag) { //記錄要刪字母的位置 p = str; //把flag變成1 flag = true; } } else { //如果要刪的字母後面仍有其它不能刪的字母 //直接把flag變成0 flag = false; } //指標往下個位址移動 str++; } //若有找到刪除的字元 if(flag) { //把之前記錄的位址的值變成0 *p = 0; } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hellloyyyoooyyy\"); //刪除右邊為y的字母 deleterchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } Hellloyyyooo 刪除左邊的字元 刪除前字串:yyyyooooyy 刪除左邊有y的字母 刪除後字串:ooooyy 思路 找出第一個不是刪除字元的記憶體位址。 count變數，記錄有幾個字元要刪除。 p指標，主要記錄第一個不是要刪的字母。 p指標，初始化為字串陣列索引0的記憶體位址。 遍歷字串陣列的每一個字元，若等於要刪除的字元，就進入迴圈，然後p指標往下一個索引移動，若下一個字元等於刪除的字元，然後就進入迴圈，直到下一個字元不等於刪除的字元就離開迴圈，而p指標所指向的就是第一個不等於y的字元，同時count變數也會記錄要刪除的個數，每進入一次迴圈就代表要刪掉一個字元。 字串 y y y y o o o o y y p指標         p           count 0 1 2 3 4           將後面的字串往前移動至最前面 字串 y y y y o o o o y y 覆蓋的字串 o o o o y y         因為有覆蓋到原本的字串，所以要使用memmove memmove(目的位址, 來源位址, 拷貝個數); 程式碼1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void deletelchr(char* str, const int c) { if(str == 0) return; //p指標初始化str字串首位址 //p指標，記錄第一個不是要刪的字母。 char *p = str; //記錄有幾個字元要刪除 int count = 0; //若當前字元為要刪除的c則進入迴圈 while(*p == c) { //指標移到下一個字元 p++; count++; //離開迴圈的條件是字元不等於c //p會指向非刪除的字元 } //若p的位址，不等於str的首位址 //代表有進入上面while的迴圈 if(p != str) { //把來源字串移到目的字串 // memmove(str, p, strlen(str) - (p - str) + 1); //+1是把結尾空字元符號\\0也拷貝過來 memmove(str, p, strlen(str) - count + 1); } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"yyyyooooyy\"); deletelchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } ooooyy 程式碼2 字串 y y y y o o o o y y str指標 str                   p指標         p           memmove(目的位址, 來源位址, 拷貝個數); memmove(str, p, strlen(str) - (p - str) + 1); 假設str的位址是0x00000004 假設p的位址是0x00000008 p - str = 4 strlen(“yyyy0000yy”) = 10 memmove(str, p, 10 - 4 + 1); 最後的+1，是把來源字串的'\\0'也覆蓋目的字串。 也就是把'ooooyy\\0'共7個覆蓋到目的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void deletelchr(char* str, const int c) { if(str == 0) return; //p指標存放str字串首位址 char *p = str; //若當前字元為要刪除的c則進入迴圈 while(*p == c) { //指標移到下一個字元 p++; //離開迴圈的條件是字元不等於c //p會指向非刪除的字元 } //若p的位址，不等於str的首位址 //代表有進入上面while的迴圈 if(p != str) { //把來源字串移到目的字串 //+1是把結尾空字元符號\\0也拷貝過來 memmove(str, p, strlen(str) - (p - str) + 1); } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"yyyyooooyy\"); deletelchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 刪除中間字串 刪除前字串 = zzz123zzz 要刪除123 刪除後字串 = zzzzzz 指標解釋 str字串陣列第0個記憶體位址 find要刪除字串的第一個記憶體位址 slen為要刪除字串的長度，要刪除123，刪除字串大小為3 find+slen排除掉刪除字串的第一個記憶體位址。 z z z 1 2 3 z z z 0 str     find     find+slen       思路 聚焦在find要刪除字串。 把find字串覆蓋前後表格 覆蓋前 1 2 3 z z z 0 第一個位址 find             覆蓋後 z z z 0       find與find+slen指標位址 1 2 3 z z z 0 find     find+slen       目的字串位址是find = 123zzz0 來源字串位址是find + slen(3) = zzz0 要覆蓋幾個字元？find字串長度(6) - 要刪字串的長度(3) + '\\0' 空字元(1) = 4個字元 memmove(目的位址, 來源位址, 拷貝個數); memmove(find, find + slen, strlen(find) - slen + 1); 程式碼(while) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void delMiddle(char* str, const char* substr) { if(str == 0 || substr == 0) return; if(strlen(str) == 0) return; int slen = strlen(substr); if(slen == 0) return; while(true) { char* find = strstr(str, substr); if(find == 0) return; memmove(find, find + slen, strlen(find) - slen + 1); } //遞迴作法 //delMiddle(find, substr); } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"zzz123123zzz\"); delMiddle(str, \"123\"); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } zzzzzz 程式碼(遞迴) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void delMiddle(char* str, const char* substr) { if(str == 0 || substr == 0) return; if(strlen(str) == 0) return; int slen = strlen(substr); if(slen == 0) return; char* find = strstr(str, substr); if(find == 0) return; memmove(find, find + slen, strlen(find) - slen + 1); //遞迴作法 delMiddle(find, substr); } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"zzz123123zzz\"); delMiddle(str, \"123\"); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } zzzzzz"
  },"/pages/c/string/chineseAscii/": {
    "title": "ASCII與中文",
    "keywords": "",
    "url": "/pages/c/string/chineseAscii/",
    "body": "Ascii Code 1-31為控制碼 字元 Ascii code \\0 0 0-9 48-57 A-Z 65-90 a-z 97-122 空格 32 印出中文Ascii code 字元char的範圍為0-255，不包含負數，只有正整數。 中文的Ascii Code 128-255，數字、大小寫英文字母、空格、標點符號、空字元(\\0)介於Ascii Code 0-127。 字元char是0-255，沒有負數，在把中文字元轉換成整數之前，必須先轉成unsigned char，再轉成int，才會正確顯示中文的ascii碼。 1 (int)(unsigned char)str[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"西西\"); cout &lt;&lt; \"長度:\" &lt;&lt; strlen(str) &lt;&lt; endl; for(int i = 0, len = strlen(str); i &lt; len; i++) { cout &lt;&lt; \"str[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; (int)(unsigned char)str[i] &lt;&lt; endl; } //印出字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 長度:6 str[0]=232 str[1]=165 str[2]=191 str[3]=232 str[4]=165 str[5]=191 西西 使用中文Ascii Code指定陣列值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); str[0] = 232; str[1] = 165; str[2] = 191; str[3] = 232; str[4] = 165; str[5] = 191; //印出字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 西西 統計中文個數 數字、大小寫英文字母、空格、標點符號、空字元(\\0)介於Ascii Code 0-127。 中文的Ascii Code 128-255。 以下程式碼是錯的，仍待修正。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int countChar(const char* str) { if(str == 0) return -1; int count = 0; bool flag = false; while(*str) { //0 if((unsigned char) *str &lt; 128) { count++; } else { if(flag) { count++; flag = false; } else { flag = true; } } str++; } return count; } int main() { cout &lt;&lt; countChar(\"西\") &lt;&lt; endl; return 0; }"
  },"/pages/life/design/": {
    "title": "生活設計",
    "keywords": "",
    "url": "/pages/life/design/",
    "body": "收納設計 納米膠/布膠帶/免釘膠/油性膠水/熱融膠 壓克力板/透明瓦楞板 百頁 抽屜 折的抽屜 13L抽屜 8L抽屜 自製抽屜 抽拉櫃 廚房鞋架 夾拖把 伸縮杆 浴廁架子 瓶子 牛奶瓶廚房收納架 牛奶瓶分隔 可樂瓶收納 舒跑瓶筆桶 舒跑瓶香皂桶 垃圾收納架 壁掛 淘寶好物 美妝 洗髮 包包開箱 假皮 真皮 二層 頭層 油蠟 植柔 女鞋開箱 假皮 真皮 ADHD 我被霸凌的那件事 生活趣事 育兒日誌 愛的教育 誰說疼愛小孩會變壞，打罵才會有一輩子心理創傷。 要把小孩當作獨立的個體，視為一個成人，尊重他，讓他自己選擇，而不是幫他選擇，讓他做喜歡的事，有成就感的事。 若不讓他皮，那他如何釋放？皮被困在身體裡面會變成什麼？ 沒有控制權，產生精神疾病。 兒童霸凌的回應 霸凌是”針對”同一個人，進行”重覆”的言語上 或 肢體上 或 散播遙言，以任何手段造成當事人心理折磨，霸凌者覺得這一切都是他的錯，是他活該，他活該被這樣對待。 步驟一，你在這樣做，我就不會喜歡你，我就不要跟你玩，我要跟老師說。 步驟二，跟老師說了，仍是受到霸凌，老師無法處理，情況仍是依舊，重覆的事情仍然發生。 步驟三，家長出面，也請對方家長出面。因為這種狀況，小孩已經沒辦法處理，老師也沒辦法處理，必須由雙方家長處理。 步驟四，對方家長放任，無法改變情況，已經無力回天，直接幫小孩換環境。 成人霸凌處理的方式 霸凌是”針對”同一個人，進行”重覆”的言語上 或 肢體上 或 散播遙言，以任何手段造成當事人心理折磨，霸凌者覺得這一切都是對方的錯，是他活該，他很黑，他很差，他很爛很笨，他活該被我霸凌。 霸凌者是同事 步驟一，你在這樣做，你這樣的行為讓我不舒服，並且告知主管。 步驟二，告知主管後，仍是受到霸凌，主管無法處理，情況仍是依舊，重覆的事情仍然發生。 步驟三，無法改變情況，已經無力回天，直接換環境，愈快愈好。 步驟四，換了環境後仍遇到相同狀況，重覆執行步驟1至3，並且學會認清什麼是自己的界限，當其它人踩到自己界限第一反應很重要，善良忍耐退讓都會吸引霸凌者步步逼進，對霸凌者來說，”善良忍耐退讓”是十分香甜美味可口很吸引人，要相信人性本惡，不管是台大交大成大，人性是邪惡，跟學歷無關。 選公司就像找老公，不可能一次選到位，這個男友(公司)不好，不代表下一個男友(公司)不好，持續尋找男友(公司)，終究會找到適合自已的男朋友(公司)，眾裡尋他千百度，千百度代表經歷許多次的尋找男友(公司)，最終會找到合適的男友(公司)，重點要持續尋找。 霸凌者是主管 若是霸凌者是主管，直接進行以上步驟三，因為無法改變情況，已經無力回天，直接換環境，愈快愈好。 別相信可以感化其他人，不可能！有毒環境待著就等於慢性自殺。 人性 別想改變任何人，因為改變不了 遠離那些說你不好的人，繼續相處對方仍覺得你不好。 不要干預其它人 每個人有每個人的課題，不要干預其它人的課題，侵犯他人界限。 逃避並不可恥 無法控制等於自殺 釋放毒素 創傷無法忘，壓抑只會產生毒素在全身上下游走，產生乳線癌/腸胃相關癌症/肝癌/肺癌，最好的方式是傾訴，訴說，寫文意訴說，毒素見光即死。 千萬不要問別人，我要怎麼改？該怎麼做？我那裡不好？ 不要把控制權交給其它人，別人說了不好聽的話只會讓往身體增加毒素，不會更好，別人說不出什麼好話，不如不要問，不要做沒有意義的事，如之前提到，”霸凌者覺得這一切都是對方的錯，是他活該，他很黑，他很差，他很爛很笨，他活該被我霸凌。”，把問題問支持霸凌的人，你能期待有什麼正確答案，不管怎麼退讓改善，霸凌者永遠可以找其它部分霸凌，這是個循環，打破循環的條件就是離開有毒環境，離開這群有害的人。 對方不把你當人，你又何必把對方當人 對方不把你當人尊重，你又何必把他當人尊重，沒有什麼應不應該，沒有他是老闆就可以賤踏你的尊嚴，然後你一定要尊重他。 劣幣驅逐良幣 游泳課密集班 衣架 當房東這件事情 暗黑ptt"
  },"/pages/c/editor/clang/": {
    "title": "安裝VS在MAC(實作)",
    "keywords": "",
    "url": "/pages/c/editor/clang/",
    "body": "安裝code 打開VS Code，按住(Cmd+Shift+P)，並在以下視窗輸入 &gt;shell command 安裝成功會顯示以下畫面。 安裝clang 打開VS Code，按住(⇧⌘X)，會出現延伸模組視窗。 並輸入c++ 選擇C/C++，並安裝 修改 ~/.bash_profile 打開終端機，輸入以下指令。 vi ~/.bash_profile 在最下方複製貼上以下內容。 # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" 儲存離開。 在終端機再繼續輸入以下指令 source ~/.bash_profile 修改 ~/.zprofile 在終端機再輸入以下指令。 cat &lt;&lt; EOF &gt;&gt; ~/.zprofile # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" EOF 檢查clang version 將終端機重開，輸入以下指令 clang --version 要確保出現如下圖示。 code . 從終端機進入自建放程式碼的目錄，並在終端機輸入以下指令。 code . 建立檔案 點擊新增檔案 命名為helloword.cpp，並將以下程式碼貼上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main() { vector&lt;string&gt; msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string&amp; word : msg) { cout &lt;&lt; word &lt;&lt; \" \"; } cout &lt;&lt; endl; } 執行 點擊圖下紅框處 修改tasks.json 確定command的路徑為/usr/bin/clang++，點擊helloworld.cpp再執行一次。 執行結果"
  },"/pages/c/editor/vsDebug/": {
    "title": "VS Debug",
    "keywords": "",
    "url": "/pages/c/editor/vsDebug/",
    "body": "F9設置/取消斷點 F5/F10開始調試 shift+F5放棄調試 F10逐過程執行 F11逐語句執行(進入函式) 設置中斷點 點擊圖下紅點位置。 執行斷點 F5 移到斷點 第一次迴圈 以下紅框的按鈕為跳到下一個斷點，但目前範例只有在迴圈中一個斷點，也就意味下一個斷點就是下一次迴圈。 左邊會有變數的變化，區域變數word，會根據每一次迴圈，值有所不同。 第二次迴圈 紅框的按鈕為跳到下一個斷點，區域變數word的值已經變成C++。 查詢變數的值 全部執行完斷點 在偵錯主控台並不會邊執行邊輸出，必須等到全部執行斷點，結果才會印出來。 F11 移到下一行程式碼"
  },"/pages/c/string/split/": {
    "title": "split 切割字串",
    "keywords": "",
    "url": "/pages/c/string/split/",
    "body": "Prerequisites: 記憶體間隔計算 切割字串 = aa,bb,cc,dd,ee,ff 切割符號 = , 儲存二維陣列 values[10][50] 第一次循環 字串 aa , bb , cc , dd , ee , ff p ^                     find   ^                   第二次循環 字串 aa , bb , cc , dd , ee , ff p     ^                 find       ^               最後一次循環，find已經找不到切割符號 字串 aa , bb , cc , dd , ee , ff p                     ^ find                       完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** str 要切割的字串 splitStr 切割符號 values儲存的結果陣列 **/ size_t splitstr(const char* str,const char* splitStr, char values[][50]) { //若位址為空，回傳0 if(str == 0 || splitStr == 0) return 0; size_t slen = strlen(splitStr);//split符號長度 if(slen == 0) return 0;//若符號長度為0，就不用切割 //強制轉型const char* str轉成char* char *p = (char*)str; //aa,bb,cc,dd,ee,ff //切割符號為逗號，切割的個數為6個，分別為aa|bb|cc|dd|ee|ff size_t size = 0;//記錄切割的個數 while(true) { //找尋切割符號第一個位置 char* find = strstr(p, splitStr); //如果找到 if(find != 0) { //截取p的位置到切割符號之前的字元個數 //參數1要儲存的位址 //參數2要拷貝的開始位址 //參數3要拷貝的個數 strncpy(values[size++], p, find - p); //將p指標移到切割符號右邊的字元 p = find + slen; } else { //如果找不到切割符號 //代表是最後一個字串 strcpy(values[size++], p); break;//跳出無限迴圈 } } return size; } int main() { char values[10][50]; memset(values, 0, sizeof(values)); //回傳切割個數 size_t count = splitstr(\"aa,bb,cc,dd,ee,ff\", \",\", values); cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; for(int i = 0; i &lt; count; i++) { cout &lt;&lt; \"values[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; values[i] &lt;&lt; endl; } return 0; } count = 6 values[0] = aa values[1] = bb values[2] = cc values[3] = dd values[4] = ee values[5] = ff"
  },"/pages/c/basic/rand/": {
    "title": "亂數",
    "keywords": "",
    "url": "/pages/c/basic/rand/",
    "body": "rand() rand() std函式庫，取得亂數，但只生成一次，每次產生的亂數不會有重覆。 以下程式碼，不管執行幾次，產生的亂數都一樣，但10個數字都不相同。 1 2 3 4 5 6 7 int main() { //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 srand() srand()，產生亂數種子，根據種子不同，會產生不同結果。 但亂數種子若都固定相同，每次執行產生相同結果。 1 2 3 4 5 6 7 8 int main() { srand(1); //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 1 2 3 4 5 6 7 8 int main() { srand(2); //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 33614 564950498 1097816499 1969887316 140734213 940422544 202055088 768218109 770072199 1866991771 srand(time(0)) time(0) std函式，取得從1970-01-01累積到現在的秒數，也就是現在時間。 把time(0)作為srand()的參數，確保每次執行亂數都不會相同。 1 2 3 4 5 6 7 8 9 int main() { srand(time(0)); cout &lt;&lt; \"time(0)=\" &lt;&lt; time(0) &lt;&lt; endl; //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } time(0)=1726015663 936144365 1313144633 332406612 1152962037 1088008978 343639041 957835304 800536416 630495257 1049470101 產生一定範圍的隨機數字 產生0~20之間的亂數 假設產生0~20之間的數字，直接把亂數 % 20 1 2 3 4 5 6 7 8 int main() { srand(time(0)); //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() % 20 &lt;&lt; endl; } return 0; } 10 7 14 1 17 13 10 12 8 8 產生50~70之間的亂數 把上一個範例0~20之間的隨機數字+50，就可以產生50~70之間的亂數。 50就是最小的數字 1 rand() % 20 + 50 完整程式碼 1 2 3 4 5 6 7 8 int main() { srand(time(0)); //產生10個亂數 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() % 20 + 50 &lt;&lt; endl; } return 0; } 58 55 62 52 61 60 64 65 51 60 亂數取餘數會重覆 rand()函式產生的亂數是不會重覆。 但對rand() % 20，取餘數亂數就會重覆。 1 2 3 4 5 6 7 8 9 10 int main() { srand(time(0)); //產生10個亂數 for(int i = 0; i &lt; 10; i++) { int val = rand(); cout &lt;&lt; \"rand = \" &lt;&lt; val; cout &lt;&lt; \" , rand % 20 = \" &lt;&lt; val % 20 &lt;&lt; endl; } return 0; } rand = 976027376 , rand % 20 = 16 rand = 1612012646 , rand % 20 = 6 rand = 442850770 , rand % 20 = 10 rand = 1962054535 , rand % 20 = 15 rand = 1639170060 , rand % 20 = 0 rand = 1610974704 , rand % 20 = 4 rand = 178028752 , rand % 20 = 12 rand = 684514593 , rand % 20 = 13 rand = 566867572 , rand % 20 = 12 rand = 1105824512 , rand % 20 = 12"
  },"/pages/c/string/xml/": {
    "title": "xml搜尋",
    "keywords": "",
    "url": "/pages/c/string/xml/",
    "body": "Prerequisites: 記憶體間隔計算 要在一堆xml內容中尋找標籤名為name，並取出值。 &lt;id&gt;1&lt;/id&gt;&lt;name&gt;Cici&lt;/name&gt;&lt;age&gt;10&lt;/age&gt; 思路 組成name開始標籤與結束標籤 自已建立&lt;name&gt;字串，並在xml中尋找是否有相同的字串，函式會回傳&lt;name&gt;起始位址。 xml &lt; n a m e &gt; 回傳位址 ^           自已建立&lt;/name&gt;字串，並在xml中尋找是否有相同的字串，函式會回傳&lt;/name&gt;起始位址。 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 回傳位址                     ^             計算值的字元個數 假設位址以0x00000001開始 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; findEnd                     ^             findStart ^                                 值的字元個數計算方式，取得findEnd記憶體位址 - findStart記憶體位址 - 左右括號 - 標籤名 findEnd(11) - findStart(1) - `&lt;&gt;`左右括號(2) - xml標籤名name(4) = 4 1 size_t valueLen = findEnd - findStart - fieldLen - 2; 截取值 指標移動2格&lt;&gt;左右括號，再移動4格name標籤名的長度，就會移動到值的起始位址。 上一個步驟有算出，值的長度為4個字元，從移動後的指標，往後取得4個字元(包含移動後指標當前的值)。 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 移動前 ^                                 移動後             ^                     取值             x x x x               1 strncpy(values, findStart + 2 + fieldLen , valueLen); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** xmlbuffer xml字串 fieldname 要搜尋的 標籤名 values存放找到的值 **/ bool xmlSearch(const char* xmlbuffer, const char* fieldname, char* values) { //檢查參數有沒有值 if(xmlbuffer == 0 || fieldname == 0 || values == 0) return false; //搜尋的欄位名大小 size_t fieldLen = strlen(fieldname); //組成xml搜尋字串 //例，找xml標籤名是name的值 //開始 標籤名的字串 //&lt;name&gt;\\0 //字串大小為2個&lt;&gt;尖括號+1個結尾空字元0+標籤名name大小 char* startField = new char[2 + 1 + fieldLen]; //清空陣列 memset(startField, 0, sizeof(startField)); strcpy(startField, \"&lt;\"); strcat(startField, fieldname); strcat(startField, \"&gt;\"); //結束 標籤名的字串 //&lt;/name&gt;\\0 //字串大小為3個&lt;/&gt;符號+1個結尾空字元0+標籤名name大小 char* endField = new char[3 + 1 + fieldLen]; //清空陣列 memset(endField, 0, sizeof(endField)); strcpy(endField, \"&lt;/\"); strcat(endField, fieldname); strcat(endField, \"&gt;\"); //搜&lt;name&gt; char* findStart = (char*)strstr(xmlbuffer, startField); //搜&lt;/name&gt; char* findEnd = (char*)strstr(xmlbuffer, endField); //在xml字串中找到&lt;name&gt;與&lt;/name&gt; if(findStart &amp;&amp; findEnd) { //截取&lt;name&gt;.......&lt;/name&gt;中間的值，儲存在value字串 //計算&lt;name&gt;.......&lt;/name&gt;中間的值個數 size_t valueLen = findEnd - findStart - fieldLen - 2; //findStart + 2 + fieldLen 是指將指標移動到&lt;name&gt;的後面 //以下第三個參數代表拷貝個數 strncpy(values, findStart + 2 + fieldLen , valueLen); //清除記憶空間 delete[] startField; startField = nullptr; delete[] endField; endField = nullptr; return true; } //找不到 //清除記憶空間 delete[] startField; startField = nullptr; delete[] endField; endField = nullptr; return false; } int main() { char values[100]; //清空陣列 memset(values, 0, sizeof(values)); bool res = xmlSearch(\"&lt;id&gt;1&lt;/id&gt;&lt;name&gt;Cici&lt;/name&gt;&lt;age&gt;10&lt;/age&gt;\", \"name\", values); //如果有找到會回傳true if(res) { cout &lt;&lt; \"value = \" &lt;&lt; values &lt;&lt; endl; } return 0; } value = Cici"
  },"/pages/c/dataStruct/arrayList/": {
    "title": "ArrayList實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/arrayList/",
    "body": "Prerequisites: 記憶體間隔計算 名詞解釋 list.size 陣列有幾個元素？ 以下舉例的例子都是10個元素。 結構定義 1 2 3 4 5 6 7 8 9 //陣列最大的大小 #define MAXSIZE 100 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType data[MAXSIZE];//陣列 size_t size;//目前陣列中數量，由1開始 }; 清空所有元素 使用前確保所有元素都清空。 1 2 3 4 5 6 7 /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; memset(&amp;list, 0, sizeof(ElemType) * MAXSIZE); } 插入 位址轉成10進位，比較好理解 位址 1 2 3 4 5 6 7 8 9 10 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 假設要在索引4，插入一筆資料，必須將含索引4以後的資料往後移動1格。 list[index …] -&gt; list[index + 1 …] 移動資料前 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 移動資料後 索引 0 1 2 3 4 5 6 7 8 9 10 值 11 12 13 14 x 15 16 17 18 19 20 把x更換成要插入的值。 目的起始位址與來源起始位址 假設要在索引4，插入一筆資料，必須將含索引4以後的資料往後移動1格。 list[index …] 拷貝-&gt; list[index + 1 …] 來源起始位址 拷貝-&gt; 目的起始位址 memmove(目的起始位址, 來源起始位址, 拷貝個數) 位址 1 2 3 4 5 6 7 8 9 10 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 data指標 ^                   來源起始位址         ^           目的起始位址           ^         將(data指標 + 4)位址之後的資料，移到後一格(data指標 + (4 + 1))。 來源起始位址 list.data + index 目的起始位址 list.data + (index + 1) 拷貝個數 拷貝[含]索引4以後的個數 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 拷貝個數         ^ ^ ^ ^ ^ ^ 求拷貝個數 全部數量為10，扣掉不用拷貝的4個數量，剩下的就是我們要拷貝的。 list.size = 10，代表全部有10個元素。 10(全部數量) - 4(不用拷貝的數量) = 6(要拷貝的數量) list.size - index 1 memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); 最後一個位址可以插入 參數index索引等於list.size，直接新增資料，不需搬移資料 1 memcpy(&amp;list.data[list.size], &amp;element, sizeof(ElemType)); 插入程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == MAXSIZE) return false; //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } 刪除 往前拷貝 刪除索引4，索引4以後的元素(5 … size-1)往前移一位 list[index + 1 …] 拷貝-&gt; list[index …] 要拷貝的數量 全部數量為10，扣掉不用拷貝的4個數量，剩下的就是我們要拷貝的。 list.size = 10，代表全部有10個元素。 剩下的就是我們要拷貝的，要減掉一個刪除元素。 10(全部數量) - 4(不用拷貝的數量) - 1(拷貝的數量中有1個要刪除) = 5(要拷貝的數量) list.size - index - 1 1 2 3 //list[index + 1 ...] 拷貝-&gt; list[index ...] //因為要刪除一個元素，所以拷貝的個數要-1 memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); 最後一個位址不用搬移資料 參數index索引等於list.size - 1，直接刪除資料，不需搬移資料 刪除程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } 印出所有元素 1 2 3 4 5 void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } 測試程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main() { ArrayList list; //建立ArrayList ClearList(list);//清空 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); return 0; } 15 14 13 12 11 16 --------------------- 14 13 12 11 16 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 //陣列最大的大小 #define MAXSIZE 100 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType data[MAXSIZE];//陣列 size_t size;//目前陣列中數量，由1開始 }; /** 索引是否介於0... size-1 */ bool checkIndex(const ArrayList&amp; list, const size_t index) { return index &lt; list.size; } /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; memset(&amp;list, 0, sizeof(ElemType) * MAXSIZE); } /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == MAXSIZE) return false; //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } /** 返回索引 找不到就返回-1 */ int findElem(const ArrayList&amp; list, const ElemType&amp; e) { for(int i = 0; i &lt; list.size; i++) { if(list.data[i] == e) return i; } return -1; } /** 取得元素 參數2index:索引 參數3:e 返回元素 */ bool getElem(const ArrayList&amp; list, const size_t index,ElemType&amp; e) { if(!checkIndex(list, index)) return false; e = list.data[index]; return true; } int main() { ArrayList list; //建立ArrayList ClearList(list);//清空 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); return 0; }"
  },"/pages/c/dynamicMemory/memory_interval/": {
    "title": "記憶體間隔計算",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memory_interval/",
    "body": "Prerequisites: 數線間隔 間隔問題 數線上兩點的距離 計算間隔1 xml 指標指向0x00000001，若要指向0x00000005，請問指標要移動幾格？ 假設指標在0x00000005的位址，計算0x00000005到0x00000001之間有幾個間隔，不包含0x00000005 答案:0x00000005 - 0x00000001 = 4個間隔 0x00000001 0x00000002 0x00000003 0x00000004 0x00000005         ^ 計算間隔2 指標指向0x00000001，若要指向0x00000011，請問指標要移動幾格？ 把位址全變成10進位，比較好計算。 假設指標在11的位址，計算11到01之間有幾個間隔，不包含11 答案: 11 - 01 = 10個間隔 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 指標                     ^             以下10個間隔，只想取出Cici四個間隔，要如何取？ 10個間隔 - 2個括號&lt;&gt; - name4個字元 = 4 位址 01 02 03 04 05 06 07 08 09 10 xml &lt; n a m e &gt; C i c i 指標             x x x x 計算間隔3 刪除左邊的字元 位址 01 02 03 04 05 06 07 08 09 10 字串 y y y y o o o o y y str指標 str                   p指標         p           計算p指標位址與str指標位址，不包含p指標，總共有多少間隔？ 答案:5 - 1 = 4個間隔 yyyyooooyy字串長度為10，扣掉最左邊yyyy，只要右邊ooooyy的6個字元，數學公式如何寫？ 步驟1: strlen(yyyyooooyy) = 10 ，字串長度為10 步驟2: 取出p指標與str指標之間有多少間隔，不含p指標，p(5) - str(1) = 4個間隔 步驟3: 步驟1答案(10) - 步驟2答案(4) = 6個字元 指標移動間隔 刪除中間字串 位址 01 02 03 04 05 06 07 字串 1 2 3 z z z 0 移動前 find             移動後       find+3       find的位址在01 find + 3的意思是，find指標往右移動3格，移到04的位址。"
  },"/pages/math/tree/tree/": {
    "title": "種樹問題",
    "keywords": "",
    "url": "/pages/math/tree/tree/",
    "body": "問題1 在長720公尺的道路上，從起點到終點，種了10棵樹，每個間隔都一樣長，每個間隔是幾公尺？ 假設只種3棵樹，樹與樹之間有幾個間隔 tree tree tree 三棵樹有二個間隔 3 - 1 = 2 所以，10棵樹有9個間隔 10 - 1 = 9 間隔數會比樹少一個 720公尺 / 9個間隔 = 80公尺"
  },"/pages/c/dataStruct/arrayListExtCap/": {
    "title": "ArrayList擴展容量",
    "keywords": "",
    "url": "/pages/c/dataStruct/arrayListExtCap/",
    "body": "預設ArrayList大小，與每一次擴展容量的大小 1 2 3 4 5 //預設 #define INIT_SIZE 10 //預設擴展大小 #define EXT_SIZE 5 在結構定義最大容量 ArrayList全部分配多少記憶體大小 size_t capacity;//陣列最大容量 1 2 3 4 5 6 7 8 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType *data;//陣列 size_t size;//目前陣列中數量，由1開始 size_t capacity;//陣列最大容量 }; 清空ArrayList 結構 * 最大容量 memset(&amp;list, 0, sizeof(ElemType) * list.capacity); 1 2 3 4 5 6 7 8 /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; //代入的是陣列的最大容量list.capacity memset(&amp;list, 0, sizeof(ElemType) * list.capacity); } 建立ArrayList 1 2 3 4 5 6 7 8 9 10 11 12 void initList(ArrayList&amp; list) { //初始化大小 list.capacity = INIT_SIZE; //動態分配記憶體 list.data = new ElemType[list.capacity]; ClearList(list); } int main() { ArrayList list; //建立ArrayList initList(list return 0; } 刪除ArrayList 1 2 3 4 5 6 7 8 void destroyList(ArrayList&amp; list) { //釋放記憶體 delete [] list.data; list.data = nullptr; //全部設0 list.capacity = 0; list.size = 0; } 擴展容量 步驟如下 建立新容量的陣列 將舊的陣列拷貝到新的陣列 刪掉舊的陣列 指標指向新的陣列 重新定義最大容量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 bool extList(ArrayList&amp; list) { int new_size = list.capacity + EXT_SIZE; //建立新的陣列(容量比較大的陣列) ElemType *new_data = new (std::nothrow) ElemType[new_size]; //如果記憶體分配失敗 if(new_data == nullptr) return false; //清空新的陣列 memset(new_data, 0, sizeof(ElemType) * new_size); //拷貝舊的陣列到新的陣列 memcpy(new_data, list.data, sizeof(ElemType) * list.size); //把舊的陣列進行記憶體釋放 delete [] list.data; //把結構中的陣列，指向新的陣列記憶體位址 list.data = new_data; //重新定義結構中最大容量 list.capacity = new_size; return true; } 插入 判斷是否超出最大容量 1 2 3 4 5 6 7 8 //判斷是否超出最大容量 if(list.size == list.capacity) { //超出容量就擴展容量 if(!extList(list)) { //若返回是false，代表建立新陣列記憶體配置產生問題 return false; } } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 //預設初始化大小 #define INIT_SIZE 10 //預設擴展大小 #define EXT_SIZE 5 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType *data;//陣列 size_t size;//目前陣列中數量，由1開始 size_t capacity;//陣列最大容量 }; /** 索引是否介於0... size-1 */ bool checkIndex(const ArrayList&amp; list, const size_t index) { return index &lt; list.size; } /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; //代入的是陣列的最大容量list.capacity memset(&amp;list, 0, sizeof(ElemType) * list.capacity); } void initList(ArrayList&amp; list) { list.capacity = INIT_SIZE; list.data = new ElemType[list.capacity]; ClearList(list); } void destroyList(ArrayList&amp; list) { delete [] list.data; list.data = nullptr; list.capacity = 0; list.size = 0; } bool extList(ArrayList&amp; list) { int new_size = list.capacity + EXT_SIZE; //建立新的陣列(容量比較大的陣列) ElemType *new_data = new (std::nothrow) ElemType[new_size]; //如果記憶體分配失敗 if(new_data == nullptr) return false; //清空新的陣列 memset(new_data, 0, sizeof(ElemType) * new_size); //拷貝舊的陣列到新的陣列 memcpy(new_data, list.data, sizeof(ElemType) * list.size); //把舊的陣列進行記憶體釋放 delete [] list.data; //把結構中的陣列，指向新的陣列記憶體位址 list.data = new_data; //重新定義結構中最大容量 list.capacity = new_size; return true; } /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == list.capacity) { //超出容量就擴展容量 if(!extList(list)) { //若返回是false，代表建立新陣列記憶體配置產生問題 return false; } } //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } /** 返回索引 找不到就返回-1 */ int findElem(const ArrayList&amp; list, const ElemType&amp; e) { for(int i = 0; i &lt; list.size; i++) { if(list.data[i] == e) return i; } return -1; } /** 取得元素 參數2index:索引 參數3:e 返回元素 */ bool getElem(const ArrayList&amp; list, const size_t index,ElemType&amp; e) { if(!checkIndex(list, index)) return false; e = list.data[index]; return true; } int main() { ArrayList list; //建立ArrayList initList(list);//初始化 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); destroyList(list); return 0; }"
  },"/pages/c/dataStruct/linkedList/": {
    "title": "單向鏈結串列實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/linkedList/",
    "body": "頭節點 頭節點是沒有值，頭節點的next指向的是第一個節點，最後一個節點的next指向nullptr 結構定義 節點有二個欄位，分別是data與next，data是存放值，next是指向下一個節點 1 2 3 4 5 6 typedef int ElemType; //定義節點 struct Node { ElemType data; Node* next; }; 初始化 初始化判斷頭節點(head)記憶體位址有沒有建立成功 將頭節點(head)的next(下一個節點位址)設為nullptr 返回頭節點的記憶體位址(使用指標回傳)，new動態分配記憶體位址，會回傳位址，需要用指標來接。 在main()中建立頭節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; head-&gt;next = nullptr;//下一個節點是null return head; } int main() { //建立頭節點 Node* head = initLinkedList(); return 0; } 刪除鏈結串列 刪除所有鏈結串列，包含頭節點(head) 參數是頭節點(head)記憶體位址 繞行所有節點，先把下一個節點存到暫存節點，再刪掉頭節點，再把暫存節點設為頭節點，如此反覆進行，直至下一個節點為nullptr設到head，離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } int main() { //建立頭節點 Node* head = initLinkedList(); destroyLinkedList(head); return 0; } 新增在最前面 有一個資料要新增在最前面 頭節點的next指向新節點，新節點的next指向原本的第一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //頭節點的下一個是新節點 head-&gt;next = temp; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); destroyLinkedList(head); return 0; } 新增在最後面 要將3的資料新增在最後面 新增步驟如下 先遍歷到最後一個節點(不是nullptr) 建立新節點，將新節點的next設為nullptr 尾節點的next設為新節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } 刪除最前面 把頭節點(head)的next指向要刪除節點的下一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //把p刪掉 delete p; return true; } 刪除最後一個節點 要刪除最後一個節點，要先找到倒數第二個節點。 把倒數第二個節點的next指向nullptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } 印出所有節點 因為頭節點head是沒有資料，所以一開始是把p指標指向head的下一個節點。 然後將p指標一直往next移動，直至指到nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); destroyLinkedList(head); return 0; } 新增節點在某個節點之前 Data3要新增Data2前面 破解傳統的方式，傳統的方式是用迴圈繞行鏈結串列，找到下一個節點是Data2，才把Data3插進去，新的方式如下: 步驟如下 Data2的值拷貝到新節點Data3 新節點Data3的next設為Data2的next Data2的next設為Data3 Data2的值設成新的資料內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //將節點的資料複製到新節點 new_node-&gt;data = node-&gt;data; new_node-&gt;next = node-&gt;next; //把節點的內容改成新的內容 node-&gt;data = e; //下一個節點指向新節點 node-&gt;next = new_node; return true; } 刪除某個節點 因為節點不知道上一個節點是那個？ 所以採用以下作法 把下一個節點的值複製在要刪除的節點 把要刪除的節點的next指向下一個節點的next 把下一個節點刪除 但要刪除的節點沒下一個節點的話，使用刪除最後一個節點的函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //若節點為最後一個節點 if(node-&gt;next == nullptr) { //使用其它函式removeLast() cout &lt;&lt; \"要刪除的節點是最後一個節點，請使用removeLast()\" &lt;&lt; endl; return false; } //取得後面節點 Node* after = node-&gt;next; //將後面的節點資料，複製到要刪除的節點中 node-&gt;data = after-&gt;data; node-&gt;next = after-&gt;next; //把後面的節點刪除 delete after; return true; } 取得鏈結串列長度 大小不包含頭節點(head)，將鏈結串列繞行一遍就會知道有多少節點。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } 取得某個節點 1 2 3 4 5 6 7 8 9 10 11 12 Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，回傳節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 typedef int ElemType; //定義節點 struct Node { ElemType data; Node* next; }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; head-&gt;next = nullptr;//下一個節點是null return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //頭節點的下一個是新節點 head-&gt;next = temp; return true; } bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //將節點的資料複製到新節點 new_node-&gt;data = node-&gt;data; new_node-&gt;next = node-&gt;next; //把節點的內容改成新的內容 node-&gt;data = e; //下一個節點指向新節點 node-&gt;next = new_node; return true; } /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //若節點為最後一個節點 if(node-&gt;next == nullptr) { //使用其它函式removeLast() cout &lt;&lt; \"要刪除的節點是最後一個節點，請使用removeLast()\" &lt;&lt; endl; return false; } //取得後面節點 Node* after = node-&gt;next; //將後面的節點資料，複製到要刪除的節點中 node-&gt;data = after-&gt;data; node-&gt;next = after-&gt;next; //把後面的節點刪除 delete after; return true; } Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，回傳節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //把p刪掉 delete p; return true; } /** 刪除鏈結串列，但頭節點不刪除 */ void clearList(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //不包含頭節點，頭節點下一個節點不存在 if(head-&gt;next == nullptr) { cout &lt;&lt; \"鏈結串列沒有節點\" &lt;&lt; endl; return; } Node* temp1; //從下一個節點開始刪，頭節點要保留 Node* temp2 = head-&gt;next; while(temp2 != nullptr) { //下一個節點先丟到temp1 temp1 = temp2-&gt;next; //刪掉temp2 delete temp2; //temp2變成下一個節點 temp2 = temp1; } head-&gt;next = nullptr; } /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); cout &lt;&lt; \"--------------\" &lt;&lt; endl; //增加節點 addLast(head, 5); //增加節點 addLast(head, 6); //增加節點 addLast(head, 7); //增加節點 addLast(head, 8); //印出所有節點 printList(head); cout &lt;&lt; \"size = \" &lt;&lt; size(head) &lt;&lt; endl; cout &lt;&lt; \"--------------\" &lt;&lt; endl; //取得資料為\"5\"的節點 Node* node = getNode(head, 5); //在資料為\"5\"的節點之前，新增54 insert(node, 54); //印出所有節點 printList(head); //刪除54節點 deleteNode(getNode(head, 54)); //印出所有節點 printList(head); //刪除第一個節點 removeFirst(head); //印出所有節點 printList(head); //刪除最後一個節點 removeLast(head); //印出所有節點 printList(head); //清空所有節點，(不包含頭節點) clearList(head); //釋放記憶體(包含頭節點) destroyLinkedList(head); return 0; }"
  },"/pages/c/dataStruct/doublelinkedList/": {
    "title": "雙向鏈結串列實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/doublelinkedList/",
    "body": "雙向鏈結串列代表的是結構中有二個指標，分別指向前面節點跟後面節點 結構定義 1 2 3 4 5 6 typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; 初始化 以下程式碼是指把指向前面節點與後面節點的指標設為nullptr 1 head-&gt;prev = head-&gt;next = nullptr; 1 2 3 4 5 6 7 8 9 10 11 12 /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } 最前面新增節點 資料3要插入在最前面 步驟如下 建立新節點 新節點的next指向第一個節點 新節點的prev指向頭節點 頭節點的next指向新節點 第一個節點的prev指向新節點(如果沒有第一個節點就不用做這個步驟) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } 刪除節點 步驟如下 將待刪除節點的前一個節點next指向待刪除節點的下一個節點 將待刪除節點的下一個節點的prev指向待刪除節點的前一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //node的前一個節點的next指向node的下一個節點 node-&gt;prev-&gt;next = node-&gt;next; if(node-&gt;next != nullptr) { //node的下一個節點的prve指向node的prev node-&gt;next-&gt;prev = node-&gt;prev; } delete node; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的前面節點 temp-&gt;prev = p; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //塞入資料 new_node-&gt;data = e; //新節點的前一個節點是插入節點的前一個 new_node-&gt;prev = node-&gt;prev; //插入節點的前個節點的下一個是新節點 node-&gt;prev-&gt;next = new_node; //插入節點的前一個節點是新節點 node-&gt;prev = new_node; return true; } /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //node的前一個節點的next指向node的下一個節點 node-&gt;prev-&gt;next = node-&gt;next; if(node-&gt;next != nullptr) { //node的下一個節點的prve指向node的prev node-&gt;next-&gt;prev = node-&gt;prev; } delete node; return true; } Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，回傳節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; //把p刪掉 delete p; return true; } /** 刪除鏈結串列，但頭節點不刪除 */ void clearList(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //不包含頭節點，頭節點下一個節點不存在 if(head-&gt;next == nullptr) { cout &lt;&lt; \"鏈結串列沒有節點\" &lt;&lt; endl; return; } Node* temp1; //從下一個節點開始刪，頭節點要保留 Node* temp2 = head-&gt;next; while(temp2 != nullptr) { //下一個節點先丟到temp1 temp1 = temp2-&gt;next; //刪掉temp2 delete temp2; //temp2變成下一個節點 temp2 = temp1; } head-&gt;next = nullptr; } /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); cout &lt;&lt; \"--------------\" &lt;&lt; endl; //增加節點 addLast(head, 5); //增加節點 addLast(head, 6); //增加節點 addLast(head, 7); //增加節點 addLast(head, 8); //印出所有節點 printList(head); cout &lt;&lt; \"size = \" &lt;&lt; size(head) &lt;&lt; endl; cout &lt;&lt; \"--------------\" &lt;&lt; endl; //取得資料為\"5\"的節點 Node* node = getNode(head, 5); //在資料為\"5\"的節點之前，新增54 insert(node, 54); //印出所有節點 printList(head); //刪除54節點 deleteNode(getNode(head, 54)); //印出所有節點 printList(head); //刪除第一個節點 removeFirst(head); //印出所有節點 printList(head); //刪除最後一個節點 removeLast(head); //印出所有節點 printList(head); //清空所有節點，(不包含頭節點) clearList(head); //釋放記憶體(包含頭節點) destroyLinkedList(head); return 0; }"
  },"/pages/c/dataStruct/stack/": {
    "title": "Stack實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/stack/",
    "body": "Stack是在同一個位置新增/刪除的動作。 新增在頭節點 Stack是新增節點在頭節點。 刪除在頭節點 Stack是刪除節點在頭節點。 函式解釋 Stack的新增，等同於鏈結串列的addFirst，此處改為push Stack的刪除，等同於鏈結串列的removeFirst，此處改為pop 程式碼與單向鏈結串列大致相同，刪除以下描述的函式。 新增在最後addLast()，插入在某個節點前面insert()，以上二種函式在Stack中都不需要。 刪除在最後removeLast()，刪除在某個節點deleteNode()，以上二種函式在Stack中都不需要。 getNode()，取得節點的函式，在Stack中也不需要。 pop 對Stack來說，刪除鏈結串列第1個節點之外，還要把值返回。 所以以下的程式碼參數有ElemType&amp; e，接收刪除後返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 bool pop(Node* head, ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; e = p-&gt;data; //把p刪掉 delete p; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool push(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool pop(Node* head, ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; e = p-&gt;data; //把p刪掉 delete p; return true; } int main() { //建立頭節點 Node* stack = initLinkedList(); //增加節點 push(stack, 1); //增加節點 push(stack, 2); //增加節點 push(stack, 3); //增加節點 push(stack, 4); //印出所有節點 printList(stack); ElemType e; pop(stack,e); cout &lt;&lt; \"pop 的值 = \" &lt;&lt; e &lt;&lt; endl; //釋放記憶體(包含頭節點) destroyLinkedList(stack); return 0; }"
  },"/pages/c/dataStruct/bubbleSort/": {
    "title": "氣泡排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/bubbleSort/",
    "body": "交換過程圖 比較大小 陣列大小為6，以下為陣列的索引 0 1 2 3 4 5 i與j變數解釋 i變數為最大輪數與最大次數。 以本例來說，最大輪數為5輪 以本例來說，比較最大次數5次 j變數為比較次數的計數器，arr[j]與arr[j+1]，二個相鄰的變數比較大小 例 j = 0，arr[0]與arr[1]比較大小 j = 1，arr[1]與arr[2]比較大小 j = 2，arr[2]與arr[3]比較大小 j = 3，arr[3]與arr[4]比較大小 j = 4，arr[4]與arr[5]比較大小 第1輪 i =5 i最大比較次數 i = 5 j &lt; i最大次數5 j的索引0…4 arr[j]與arr[j+1]，二個互相比較 索引 0 1 2 3 4 5 j=0 0 1         j=1   1 2       j=2     2 3     j=3       3 4   j=4         4 5 第2輪 i =4 i最大比較次數 i = 4 j &lt; i最大次數4 j的索引0…3 arr[j]與arr[j+1]，二個互相比較 索引 0 1 2 3 4 5 j=0 0 1         j=1   1 2       j=2     2 3     j=3       3 4   第3輪 i = 3 i最大比較次數 i = 3 j &lt; i最大次數3 j的索引0…2 arr[j]與arr[j+1]，二個互相比較 索引 0 1 2 3 4 5 j=0 0 1         j=1   1 2       j=2     2 3     第4輪 i = 2 i最大比較次數 i = 2 j &lt; i最大次數2 j的索引0…1 arr[j]與arr[j+1]，二個互相比較 索引 0 1 2 3 4 5 j=0 0 1         j=1   1 2       第5輪 i = 1 i最大比較次數 i = 1 j &lt; i最大次數1 j的索引0 arr[0]與arr[0+1]，二個互相比較 索引 0 1 2 3 4 5 j=0 0 1         完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 using namespace std; void bubbleSort(int arr[], int len) { for(int i = len-1; i &gt; 0; i--) { for(int j = 0; j &lt; i; j++) { if(arr[j] &gt; arr[j+1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); bubbleSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 1,2,3,4,5,6,"
  },"/pages/c/dataStruct/queue/": {
    "title": "Queue實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/queue/",
    "body": "新增在尾部 Queue是新增節點在尾部。 以下是新增節點的過程。 刪除在頭部 Queue是刪除節點在頭部。 以下是刪除節點的過程。 結構定義 Queue會定義頭節點與尾節點。 1 2 3 4 5 6 7 8 9 10 typedef int ElemType; //定義節點 struct Node { ElemType data; Node *next; }; struct queue { //定義頭節點與尾節點 Node *head,*tail; }; 初始化頭節點與尾節點 一開始頭節點與尾節點都指向頭節點 1 2 3 4 5 6 7 8 9 10 11 12 /** 初始化Queue */ bool initQueue(queue&amp; que) { //頭節點 que.head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(que.head == nullptr) return false; que.head-&gt;next = nullptr;//queue的下一個節點為null que.tail = que.head;//一開始頭節點與尾節點指向同一個記憶體位址 return true; } 新增 完全沒任何節點 在沒有任何節點的狀況下，新節點新增在tail尾節點後面。 步驟如下 建立新節點 新節點的next指向nullptr 新節點新增在tail尾節點後面 tail尾節點指向新節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool inQueue(queue&amp; que, const ElemType&amp; ee) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; temp-&gt;next = nullptr; //將新節點插入到tail之後 que.tail-&gt;next = temp; //把tail指向temp que.tail = temp; return true; } 有節點 尾節點指向鏈結串列中最後一個節點(不是nullptr)。 在有節點的狀況下，新節點新增在tail尾節點後面。 程式步驟跟沒任何節點的步驟一模一樣。 刪除節點 刪除的方式跟鏈結串列removeFirst()一樣，從鏈結串列第一個節點刪除。 如果刪的節點是尾節點，刪除完節點後，要把尾節點指向頭節點，回到初始的狀況下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool deQueue(queue&amp; que, ElemType&amp; e) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(que.head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //鏈結串列中第一個節點，不包含頭節點 Node* first = que.head-&gt;next; //將第一個節點的值存在e，作為返回 e = first-&gt;data; //將第一個節點(不包含頭節點)指向first的下個節點 que.head-&gt;next = first-&gt;next; //如果刪的節點是tail節點 if(first == que.tail) //將tail指向head que.tail = que.head; //將第一個節點刪除 delete first; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *next; }; struct queue { Node *head,*tail; }; /** 初始化Queue */ bool initQueue(queue&amp; que) { //頭節點 que.head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(que.head == nullptr) return false; que.head-&gt;next = nullptr;//queue的下一個節點為null que.tail = que.head;//一開始頭節點與尾節點指向同一個記憶體位址 return true; } /** 摧毀Queue 參數為頭節點 */ void destroyQueue(queue&amp; que){ //暫存節點 Node* temp; while(que.head != nullptr) { //先暫存下一個節點 temp = que.head-&gt;next; //刪掉目前頭節點 delete que.head; //頭節點換成下一個節點 que.head = temp; } } bool inQueue(queue&amp; que, const ElemType&amp; ee) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; temp-&gt;next = nullptr; //將新節點插入到tail之後 que.tail-&gt;next = temp; //把tail指向temp que.tail = temp; return true; } bool deQueue(queue&amp; que, ElemType&amp; e) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(que.head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //鏈結串列中第一個節點，不包含頭節點 Node* first = que.head-&gt;next; //將第一個節點的值存在e，作為返回 e = first-&gt;data; //將第一個節點(不包含頭節點)指向first的下個節點 que.head-&gt;next = first-&gt;next; //如果刪的節點是tail節點 if(first == que.tail) //將tail指向head que.tail = que.head; //將第一個節點刪除 delete first; return true; } void printQueue(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = que.head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = que.head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } /** 清空鏈表，除了頭節點 */ void clear(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //移到頭節點的下一個節點(清空不包含頭節點) Node* tmp = que.head-&gt;next,*tmpnext; //繞行所有節點 while(tmp != nullptr) { //把節點的下一個節點暫存 tmpnext = tmp-&gt;next; //刪除目前節點 delete tmp; //將下一個節點作為目前節點 tmp = tmpnext; } //頭節點的下一個設null que.head-&gt;next = nullptr; //尾節點與頭節點指向相同 que.tail = que.head; } int main() { //建立queue queue que; //清空 memset(&amp;que, 0, sizeof(que)); //初始化 initQueue(que); inQueue(que, 1); inQueue(que, 2); inQueue(que, 3); inQueue(que, 4); inQueue(que, 5); cout &lt;&lt; \"大小:\" &lt;&lt; size(que) &lt;&lt; endl; cout &lt;&lt; \"queue的內容:\" &lt;&lt; endl; printQueue(que); ElemType e; while(deQueue(que, e)) cout &lt;&lt; e &lt;&lt; endl; inQueue(que, 6); inQueue(que, 7); inQueue(que, 8); inQueue(que, 9); inQueue(que, 10); cout &lt;&lt; \"大小:\" &lt;&lt; size(que) &lt;&lt; endl; cout &lt;&lt; \"queue的內容:\" &lt;&lt; endl; printQueue(que); destroyQueue(que); return 0; }"
  },"/pages/c/dataStruct/insertSort/": {
    "title": "插入排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/insertSort/",
    "body": "插入過程圖 假設目前位置在5的數字，往前尋找比5還小的數字，把5放在比5還小的數字的後面，若尋找的過程中，數字比5還大，就把數字往後移一位。 i是目前位置 j就是往前尋找比5還小的數字的計數變數 數字比5還大，就把數字往後移一位 下圖arr[i] = 5，arr[j] = 44，44 &gt; 5，把44往後移一位，arr[j + 1] = 44 下圖arr[i] = 5，arr[j] = 38，38 &gt; 5，把38往後移一位，arr[j + 1] = 38 尋找比5還小的數字，把5放在比5還小的數字的後面 下圖arr[i] = 5，arr[j] = 3，3 &lt; 5，把5放在3的後面 變數起始位置 i起始位置為1，因為arr[0]前面沒有值可以比較，所以把i的一開始的位置定義在arr[1] j的起始位置為i-1，也就是從i的位置以前(不含i)去搜尋有沒有比arr[i]還小的數字，若比arr[i]大，就把arr[j]的值往後移動一格arr[j+1] 二個迴圈 外圍的迴圈，是遍歷每一個數字 內圍的迴圈，是尋找外圍數字之前有沒有比它小的數字。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void insertSort(int arr[], int len) { for(int i = 1; i &lt; len; i++) { int temp = arr[i]; int j = i - 1; for(; j &gt;= 0; j--) { if(arr[j] &gt; temp) { arr[j + 1] = arr[j]; } else { //若i=1,j=0 //6放進arr[0+1]之後，就會離開這個迴圈，因為j--，j=-1 //j=-1，就不會執行以下這一行 break; } } //若i=1,j=0 //6放進arr[j+1]之後，就會離開迴圈，j--，j=-1 //arr[1]=6 //arr[-1 + 1] = 5 //arr[0] = 5 arr[j + 1] = temp; } } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); insertSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 1,2,3,4,5,6,"
  },"/pages/c/dataStruct/quickSort/": {
    "title": "快速排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/quickSort/",
    "body": "陣列2,5,3,6,4,1 值將陣列0的資料作為基準 以下圖來說，陣列0的值是2，是作為比較大小的標準。 L指向陣列0的位址 R指向陣列最後的位址 比較R值，尋找比基準值小 預設先比對R的值 若陣列[R]&lt;2，將陣列[L]的值設成陣列[R]，並且L前進一格。 若以上條件不符合，R往後退一格。 if(陣列[R] &lt; 2) { 陣列[L] = 陣列[R] L++; } else { R--; } 下圖陣列[R]&lt;2，將陣列[L]的值設成陣列[R]，並且L前進一格 比較L值，尋找比基準值大 若陣列[L]&gt;2，將陣列[R]的值設成陣列[L]，並且R往後退一格。 若以上條件不符合，L往前一格。 if(陣列[L] &gt; 2) { 陣列[R] = 陣列[L] R--; } else { L++; } 下圖陣列[L]&gt;2，將陣列[R]的值設成陣列[L]，並且R後退一格 L==R 若陣列[R]一直找不到比2小，就會一直往後退移到跟L相同的位址。 將基準值2放入L==R的位址，第一個數字排序好 遞迴設定 下圖中從2(已排序好)作為中點，分為左右二半，左邊剩下1個，右邊剩下4個待排序。 左邊只剩下1個，至少要有2個數字才可以比較大小，因此視作排序完成。 把arr指標移動2格(arr+2)，從3的數字開始視作為陣列起點，大小為4個。 left的陣列位址為1，len(陣列長度)為6 quickSort(arr + left + 1, len - left - 1); 以上程式轉換如下 quickSort(arr + 2, 4); 重新設定L、R與基準值 將L指向數字3，並將比較基準值設為3，R指向陣列最尾部。 R找不到比基準值小的值 R指標找不到比基準值3小的，最後L==R L==R(2) 將基準值3放入L==R的位址，第二個數字排序好 重新設定L、R與基準值(2) 將L指向數字6，並將基準值設為6，R指向陣列最尾部。 比較R值，尋找比基準值小(2) 預設先比對R的值 若陣列[R]&lt;6，將陣列[L]的值設成陣列[R]，並且L前進一格。 L==R(3) 將基準值6放入L==R的位址，第三個數字排序好 重新設定L、R與基準值(3) 比較R值，尋找比基準值小(3) 預設先比對R的值 若陣列[R]&lt;5，將陣列[L]的值設成陣列[R]，並且L前進一格。 L==R(4) 將基準值5放入L==R的位址，第四個數字排序好 重點步驟 至少要有2個數字才可以比較大小 L指向陣列0的位址 R指向陣列最後的位址 將陣列0的值作為基準值 預設先比較R值 L&lt;R,比較R值，尋找比基準值小 L&lt;R,比較L值，尋找比基準值大 L==R，將基準值放入L==R的位址 基準值作為中點，陣列分為左右二半(不包含基準值的位址) 左右二半陣列繼續依上述文字進行，直至陣列個數小於2 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /** 參數1 陣列位址 參數2 陣列大小 */ void quickSort(int arr[], int len) { //至少要有2個數字才可以比較大小 if(len &lt; 2) return; int left = 0; int right = len - 1; //基準值都為arr[0] int pivot = arr[0]; //預設先比較R //action有L與R，預設先比對R的值 char action = 'R'; //若left&lt;right才進入循環 while(left &lt; right) { //比較R值，尋找比基準值小 if(action == 'R') { //比較R值，尋找比基準值小 //若陣列[R]&lt;基準值，將陣列[L]的值設成陣列[R]，並且L前進一格。 if(arr[right] &lt; pivot) { arr[left] = arr[right]; left++; //設定下一次是L移動 action = 'L'; } else { //若以上條件不符合，R往後退一格。 right--; } //比較L值，尋找比基準值大 } else if(action == 'L') { //比較L值，尋找比基準值大 //若陣列[L]&gt;基準值，將陣列[R]的值設成陣列[L]，並且R往後退一格。 if(arr[left] &gt; pivot) { arr[right] = arr[left]; right--; //設定下一次是R移動 action = 'R'; } else { //若以上條件不符合，L往前一格。 left++; } } } //L==R //將基準值放入L==R的位址 arr[right] = pivot; //遞迴設定 //基準值作為中點，分為左右二半陣列(不包含基準值) //參數1陣列起始位址,參數2分成左右二半的各別個數 //左半邊 quickSort(arr,left); //右半邊 //起始位址在基準值位址的下一格 //個數(請參照遞迴設定的說明與圖) quickSort(arr + left + 1, len - left - 1); } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); quickSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/dataStruct/mergeSort/": {
    "title": "合併排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/mergeSort/",
    "body": "Prerequisites: 遞迴 傳遞函式前處理 在遞迴有討論過二種遞迴方式，合併排序結合二種遞迴方式。 首先，先把陣列切半拆分，直到切到只剩下一個元素，就不要再拆分了。 傳遞函式後處理 拆到只剩下一個元素，把一個一個的元素排序組回臨時的陣列，再copy到原本arr的陣列。 先處理已拆分成個別值6,5，二個數值比大小，比較小的放入臨時陣列(temp)，start為臨時陣列的計數器，每放進一個值，start就加1 因已經沒得比了，把剩下的6放入臨時陣列，此時start已經是1，將排好序的臨時陣列56拷貝至原本的arr陣列 處理已拆分成個別值3,2，二個數值比大小，比較小的放入臨時陣列(temp)，start為臨時陣列的計數器，start目前為3，每放進一個值，start就加1。 因已經沒得比了，把剩下的3放入臨時陣列，此時start已經是4，將排好序的臨時陣列23拷貝至原本的arr陣列 處理已拆分的二個陣列[56][4]，二個陣列分別有start1與start2，分別指著二個陣列的第1個元素。4(start2)比5(start1)小，目前start為0把4放進臨時陣列temp[0]start++ 與 start2++ 陣列[56]已經是有排序過的陣列，目前start為1，直接把陣列[56]所有元素放入臨時陣列 陣列[56]放入臨時陣列後，把臨時陣列[456]拷貝到原本arr的陣列中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void _mergeSort(int arr[], int temp[], int start, int end) { //列切半拆分，直到切到只剩下一個元素，start與end會是相同，就返回 if(start &gt;= end) return; //陣列切半拆分 //若拆的陣列為[654321]，拆成[654]與[321]，要再拆分[321]，3的陣列索引是3 // (5-3)/2 = 1 要再+3，拆分的中點索引才會在4，而不是在1 // 拆成[34] [1] int mid = start + (end - start)/2; //拆成二半，二個陣列的起始位置 int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; _mergeSort(arr, temp, start, mid); _mergeSort(arr, temp, mid+1, end); //臨時陣列計數器 int i = start; //判斷二個拆分陣列的值的大小 while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) { if(arr[start1] &lt; arr[start2]) { temp[i++] = arr[start1++]; } else { temp[i++] = arr[start2++]; } } //左半邊 while(start1 &lt;= end1) { temp[i++] = arr[start1++]; } //右半邊 while(start2 &lt;= end2) { temp[i++] = arr[start2++]; } memcpy(arr+start, temp+start, (end - start + 1) * sizeof(int)); } void mergeSort(int arr[],size_t len) { //小於2個不用比 if(len &lt; 2) return; int temp[len]; _mergeSort(arr, temp, 0, len-1); } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); mergeSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/dataStruct/recursion/": {
    "title": "遞迴",
    "keywords": "",
    "url": "/pages/c/dataStruct/recursion/",
    "body": "什麼是遞迴？ 自己呼叫自己 從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？「從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？『從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？……』」 這個故事一直不停的說一直不停的說同一個故事，說到什麼時候停止？聽故事的人聽到不耐煩，不想再聽為止。 終止條件 所以要設定一個結束故事的條件，假設講了10次故事，聽故事的人就不想聽了，作為終止條件。 次數 每一次講故事的次數怎麼傳進去？通常使用參數傳進去講故事的函式，每講一次，就把前面講過的故事總次數加1，呼叫下一個講故事的函式中。 講故事(1) -&gt; 講故事(1+1) -&gt; 講故事(2+1) -&gt; 講故事(3+1) -&gt; 講故事(4+1) -&gt; 講故事(5+1) -&gt; 講故事(6+1) -&gt; 講故事(7+1) -&gt; 講故事(8+1) -&gt; 講故事(9+1) -&gt; 講故事(10+1) -&gt; 已經講了10次，終止講故事。 1 2 3 4 5 6 7 8 9 10 void story(int count) { if(count &gt; 10) return; cout &lt;&lt; \"第\" &lt;&lt; count &lt;&lt; \"次:\"; cout &lt;&lt; \"從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？\" &lt;&lt; endl; story(count + 1); } int main() { story(1); return 0; } 第1次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第2次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第3次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第4次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第5次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第6次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第7次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第8次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第9次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第10次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 二種遞迴 傳遞函式前處理 士兵長對10個士兵說，把前面的人的子彈總數加上自己手上的子彈，告訴下一個人，最後一個人把子彈的總數傳給上一個人。 每個士兵的代號跟擁有的子彈數是一致。 士兵代號1，有1個子彈。 士兵代號2，有2個子彈。 士兵代號3，有3個子彈。 . . . 士兵代號9，有9個子彈。 士兵代號10，有10個子彈。 1 2 3 4 5 6 int func1(士兵代號,士兵子彈數,前面的人的子彈數) { //判斷前面的士兵是否為最後一個人 //若前面的士兵為最後一個人 if(士兵代號 &gt; 10) 回傳全部子彈數給上一個人 return func1(告訴下一個士兵, 下一個士兵子彈數, 前面的人的子彈數 + 自已的子彈數); } 1 2 3 4 5 6 7 8 9 10 11 int func1(int i, int bullet, int total) { //判斷前面的士兵是否為最後一個人 if(i &gt; 10) return total; total = total + bullet; return func1(i + 1, bullet + 1, total); } int main() { int total = func1(1, 1, 0); cout &lt;&lt; total &lt;&lt; endl; return 0; } 55 傳遞函式後處理 士兵長對10個士兵說，告訴最後一個人把子彈數傳上來，後面傳上來的同時也加上自己的子彈數。 每個士兵的代號跟擁有的子彈數是一致。 士兵代號1，有1個子彈。 士兵代號2，有2個子彈。 士兵代號3，有3個子彈。 . . . 士兵代號9，有9個子彈。 士兵代號10，有10個子彈。 1 2 3 4 5 6 int func1(士兵代號,士兵子彈數) { //判斷前面的士兵是否為最後一個人 if(士兵代號 &gt; 10) return 0;//第11個士兵不存在，沒有子彈 //自己的子彈數 + 後面的人的子彈數 return 士兵自己的子彈數 + func1(告訴下一個士兵, 下一個士兵子彈數); } 1 2 3 4 5 int func1(int i, int bullet) { if(i &gt; 10) return 0; //自己的子彈數 + 後面的人的子彈數 return bullet + func2(i+1, bullet+1); } 55 類別與遞迴 若在類別中寫遞迴函式，參數不用傳遞，可直接使用成員屬性供遞迴使用，成員屬性可以保存值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Story { public: int times = 0; void tell() { if(times &gt; 10) return; cout &lt;&lt; \"第\" &lt;&lt; times &lt;&lt; \"次:\"; cout &lt;&lt; \"從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？\" &lt;&lt; endl; times++; tell(); } }; int main() { Story story; story.tell(); return 0; } 第0次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第1次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第2次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第3次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第4次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第5次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第6次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第7次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第8次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第9次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第10次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？"
  },"/pages/c/basic/param/": {
    "title": "參數與引數",
    "keywords": "",
    "url": "/pages/c/basic/param/",
    "body": "Prerequisites: 維基參數和引數 引數 Argument 傳給函式的變數。 1 2 3 4 5 6 int main() { int var1 = 10; //將var1傳到func1()函式中，而var1就是引數Argument func1(var1); return 0; } 參數 Parameter 函式接收到的變數。 1 2 3 4 //函式接收到來自外面傳進來的變數，變數名param1，而param1就是參數 void func1(int param1) { cout &lt;&lt; \"param1=\" &lt;&lt; param1 &lt;&lt; endl; }"
  },"/pages/c/class/class/": {
    "title": "類別與物件",
    "keywords": "",
    "url": "/pages/c/class/class/",
    "body": "權限 類別權限預設是private，結構權限預設是public public與private與其它權限，可以在類別中出現很多次，以下public就出現2次，private出現2次 1 2 3 4 5 6 7 8 9 10 class Student { public: char name[50]; private: char address[100]; public: int age; private: char father[50]; }; 成員屬性命名 命名方式使用m_成員屬性名字或成員屬性_ 前綴加上m_ 後綴加上底線_ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Student { public: string m_name; public: Student() { } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student s; s.m_name = \"Bill\"; s.print(); return 0; } name: Bill 類別作為函式參數 使用類別作為函式參數，都是使用參考&amp;的方式傳遞。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Student { public: string m_name; public: Student() { } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; void func1(const Student&amp; s) { cout &lt;&lt; s.m_name &lt;&lt; endl; } int main() { Student s; s.m_name = \"Bill\"; func1(s); return 0; } Bill 類別中的函式自動變為內嵌函式(inline) inline 類別中的函式自動變為內嵌函式，但不是在類別中的函式不會變成內嵌函式。 以下print()是內嵌函式 1 2 3 4 5 6 7 class Student { public: char m_name[50]; //函式自動變為內嵌函式 void print() { } }; 成員函式在類別外定義 函式宣告與定義 print()成員函式程式碼在類別之外定義，定義方式如下。 回傳值 類別名::函式名(){程式碼} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: char m_name[50]; //宣告函式 void print(); }; //類別外部定義 void Student::print() { cout &lt;&lt; \"test\" &lt;&lt; endl; } int main() { Student student; student.print(); return 0; } test"
  },"/pages/c/function/func_default_param/": {
    "title": "函式參數預設值",
    "keywords": "",
    "url": "/pages/c/function/func_default_param/",
    "body": "參數預設值 有預設值，呼叫函式時就可以不用代入參數。 1 2 3 4 5 6 7 8 void func1(const string&amp; msg = \"這是預設值\") { cout &lt;&lt; msg &lt;&lt; endl; } int main() { func1(\"test\"); func1(); return 0; } test 這是預設值test 這是預設值 宣告函式與定義函式分開，函式預設值只能在宣告 何謂宣告函式？ 宣告就是告訴編譯器我有一個函式藍圖模型(尚未實作)，又稱函式原型(prototype)，在程式的某處會引入此函式。 何謂定義函式？ 函式全部的程式碼。 何謂呼叫函式？ 程式執行到呼叫函式，程式的執行會移轉到函式定義(函式全部的程式碼)。 1 2 3 4 5 6 7 8 9 10 11 //宣告函式 void func1(); int main() { //呼叫函式 func1(); return 0; } //定義函式 void func1() { cout &lt;&lt; \"test\" &lt;&lt; endl; } 函式預設值只能在宣告 1 2 3 4 5 6 7 8 9 10 11 12 //宣告函式 void func1(const string&amp; msg = \"這是預設值\"); int main() { //呼叫函式 func1(\"test\"); func1(); return 0; } //定義函式 void func1(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; endl; } test 這是預設值 若有一個參數有預設值，排在它後面的參數也要有預設值 參數msg2排在參數msg1後面，參數msg1已設置預設值，若參數msg2不設置預設值會編譯錯誤。 呼叫函式，有預設值的參數，可以不用設置引數。 1 2 3 4 5 6 7 8 9 10 11 void func1(int error_code, const string&amp; msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } int main() { func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); func1(200); return 0; } Error code: 500, Msg1: Server Error!, Msg2: Server has some error. Error code: 404, Msg1: Not Found!, Msg2: 這是預設值2 Error code: 200, Msg1: 這是預設值1, Msg2: 這是預設值2 若某個參數設值，排在它之前的參數也要設值 下例中，傳值給第3個參數，前面2個參數都要設置。 func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); 1 2 3 4 5 6 7 8 9 10 void func1(int error_code, const string&amp; msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } int main() { func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); return 0; }"
  },"/pages/c/function/func_inline/": {
    "title": "內嵌函式",
    "keywords": "",
    "url": "/pages/c/function/func_inline/",
    "body": "內嵌函式inline 函式會占記憶體空間，主程式呼叫函式時會跳到函式占用的記憶體位址，待函式結尾再跳回主程式，為了節省跳來跳去的執行時間，可在函式前面加上inline，編譯器一看到inline就會把函式拷貝一份插入在主程式之中。 在以下程式碼print()最前面加上inline，使print()函式變成內嵌函式。 1 2 3 4 5 6 7 8 9 inline void print(string s) { cout &lt;&lt; s &lt;&lt; endl; } int main() { print(\"test\"); print(\"abcdef\"); print(\"aaaa\"); return 0; } 轉變內嵌函式，程式在執行時就會變成以下這樣 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { { string s = \"test\"; cout &lt;&lt; s &lt;&lt; endl; } { string s = \"abcdef\"; cout &lt;&lt; s &lt;&lt; endl; } { string s = \"aaaa\"; cout &lt;&lt; s &lt;&lt; endl; } return 0; } 若是呼叫print() 1000次就會copy程式碼1000份在主程式中，占用記憶體空間。(變數也是占記憶體位址)"
  },"/pages/c/function/func_overload/": {
    "title": "函式多載",
    "keywords": "",
    "url": "/pages/c/function/func_overload/",
    "body": "多載override 多載是指相同函式名，完成相似的工作。 函式名相同，回傳值相同，但參數的型態或數量不同，編譯時，編譯器會根據引數類型與函式參數類型，引數的數量與函式參數的數量，進行匹配。 int func(short a, string b); int func(int a, string b); int func(double a, string b); int func(int a, string b, int c); int func(string a, int b); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(int a, int b) { cout &lt;&lt; \"比較int\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } int main() { float a1 = 100.5f; float b1 = 100.3f; max(a1, b1); int a2 = 20; int b2 = 30; max(a2, b2); return 0; } 比較float a大 比較int b大 多載注意事項 函式名相同，參數型態與數量相同，但一個參數有const，這樣不是函式多載。 以下函式名、參數型態與數量相同，但有一個是const，這樣不是函式多載。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(const float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } 返回值要相同 函式名相同，參數型態與數量相同，但一個參數是參考，編譯器不知道要使用那一個 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(float&amp; a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } int main() { float a1 = 100.5f; float b1 = 100.3f; max(a1, b1); return 0; } 使用預設值，編譯器不知道要使用那一個函式 以下有二個相同名稱的函式，一個是三個參數(但有預設值)，一個是二個參數(沒預設值)，若使用二個引數呼叫，編譯器不知道要使用那一個函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 void func1(int error_code, string msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } void func1(int error_code, string msg1) { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; } int main() { func1(500,\"Server error!\"); return 0; }"
  },"/pages/c/class/enum/": {
    "title": "Enum列舉",
    "keywords": "",
    "url": "/pages/c/class/enum/",
    "body": "主程式 enum宣告 語法 enum 變數名稱{常數1, 常數2, 常數3, 常數4, ...}; 列舉型態在內部視為整數，通常集合第一個元素值為0，下一個為1，以此類推。 以下的寫法是錯誤，編譯器編不過。 day1 = 5; 完整程式碼 1 2 3 4 5 6 7 8 9 10 enum days_of_week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; int main() { days_of_week day1, day2; day1 = Mon; day2 = Thu; int diff = day2 - day1; cout &lt;&lt; \"Days between = \" &lt;&lt; diff &lt;&lt; endl; return 0; } Days between = 3 類別與Enum列舉 enum宣告 enum {girl = 0, boy = 1}; 變數存放enum 要記得存放enum值的變數 int sex; 指派enum給變數 在類別之外設定列舉 student.sex = student.girl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Student { public: char name[50]; int sex; enum {girl = 0, boy = 1}; private: char address[100]; public: int age; private: char father[50]; public: void setName(const char* name1) { strcpy(name, name1); } void setAge(const int age) { this-&gt;age = age; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; \"sex: \"; if(sex == girl) cout &lt;&lt; \"girl\" &lt;&lt; endl; else cout &lt;&lt; \"boy\" &lt;&lt;endl; } }; int main() { Student student; student.setName(\"Bill\"); student.setAge(20); student.sex = student.girl; student.print(); return 0; }"
  },"/pages/c/class/constructor/": {
    "title": "建構子與解構子",
    "keywords": "",
    "url": "/pages/c/class/constructor/",
    "body": "建構子 語法 public: 類別名() { } Student(){ } 與類別的名字相同 沒有返回值 權限是public 可以有參數，參數也可以有預設值 參數為空的建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); } }; int main() { Student student; return 0; } 沒參數建構子 建構子參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); m_age = 0; } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student; Student student1(\"Bill\", 20); student1.print(); return 0; } 沒參數建構子 有參數建構子 name: Bill 解構子 物件記憶體釋放前，會執行解構子。 語法 public: ~類別名() { } ~Student(){ } 與類別的名字相同，前面加上~ 沒有返回值 權限是public 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student student; return 0; } 建構子 解構子 建構子參數只有一個，可使用指派運算子 建構子參數只有一個，可使用指派運算子=，呼叫只有一個參數的建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: string name; Student(){}; //參數只有一個建構子 Student(const char* name) { this-&gt;name = name; } }; int main() { //使用等於(=)指派運算子呼叫只有一個參數的建構子 Student student = \"Bill\"; cout &lt;&lt; \"name = \" &lt;&lt; student.name &lt;&lt; endl; return 0; } name = Bill 注意事項 建構子解構子自動生成 若沒實作建構子/解構子，編譯器會自動生成空的建構子與解構子，若實作建構子，不管建構子有沒有參數，編譯器不會自動生成空的建構子或解構子 如果沒有實作空的建構子，只實作有參數的建構子，以下程式碼編譯不過。 以下程式碼在主程式main函式，會尋找空的建構子。 Student student; 以下程式碼編譯不過 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Student { public: char m_name[50]; int m_age = 20; Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student; return 0; } 不要用變數名()建立物件 以下程式碼，會編譯成功，但不會呼叫建構子，建立物件失敗，編譯器認為是呼叫函式名為student()的函式。 注意！student()是小寫，是變數名，不是類別名Student Student student(); 執行結果為空，沒有印出”沒參數建構子” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); m_age = 0; } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student(); return 0; } 用以上student呼叫成員函式print()，會編譯失敗，因為根本沒有建立物件，沒有在記憶體產生物件存放的位址。 student.print(); 1 2 3 4 5 int main() { Student student(); student.print(); return 0; } 多個建構子使用的程式碼寫在成員函式中 以下建構子呼叫init()函式，清空成員變數，多個建構子可以使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; init(); } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; init(); strcpy(m_name, name); m_age = age; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void init() { memset(m_name,0,sizeof(m_name)); m_age = 0; } }; int main() { Student student = Student(); Student student1 = Student(\"Bill\", 20); return 0; }"
  },"/pages/c/class/copy_constructor/": {
    "title": "拷貝函式",
    "keywords": "",
    "url": "/pages/c/class/copy_constructor/",
    "body": "複製語法 已建立的物件成員變數的值，複製給另一個物件。 語法如下 類別 新物件變數名(已建立物件變數名); 類別 新物件變數名 = 已建立物件變數名; 拷貝函式程式會自動產生，會自動產生二個物件的成員變數拷貝程式碼。 呼叫拷貝函式 以下二種程式碼都是呼叫預設的拷貝函式 方式一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2 = s1; s2.print(); return 0; } 方式二 1 2 3 4 5 6 7 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1); s2.print(); return 0; } 由執行結果可以發現建立2個物件(s1,s2)只呼叫一次拷貝函式。 s2.print()印出的值是複製s1的成員變數。 沒參數建構子 name: Cici 解構子 解構子 拷貝函式自行實作 類別名(const 類別名&amp; 參數名) {...} 權限為public 函式名必須與類別名相同 沒有傳回值，不寫void 如果自行實作拷貝函式，編譯器就不會自動產生預設拷貝函式 如果自行實作拷貝函式，但裡面都沒有程式碼，編譯器會自動產生預設的程式碼。 拷貝函式參數要包含const 類別名&amp;參考，不包含的話，就是建構子。 1 2 3 4 5 Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1); s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 name: Cici 解構子 解構子 函式參數的值是類別，會呼叫拷貝函式 函式參數是值 除了基本資料型態，在函式參數是值的時候會原始變數拷貝到新變數，若值是類別，也會把原始物件拷貝到新物件，此時就會呼叫到拷貝函式。 1 2 3 4 5 6 7 8 9 void func(Student s) { s.print(); } int main() { Student s1; strcpy(s1.m_name, \"Cici\"); func(s1); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 name: Cici 解構子 解構子 函式傳回值是臨時物件 函式傳回值是值 臨時物件 函式傳回值是臨時物件會呼叫拷貝函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } Student(const Student &amp;src) { cout &lt;&lt; \"拷貝函式\" &lt;&lt; endl; } Student&amp; operator=(const Student&amp; src) { cout &lt;&lt; \"指派運算子\" &lt;&lt; endl; return *this; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student func() { Student s; cout &lt;&lt; \"函式物件記憶體位址 = \" &lt;&lt; &amp;s &lt;&lt; endl; return s; } int main() { Student s1 = func(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; } 建構子 函式物件記憶體位址 = 0x7ff7bfeff410 拷貝函式 解構子 拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 拷貝函式多載(Overload) 在拷貝函式增加參數str 1 2 3 4 5 6 Student(const Student &amp;s, string str) { memset(m_name,0,sizeof(m_name)); string temp = str + s.m_name; strcpy(m_name, temp.c_str()); cout &lt;&lt; \"呼叫Student(const Student &amp;s, string str)拷貝函式\" &lt;&lt; endl; } 執行的main函式 1 2 3 4 5 6 7 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1, \"漂亮的\"); s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s, const char str[50])拷貝函式 name: 漂亮的Cici 解構子 解構子"
  },"/pages/c/class/deep_shallow_copy/": {
    "title": "深淺拷貝",
    "keywords": "",
    "url": "/pages/c/class/deep_shallow_copy/",
    "body": "淺拷貝 淺拷貝介紹 二個物件二個指標都指向同一個記憶體位址，一旦一個指標指向的記憶體位址釋放，使用到另一個指標就會執行錯誤，因為它指向的記憶體位址已經被釋放。 以下程式碼，在建構子時，對m_ptr指標動態分配記憶體位址，並把位址存放的值設為abcdef，在解構子中，把m_ptr指標記憶體釋放，若沒使用拷貝函式前，以下程式碼運作正常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = new char[100]; strcpy(m_ptr, \"abcdef\"); cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr m_ptr = s.m_ptr; cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.print(); return 0; } 沒參數建構子 name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = abcdef 解構子 淺拷貝刪除問題 一旦使用拷貝函式，在解構子時就會出現問題，因為s1與s2的m_ptr指向同一個記憶體位址，但s1的解構子把m_ptr記憶體釋放掉，s2的解構子就找不到m_ptr的記憶體位址。 1 2 3 4 5 6 7 8 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.print(); Student s2(s1); s2.print(); return 0; } 沒參數建構子 name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = abcdef 呼叫Student(const Student &amp;s)拷貝函式 name: Cici m_ptr address:0x7ff7bfeff420 m_ptr value = abcdef 解構子 lsn11(15006,0x100098600) malloc: *** error for object 0x600002900000: pointer being freed was not allocated lsn11(15006,0x100098600) malloc: *** set a breakpoint in malloc_error_break to debug 淺拷貝修改同一個記憶體位址內容問題 以下程式碼，s1.m_ptr的指標內容為abcdef，s2.m_ptr也修改成zzzzz，造成s1.print()印出的結果也是zzzzz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = nullptr; cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr m_ptr = s.m_ptr; cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.m_ptr = new char[100]; strcpy(s1.m_ptr, \"abcdef\"); Student s2(s1); strcpy(s2.m_ptr, \"zzzzz\"); cout &lt;&lt; \"##### s1 #### \" &lt;&lt; endl; s1.print(); cout &lt;&lt; \"##### s2 #### \" &lt;&lt; endl; s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 ##### s1 #### name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = zzzzz ##### s2 #### name: Cici m_ptr address:0x7ff7bfeff420 m_ptr value = zzzzz 深拷貝 二個物件二個指標分別指向不同記憶體位址，複製的時候，把值複製到另一個記憶體位址。 以下程式碼在拷貝函式先判斷拷貝的對象是不是nullptr，若不是，才動態分配記憶體位址，並把字串指標的內容透過strcpy()拷貝到另一個字串指標。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = nullptr; cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr if(s.m_ptr) { m_ptr = new char[100]; strcpy(m_ptr, s.m_ptr); } else { m_ptr = nullptr; } cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } };"
  },"/pages/c/class/init_list/": {
    "title": "建構子初始化列表",
    "keywords": "",
    "url": "/pages/c/class/init_list/",
    "body": "語法 建構子初始化列表(Initialization list of constructors)，因為不知道繁體中文的名稱，先以大陸的名稱來替代。 成員變數已經在初始化列表，不應該再建構子中再設值 語法如下 類別名(資料型態 參數名1, 資料型態 參數名2, ...):成員變數1(參數名1),成員變數2(參數名2), ... {} 下方有參數的建構子，使用初始化列表，初使化成員變數。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: string m_name; int m_age; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(string name, int age):m_name(name),m_age(age) { cout &lt;&lt; \"初始化列表建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; m_age &lt;&lt; endl; } }; int main() { Student s1(\"cici\", 18); s1.print(); return 0; } 初始化列表建構子 name: cici age: 18 解構子 初始化列表與運算式 下方有參數的建構子，使用初始化列表並加上運算式，初使化成員變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: string m_name; int m_age; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(string name, int age):m_name(\"漂亮的\" + name),m_age(age + 10) { cout &lt;&lt; \"初始化列表建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; m_age &lt;&lt; endl; } }; int main() { Student s1(\"cici\", 18); s1.print(); return 0; } 初始化列表建構子 name: 漂亮的cici age: 28 解構子"
  },"/pages/c/pthread/create_pthread/": {
    "title": "建立pthread",
    "keywords": "",
    "url": "/pages/c/pthread/create_pthread/",
    "body": ""
  },"/pages/c/thread/create_thread/": {
    "title": "建立thread",
    "keywords": "",
    "url": "/pages/c/thread/create_thread/",
    "body": "thread建構子介紹 匯入 #include &lt;thread&gt; 建立thread thread t1(func, \"test test\"); 第一個參數是函式名 第二個參數是呼叫函式代入的參數 sleep函式 使用sleep函式，需要匯入以下標頭檔，因為我是mac，所以匯入unistd.h #include &lt;unistd.h&gt; sleep函式使用方式 sleep(1); 在mac中，sleep是小寫，建構子代入參數1，代表1秒。 join 執行緒記憶體釋放 1 t1.join(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { for(int i = 0; i &lt;= 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } i = 0, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =test test i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 2, msg =test test i = 3, msg =abcdefg abcdefg i = 3, msg =test test i = 4, msg =abcdefg abcdefg i = 4, msg =test test i = 5, msg =abcdefg abcdefg i = 5, msg =test test i = 6, msg =i = 6, msg =test test abcdefg abcdefg i = 7, msg =test test i = 7, msg =abcdefg abcdefg i = 8, msg =test test i = 8, msg =abcdefg abcdefg i = 9, msg =test test i = 9, msg =abcdefg abcdefg i = 10, msg =abcdefg abcdefg i = 10, msg =test test thread與成員函式 thread 執行緒變數(&amp;類別名::成員函式, &amp;物件名, 傳進成員函式的參數1,傳進成員函式的參數2); 參數1為成員函式的記憶體位址 參數2為物件記憶體位址 參數3與參數4為函式的參數 以下的程式碼包含Student的類別，t3執行緒是呼叫Student物件的成員函式func()，並代入參數msg。 1 2 3 4 5 Student student;//建立物件 //第一個參數傳入成員函式位址，要有&amp;類別名::成員函式，注意！成員函式結尾不用括號 //第二個參數傳入物件地址 //第三個參數傳入函式的參數 thread t3(&amp;Student::func, &amp;student, \"ccccccc\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Student { public : void func(const string&amp; msg) { for(int i = 0; i &lt;= 10; i++) { cout &lt;&lt; \" i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; } } }; int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); Student student;//建立物件 //第一個參數傳入成員函式位址，要有&amp;類別名::成員函式，注意！成員函式結尾不用括號 //第二個參數傳入物件地址 //第三個參數傳入函式的參數 thread t3(&amp;Student::func, &amp;student, \"ccccccc\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); t3.join(); return 0; }"
  },"/pages/c/thread/join/": {
    "title": "執行緒記憶體釋放",
    "keywords": "",
    "url": "/pages/c/thread/join/",
    "body": "main()函式執行完成，執行中的執行緒強迫結束 執行緒函式返回，執行緒結束。 main程式退出，正在執行的執行緒都會被強迫結束。 以下範例，執行緒執行10秒結束，但main函式(主程式) 只執行5秒結束，明顯執行緒執行的時間比主程式久，重點是主程式結束，其它未執行完的執行緒也會強迫結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //每一秒印1次，這裡是執行5秒 for(int i = 0; i &gt; 5; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } return 0; } 釋放執行緒記憶體位址 多個執行緒共享Stack空間，每一個執行緒都會占記憶體空間，所以執行緒結束時要釋放它的記憶體位址。 執行緒記憶體釋放有2種方法 在main()函式使用join()，等待執行緒結束，記憶體位址釋放(也稱記憶體回收)後，返回main()主程式。 使用detach()執行緒與主程式分離，各別運行，執行緒結束後會自行使用joinalbe()把它占用的記憶體位址釋放。 即便以下程式，main()主程式執行時間改為12秒，比執行緒10秒久，但執行緒記憶體位址沒被釋放，仍會執行錯誤。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //每一秒印1次，這裡是執行12秒 for(int i = 0; i &gt; 12; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } return 0; } join() 以下程式碼，即便main()函式已經刪掉執行時間12秒的程式碼，也就是說main()函式的執行時間為0秒，但使用join()，main()函式仍會等待執行緒都執行完(包含記憶體釋放)，才會跟著結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } detach() 使用detach()分離執行緒，main()函式要執行的比執行緒久，不然的話，主程式執行結束，執行緒也會跟著執行結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //分離執行緒 t1.detach(); //分離執行緒 t2.detach(); //main()函式等留12秒，等待執行緒(執行緒10秒) sleep(12); return 0; }"
  },"/pages/c/thread/mutex/": {
    "title": "互斥鎖Mutex",
    "keywords": "",
    "url": "/pages/c/thread/mutex/",
    "body": "執行緒安全 多個執行緒搶同一個資源，就會發生問題，以下程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } i = 0, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =test test i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 2, msg =test test i = 3i = 3, msg =test test, msg =abcdefg abcdefg i = 4i = 4, msg =abcdefg abcdefg, msg =test test i = 5, msg =test test i = 5, msg =abcdefg abcdefg i = 6, msg =test test i = 6, msg =abcdefg abcdefg i = 7, msg =test test i = 7, msg =abcdefg abcdefg i = 8, msg =abcdefg abcdefg i = 8, msg =test test i = 9, msg =abcdefg abcdefg i = 9, msg =test test 從執行結果來看，以下二句是二個執行緒搶cout(全域變數)這個資源，導致輸出的結果不正常。 i = 3i = 3, msg =test test, msg =abcdefg abcdefg i = 4i = 4, msg =abcdefg abcdefg, msg =test test 互斥鎖Mutex 同步(Concurrency Control)是指，多個執行緒協調如何使用同一個資源。 如下圖，每一個人代表一個執行緒，他們都在排隊上同一間廁所(同一個資源)，當一個人(一個執行緒)進入廁所，就要把門鎖上，當上完廁所，再把門打開，輪下一個人(下一個執行緒)進去上廁所(同一個資源)。 互斥鎖保證同一個時間只有一個人(一個執行緒)使用廁所(同一個資源)，當一個執行緒把門鎖上，其它執行緒就在門外排隊等候，等待廁所中的執行緒把門打開(開鎖)，輪下一個執行緒進去把門鎖上。 匯入標頭檔 #include &lt;mutex&gt; 互斥鎖全域變數 mutex mtx; lock() 鎖上 可以把mutex想像成是廁所那個門，若是門是鎖起來的狀態，代表有人(一個thread)在廁所裡面，其它人(threads)就要在門外排隊等待，直到門開鎖，沒有鎖起來的狀態，執行緒呼叫mutex.lock()會自行判斷鎖起來的狀態，若沒鎖上，執行緒會得到鎖，若鎖上，執行緒就要排隊等待。 unlock() 開鎖 只有在廁所中的執行緒才有開鎖的功能，其它在廁所門外排隊的執行緒是沒辦法開鎖。 程式碼 先前的程式，把cout想成廁所，程式碼修改如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; #include &lt;mutex&gt; using namespace std; //建立mutex互斥鎖 mutex mtx; void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { mtx.lock();//把門鎖上 cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 mtx.unlock();//使用完畢，把門開鎖 } } i = 0, msg =test test i = 1, msg =test test i = 2, msg =test test i = 3, msg =test test i = 4, msg =test test i = 5, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 3, msg =abcdefg abcdefg i = 4, msg =abcdefg abcdefg i = 5, msg =abcdefg abcdefg i = 6, msg =abcdefg abcdefg i = 7, msg =abcdefg abcdefg i = 8, msg =abcdefg abcdefg i = 9, msg =abcdefg abcdefg i = 6, msg =test test i = 7, msg =test test i = 8, msg =test test i = 9, msg =test test 判斷是那個thread加鎖/解鎖/申請鎖 1 2 3 4 5 6 7 8 9 10 11 12 void func(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"申請鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; mtx.lock(); cout &lt;&lt; \"鎖上的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 cout &lt;&lt; \"開鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; mtx.unlock(); } } 類別與mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { //私有成員變數互斥鎖 mutex m_mutex; public: void func(string msg) { for(int i = 0; i &lt; 10; i++) { m_mutex.lock(); cout &lt;&lt; \"msg = \" &lt;&lt; msg &lt;&lt; endl; m_mutex.unlock(); } } }; int main() { Student student;//建立物件 thread t1(&amp;Student::func, &amp;student, \"student1\"); thread t2(&amp;Student::func, &amp;student, \"student2\"); thread t3(&amp;Student::func, &amp;student, \"student3\"); thread t4(&amp;Student::func, &amp;student, \"student4\"); thread t5(&amp;Student::func, &amp;student, \"student5\"); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0; } msg = student1 msg = student3 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 以下截斷 recursive_mutex 以下程式碼，func4()呼叫func3()，但執行結果只印出func4。 若是鎖中有鎖，會有死鎖(Dead lock)問題，mutex必須解鎖才能加鎖。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 mutex mtx; void func3() { mtx.lock();//加鎖 cout &lt;&lt; \"func3\" &lt;&lt; endl; mtx.unlock();//解鎖 } void func4() { mtx.lock();//加鎖 cout &lt;&lt; \"func4\" &lt;&lt; endl; func3();//呼叫func3 mtx.unlock();//解鎖 } int main() { //建立執行緒t1 thread t1(func4, \"test test\"); //執行緒t1被記憶體釋放 t1.join(); return 0; } func4 改成使用recursive_mutex，就不會有死鎖問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 recursive_mutex r_mtx; void func3() { r_mtx.lock();//加鎖 cout &lt;&lt; \"func3\" &lt;&lt; endl; r_mtx.unlock();//解鎖 } void func4() { r_mtx.lock();//加鎖 cout &lt;&lt; \"func4\" &lt;&lt; endl; func3();//呼叫func3 r_mtx.unlock();//解鎖 } int main() { //建立執行緒t1 thread t1(func4); //執行緒t1被記憶體釋放 t1.join(); return 0; } func4 func3 lock_guard lock_guard是mutex的樣板，只要管加鎖，不用管解鎖，它會在離開有效範圍(Scope)與生命週期(Lifetime)，自動解鎖。 語法 1 lock_guard&lt;mutex類別名&gt; mlock(mtx物件名); 把之前的程式碼修改成lock_guard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void func2(string msg) { //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"申請鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //有效範圍scope 開始 { lock_guard&lt;mutex&gt; mlock(mtx);//把門鎖上 cout &lt;&lt; \"鎖上的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 cout &lt;&lt; \"開鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; } //有效範圍scope 結束 } } int main() { //建立執行緒t1 thread t1(func2, \"test test\"); //建立執行緒t2 thread t2(func2, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 0, msg =test test 申請鎖的thread = 0x700005ead000 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 1, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 2, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 3, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005ead000 i = 0, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 1, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 2, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 3, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 4, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 以下截斷"
  },"/pages/c/thread/this_thread/": {
    "title": "this_thread",
    "keywords": "",
    "url": "/pages/c/thread/this_thread/",
    "body": "取得get_id() 像linux中每一個行程(Process)都有pid，執行緒也有自己的id。 取得main thread的id 在main()函式中，放入以下程式碼就可以取得main thread的id this_thread::get_id() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); cout &lt;&lt; \"get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } 取得thread的id 以下程式碼就可以取得執行緒的id 1 2 3 4 5 6 7 8 void func(string msg) { cout &lt;&lt; \"func get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //每一秒印1次，這裡是執行10秒 for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } 也可以透過執行緒物件取得id 語法 執行緒物件.get_id() 程式碥 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); cout &lt;&lt; \"main() get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"t1 get_id() = \" &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; \"t2 get_id() = \" &lt;&lt; t2.get_id() &lt;&lt; endl; //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } sleep_for() 跟sleep()函式一樣，但sleep()會有作業系統不同造成寫法不同，匯入的標頭檔不同。但sleep_for()解決這個問題。 以下是暫停1秒 1 this_thread::sleep_for(chrono::seconds(1));"
  },"/pages/c/thread/condition_variable/": {
    "title": "condition_variable",
    "keywords": "",
    "url": "/pages/c/thread/condition_variable/",
    "body": "通知與等待 想像一下，當有人寄簡訊給你，你的手機會收到簡訊的通知Notify，其它時候，你的手機一直處於等待Wait的狀態。 建立condition_variable condition_variable m_cond;//條件 通知接收訊息 通知一個執行緒 m_cond.notify_one(); 通知多個執行緒 m_cond.notify_all(); unique_lock unique_lock支援condition_variable(通知/等待) unique_lock支援解鎖功能。 1 2 3 unique_lock&lt;mutex&gt; lock(m_mtx);//加鎖 lock.unlock();//解鎖 也可使用scope有效範圍作為離開範圍解鎖 1 2 3 4 { unique_lock&lt;mutex&gt; lock(m_mtx);//加鎖 //離開scope{}就解鎖 } 等待有訊息傳過來 1 m_cond.wait(lock); Queue 建立一個Queue儲存訊息。 無限迴圈 手機無限迴圈等待有訊息通知 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &lt;queue&gt; #include &lt;condition_variable&gt; using namespace std; class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; public: void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; int main() { //建立物件 SafeQueue safeQue; //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for(int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for(int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; } 執行緒:0x70000ff3d000,msg0 執行緒:0x70000ff3d000,msg1 執行緒:0x70000ff3d000,msg2 執行緒:0x70000ff3d000,msg3 執行緒:0x70000ff3d000,msg4 執行緒:0x70000ff3d000,msg5 執行緒:0x70000ff3d000,msg6 執行緒:0x70000ff3d000,msg7 執行緒:0x70000ff3d000,msg8 執行緒:0x70000ff3d000,msg9 執行緒:0x70000ff3d000,msg10 執行緒:0x70000ff3d000,msg11 執行緒:0x70000ffc0000,msg12 執行緒:0x70000ffc0000,msg13 執行緒:0x70000ffc0000,msg14 執行緒:0x70000ffc0000,msg15 以下截掉 證明wait()自帶解鎖功能 因為mutex互斥鎖一次只能把鎖給一個執行緒，拿到鎖的執行緒就可以執行互斥鎖mutex之後的程式碼，其它執行緒都在mutex之外排隊， 但wait()的參數中又需要有lock，只能有鎖的執行緒才能等待通知，這樣就只有一個執行緒在等待通知， 其它執行緒都在mutex之外排隊等待拿到鎖，因此wait()為了要讓其它執行緒能等待接收訊息，自帶解鎖功能，證明的過程在最後面。 在wait()之前增加一行，休眠一小時 this_thread::sleep_for(chrono::hours(1)); 目的是不要執行wait()，可以看到執行緒搶鎖的過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"排隊等待\" &lt;&lt; endl; unique_lock&lt;mutex&gt; lock(m_mtx); cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"加鎖成功\" &lt;&lt; endl; this_thread::sleep_for(chrono::hours(1)); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; 從執行結果可以看出，只有一個執行緒拿到鎖，並加鎖，其它執行緒都在外面排隊等待拿到鎖。 執行緒 = 執行緒 = 0x7000016b9000執行緒 = 0x700001636000排隊等待0x70000173c000排隊等待 排隊等待 執行緒 = 0x7000016b9000加鎖成功 把休眠一小時的程式碼拿掉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"排隊等待\" &lt;&lt; endl; unique_lock&lt;mutex&gt; lock(m_mtx); cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"加鎖成功\" &lt;&lt; endl; // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; 從執行結果可以看到，三個執行緒都拿到鎖，證明wait()有自帶解鎖功能。 執行緒 = 執行緒 = 執行緒 = 0x70000ea07000排隊等待0x70000ea8a000 執行緒 = 排隊等待 0x70000ea07000加鎖成功 執行緒 = 0x70000ea8a000加鎖成功 0x70000e984000排隊等待 執行緒 = 0x70000e984000加鎖成功"
  },"/pages/c/class/member_class/": {
    "title": "成員變數是類別",
    "keywords": "",
    "url": "/pages/c/class/member_class/",
    "body": "在Java的世界中，只有new的那一刻才會呼叫類別的建構子。 但在C++的世界中，Family m_family;就會呼叫類別的建構子，並且在記憶體建立此物件的位址。 1 2 3 4 class Student { public: Family m_family; }; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Family { public: string mon; string dad; Family(){ cout &lt;&lt; \"Family 建構子\" &lt;&lt; endl; } }; class Student { public: Family m_family; }; int main() { Student student; return 0; } Family 建構子 由執行結果可以知道，建立student物件的時候，就會建立Family物件。"
  },"/pages/c/class/static_class/": {
    "title": "靜態類別變數與函式",
    "keywords": "",
    "url": "/pages/c/class/static_class/",
    "body": "Prerequisites: 記憶體配置 靜態類別變數與靜態類別函式不屬於物件，與物件是分開，靜態類別變數與靜態類別函式存放在靜態bss與data segment 靜態類別變數只有一個，無論物件有多少個，但靜態類別變數只有一個。 靜態類別變數 在變數前面加上static 語法 static int count; 靜態類別變數不會在建立物件的時候初始化，需要使用::範圍運算子在全域變數的位置初始化。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; class Student { public: static int count; }; //在這邊初始化靜態類別變數 int Student::count = 100; int main() { return 0; } 物件的成員變數需要建立物件才能讀寫。 讀取類別靜態變數不用建立物件，只需要類別名與::範圍運算子與變數名就可以讀取靜態類別變數。 類別::靜態類別變數 cout &lt;&lt; \"count = \" &lt;&lt; Student::count &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 class Student { public: static int count; }; int Student::count = 100; int main() { cout &lt;&lt; \"count = \" &lt;&lt; Student::count &lt;&lt; endl; return 0; } count = 100 靜態類別函式 在函式前面加上static 語法 static void getCount(){}; 呼叫靜態類別函式不用建立物件，只需要類別名與::範圍運算子與函式名就可以讀取靜態類別函式。 類別::靜態類別函式 Student::getCount(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student::getCount(); return 0; } 物件可以讀取靜態類別變數與靜態類別函式 物件可以直接讀取靜態類別變數與靜態類別函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student student; cout &lt;&lt; \"student.count = \" &lt;&lt; student.count &lt;&lt; endl; student.getCount(); return 0; } student.count = 100 count = 100 所有物件共享同一個靜態變數 以下的例子即便建了三個物件，但靜態類別變數在記憶體中只有一份，而不是三份，所以三個物件都只在同一個記憶體位址的靜態類別變數進行修改，所以最後一個人修改130，把每個物件的count印出來也全是130。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { Student student1; student1.count = 110; Student student2; student2.count = 120; Student student3; student3.count = 130; cout &lt;&lt; \"student1.count = \" &lt;&lt; student1.count &lt;&lt; endl; cout &lt;&lt; \"student2.count = \" &lt;&lt; student2.count &lt;&lt; endl; cout &lt;&lt; \"student3.count = \" &lt;&lt; student3.count &lt;&lt; endl; return 0; } student1.count = 130 student2.count = 130 student3.count = 130 靜態類別函式只能讀取靜態類別變數 靜態類別函式只能存取靜態類別變數，不能存取物件成員變數。 以下程式碼，試圖在靜態類別函式(getCount)中存取成員變數(name)，編譯出錯。 1 2 3 4 5 6 7 8 9 class Student { public: string name; static int count; static void getCount() { cout &lt;&lt; \"name =\" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; 靜態類別函式無法讀取物件成員函式 以下程式碼，試圖在靜態類別函式(getCount)呼叫成員函式(print)，編譯出錯。 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: string name; static int count; void print() { cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; } static void getCount() { print(); cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; 成員函式可以讀取靜態類別函式與靜態類別變數 以下程式碼，在成員函式(print)呼叫靜態類別函式(getCount)與靜態類別變數(count)，不會有問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Student { public: string name; static int count; void print() { cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; getCount(); cout &lt;&lt; \"2. count = \" &lt;&lt; count &lt;&lt; endl; } static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student student1; student1.name = \"Bill\"; student1.count = 110; Student student2; student2.name = \"Mary\"; student2.count = 120; Student student3; student3.name = \"Tom\"; student3.count = 130; student1.print(); cout &lt;&lt; \"-----------------\" &lt;&lt; endl; student2.print(); cout &lt;&lt; \"-----------------\" &lt;&lt; endl; student3.print(); return 0; } name = Bill count = 130 2. count = 130 ----------------- name = Mary count = 130 2. count = 130 ----------------- name = Tom count = 130 2. count = 130 靜態類別函式沒有this 因為不是物件，所有不能用this private靜態類別變數與private靜態類別函式無法在類別之外被訪問 以下程式碼把count與getCount()移到private 可以使用全域的方式初始化靜態類別變數 int Student::count = 100; 但以下程式碼試圖在類別之外讀取私有靜態類別變數與私有類別函式，編譯失敗。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } public: string name; }; int Student::count = 100; int main() { cout &lt;&lt; Student::count &lt;&lt; endl; Student::getCount(); return 0; }"
  },"/pages/c/class/functor/": {
    "title": "operator()物件函式",
    "keywords": "",
    "url": "/pages/c/class/functor/",
    "body": "物件函式Functor 物件名本身就是函式名，但使用方法像呼叫函式一樣。 必須在類別裡面定義 以下回傳值型態與參數可自定義，沒有限制，但函式名必須為operator() 1 2 3 回傳值型態 operator()(參數) { cout &lt;&lt; \"要做的事\" &lt;&lt; endl; } 呼叫物件函式步驟 建立物件 呼叫物件函式 1 2 3 4 //建立物件 Student student; //呼叫物件函式，注意!這裡不是呼叫建構子 student(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; void operator()() { cout &lt;&lt; \"Hello\" &lt;&lt; endl; } }; int main() { //建立物件 Student student; //呼叫物件函式，注意!這裡不是呼叫建構子 student(); return 0; } Hello 全域函式與物件函式同名如何執行？ 有一個全域函式名為student() 有一個物件函式名為student() 如何區別，使用::範圍運算子，來進行區別。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; void operator()() { cout &lt;&lt; \"Hello\" &lt;&lt; endl; } }; void student() { cout &lt;&lt; \"abcdefghijkl......\" &lt;&lt; endl; } int main() { //建立物件 Student student; //呼叫全域student() ::student(); //呼叫物件函式 student(); return 0; } abcdefghijkl...... Hello"
  },"/pages/c/class/operator_add/": {
    "title": "operator+()",
    "keywords": "",
    "url": "/pages/c/class/operator_add/",
    "body": "addScore()函式 以下程式碼，在類別外定義addScore()函式，並在Student類別中把addScore()設為friend(友情/朋友)，代表addScore()類別外的函式可以使用Student的private成員變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void addScore(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void addScore(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 addScore(student, 15); //印出學生姓名與各科分數 student.print(); return 0; } name = Bill math = 65 english = 75 chinese = 85 operator+()函式 把addScore函式名全改成operator+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 operator+(student, 15); //印出學生姓名與各科分數 student.print(); return 0; } student + 15 如果函式名是operator+(student,30)，寫法就可以換成student + 30，student是operator+()第一個參數，30是operator+()第二個參數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student + 15; //印出學生姓名與各科分數 student.print(); return 0; } name = Bill math = 65 english = 75 chinese = 85 回傳值型態是物件 student = student + 15; 以上的程式碼，是要把運算的結果回傳給型態是Student的物件，所以必須把回傳值型態改成物件的參考。 1 Student&amp; operator+(Student&amp; s, int score) 運算的過程也可以是很多數字的相加，不變的是，要把運算的結果回傳給型態是Student的物件。 student = student + 15 + 5 + 5; 以上的運算過程，函式的呼叫如下 student = (((student + 15) + 5) + 5); 每一個括號就有一個回傳值，+加號左邊的參數是operator+()第一個參數，+加號右邊是operator+()第二個參數。 再次分解如下 student = operator+(operator+(operator+(student, 15), 5), 5); 程式的回傳值型態改寫如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = student + 15; //印出學生姓名與各科分數 student.print(); return 0; } operator+()成員函式 之前的方式是把類別之外的函式透過friend實現，接下來將operator+()在類別內實作。 把operator+()變為成員函式，成員函式本身就有隱藏的this指標，指向呼叫函式的物件，所以原本的第一個參數可以刪掉。 Student&amp; operator+(int score){} 而原本 1 2 3 s.m_math += score; s.m_chinese += score; s.m_english += score; 可以改為 1 2 3 m_math += score; m_chinese += score; m_english += score; 原本的friend函式也可以刪掉 1 friend Student&amp; operator+(Student&amp; s, int score); 回傳值也改為隱藏的this指標，this指標為物件存放的記憶體位址，使用取值運算子，回傳物件。 return *this; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } Student&amp; operator+(int score) { m_math += score; m_chinese += score; m_english += score; return *this; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = student + 15 + 5; //印出學生姓名與各科分數 student.print(); return 0; } operator+()參數替換 若想使用以下的方式，數值在加號+左邊，物件在加號+右邊。 student = 15 + student; 只能使用類別外的friend函式實現，無法使用成員函式實現。 增加函式如下 1 Student&amp; operator+(int score, Student&amp; s){...} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); friend Student&amp; operator+(int score, Student&amp; s); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(int score, Student&amp; s) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = 15 + student; //印出學生姓名與各科分數 student.print(); return 0; } operator+()參數都為物件 若想使用以下的方式。 1 2 3 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + s2; 寫一個operator+傳入的參數為2個物件 1 Student&amp; operator+(Student&amp; s1, Student&amp; s2){} 程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); friend Student&amp; operator+(int score, Student&amp; s); friend Student&amp; operator+(Student&amp; s1, Student&amp; s2); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(int score, Student&amp; s) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(Student&amp; s1, Student&amp; s2) { s1.m_math += s2.m_math; s1.m_chinese += s2.m_chinese; s1.m_english += s2.m_english; return s1; } int main() { //建立物件 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + s2; //印出學生姓名與各科分數 s1.print(); return 0; } 混合使用 以上程式碼支援以下寫法 s1 = s1 + 10 + 5 + s2; 1 2 3 4 5 6 7 8 9 int main() { //建立物件 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + 10 + 5 + s2; //印出學生姓名與各科分數 s1.print(); return 0; }"
  },"/pages/c/class/operator_assign/": {
    "title": "operator=()",
    "keywords": "",
    "url": "/pages/c/class/operator_assign/",
    "body": "指派運算子使用方式 二個物件都已經存在，其中一個物件指派另一個物件。 編譯器預設會有預設的指派運算子operator=()，使用者可改寫。 改寫operator=函式的語法如下 類別名&amp; operator=(const 類別名&amp; src來源物件); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; Student&amp; operator=(const Student&amp; s) { m_name = s.m_name; return *this; } }; int main() { //建立二個物件 Student s1,s2; s1.m_name = \"Bill\"; //使用operator=函式 s2 = s1; cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.m_name &lt;&lt; endl; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.m_name &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Bill 深拷貝 預設是淺拷貝。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; int* m_ptr; Student(){m_ptr = nullptr;} ~Student(){if(m_ptr) delete m_ptr;} //參數為來源物件，也就是指要copy的物件 Student&amp; operator=(const Student&amp; src) { m_name = src.m_name; //如果來源物件的m_ptr指標是空 if(src.m_ptr == nullptr) { //要把目的物件清空(如果目的物件不是空的話) if(m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; } } else { //如果目的物件為空 if(m_ptr == nullptr) { //動態分配記憶體 m_ptr = new int; } //記憶體的值拷貝 memcpy(m_ptr, src.m_ptr, sizeof(int)); } return *this; } }; int main() { //建立二個物件 Student s1,s2; s1.m_name = \"Bill\"; s1.m_ptr = new int(15); //使用operator=函式 s2 = s1; cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.m_name &lt;&lt; endl; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.m_name &lt;&lt; endl; cout &lt;&lt; \"s1 m_ptr = \" &lt;&lt; *s1.m_ptr &lt;&lt; endl; cout &lt;&lt; \"s2 m_ptr = \" &lt;&lt; *s2.m_ptr &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Bill s1 m_ptr = 15 s2 m_ptr = 15"
  },"/pages/c/class/operator_equal/": {
    "title": "operator==()",
    "keywords": "",
    "url": "/pages/c/class/operator_equal/",
    "body": ""
  },"/pages/c/function/auto_func/": {
    "title": "auto與函式",
    "keywords": "",
    "url": "/pages/c/function/auto_func/",
    "body": "Prerequisites: 函式指標 auto的中文意思為自動推導類型，使用時不用特別寫準確的類型，編譯器會自動推導。 自動推導函式回傳值類型 注意！這邊的函式名後面有括號()，auto是函式回傳值類型。 語法 auto 變數 = 函式名(); auto var = func(); 1 2 3 4 5 6 7 8 9 10 //宣告一個函式為func()，回傳值為string類型 string func() { return \"test\"; } int main() { //使用函式的回傳值，由auto自動推導函式的回傳的類型string auto var = func(); cout &lt;&lt; \"var = \" &lt;&lt; var &lt;&lt; endl; return 0; } test 自動推導函式指標類型 函數指針設計複雜，可以使用auto簡化。 注意！這邊的函式名後面沒有括號，auto指的是函式指標類型。 語法 auto 函式指標名 = 函式名; auto f = func; 呼叫函式 f(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 string func() { cout &lt;&lt; \"abcdef\" &lt;&lt; endl; return \"test\"; } int main() { //注意!函式func後面沒有括號 auto f = func; //呼叫函式 cout &lt;&lt; f() &lt;&lt; endl; return 0; } abcdef 簡化函式指標 參數很多的函式，可用auto簡化函式指標。 未簡化前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //定義一個函式名為println，回傳值為int， //參數有二個，分別為char指標型別的參數msg1與msg2 int println(char* msg1, char* msg2) { printf(\"印出msg1:%s\\nmsg2:%s\\n\",msg1,msg2); return 1; } int main() { //(*funcPtr)宣告函式指標的名稱為funcPtr //回傳值為int //(char*,char*)代表參數型別 //實作函式指標的函式是println()的函式 //注意= println後面是沒有括號() int (*funcPtr)(char*,char*)= println; //呼叫函式指標，並把參數代入 funcPtr(\"test\",\"c++\"); return 0; } 印出msg1:test msg2:c++ 使用auto簡化函式指標 1 2 3 4 5 6 7 8 9 int println(char* msg1, char* msg2) { printf(\"印出msg1:%s\\nmsg2:%s\\n\",msg1,msg2); return 1; } int main() { auto func = println; func(\"test\",\"c++\"); return 0; } 以下程式碼未簡化前 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; void say(void (*p)(char*),char *msg) { p(msg); } void println(char* msg) { printf(\"印出結果:%s\\n\",msg); } int main() { void(*p)(char*) = println; say(p, \"hello\"); return 0; } 印出結果:hello 使用auto簡化函式指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //定義一個函式指標的類型為FuncPtr，回傳值為void的類型，參數是char指針 typedef void(*FuncPtr)(char*); //參數為FuncPtr類型(回傳值為void的類型，參數是char指針) void say(FuncPtr func1, char* msg) { //呼叫函式指標 func1(msg); } void printMsg(char* msg) { cout &lt;&lt; \"msg:\" &lt;&lt; msg &lt;&lt; endl; } int main() { auto say_fun = say; auto print_fun = printMsg; //注意print_fun後面沒有括號() say_fun(print_fun,\"test\"); return 0; } msg:test"
  },"/pages/c/function/lambda/": {
    "title": "lambda",
    "keywords": "",
    "url": "/pages/c/function/lambda/",
    "body": "Prerequisites: 函式指標 auto與函式 lambda又稱匿名函式，也就是沒有名字的函式。 語法介紹 []()-&gt;Int{ return 0; } [] 獲取外部的變數值或參考 () 函式參數 -&gt; 函式回傳值型態，若為void可以不寫， {} 函式主體 []傳入外部變數值或參考 auto與函式要先看過才看的懂以下程式碼。 傳變數值 以下程式碼是把外部變數name透過[name]的方式，傳入lambda。 若要傳多個，用逗號。 注意！傳值的方式是不能修改外部變數。 語法 [name, age, ...] 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; int age = 20; auto f1 = [name](){ cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; }; f1(); return 0; } name = Mary 傳變數參考 傳參考是可以修改變數的值 若要傳多個，用逗號。 語法 [&amp;name, &amp;age, ...] 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; auto f1 = [&amp;name](){ name = \"Bill\"; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; }; f1(); return 0; } name = Bill 傳值= 若lambda中有用到外部變數，就會直接以值的方式把有用到的外部變數傳入lambda 語法 [=] 1 2 3 4 5 6 7 8 9 10 int main() { string name = \"Mary\"; int age = 18; auto f1 = [=](){ cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Mary age = 18 傳參考&amp; 若lambda中有用到外部變數，就會直接以參考的方式把有用到的外部變數傳入lambda 傳參考是可以修改變數的值 語法 [&amp;] 1 2 3 4 5 6 7 8 9 10 11 12 int main() { string name = \"Mary\"; int age = 18; auto f1 = [&amp;](){ name = \"Bill\"; age = 30; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Bill age = 30 混合傳 語法 [&amp;, name] 除了name變數是傳值的方式，其它lambda中有用到的變數一律傳參考的方式代入。 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [&amp;, name](){ age = 30; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Mary age = 30 語法 [=, &amp;name] 除了name變數是傳參考的方式，其它lambda中有用到的變數一律傳值的方式代入。 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [=, &amp;name](){ name = \"Tom\"; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Tom age = 18 不傳任何外部變數 語法 [] 外部變數都不能使用 1 2 3 4 5 6 7 8 9 10 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](){ //cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; //cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } 傳參數 語法 (參數型態 參數1, 參數型態2 參數2, ...) (string address) 以下程式碼設定lambda的參數，呼叫函式的時候代入參數。 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](string address){ cout &lt;&lt; \"address = \" &lt;&lt; address &lt;&lt; endl; }; f1(\"Taiwan Taipei ....\"); return 0; } 回傳值型態 若回傳型態為void，可以省略以下語法，也可以不寫，lambda會自動推導回值型態 -&gt;型態 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](string address) -&gt; int{ cout &lt;&lt; \"address = \" &lt;&lt; address &lt;&lt; endl; return 100; }; int val = f1(\"Taiwan Taipei ....\"); cout &lt;&lt; \"val = \" &lt;&lt; val &lt;&lt; endl; return 0; } address = Taiwan Taipei .... val = 100 函式轉成lambda 轉換前 以下程式碼有fun()的函式，參數為int型別的x與y，回傳值型別為int。 1 2 3 4 5 6 7 int fun(int x, int y) { return x + y; } int main() { cout &lt;&lt; \"x + y = \" &lt;&lt; fun(10, 100) &lt;&lt; endl; return 0; } x + y = 110 轉換後 使用auto宣告函式型態，f為函式變數名。 1 2 3 4 5 6 7 int main() { auto f = [](int x, int y) -&gt; int { return x + y; }; cout &lt;&lt; \"x + y = \" &lt;&lt; f(10, 100) &lt;&lt; endl; return 0; } x + y = 110 比對fun函式跟lambda匿名函式 1 2 3 int fun(int x, int y) { return x + y; } 1 2 3 [](int x, int y) -&gt; int { return x + y; };"
  },"/pages/c/function/using_func_pointer/": {
    "title": "using函式指標別名",
    "keywords": "",
    "url": "/pages/c/function/using_func_pointer/",
    "body": "Prerequisites: typedef類型別名 函式宣告與定義 typedef函式指標類型別名 函式參考 以上文章必須看完，才能往下看。 using替函式指標取類型別名 與typedef一樣，都是替函式指標取類型別名 定義函式指標類型別名語法 using 類型別名 = 函式指標 using Func = void(int, const string&amp;); 函式宣告 print函式與void(int, const string&amp;)是相符 注意！以下的print後面是沒有()括號 Func print; 以上程式碼等同普通函式宣告 void print(int, const string&amp;); 函式定義 所謂的函式定義就是有實作程式碼的函式 1 2 3 4 5 6 7 8 9 10 11 //Func類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server error. 函式指標 宣告函式指標，並指向函式 類型別名* 函式指標變數名 = 函式; Func* func_pointer = print; 呼叫函式 函式指標變數名(參數) func_pointer(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //Func函式類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { //宣告函式指標，指向print函式 Func* func_pointer = print; //呼叫函式 func_pointer(500, \"Server error.\"); //宣告函式參考，指向print函式 Func* func_ref = print; func_ref(400, \"Not Found.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 400 , Msg = Not Found. 函式參考 宣告函式參考，並指向函式 類型別名&amp; 函式指標變數名 = 函式; Func&amp; func_ref = print; 呼叫函式 函式參考變數名(參數) func_ref(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Func函式類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { //宣告函式參考，指向print函式 Func* func_ref = print; //呼叫函式 func_ref(400, \"Not Found.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 400 , Msg = Not Found. 類別靜態函式指標 靜態類別函式 函式指標語法 加上類別名字以及範圍運算子:: void (*func_pointer)(int, const string&amp;) = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //宣告函式指標 void (*func_pointer)(int, const string&amp;) = Student::print; func_pointer(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 使用using函式指標別名 加上類別名字以及範圍運算子:: Func *func_p = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; //Func函式類型別名 using Func = void(int, const string&amp;); int main() { //函式類型別名宣告函式指標 Func *func_p = Student::print; func_p(404, \"Page not Found.\"); return 0; } Error code = 404 , Msg = Page not Found. 物件成員函式指標 物件成員函式指標語法 必須把記憶體位址傳進去，所以有使用&amp;取位址運算子 呼叫函式時，使用物件加點(.)運算子與指標運算子(*) void(Student::* func_pointer)(int, const string&amp;) = &amp;Student::print; (student.*func_pointer)(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //物件宣告 Student student; //成員函式轉成函式指標 void(Student::* func_pointer)(int, const string&amp;) = &amp;Student::print; //函式指標呼叫函式 (student.*func_pointer)(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 使用using函式指標別名 函式指標類型別名 using Func = void(Student::*)(int, const string&amp;); 建立函式指標 Func func_pointer = &amp;Student::print; 呼叫函式指標 (student.*func_pointer)(400,\"Page not found.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; //Func函式類型別名 using Func = void(Student::*)(int, const string&amp;); int main() { //建立物件 Student student; //建立函式指標 Func func_pointer = &amp;Student::print; //呼叫函式指標 (student.*func_pointer)(400,\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found."
  },"/pages/c/c11/functional/": {
    "title": "functional",
    "keywords": "",
    "url": "/pages/c/c11/functional/",
    "body": "Prerequisites: typedef類型別名 函式宣告與定義 typedef函式指標類型別名 函式參考 using函式指標別名 以上文章必須看完，才能往下看。 大陸稱包裝器，台灣目前不知稱為什麼。 功能類似函式指標 include #include &lt;functional&gt; 語法1 宣告function function&lt;函式回傳值類型(函式參數1類型 參數名1,函式參數2類型 參數名2, ...)&gt; 變數名 = 函式名; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 語法2 可以把函式類型取別名 using FuncType = void(int, const string&amp;); 宣告function時，在模板類型設成FuncType函式類型別名 function&lt;FuncType&gt; func = print; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { using FuncType = void(int, const string&amp;); //宣告function function&lt;FuncType&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 類別靜態函式指標 語法 function&lt;void(int, const string&amp;)&gt; func = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = Student::print; //呼叫函式 func(500, \"Server error.\"); return 0; } 物件函式 物件函式 語法 function&lt;函式回傳值類型(函式參數1類型,函式參數2類型, ...)&gt; func = 物件名; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void operator()(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //宣告function function&lt;void(int, const string&amp;)&gt; func = student; //呼叫函式 func(500, \"Server error.\"); return 0; } lambda lambda 程式碼1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; int main() { //lambda auto print = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //宣告function function&lt;void(int, const string&amp;)&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } 程式碼2 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //呼叫函式 func(500, \"Server error.\"); return 0; } 物件成員函式 宣告function function&lt;參數類型1, …&gt; 第1個參數要填入類別參考&amp; 等於號(=)指派對映的函式，必須把記憶體位址傳進去，所以使用&amp;取位址運算子+類別名+::範圍運算子+函式名 function&lt;void(Student&amp;,int, const string&amp;)&gt; func = &amp;Student::print; 呼叫function 必須把物件代入第1個參數 func(student, 500, \"Server error.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //宣告function function&lt;void(Student&amp;,int, const string&amp;)&gt; func = &amp;Student::print; //呼叫函式 func(student, 500, \"Server error.\"); return 0; }"
  },"/pages/c/function/func_def/": {
    "title": "函式宣告與定義",
    "keywords": "",
    "url": "/pages/c/function/func_def/",
    "body": "函式宣告(declaration) 沒有程式碼，最後面有冒號; 告知編譯器有一個函式名字為print，傳回值型態為void，參數類型有int與const string&amp;，之後會有程式碼實作。 void print(int code,const string&amp; msg); 函式定義(definition) 有程式碼。 1 2 3 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } 呼叫函式 print(500, \"Server Error.\"); 函式宣告與函式定義 1 2 3 4 5 6 7 8 9 10 11 //函式宣告 void print(int code,const string&amp; msg); int main() { //呼叫函式 print(500, \"Server Error.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server Error. 函式宣告與定義合在一起 在main()主程式前宣告函式，並且實作程式碼，就是函式宣告與定義結合一起，有實作程式碼一律稱之函式定義。 1 2 3 4 5 6 7 8 //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { print(500, \"Server Error.\"); return 0; } Error code = 500 , Msg = Server Error."
  },"/pages/c/function/func_ref/": {
    "title": "函式參考",
    "keywords": "",
    "url": "/pages/c/function/func_ref/",
    "body": "Prerequisites: 函式指標 函式參考與函式指標相同，不同的只是符號不同，一個用星號*，一個用&amp; 函式指標宣告 void (*func_pointer)(int, const string&amp;); 函式參考宣告 void (&amp;func_ref)(int, const string&amp;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //函式宣告 void print(int code, const string&amp; msg); int main() { //宣告函式指標，指到print函式 void (*func_pointer)(int, const string&amp;) = print; //呼叫函式 func_pointer(500, \"Server Error.\"); //宣告函式參考，指到print函式 void (&amp;func_ref)(int, const string&amp;) = print; //呼叫函式 func_ref(500, \"Server Error.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server Error. Error code = 500 , Msg = Server Error."
  },"/pages/c/c11/bind/": {
    "title": "bind綁定",
    "keywords": "",
    "url": "/pages/c/c11/bind/",
    "body": "Prerequisites: function 語法 function&lt;函式回傳值類型(函式參數1類型 參數名1,函式參數2類型 參數名2)&gt; func2 = bind(函式名, placeholders::_1, placeholders::_2); function&lt;void(int, const string&amp;)&gt; func2 = bind(print, placeholders::_1, placeholders::_2); placeholders::_1 對映函式參數名1 placeholders::_2 對映函式參數名2 函式bind 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. 參數對調 以下語法把函式參數對調 function&lt;void(const string&amp;,int)&gt; func = bind(print, placeholders::_2,placeholders::_1); 呼叫函式時也要對調 func(\"Page not found.\", 400); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(const string&amp;,int)&gt; func = bind(print, placeholders::_2,placeholders::_1); //呼叫函式 func(\"Page not found.\", 400); return 0; } Error code = 400 , Msg = Page not found. 參數數量可自訂 使用bind，可以預設參數值，限制傳進參數的個數。 function&lt;void(const string&amp;)&gt; func = bind(print, 400, placeholders::_1); 呼叫函式只傳一個參數 func(\"Page not found.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, 400, placeholders::_1); //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. bind預設傳值 以下的程式碼，即便之後把error_code改成500，顯示仍為400 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { int error_code = 400; //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, error_code, placeholders::_1); //修改成500 error_code = 500; //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. bind傳參考 語法 function&lt;void(const string&amp;)&gt; func = bind(print, ref(error_code), placeholders::_1); 使用ref(), 可以傳參考，也就可以修改變數中的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { int error_code = 400; //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, ref(error_code), placeholders::_1); error_code = 500; //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 500 , Msg = Page not found. 參數傳的比函式參數還多 print函式只有2個參數，但有一個需求需要傳3個參數，怎麼修改？ 在function的函式參數多增加一個，呼叫函式的參數也多增加一個 function&lt;void(int, const string&amp;, int)&gt; func = bind(print, placeholders::_1, placeholders::_2); func(400, \"Page not found.\", 1000); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;, int)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\", 1000); return 0; } Error code = 400 , Msg = Page not found. 物件成員函式與bind function&lt;參數類型1, …&gt; 第1個參數要填入類別參考&amp; 等於號(=)指派對映的函式，必須把記憶體位址傳進去，所以使用&amp;取位址運算子+類別名+::範圍運算子+函式名 注意！bind的參數有三個，分別是物件參考student&amp;，整數int，字串參考string&amp; function&lt;void(Student&amp;,int, const string&amp;)&gt; func = bind(&amp;Student::print, placeholders::_1, placeholders::_2, placeholders::_3); 呼叫function 必須把物件代入第1個參數 func(student, 500, \"Server error.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //設定bind與綁定的參數個數 function&lt;void(Student&amp;,int, const string&amp;)&gt; func = bind(&amp;Student::print, placeholders::_1, placeholders::_2,placeholders::_3); //呼叫函式 func(student, 400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. 類別靜態函式 語法 只需要函式前面加上類別名:: function&lt;void(int, const string&amp;)&gt; func = bind(Student::print, placeholders::_1, placeholders::_2); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(Student::print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } lambda bind的第1個參數代入lambda的變數名，也可以直接把lambda函式放進bind的第一個參數。 1 2 3 4 5 6 7 8 9 10 11 int main() { //lambda auto print = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } 物件函式 bind的第1個參數代入student物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: void operator()(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(student, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found."
  },"/pages/c/c11/move_operator/": {
    "title": "移動建構子與移動指派運算子",
    "keywords": "",
    "url": "/pages/c/c11/move_operator/",
    "body": "Prerequisites: 拷貝函式 operator=() 深淺拷貝 l-value與r-value l-value參考與r-value參考 臨時物件 關閉RVO 把RVO關閉後，才能進行以下的範例。 目的 以下的拷貝函式，針對指標(m_ptr)動態分配記憶體位址，將來源(source)物件指標內容拷貝到新分配的記憶體位址。 1 2 3 4 5 6 7 8 9 10 11 Student(const Student &amp;s) { //判斷來源(source)m_ptr是否null if(s.m_ptr) { //動態分配記憶體位址 m_ptr = new int; //拷貝來源物件m_ptr指標到新的記憶體位址 memcpy(m_ptr, src.m_ptr, sizeof(int)); } else { m_ptr = nullptr; } } 以上程式碼若拷貝的容量很大，將會花費許多時間在拷貝資料。 移動建構子(Move constructor)與移動指派運算子(Move assignment operator)主要針對右值進行指標移動，因為右值是一個臨時物件，通常使用完畢立即記憶體釋放，移動建構子與移動指派運算子是不釋放臨時物件記憶體，把指標指向臨時物件(來源物件)的記憶體位址，省略以上程式碼拷貝動作。 語法 移動建構子(Move constructor)與移動指派運算子(Move assignment operator)的參數都是右值(r-value)，因為要刪除來源物件指標(有修改的動作)，所以參數不用const，拷貝與指派運算子則是不會修改來源物件。 移動建構子(Move constructor) 類別名(類別名&amp;&amp; 來源物件) { .... } 移動指派運算子(Move assignment operator) 類別名&amp; operator=(類別名&amp;&amp; 來源物件) { ...... return *this; } 指標轉移語法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Student(Student&amp;&amp; src) { cout &lt;&lt; \"移動建構子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; } Student&amp; operator=(Student&amp;&amp; src) { cout &lt;&lt; \"移動指派運算子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; return *this; } 使用右值移動建構子 第一次右值移動建構子：return s;這個臨時對象被移動到一個中間的無名臨時對象中，觸發了第一次的右值移動建構子。 第二次右值移動建構子：接著，這個中間的無名臨時對象被移動到 s4 中，觸發了第二次的右值移動建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: int* m_ptr; public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; //初始化成員變數 m_ptr = nullptr; } Student(const Student &amp;src) { cout &lt;&lt; \"左值拷貝函式\" &lt;&lt; endl; //判斷來源(source)m_ptr不是null if(src.m_ptr) { //動態分配記憶體位址 m_ptr = new int; //拷貝來源物件m_ptr指標到新的記憶體位址 memcpy(m_ptr, src.m_ptr, sizeof(int)); } else { m_ptr = nullptr; } } Student&amp; operator=(const Student&amp; src) { cout &lt;&lt; \"左值指派運算子\" &lt;&lt; endl; //如果來源物件的m_ptr指標是空 if(src.m_ptr == nullptr) { //要把目的物件清空(如果目的物件不是空的話) if(m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; } } else { //如果目的物件為空 if(m_ptr == nullptr) { //動態分配記憶體 m_ptr = new int; memset(m_ptr, 0, sizeof(int)); } //記憶體的值拷貝 memcpy(m_ptr, src.m_ptr, sizeof(int)); } return *this; } Student(Student&amp;&amp; src) { cout &lt;&lt; \"右值移動建構子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; } Student&amp; operator=(Student&amp;&amp; src) { cout &lt;&lt; \"右值移動指派運算子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; return *this; } ~Student() { delete m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; *m_ptr &lt;&lt; endl; } }; int main() { //右值指派運算子 Student s4 = [] { Student s; s.m_ptr = new int; *s.m_ptr = 200; return s; }(); cout &lt;&lt; \"s4 mptr = \" &lt;&lt; *s4.m_ptr &lt;&lt; endl; return 0; } 建構子 右值移動建構子 解構子 右值移動建構子 解構子 s4 mptr = 200 解構子"
  },"/pages/note/ip_setting/": {
    "title": "固定ip設定",
    "keywords": "",
    "url": "/pages/note/ip_setting/",
    "body": "查看dns ipconfig /all 在「其他 DNS 伺服器」欄位中輸入一個不同的備用 DNS 伺服器地址，或保留為空。例如： 如果只想使用一個 DNS 伺服器，則可以將「其他 DNS 伺服器」欄位留空。"
  },"/pages/c/c11/forward/": {
    "title": "forward",
    "keywords": "",
    "url": "/pages/c/c11/forward/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 參數為左值與右值 呼叫的函式的參數為左值與右值，相同的函式名，但參數多載(overload)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } int main() { int i = 10; //呼叫函式，參數為左值 func(i); //呼叫函式，參數為右值 func(100); return 0; } l-value r-value 保留右值參考的屬性 以下的函式，多出了middle()的函式，目的是再一次傳送參數，執行的結果會導致全被視作左值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } void middle(int x) { func(x); } int main() { int i = 10; //呼叫函式，參數為左值 middle(i); //呼叫函式，參數為右值 middle(100); return 0; } l-value l-value 為了解決以上的問題，需寫一個template，可以接收右值與左值，並把左右值屬性保留住，傳到func()的函式 T&amp;&amp; 若模板的類型為T&amp;&amp;，代表可以接收左值與右值，注意！這邊的T&amp;&amp;不是只能接收右值，也可以不接收左值，跟一般函式參數int&amp;&amp;是不一樣，函式參數類型為int&amp;&amp;就能接收右值。 forward 左右值屬性保留住，傳到其它函式。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } template&lt;typename T&gt; void middle(T&amp;&amp; x) { func(forward&lt;T&gt;(x)); } int main() { int i = 10; //呼叫函式，參數為左值 middle(i); //呼叫函式，參數為右值 middle(100); return 0; } l-value r-value"
  },"/pages/c/c11/variadic/": {
    "title": "可變參數模板",
    "keywords": "",
    "url": "/pages/c/c11/variadic/",
    "body": "語法 Args代表多個不同類型與數量的參數。 以下三種…位置不同，都可以。 template&lt;typename... Args&gt; template&lt;typename ...Args&gt; template&lt;typename ... Args&gt; 參數清單 以下程式碼”Bill”,”Mary”,”Tom”,”Allen”就是參數清單。 1 2 3 4 int main() { print(\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 遞迴呼叫 以下的模板是遞迴的方式在運作 T為類型 …Args為參數清單類型 arg為每一次遞迴，就會從參數清單取出一個 args為每一次遞迴，未被取出的剩下參數清單 1 2 3 4 5 6 7 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { //每呼叫一次就從args中拿出一個參數arg cout &lt;&lt; \"參數\" &lt;&lt; arg &lt;&lt; endl; //剩下未取出的參數繼續遞迴呼叫自已 print(args...); } 遞迴結束呼叫的函式 參數為空(因為可變參數清單已經全取出來，也沒參數可傳遞) 傳回值型態void 1 2 3 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //print()傳回值void，參數為空()，待遞迴結束時會呼叫此函式 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } //print是遞回函式template //每呼叫一次就從args中拿出一個參數arg，其它的args又傳入print中遞迴呼叫 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { cout &lt;&lt; \"參數\" &lt;&lt; arg &lt;&lt; endl; print(args...); } int main() { print(\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 參數Bill 參數Mary 參數Tom 參數Allen end 其它函式呼叫遞迴模板，呼叫的函式也要變成模板 以下程式碼為了呼叫遞迴模板，所以本身函式也要變成模板，再把參數傳入遞迴模板 1 2 3 4 5 6 //定義參數的類型名稱Args template&lt;typename... Args&gt; void func(const string&amp; school, Args... args) { cout &lt;&lt; school &lt;&lt; \"的學生有:\" &lt;&lt; endl; print(args...); } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //print()傳回值void，參數為空()，待遞迴結束時會呼叫此函式 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } //print是遞迴函式template //每呼叫一次就從args中拿出一個參數arg，其它的args又傳入print中遞迴呼叫 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { cout &lt;&lt; arg &lt;&lt; endl; print(args...); } template&lt;typename... Args&gt; void func(const string&amp; school, Args... args) { cout &lt;&lt; school &lt;&lt; \"的學生有:\" &lt;&lt; endl; print(args...); } int main() { //只有第1個參數傳進func印出來 //第1個參數之後都參數都是args，代入遞迴函式 func(\"青草湖國小\",\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 青草湖國小的學生有: Bill Mary Tom Allen end 可變參數模板與bind與functional functional bind l-value與r-value l-value參考與r-value參考 寫一個函式可以接收任何種類的函式與不同數量的參數，函式與參數可為左值右值。 以下程式碼不支援函式多載(overload) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } template&lt;typename Func, typename... Args&gt; auto callFunc(Func&amp;&amp; func, Args&amp;&amp;...args) { auto f = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)...); f(); return f; } int main() { callFunc(print, 400, \"Page not found.\"); //物件成員函式 Student student; callFunc(&amp;Student::print, student, 500, \"Server error.\"); //函式為右值 callFunc([](int code, const string&amp; msg) { cout &lt;&lt; \"Lambda error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }, 500, \"Server error.\"); return 0; } Error code = 400 , Msg = Page not found. Error code = 500 , Msg = Server error. Lambda error code = 500 , Msg = Server error."
  },"/pages/c/c11/callback/": {
    "title": "callback",
    "keywords": "",
    "url": "/pages/c/c11/callback/",
    "body": "Prerequisites: condition_variable 可變參數模板與bind與functional 增加callback 在condition_variable的程式碼中加上callback的程式碼 主要程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class SafeQueue { //成員變數為函式，函式類型為void(const string&amp; msg) function&lt;void(const string&amp; msg)&gt; m_callback; public: //成員函式模板 //參數1函式，參數2物件(可能沒有物件所以用可變參數Args...) template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { //args是物件，若呼叫的函式是物件成員函式，第二個參數就是物件 //若是函式，就不需要傳入第2個參數(因為可能沒有第2個參數，所以用可變參數Args...) m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } .... 以下程式碼略過 //若有設定回呼函式 if(m_callback) //執行回呼函式，並把回呼函式的參數傳入 m_callback(msg); .... 以下程式碼略過 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; //成員變數為函式，函式類型為void(const string&amp; msg) function&lt;void(const string&amp; msg)&gt; m_callback; public: //成員函式模板 //參數1函式，參數2物件(可能沒有物件所以用可變參數Args...) template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { //args是物件，若呼叫的函式是物件成員函式，第二個參數就是物件 //若是函式，就不需要傳入第2個參數(因為可能沒有第2個參數，所以用可變參數Args...) m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //解鎖 lock.unlock(); //若有設定回呼函式 if(m_callback) //執行回呼函式，並把回呼函式的參數傳入 m_callback(msg); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; callback是成員函式 1 2 3 Student student; //參數為物件成員函式，第二個參數是物件 safeQue.callback(&amp;Student::print, student); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void print(const string&amp; msg) { cout &lt;&lt; \" Msg = \" &lt;&lt; msg &lt;&lt; endl; } class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; function&lt;void(const string&amp; msg)&gt; m_callback; public: template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //解鎖 lock.unlock(); if(m_callback) m_callback(msg); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; int main() { //建立物件 SafeQueue safeQue; //建立物件 Student student; //參數為物件成員函式，第二個參數是物件 safeQue.callback(&amp;Student::print, student); //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for(int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for(int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; } Msg = msg0 Msg = Msg = msg2 Msg = Msg = msg4 msg1 Msg = Msg = msg3msg6msg5 Msg = msg7 Msg = msg9 Msg = . . . 以下截掉 callback參數為函式 以下新增print()函式 callback函式設為print safeQue.callback(print); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void print(const string&amp; msg) { cout &lt;&lt; \" Msg = \" &lt;&lt; msg &lt;&lt; endl; } class SafeQueue { . . . 以下截掉(跟前一個程式碼一模一樣) } int main() { //建立物件 SafeQueue safeQue; //設定回呼函式 safeQue.callback(print); //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for(int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for(int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; }"
  },"/pages/c/stl/string/": {
    "title": "string",
    "keywords": "",
    "url": "/pages/c/stl/string/",
    "body": "Prerequisites: ArrayList實作 ArrayList記憶體擴充 string物件 動態分配記憶體位址存放一組字元 自動建立記憶體位址與釋放記憶體位址，使用時程式設計師不用做釋放記憶體的動作 自動擴展容量 底層以ArrayList實作 string記憶體擴充 string底層是ArrayList實作。 以下程式碼證明string記憶體擴充後，capacity(最大容量)會呈倍數成長。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; int main() { //建立空的字串，呼叫string()空的建構子 string s1; //印出string cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; //容量 cout &lt;&lt; \"s1.capacity() = \" &lt;&lt; s1.capacity() &lt;&lt; endl; //實際用了多少 cout &lt;&lt; \"s1.size()\" &lt;&lt; s1.size() &lt;&lt; endl; //s1的記憶體位址 cout &lt;&lt; \"s1記憶體位址 = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; cout &lt;&lt; \"----------------------------\" &lt;&lt; endl; //記憶體擴展 //25個字元(Hello 5字元*5遍) s1 = \"HelloHelloHelloHelloHello\"; //印出string cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; //容量 cout &lt;&lt; \"s1.capacity() = \" &lt;&lt; s1.capacity() &lt;&lt; endl; //實際用了多少 cout &lt;&lt; \"s1.size()\" &lt;&lt; s1.size() &lt;&lt; endl; //s1的記憶體位址 cout &lt;&lt; \"s1記憶體位址 = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; return 0; } s1 = s1.capacity() = 22 s1.size()0 s1記憶體位址 = 0x7ff7bfeff451 ---------------------------- s1 = HelloHelloHelloHelloHello s1.capacity() = 47 s1.size()25 s1記憶體位址 = 0x600000c00120 從執行結果可以看出 capacity(最大容量)呈倍數成長，從22變成47。 記憶位址不同，從0x7ff7bfeff451變成0x600000c00120 建立一個容量是47的記憶體空間，把s1的值從容量22的記憶體空間搬到容量47的記憶體空間，搬完後把容量22的記憶體空間進行記憶體釋放，所以記憶體位址才會不同。 string建構子為c字串 語法 建構子參數為c字串 string(const char *s) 呼叫建構子 方式1 string s2(\"Hello world!\"); 方式2 建構子參數只有一個，可使用指派運算子 string s3 = \"Hello World!\"; 完整程式碼 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; int main() { // 方式1 string s2(\"Hello world!\"); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; // 方式2 string s3 = \"Hello World!\"; cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl; } s2 = Hello world! s3 = Hello World! string拷貝函式 拷貝函式用於從另一個已經存在的string物件來初始化新物件。 語法 string(const string &amp;str) 方式1 1 2 3 4 5 6 7 8 #include &lt;iostream&gt; using namespace std; int main() { string s2(\"Hello world!\"); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; string s3 = s2; cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl; } s2 = Hello world! s3 = Hello world! 方式2 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hello world s2 size = 11 string assign operator=() 物件已經存在的情況下，將一個新值賦給該物件，會啟動assign operator=() 1 2 string s3; s3 = \"Hello World!\"; 建構子參數為c字串與n個字元 n小於c字串的長度 目的 從c字串的位址開始複製n個字元，建立字串。 語法 參數1為c字串 數數2為複製n個字元 string(const char *s,size_t n); 完整程式碼 1 2 3 4 5 6 7 int main() { //從c字串的位址開始複製5個字元，建立字串 string s(\"hello world\", 5); cout &lt;&lt; \"s = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"size = \" &lt;&lt; s.size() &lt;&lt; endl; return 0; } s = hello size = 5 n大於c字串的長度 從c字串的位址開始複製100個字元，建立字串。 從執行結果可以發現，並不會遇到\\0結尾字元而停止複製，s物件的實際大小也是20字元。 1 2 3 4 5 6 7 int main() { //從c字串的位址開始複製20個字元，建立字串 string s(\"hello world\", 20); cout &lt;&lt; \"s = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"size = \" &lt;&lt; s.size() &lt;&lt; endl; return 0; } s = hello world = siz size = 20 參數為string物件與拷貝開始與結束位置 以下是string的拷貝函式，拷貝開始位置(預設從0開始)與結束位置(預設unsigned int最大值) string(const string &amp; str, size_t pos = 0, size_t n = npos) 參數1 string物件。 參數2 拷貝開始位置(預設從0開始)，可不寫。 參數3 拷貝結束位置(預設unsigned int最大值)，可不寫。 拷貝結束位置介於字元大小間 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1,0,3); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hel s2 size = 3 拷貝結束位置超出字元大小 從執行結果可以發現遇到\\0結尾字元而停止複製，size仍是11，而不是100。 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1,0,100); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hello world s2 size = 11 建立多個相同字元的string string(size_t n, char c) 參數1個數 參數2字元 1 2 3 4 5 6 int main() { string s1(100,'C'); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; \"s1 size = \" &lt;&lt; s1.size() &lt;&lt; endl; return 0; } s1 = CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC s1 size = 100 string成員函式 取得string物件記憶體大小 size_t capacity() const; 取得string物件實際使用大小 以下二者相同 size_t length() const; size_t size() const; 判斷實際使用的大小為0 若為0返回true bool empty() const; 清空字串 void clear(); 讀取string位置 使用[位置]，可以取得某個位置字元 char &amp;operator[](size_t n); 1 2 string s1 = \"Hello\"; cout &lt;&lt; \"s1[1] = \" &lt;&lt; s1[1] &lt;&lt; endl; s1[1] = e 取得string物件存放字串的記憶體位址 (void*)印出16進制的位址 &amp;是取得物件的位址 以下是取得string物件中動態分配記憶體空間存放字串的位址 const char *c_str() const; const char *data() const; 1 2 3 4 5 6 7 8 9 int main() { string s1 = \"Hello\"; //取得string物件的記憶體位址 cout &lt;&lt; \"s1 &amp; address = \" &lt;&lt; &amp;s1 &lt;&lt; endl; //取得string物件中動態分配記憶體空間存放字串的位址 cout &lt;&lt; \"s1 c_str address = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; cout &lt;&lt; \"s1 data address = \" &lt;&lt; (void*)s1.data() &lt;&lt; endl; return 0; } s1 &amp; address = 0x7ff7bfeff450 s1 c_str address = 0x7ff7bfeff451 s1 data address = 0x7ff7bfeff451 字串連接 string &amp;operator+=(const string &amp;str); 1 2 3 4 5 6 int main() { string s1 = \"Hello\"; s1+=\" world\"; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello world string &amp;append(const char *s); 1 2 3 4 5 6 int main() { string s1 = \"Hello\"; s1.append(\" world\"); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello world string &amp;append(const string &amp;str); 1 2 3 4 5 6 7 int main() { string s1 = \"Hello\"; string s2 = \" world\"; s1.append(s2); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello world 字串截取 string substr(size_t pos = 0,size_t n = npos) const; 1 2 3 4 5 int main() { string s1 = \"Hello\"; cout &lt;&lt; \"s1 = \" &lt;&lt; s1.substr(1,3) &lt;&lt; endl; return 0; } s1 = ell 字串比較 bool operator==(const string &amp;str1,const string &amp;str2) const; 1 2 3 4 5 6 int main() { string s1 = \"Hello\"; string s2 = \"world\"; cout &lt;&lt; \"compare result = \" &lt;&lt; (s1 == s2) &lt;&lt; endl; return 0; } 其它更多成員函式"
  },"/pages/c/class/temp_obj/": {
    "title": "臨時物件temporary object",
    "keywords": "",
    "url": "/pages/c/class/temp_obj/",
    "body": "Prerequisites: 關閉RVO 拷貝函式 operator=() 匿名物件 把RVO關閉後，才能進行以下的範例。 傳回臨時物件 傳回臨時物件1 以下語法會觸發拷貝函式 Student()返回的臨時 Student 物件再次被拷貝給 s1 Student s1 = Student(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student s1 = Student(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; //離開主程式針對s1呼叫解構子 } 建構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件2 函式傳回值是臨時物件會呼叫拷貝函式。 以下程式碼會呼叫二次拷貝函式。 第一個拷貝操作：在 return Student(); 創建的臨時 Student 物件被拷貝一次，以便返回到 main 函數。這觸發了第一次拷貝建構子呼叫。 第二個拷貝操作：從 getStudent() 返回的臨時 Student 物件再次被拷貝給 s1，這會觸發第二次拷貝建構子的呼叫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; class Student { public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; cout &lt;&lt; \"address = \" &lt;&lt; this &lt;&lt; endl; } Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student getStudent() { return Student(); } int main() { Student s1 = getStudent(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; } 沒參數建構子 address = 0x7ff7bfeff410 呼叫Student(const Student &amp;s)拷貝函式 解構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件3 函式傳回值是臨時物件會呼叫拷貝函式。 以下程式碼會呼叫二次拷貝函式。 第一個拷貝操作：在 return s; 創建的臨時 Student 物件被拷貝一次，以便返回到 main 函數。這觸發了第一次拷貝建構子呼叫。 第二個拷貝操作：從 func() 返回的臨時 Student 物件再次被拷貝給 s1，這會觸發第二次拷貝建構子的呼叫。 1 2 3 4 5 Student func() { Student s; return s;//呼叫拷貝函式 //離開函式，針對物件s呼叫解構子 } 以下的程式碼回傳臨時物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student func() { Student s;//呼叫建構子 cout &lt;&lt; \"函式物件記憶體位址 = \" &lt;&lt; &amp;s &lt;&lt; endl; return s;//呼叫拷貝函式 //離開函式，針對物件s呼叫解構子 } int main() { Student s1 = func(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; //離開主程式針對s1呼叫解構子 } 建構子 函式物件記憶體位址 = 0x7ff7bfeff410 呼叫Student(const Student &amp;s)拷貝函式 解構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件4 因為student是已經存在的物件，因此會呼叫指派運算子=operator() Student student; 這行程式碼創建了一個 Student 類別的實例，並呼叫了預設建構子。此時 student 變數已經存在。 student = Student(); 這行程式碼產生了一個新的臨時 Student 對象，然後將它賦值給已有的 student 對象。這樣的操作會呼叫指派運算子（operator=），而不是拷貝建構子，因為 student 已經存在，不需要創建新的物件。 1 2 3 4 5 int main() { Student student; student = Student(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student student; student = Student(); return 0; } 建構子 建構子 呼叫Student operator=指派運算子 解構子 解構子 建立臨時物件 在成員函式或其它有參數的建構子呼叫參數為空建構子，只是建立臨時物件，然後很快的又被記憶體釋放。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"建立臨時物件\" &lt;&lt; endl; Student(); cout &lt;&lt; \"結束臨時物件\" &lt;&lt; endl; } }; int main() { Student s1; s1.print(); return 0; //離開主程式針對s1呼叫解構子 } 建構子 建立臨時物件 建構子 解構子 結束臨時物件 解構子"
  },"/pages/c/editor/rvo/": {
    "title": "關閉RVO",
    "keywords": "",
    "url": "/pages/c/editor/rvo/",
    "body": "什麼是RVO 「返回值優化」（Return Value Optimization, RVO）或「拷貝省略」技術。 Student student = Student(); 這行程式碼的作用是使用「臨時物件」（temporary object）初始化 student。但有以下幾個重點： 臨時物件的優化（Return Value Optimization, RVO）：在這段程式碼中，編譯器通常會應用「返回值優化」（RVO）或「拷貝省略」技術，這樣一來，它會直接在 student 的記憶體位置構建物件，而不是先創建一個臨時的 Student 物件然後再拷貝給 student。因此在實際運行中，不會產生臨時物件，而是直接將 Student() 產生的結果構建到 student 中。 不是指派記憶體位址：這段程式碼不是把臨時物件的記憶體位址「指派」給 student。它其實是構建了一個新的 Student 物件並用來初始化 student。而且，RVO 技術使得這個過程中不會額外創建臨時物件。 簡化的初始化語法：Student student = Student(); 的效果其實等同於 Student student; 或 Student student{};，因為它們都是呼叫 Student 類別的預設建構子來初始化 student。 Student student = Student(); 這段程式碼在大多數情況下不會創建額外的臨時物件。編譯器會透過優化直接將 Student() 建構的物件初始化到 student，而不是先生成臨時物件再指派給 student。 在沒有優化的情況下，Student() 會生成一個臨時 Student 對象，並在返回時拷貝或移動到主程式中的變數 student 中。 但在現代編譯器中，大多數情況下會應用「返回值優化」（Return Value Optimization, RVO）或「拷貝省略」技術。這樣一來，編譯器會直接在 student 變數所在的記憶體位置構建返回的 Student 物件，避免產生額外的臨時物件。這樣的優化讓返回的過程更加高效。 xcode關閉RVO 調降成c++11 關閉RVO 關閉RVO指令 g++ main.cpp -o main -fno-elide-constructors"
  },"/pages/c/stl/iterator/": {
    "title": "iterator疊代器",
    "keywords": "",
    "url": "/pages/c/stl/iterator/",
    "body": "Prerequisites: 記憶體間隔計算 函式模板 begin與end的位置 iterator.begin指向容器的首元素記憶體位址 iterator.end指向容器最後一個元素的下一個位址 圖中容器有10個元素，begin指向首元素，end指向最後一個元素的下一個位址 find模板 find在array寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 /** 參數1 arr陣列位址 參數2 陣列大小 參數3 要尋找的值 */ int* _find(int* arr, int n, const int&amp; val) { for(int i = 0; i &lt; n; i++) { //若找到與val相同的值，返回元素的記憶體位址 if(arr[i] == val) return &amp;arr[i]; } //找不到就返回null return nullptr; } 改寫成begin與end的參數 1 2 3 4 5 6 7 8 9 10 11 12 13 /** 參數1 開始位址 參數2 最後位址的下一個位址 參數3 要尋找的值 */ int* _find(int* begin, int* end, const int&amp; val) { for(int* iter = begin; iter != end; iter++) { //若找到與val相同的值，返回元素的記憶體位址 if(*iter == val) return iter; } //找不到就返回null return nullptr; } 支援鏈結串列的find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Node { int item; Node* next; }; /** 參數1 開始位址 參數2 最後位址的下一個位址 參數3 要尋找的值 */ Node* _find(Node* head, Node* end, const Node&amp; val) { for(Node* iter = head; iter != end; iter = iter-&gt;next) { //若找到與val相同的值，返回元素的記憶體位址 if(iter-&gt;item == val.item) return iter; } //找不到就返回null return nullptr; } find模板程式碼 C++的容器(vector,list,string…)都有iterator，iterator包含begin與end，可以把不同容器的begin與end作為模板參數傳入模板函式。 注意!!模板中，找不到元素是返回end位址，而不是nullptr。 1 2 3 4 5 6 7 8 template&lt;typename T1,typename T2&gt; T1 _find(T1 begin, T1 end, const T2 &amp;val) { for(T1 iter = begin; iter != end; iter ++) { if(*iter == val) return iter; } //注意!!如果找不到就返回end位址 return end; } vector使用find模板 vector資料結構是陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T1,typename T2&gt; T1 _find(T1 begin, T1 end, const T2 &amp;val) { for(T1 iter = begin; iter != end; iter ++) { if(*iter == val) return iter; } return end; } int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; vector&lt;int&gt;::iterator it1 = _find(v.begin(), v.end(), 4); if (it1 != v.end()) cout &lt;&lt; \"找到\" &lt;&lt; *it1 &lt;&lt; endl; else cout &lt;&lt; \"找不到\" &lt;&lt; endl; return 0; } 找到4 list使用find模板 list的資料結構是鏈結串列。 要記得include #include &lt;list&gt; 1 2 3 4 5 6 7 8 9 int main() { list&lt;int&gt; list1 = {1, 2, 3, 4, 5}; list&lt;int&gt;::iterator it1 = _find(list1.begin(), list1.end(), 4); if (it1 != list1.end()) cout &lt;&lt; \"找到\" &lt;&lt; *it1 &lt;&lt; endl; else cout &lt;&lt; \"找不到\" &lt;&lt; endl; return 0; } 找到4 疊代器支持的運算子 疊代器模擬了C++中的指針，可以有++運算，用*（取值運算子，deference）或-&gt;來訪問容器中的元素。 *iter 取值運算子 iter-&gt;member 讀取當前物件的成員變數 iter=iter1 指派給另一個疊代器 iter==iter1 疊代器相等比較 iter!=iter1 疊代器不等比較 疊代器分類 正向疊代器 只能++，不能–，只能往前遍歷，不能往後遍歷。例如資料結構為單向鏈結串列的list不能向後遍歷。 宣告疊代器語法 可修改元素的疊代器 容器&lt;元素類型&gt;::iterator 疊代器名; vector&lt;int&gt;::iterator it; 不可修改元素的疊代器 容器&lt;元素類型&gt;::const_iterator 疊代器名; vector&lt;int&gt;::const_iterator it; begin() iterator移到容器第0個元素，回傳的iterator可以修改值 1 iterator begin(); 回傳的iterator不可以修改值(有const) 1 const_iterator begin(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; using namespace std; int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; //把iterator移到容器第0個元素 vector&lt;int&gt;::iterator it = v.begin(); //將第0個元素的值改成7 *it = 7; //iterator移到下一個元素 it++; //將第1個元素的值改為8 *it = 8; for (vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } return 0; } 7, 8, 3, 4, 5, cbegin() 類型可以簡寫成auto，不可以修改值(有const) const_iterator cbegin(); 原本的程式碼 1 2 3 4 for (vector&lt;int&gt;::const_iterator it = v.cbegin(); it != v.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; 類型簡寫成auto 1 2 3 4 for (auto it = v.cbegin(); it != v.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; end() 取得最後一個元素的下一個記憶體位址 可以修改值 1 iterator end(); 不可以修改值 1 const_iterator end(); 類型可簡寫成auto，不可以修改值 1 const_iterator cend(); 雙向疊代器 疊代器可以往前遍歷，也可以向後遍歷，支援–(向後遍歷)的功能。擁有正向疊代器與反向疊代器的功能，正向疊代器上述已提過。 reverse_iterator反向疊代器 圖中容器有10個元素，rbegin指向「最後一個元素」的「起始位址」，rend指向「第 0 個元素的前一個位置」。 可修改元素的疊代器 1 2 容器&lt;元素類型&gt;::reverse_iterator 疊代器名; vector&lt;int&gt;::reverse_iterator it; 不可修改元素的疊代器 1 2 容器&lt;元素類型&gt;::const_reverse_iterator 疊代器名; vector&lt;int&gt;::const_reverse_iterator it; rbegin() 返回的是一個反向迭代器，指向容器最後一個元素的位址。這樣可以從容器的最後一個元素開始反向遍歷。 可以修改iterator指向位址的值。 1 reverse_iterator rbegin(); crbegin() 類型可以簡化成auto，不可以修改iterator指向位址的值。 1 const_reverse_iterator crbegin(); rend() 返回的則是指向容器「第 0 個元素的前一個位置」的反向迭代器，因此，它表示反向迭代器的結束位置。 可以修改iterator指向位址的值。 1 reverse_iterator rend(); crend() 返回的則是指向容器「第 0 個元素的前一個位置」的反向迭代器，因此，它表示反向迭代器的結束位置。 類型可以簡化成auto，不可以修改iterator指向位址的值。 1 const_reverse_iterator crend(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; //把iterator移到容器第0個元素 vector&lt;int&gt;::reverse_iterator it = v.rbegin(); //將最後一個元素的值改成7 *it = 7; //iterator移到倒數第2個元素 it++; //將倒數第2個元素的值改為8 *it = 8; //正向疊代器 cout &lt;&lt; \"正向 : \" &lt;&lt; endl; for (auto it = v.cbegin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; //反向疊代器 cout &lt;&lt; \"反向 : \" &lt;&lt; endl; for (auto it = v.crbegin(); it != v.crend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 正向 : 1, 2, 3, 8, 7, 反向 : 7, 8, 3, 2, 1, 用疊代器建立容器 vector 建構子 參數為其它容器的疊代器建立vector容器 二個參數為iterator的建構子 vector(Iterator first, Iterator last) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //使用v1的cbegin()與v1的cend()，建立v2容器 vector&lt;int&gt; v2(v1.cbegin() + 2, v1.cend() - 3); //遍歷v2容器所有元素 for (auto it = v2.cbegin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 3, 4, 5, 6, 7, 指派 void assign(Iterator first, Iterator last); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //使用v1的cbegin()與v1的cend()，建立v2容器 vector&lt;int&gt; v2; v2.assign(v1.cbegin() + 2, v1.cend() - 3); //遍歷v2容器所有元素 for (auto it = v2.cbegin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 3, 4, 5, 6, 7, 插入 返回的位址是插入元素的位址 iterator insert(iterator pos, const T&amp; value); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //在2的位址後面插入一個12 //返回插入元素的位址(指標) auto iter = v1.insert(v1.begin() + 2, 12); cout &lt;&lt; \"插入的元素是:\" &lt;&lt; *iter &lt;&lt; endl; for (auto it = v1.cbegin(); it != v1.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 插入的元素是:12 1 2 12 3 4 5 6 7 8 9 10 插入區間元素 iterator insert(iterator pos, iterator first, iterator last); 參數1:要插入的位址 參數2:其它容器的開始位址 參數3:其它容器的結束位址 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; vector&lt;int&gt; v2 = {11, 22, 33, 44, 55, 66, 77, 88, 99, 100}; //在2的位址後面插入一個v2區間 //返回第一個插入元素的位址(指標) auto iter = v1.insert(v1.begin() + 2, v2.begin() + 1, v2.end() - 3); cout &lt;&lt; \"第一個插入的元素是:\" &lt;&lt; *iter &lt;&lt; endl; for (auto it = v1.cbegin(); it != v1.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 第一個插入的元素是:22 1 2 22 33 44 55 66 77 3 4 5 6 7 8 9 10 疊代器失靈 若在迴圈中有新增、插入、刪除的動作會導致疊代器無法移動到下一個位址。 resize(),reserve(),assign(),push_back(),pop_back(),insert(),erase()導致疊代器指向陣列元素或鏈結串列的節點位址移動，會導致iterator無法作用。 vector刪除元素 參數都是iterator，重點返回的是刪除元素的下一個位址。 iterator erase(iterator pos); iterator erase(iterator first, iterator last); 以下的程式碼會造成疊代器失靈 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for (vector&lt;int&gt;::const_iterator it = v1.begin(); it != v1.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; v1.erase(it); } return 0; } 1 3 5 7 9 解決疊代器失靈 把it++移除，it指向刪除元素後會返回下一個位址，疊代器就可以正常運作。 1 2 3 4 5 6 7 8 int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for (vector&lt;int&gt;::const_iterator it = v1.begin(); it != v1.end(); ) { cout &lt;&lt; *it &lt;&lt; \" \"; it = v1.erase(it); } return 0; } 1 2 3 4 5 6 7 8 9 10"
  },"/pages/c/basic/format/": {
    "title": "程式碼格式",
    "keywords": "",
    "url": "/pages/c/basic/format/",
    "body": "以下內容參考google C++風格指南 命名 命名規則 名稱要有描述性；少用縮寫。 1 2 3 4 int price_count_reader; // 無縮寫。 int num_errors; // \"num\" 是很常見的縮寫字。 int num_dns_connections; // 大部份的人都知道 \"DNS\" 是啥。 int lstm_size; // \"LSTM\" 在機器學習領域中是個常用的縮寫字。 1 2 3 4 5 6 7 int n; // 毫無意義。 int nerr; // 模稜兩可的縮寫。 int n_comp_conns; // 模稜兩可的縮寫。 int wgc_connections; // 只有貴團隊知道是啥意思。 int pc_reader; // \"pc\" 有太多可能的解釋了。 int cstmr_id; // 有刪減若干字母。 FooBarRequestInfo fbri; // 根本不是個單字。 檔案名 檔案名稱要全部小寫，可以包含底線 () 或減號 (-)。依專案慣例來選用。如果專案沒有一致的用法，用 「」 比較好。 變數名 一般變數、函式參數 變數（包括函式的參數）以及資料成員的名稱一律小寫，單字之間用底線連接。類別的資料成員結尾處多加一個底線（但結構的資料成員不用），如：a_local_variable、a_ struct_data_member、a_class_data_member_。 1 2 string table_name; // 可 - 用底線。 string tablename; // 可 - 全小寫。 類別成員 小寫變數名，最後加底線_ 1 2 3 4 5 6 7 class TableInfo { ... private: string table_name_; // 可 - 字尾加底線。 string tablename_; // 可。 static Pool&lt;TableInfo&gt;* pool_; // 可。 }; 結構成員 不用最後加底線_ 1 2 3 4 struct UrlTableProperties { string name; int num_entries; } 命名空間 命名空間用小寫字母命名，避免使用不當的縮寫。 把檔案名稱加到名稱中，可以有效建立獨一無二的名稱（例如 在 frobber.h 中，就用 websearch::index::frobber_internal 這樣的名稱）。 函式名 一般函式使用大小寫混合。 一般來說，函式名稱的第一個字母要大寫，其後每個單字的字首字母均大寫。 1 2 3 AddTableEntry() DeleteUrl() OpenFileOrDie() 類別、型別 字首大寫，不能有底線，採駝峰式命名 型別名稱的每個單字首字母均大寫，不使用底線：MyExcitingClass，MyExcitingEnum。 所有型別命名（類別、結構、型別別名、列舉，以及模板型別參數）均使用相同規則。型別名稱的第一個字母要大寫，其後每個單字的字首字母均大寫，例如: 1 2 3 4 5 6 7 8 9 10 11 12 13 // 類別和結構 class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap; // using 別名 using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;; // 列舉 enum UrlTableErrors { ... 常數 宣告時加上 constexpr 或 const，且整個程式執行時間內都不會改變的變數，命名時需以 「k」 開頭，後面的字母以混合大小寫的方式書寫。在少數大寫字無法將單字隔開的情況下，可以使用底線當作區隔。舉例來說： 1 2 const int kDaysInAWeek = 7; const int kAndroid8_0_0 = 24; // Android 8.0.0 列舉 列舉若是常數，按照常數標準。 列舉若是型別，按照類別標準。 註解 使用 // 或 /* */，只要一致就好。 註解必須清晰易讀且平舖直述。 類別 類別前都要附帶一份註解(除非看到類別名就知道是在做什麼)，描述類別的功能和用法，了解如何使用、何時該使用這個類別。 類別運作以及實作方法的註解應該要放在類別成員函式的實作之處 函式 函式前加上用法說明的註解，除非看到函式名就知道是在做什麼，就可以不用寫。 變數名 通常變數名本身足以很好說明變數的用途。某些情況下，還是需要額外的註解說明。 全域變數 所有的全域變數都要註解說明含義、用途，以及為什麼要將它宣告為全域變數 TODO TODO 註解要使用全大寫的字串 TODO 在那些臨時的、短期的解決方案，或已經夠好但仍不完美的程式碼旁加上 TODO 註解 1 2 3 // TODO(kl@gmail.com): Use a \"*\" here for concatenation operator. // TODO(Zeke) change this to use relations. // TODO(bug 12345): remove the \"Last visitors\" feature 棄用deprecation 若已被棄用，用全大寫 DEPRECATED 註解標記。 空白 每一句程式碼內縮2個空白 以下程式碼vector前面留有2個空白 1 2 3 4 int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; return 0; } xcode把tab改為2個空白 if 注意在所有情況下，if 和左括號間都有個空格。如果有大括號的話，右括號和左大括號之間也要有個空格： 正確方式 1 if (condition) { // 可 - IF 後面和 { 前面都留有適當的空格。 錯誤方式 1 2 3 if(condition) // 差 - IF 後面沒空格。 if (condition){ // 差 - { 前面沒空格。 if(condition){ // 前面兩項錯誤犯好犯滿。 if,else if,else 正確方式 1 2 3 4 5 6 7 if (condition) { // 括號裡沒空格。 ... // 2 空格縮排。 } else if (...) { // else 與 if 的右大括號放在同一行。 ... } else { ... } 簡短的條件語句可以寫在同一行，如果這樣可讀性比較高的話。只有當句子簡單並且沒有使用 else 子句時可以使用： 1 2 if (x == kFoo) return new Foo(); if (x == kBar) return new Bar(); 如果述句中有 else 的話就禁止如此使用： 1 2 3 // 不可以這樣子 - 當 ELSE 子句存在時，IF 陳述句卻只擠在同一行 if (x) DoThis(); else DoThat(); if大括號 一般來說，單行語句不需要使用大括號，如果你喜歡用也沒問題 1 2 3 4 5 6 if (condition) DoSomething(); // 2 空格縮排。 if (condition) { DoSomething(); // 2 空格縮排。 } 但如果整個述句中某個 if-else 的區塊使用了大括號的話，其它區塊也必須使用： 1 2 3 4 5 6 7 8 9 10 11 12 // 不可以這樣子 - IF 有大括號 ELSE 卻沒有。 if (condition) { foo; } else bar; // 不可以這樣子 - ELSE 有大括號 IF 卻沒有。 if (condition) foo; else { bar; } 正確方式 1 2 3 4 5 6 // 只要其中一個區塊用了大括號，兩個區塊都要用。 if (condition) { foo; } else { bar; } for for () {….}中的內縮仍是2個空白 1 2 3 4 5 6 7 8 int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; for (auto it = v.crbegin(); it != v.crend(); it++) { //內縮2個空白 cout &lt;&lt; *it &lt;&lt; \", \"; } return 0; } for與圓括號()之間要有空白，圓括號()與左大括號{要有空白，並且左大括號{與for在同一行 1 2 for () { } 圓括號()與裡面的條件，開頭與結尾是沒空白 1 2 for (int i = 0; i &lt; 10; i++) { } 分號;後留一個空白，=等於的前後留空白，&lt;的前後留空白，++前後不用留空白 1 for (int i = 0; i &lt; 10; i++) 分號後一定要有空格。 1 2 // 迴圈中，分號後一定要有空格。 for (auto it = first; ; ) 引數 大括號{…}裡面的值，逗號(,)右側留一個空白，左側不留空白，大括號{…}中，前後不留空白。 變數名v與類型留一個空白 =等於，前後留空白 1 vector&lt;int&gt; v = {1, 2, 3, 4, 5}; 類別 public前面留一個空白 public裡面的述敘與public是一個空白 1 2 3 4 5 6 7 8 class callbackObj { public://與最邊緣留1個空白 //與public留1個空白，與最邊緣留2個空白 void print(const string&amp; msg) { //與void留2個空白，與最邊緣留4個空白 cout &lt;&lt; msg &lt;&lt; endl; } }; 模板 template與尖括號&lt;，中間有空白 1 template &lt;typename T, typename U&gt; 註解空白與對齊 2個斜線後面加一個空白 1 2 // Process \"element\" unless it was already processed. auto iter = std::find(v.begin(), v.end(), element); 行尾註解空2個空白 在行尾加兩格空隔後，加上2個斜線，再加一個空白後，開始註解 1 2 if (.....) return; // Error already logged. 註解對齊 1 2 3 4 5 6 7 8 9 10 11 DoSomething(); // 把註解放這裡才能和下一行對齊。 DoSomethingElseThatIsLonger(); // 註解和程式碼之間要有兩個空格。 { // 當開啟一個新的作用域時，可以只放一個空隔， // 這樣接下來的註解和程式碼都可以和前面那行對齊。 DoSomethingElse(); // 一般來說行註解前面都需要兩個空隔。 } std::vector&lt;string&gt; list{ // 在條列初始化中，用來說明下一個元素的註解... \"First item\", // .. 必須要妥善對齊。 \"Second item\"}; 斷行 除非必要，不要使用斷行。尤其是：兩個函式定義之間的斷行不要超過 2 行，函式起始處不要是斷行，最後一行也不要是斷行，其餘地方也儘量少用斷行。在一個程式碼區塊中，斷行像是文章中的段落：在視覺上將兩個想法區隔開來。 函式內開頭或結尾的斷行對可讀性沒有幫助。 在多重 if-else 區塊裡加斷行對可讀性可能有些幫助。 在註解前面加空行通常可以增加可讀性，引入一段新的註解等於在介紹一個新想法的開始，此時加上空行可以清楚地表示這段註解是在說明接下來的程式碼，而非延續前面的行為。 initializer_list 若是你不得不斷行，放在下一行，加上4格的縮排 1 2 3 4 5 6 7 8 9 10 11 12 // 若是你不得不斷行。 SomeFunction( {\"assume a zero-length name before {\"}, some_other_function_parameter); SomeType variable{ \"This is too long to fit all in one line\"}; MyType m = { // 你也可以在 { 前斷行。 superlongvariablename1, superlongvariablename2, {short, interior, list}, {interiorwrappinglist, interiorwrappinglist2}};"
  },"/pages/c/class/anonymous_obj/": {
    "title": "匿名物件",
    "keywords": "",
    "url": "/pages/c/class/anonymous_obj/",
    "body": "匿名物件，也就是沒有名字(變數名)的物件，建立後馬上銷毀，沒有生命周期。 語法 類別名() 建立匿名物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { //建立匿名物件 Student(); return 0; } 建構子 解構子 返回匿名物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student createStudent() { return Student(); } int main() { createStudent(); return 0; } 建構子 解構子 解構子 匿名物件指派給變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student s1 = Student(); return 0; } 建構子 解構子 解構子 匿名物件也是臨時物件 匿名物件是直接由程式碼直接生成。 1 2 3 4 5 int main() { //由程式碼直接建立物件 Student(); return 0; } 若函式返回的是匿名物件，編譯器自動管理其生命週期，就會變成臨時物件，所謂的臨時物件就是由編譯器生成。 通過函式回傳的物件(包含匿名物件或不是匿名物件)，全是臨時物件。 initializer_list匿名物件 initializer list 以下程式碼由initializer_list方式建立物件 {8, \"cici\"} 與 {3, \"john\"} 為匿名物件，因為他們沒有名字。 1 2 3 4 5 6 7 8 #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { map&lt;int, string&gt; m; m.insert({ {8, \"cici\"}, {3, \"john\"} }); return 0; }"
  },"/pages/c/template/findif_template/": {
    "title": "find_if模板",
    "keywords": "",
    "url": "/pages/c/template/findif_template/",
    "body": "Prerequisites: continue 物件函式 foreach模板 find_if()函式 若在容器中找到元素就返回疊代器iterator，找不到就返回容器最後一個元素的下一個位址 增加搜尋值與傳回值 將foreach模板的程式拿來修改，增加搜尋值T3的模板參數與T1的模板回傳值。 找到欲搜尋的值T3，就返回iterator 找不到就回傳容器最後一個元素的下一個位址。 1 2 3 4 5 6 7 template&lt;typename T1, typename T2, typename T3&gt; T1 findif(const T1 first, const T1 last, T2 callback, T3 search_val) { for (auto it = first; it != last; it++) { if(callback(*it, search_val) == true) return it; } return last; } 修改callback函式指標模板 增加搜尋值T的模板參數，回傳bool，判斷msg是否與要搜尋的值相同。 1 2 3 4 template&lt;typename T&gt; bool callback(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } 修改callback物件函式模板 增加搜尋值T的模板參數，回傳bool，判斷msg是否與要搜尋的值相同。 1 2 3 4 5 6 7 template&lt;typename T&gt; class Callback { public: bool operator()(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } }; 呼叫findif模板 傳回值為iterator，把iterator指標的值印出來。 1 2 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(), \"03\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; bool callback(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } template&lt;typename T&gt; class Callback { public: bool operator()(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } }; template&lt;typename T1, typename T2, typename T3&gt; T1 findif(const T1 first, const T1 last, T2 callback, T3 search_val) { for (auto it = first; it != last; it++) { if(callback(*it, search_val) == true) return it; } return last; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; // 物件函式 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(), \"03\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; // 函式指標 vector&lt;string&gt;::iterator it2 = findif(v2.begin(), v2.end(), callback&lt;string&gt;, \"05\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it2 &lt;&lt; endl; return 0; } 找到 = 03 找到 = 05 物件函式，使用建構子，搜尋值作為參數 建構子初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; class Callback { public: T search_val; Callback(const T&amp; search_val):search_val(search_val) {} bool operator()(const T&amp; msg) { return msg == search_val; } }; template&lt;typename T1, typename T2&gt; T1 findif(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { if(callback(*it) == true) return it; } return last; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; // 物件函式 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(\"03\")); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; return 0; } 技巧: 在迴圈中，若函式()返回true，就continue回到迴圈的條件判斷式，返回false就繼續執行接下來的程式碼。 之後sort模板會利用到這個技巧。"
  },"/pages/c/template/foreach_template/": {
    "title": "foreach模板",
    "keywords": "",
    "url": "/pages/c/template/foreach_template/",
    "body": "Prerequisites: iterator 傳統思維 試想一下，寫一個foreach函式，傳統思維會將容器(vector,list)位址傳入函式，如以下的寫法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;&amp; v) { for (auto it = v.cbegin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1); return 0; } 1 2 3 4 5 6 7 8 9 10 疊代器思維 STL容器(vector,list)皆有iterator疊代器，把iterator疊代器作為參數代入函式，有以上相同效果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;::iterator first, const vector&lt;int&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 函式多載(overload) 若容器元素的類型為string，就要多寫一個支援容器元素為string的函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;::iterator first, const vector&lt;int&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void foreach(const vector&lt;string&gt;::iterator first, const vector&lt;string&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); vector&lt;string&gt; v2 = {\"首頁\", \"客服\", \"購物車\", \"個人資訊\"}; foreach(v2.begin(), v2.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 首頁 客服 購物車 個人資訊 模板取代函式多載 類型全換成T，不管T是什麼類型，只要支持函式中的assign(=)、!=、it++、*it的功能就可以使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; void foreach(const T first, const T last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); vector&lt;string&gt; v2 = {\"首頁\", \"客服\", \"購物車\", \"個人資訊\"}; foreach(v2.begin(), v2.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 首頁 客服 購物車 個人資訊 callback模板函式(回調/回呼函式) 在模板函式中要做的事由callback函式去完成。 callback函式為函式指標 寫一個callback函式支援容器元素為string，並印出元素的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void callback(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; void foreach(const T first, const T last, void(*callback)(const string&amp;)) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; foreach(v2.begin(), v2.end(), callback); return 0; } 01 02 03 04 05 callback函式為物件函式 物件函式 匿名物件 呼叫函式物件，使用匿名物件方式呼叫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Callback { public: void operator()(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; template&lt;typename T&gt; void foreach(const T first, const T last, Callback callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; foreach(v2.begin(), v2.end(), Callback()); // 呼叫函式物件，使用匿名物件方式呼叫 return 0; } 01 02 03 04 05 模板取代函式指標與物件函式 從以上二個程式碼，可以發現呼叫函式指標與物件函式的方式都一樣，因此把foreach函式中的Callback參數化為模板，參數可以為函式指標或物件函式。 callback(*it); 把callback類型化為模板T2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void callback(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } class Callback { public: void operator()(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; //把callback類型化為模板T2 template&lt;typename T1, typename T2&gt; void foreach(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 foreach(v2.begin(), v2.end(), Callback()); //函式指標 foreach(v2.begin(), v2.end(), callback); return 0; } callback函式參數模板化 以上函式的缺點在於函式參數固定是string&amp;的類型。 將callback函式與類別的參數模板化 函式模板 1 2 3 4 template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } 類別模板 1 2 3 4 5 6 7 template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; 呼叫函式模板、類別模板 呼叫模板函式與模板類別，記得加上&lt;型別&gt; 1 2 3 4 //物件函式 foreach(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 foreach(v2.begin(), v2.end(), callback&lt;string&gt;); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; template&lt;typename T1, typename T2&gt; void foreach(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 foreach(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 foreach(v2.begin(), v2.end(), callback&lt;string&gt;); return 0; } 01 02 03 04 05 01 02 03 04 05 使用官方for_each 以上已實作官方for_each模板函式，以下為使用官方for_each include 1 #include &lt;algorithm&gt; for_each 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 for_each(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 for_each(v2.begin(), v2.end(), callback&lt;string&gt;); return 0; } 01 02 03 04 05 01 02 03 04 05"
  },"/pages/c/template/bsort_template/": {
    "title": "氣泡排序模板",
    "keywords": "",
    "url": "/pages/c/template/bsort_template/",
    "body": "Prerequisites: 氣泡排序 由小到大排序 回傳true的條件，左邊的值小於右邊的值 1 2 3 4 template&lt;typename T&gt; bool CompareASC(const T&amp; left, const T&amp; right) { return left &lt; right; } 由大到小排序 回傳true的條件，左邊的值大於右邊的值 1 2 3 4 template&lt;typename T&gt; bool CompareDESC(const T&amp; left, const T&amp; right) { return left &gt; right; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; bool CompareASC(const T&amp; left, const T&amp; right) { return left &lt; right; } template&lt;typename T&gt; bool CompareDESC(const T&amp; left, const T&amp; right) { return left &gt; right; } template&lt;typename T, typename Compare&gt; void BubbleSort(const T first, const T last, Compare comp) { while (true) { // 判斷容器所有容器原本就排好 bool bswap = false; // it指標移到第一個元素位址 for (auto it = first; ; ) { // 左邊的元素 auto left = it; // 移到下個位址 it++; // 右邊的元素 auto right = it; // right是最後一個元素的下一個位址 if (right == last) break; // 若二個元素已經是排好就回到for判斷條件 if (comp(*left, *right) == true) continue; // 交換 auto temp = *right; *right = *left; *left = temp; // 代表有交換 bswap = true; } // 若沒有交換代表全部元素都已經是有序的。 if (bswap == false) break; } } int main() { vector&lt;string&gt; v = {\"05\", \"04\", \"03\", \"02\", \"01\"}; BubbleSort(v.begin(), v.end(), CompareASC&lt;string&gt;); for (auto val: v) { cout &lt;&lt; val &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 01 02 03 04 05 改用物件函式 效果與函式指標是相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; class CompareASC { public: bool operator()(const T&amp; left, const T&amp; right) { return left &lt; right; } }; template&lt;typename T&gt; class CompareDESC { public: bool operator()(const T&amp; left, const T&amp; right) { return left &gt; right; } }; template&lt;typename T, typename Compare&gt; void BubbleSort(const T first, const T last, Compare comp) { while (true) { // 判斷容器所有容器原本就排好 bool bswap = false; // it指標移到第一個元素位址 for (auto it = first; ; ) { // 左邊的元素 auto left = it; // 移到下個位址 it++; // 右邊的元素 auto right = it; // right是最後一個元素的下一個位址 if (right == last) break; // 若二個元素已經是排好就回到for判斷條件 if (comp(*left, *right) == true) continue; // 交換 auto temp = *right; *right = *left; *left = temp; // 代表有交換 bswap = true; } // 若沒有交換代表全部元素都已經是有序的。 if (bswap == false) break; } } int main() { vector&lt;string&gt; v = {\"05\", \"04\", \"03\", \"02\", \"01\"}; BubbleSort(v.begin(), v.end(), CompareASC&lt;string&gt;()); for (auto val: v) { cout &lt;&lt; val &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 05 04 03 02 01"
  },"/pages/c/editor/openssh_server/": {
    "title": "安裝openssh-server",
    "keywords": "",
    "url": "/pages/c/editor/openssh_server/",
    "body": "openssh-server 以下環境 本機MAC Ubuntu 24.04 VMware Fusion 以下為Ubuntu虛擬機終端機設定 更新package list $ sudo apt update 安裝openssh-server $ sudo apt install openssh-server 按下y 啟動ssh $ sudo systemctl status ssh 離開按q $ sudo systemctl enable --now ssh 本機連ssh $ ssh localhost 按下y 重新啟動ssh $ sudo systemctl restart ssh 安裝c++ $ sudo apt install gcc $ sudo apt install g++ $ sudo apt install build-essential $ gcc --version $ g++ --version 安裝man page $ sudo apt install manpages-dev manpages-posix-dev $ man strcpy 按q退出 若跟user command有衝突的函式，請在函式名前輸入3 $ man 3 sleep 1是user command 3是Standard C library"
  },"/pages/c/template/function_class_template/": {
    "title": "類別中函式模板",
    "keywords": "",
    "url": "/pages/c/template/function_class_template/",
    "body": "建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; class MyArray{ public: template &lt;typename T&gt; // 建構子的參數為模板類型參數T MyArray(T element) { cout &lt;&lt; \"element : \" &lt;&lt; element &lt;&lt; endl; } }; int main() { // 引數為整數 MyArray myArray1(10); // 引數為字串 MyArray myArray2(\"abcdefg\"); // 引數為double MyArray myArray3(1000.555); return 0; } element : 10 element : abcdefg element : 1000.55 成員函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; using namespace std; class MyArray{ public: template &lt;typename T&gt; MyArray(T element) { cout &lt;&lt; \"element : \" &lt;&lt; element &lt;&lt; endl; } // 建立成員函式模板printMsg，回傳值為void，參數為模板類型參數T template &lt;typename T&gt; void printMsg(T msg) { cout &lt;&lt; \"msg : \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { MyArray myArray1(10); // 引數為字串 myArray1.printMsg(\"Data Not Found!\"); // 引數為數字 myArray1.printMsg(404); // 引數為字元 myArray1.printMsg('$'); return 0; } element : 10 msg : Data Not Found! msg : 404 msg : $"
  },"/pages/c/template/function_template/": {
    "title": "函式模板",
    "keywords": "",
    "url": "/pages/c/template/function_template/",
    "body": "Prerequisites: 引數 函式多載 函式模板是編譯器根據引數，自動產生出對映的參數函式代碼。 模板定義 由template關鍵字定義模板，模板參數型別定義由關鍵字typename開始，可以命名任何您想要的參數型別，但依照慣例，最常使用單一大寫字母，T 是模板參數型別，若有多個模板參數型別可以T1,T2,T3…作為命名。 template &lt;typename T1, typename T2, typename T3&gt; 1 2 3 4 5 6 7 8 9 // template為模板定義 // typename為模板型別定義 // T 是模板參數 template &lt;typename T&gt; // 函式模板的名稱為FuncName // 回傳值void，T為模板參數型別，參數名為param void FuncName(T param) { cout &lt;&lt; \"param:\" &lt;&lt; param &lt;&lt; endl; } 函式多載 以下的Swap函式，只有參數的類型不同，屬於函式多載，其它程式碼都一模一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; using namespace std; void Swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } void Swap(double &amp;a, double &amp;b) { double temp = a; a = b; b = temp; } void Swap(string &amp;a, string &amp;b) { string temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; Swap(a,b); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; double d1 = 50.5, d2 = 20.3; Swap(d1,d2); cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; \",d2=\" &lt;&lt; d2 &lt;&lt; endl; string s1 = \"test\", s2 = \"c++\"; Swap(s1,s2); cout &lt;&lt; \"s1=\" &lt;&lt; s1 &lt;&lt; \",s2=\" &lt;&lt; s2 &lt;&lt; endl; return 0; } a=20,b=10 d1=20.3,d2=50.5 s1=c++,s2=test 引數型別替換T模板參數型別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; // 函式模板會根據引數的類型自動生成Swap(int, int)對映的代碼 Swap(a,b); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; double d1 = 50.5, d2 = 20.3; // 函式模板會根據引數的類型自動生成Swap(double, double)對映的代碼 Swap(d1,d2); cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; \",d2=\" &lt;&lt; d2 &lt;&lt; endl; string s1 = \"test\", s2 = \"c++\"; // 函式模板會根據引數的類型自動生成Swap(string, string)對映的代碼 Swap(s1,s2); cout &lt;&lt; \"s1=\" &lt;&lt; s1 &lt;&lt; \",s2=\" &lt;&lt; s2 &lt;&lt; endl; return 0; } a=20,b=10 d1=20.3,d2=50.5 s1=c++,s2=test 自訂類型 如果不想讓編譯器自動推導類型，想自訂類型，呼叫函式後面加上，就會產生此類型的函式。 1 2 3 4 5 6 7 8 9 10 11 12 template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; // 自訂類型 Swap&lt;int&gt;(a,b); return 0; } 傳回值為模板 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; T Add(T a, T b) { return a + b; } int main() { int a = 10; int b = 20; int result = Add(a,b); cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } 強制轉型 強制把引數轉成欲轉換的型別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; T Add(T a, T b) { return a + b; } int main() { int a = 10; // 整數類型char char c = 'A'; // 強制轉型char-&gt;int int result = Add&lt;int&gt;(a,c); cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } result = 75 模板多載 可以有多個相同函式模板名稱，但模板型別參數的數量不同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; template &lt;typename T1&gt; void insertLog(T1 no) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; endl; } template &lt;typename T1,typename T2&gt; void insertLog(T1 no,T2 msg) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; \",msg:\" &lt;&lt; msg &lt;&lt; endl; } template &lt;typename T1,typename T2&gt; void insertLog(T1 no,T2 msg,int seq) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; \",msg:\" &lt;&lt; msg &lt;&lt; \",seq:\" &lt;&lt; seq &lt;&lt; endl; } int main() { insertLog(10); insertLog(11, \"insert something...\"); insertLog(12, \"insert something...\", 1); return 0; } no:10 no:11,msg:insert something... no:12,msg:insert something...,seq:1 引數的類型需要一致 二個引數類型不同會產生會產生”No matching function for call to ‘Swap’“的error。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10; double b = 20.5; Swap(a,b); return 0; } 沒有參數的模板 呼叫函式模板Swap，必須自訂類型，否則編譯器無法知道要產生什麼類型的函式模板，錯誤訊息\"No matching function for call to 'Swap'\" 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; // Swap模板函式沒有模板類型參數。 void Swap() { } int main() { Swap&lt;int&gt;(); return 0; }"
  },"/pages/c/template/special_template/": {
    "title": "模板特製化",
    "keywords": "",
    "url": "/pages/c/template/special_template/",
    "body": "模板特製化template specialization 語法 template &lt;&gt; 由template後面再加上尖括號&lt;&gt;，告知編譯器以下模板是有指定類型，參數類型都有符合才會執行。 函式模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; // 模板名為getMax，回傳類型為模板形參T，參數名為a與b template &lt;typename T&gt; T getMax(T a, T b) { if(a &gt; b) return a; // 若a比較大就把a傳回去 else return b; // 若b比較大就把b傳回去。 } int main() { int a = 10; int b = 20; int max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; return 0; } max = 20 模板特製化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include &lt;iostream&gt; using namespace std; class Student { public: void setScore(int score) { this-&gt;score = score; } int getScore() { return this-&gt;score; } private: int score; }; // 函式模板 template &lt;typename T&gt; T getMax(T a, T b) { if(a &gt; b) return a; else return b; } // 模板特製化 template &lt;&gt; Student getMax&lt;Student&gt;(Student s1, Student s2) { if(s1.getScore() &gt; s2.getScore()) return s1; else return s2; } int main() { int a = 10; int b = 20; int max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; Student s1; s1.setScore(78); cout &lt;&lt; \"s1 score = \" &lt;&lt; s1.getScore() &lt;&lt; endl; Student s2; s2.setScore(50); cout &lt;&lt; \"s2 score = \" &lt;&lt; s2.getScore() &lt;&lt; endl; // 呼叫模板特製化 Student rtn = getMax(s1, s2); cout &lt;&lt; \"score = \" &lt;&lt; rtn.getScore()&lt;&lt; endl; return 0; } max = 20 s1 score = 78 s2 score = 50 score = 78 模板函式與特製化函式回傳值與參數要一致 若模板函式是使用T，特製化模板也要使用類型。若模板函式是使用T&amp;，特製化模板則是使用類型參考&amp;。否則若不一致，例:模板函式用T，特製化模板用類型參考&amp;，將會產生錯誤error: no function template matches function template specialization。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { public: void setScore(int score) { this-&gt;score = score; } int getScore() { return this-&gt;score; } private: int score; }; template &lt;typename T&gt; T&amp; getMax(T&amp; a, T&amp; b) { if(a &gt; b) return a; else return b; } template &lt;&gt; Student&amp; getMax&lt;Student&gt;(Student&amp; s1, Student&amp; s2) { if(s1.getScore() &gt; s2.getScore()) return s1; else return s2; } int main() { int a = 10; int b = 20; int&amp; max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; Student s1; s1.setScore(78); cout &lt;&lt; \"s1 score = \" &lt;&lt; s1.getScore() &lt;&lt; endl; Student s2; s2.setScore(50); cout &lt;&lt; \"s2 score = \" &lt;&lt; s2.getScore() &lt;&lt; endl; // 呼叫模板特製化 Student&amp; ref = getMax(s1, s2); cout &lt;&lt; \"score = \" &lt;&lt; ref.getScore()&lt;&lt; endl; return 0; } max = 20 s1 score = 78 s2 score = 50 score = 78"
  },"/pages/c/compile/core_dump/": {
    "title": "gdb core dump",
    "keywords": "",
    "url": "/pages/c/compile/core_dump/",
    "body": "產生memory leak的錯誤會存在core檔案。 linux預設不會產生core檔案，需修改系統參數。 查看core檔案大小語法 ulimit是限制使用者資源使用量 ulimit -a cici@cici-vm:~/test/app$ ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15194 max locked memory (kbytes, -l) 495132 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15194 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 由以上列表，可以發現core file size = 0 core file size (blocks, -c) 0 從以上列表，也可以看到stack大小 stack size (kbytes, -s) 8192 修改core檔案大小 -c是上述列表中有列出來的，-c代表的是core file size 將core file size設成無限unlimited $ ulimit -c unlimited $ ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) unlimited data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15194 max locked memory (kbytes, -l) 495132 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15194 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited core dump 建立一個cpp檔案core_test1.cpp 以下func2()中，試圖給ptr指標設值，但ptr指標是nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 *ptr = 97; // 97代表a } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下指令 $ g++ -o demo04 core_test1.cpp -g $ ./demo04 程式記憶體區段錯誤 (核心已傾印 $ ls 若是沒有產生\"core\"開頭的檔案，把core存放路徑改為目前執行程式的目錄下 echo \"core\" | sudo tee /proc/sys/kernel/core_pattern 再次執行程式 $ ./demo04 $ ls 檢查是否已經產生\"core\"開頭的檔案 debug 輸入以下指令，core是先前步驟的檔名，每個人的檔名不同，都是以core開頭 gdb ./demo04 core 黃色是要輸入的字母 Enable debuginfod for this session? (y or [n]) y Debuginfod has been enabled. To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit. Downloading separate debug info for system-supplied DSO at 0x7fffff0d2000 --Type &lt; RET &gt; for more, q to quit, c to continue without paging--c [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Core was generated by `./demo04'. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x00005a0b1c65d321 in func2 (msg=...) at core_test1.cpp:8 8 *ptr = 97; // 97代表a (gdb) 8 *ptr = 97; // 97代表a 會告知你錯誤的地方在第8行 bt 輸入bt，會列出呼叫函式的堆疊(call stack) 由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2()，最上層的是func2() (gdb) bt #0 0x00005a0b1c65d321 in func2 (msg=\"test\") at core_test1.cpp:8 #1 0x00005a0b1c65d365 in func1 (msg=\"test\") at core_test1.cpp:11 #2 0x00005a0b1c65d3d4 in main () at core_test1.cpp:14 q 輸入q就會離開gdb 顯示錯誤的行號在c++函式庫 修改程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 strcpy(ptr, msg.c_str()); } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下指令 $ g++ -o demo04 core_test1.cpp -g $ ./demo04 程式記憶體區段錯誤 (核心已傾印) $ gdb ./demo04 core 以下的錯誤無法看出來是什麼問題 #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 使用bt可以看出錯誤 (gdb) bt #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 #1 0x00005ad51c60a37f in func2 (msg=\"test\") at core_test1.cpp:8 #2 0x00005ad51c60a3c0 in func1 (msg=\"test\") at core_test1.cpp:11 #3 0x00005ad51c60a42f in main () at core_test1.cpp:14 其它方式查看core dump 安裝coredump sudo apt install systemd-coredump 執行並core dump 進入coredumpctl，使用q可離開 $ g++ -o demo03 core_test.cpp -g $ ./demo03 程式記憶體區段錯誤 (核心已傾印 $ coredumpctl TIME PID UID GID SIG COREFILE EXE &gt; Thu 2024-12-05 15:17:05 CST 25260 1000 1000 SIGSEGV present /home/cici/test/app/demo03&gt; Thu 2024-12-05 15:26:49 CST 25335 1000 1000 SIGSEGV present /home/cici/test/app/demo03&gt; $ coredumpctl debug demo03 bt 以下用黃色表示會要使用者輸入的部分與發生錯誤的行數。 bt可以列出呼叫函式的堆疊(call stack)，由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2()，最上層的是func2() 以下，使用q可離開 Enable debuginfod for this session? (y or [n]) y Debuginfod has been enabled. To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit. [Thread debugging using libthread_db enabled] --Type &lt; RET &gt; for more, q to quit, c to continue without paging--c Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Core was generated by `./demo03'. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x00005893c17b7321 in func2 (msg=...) at core_test.cpp:8 8 *ptr = 97; // 97代表a (gdb) bt #0 0x00005893c17b7321 in func2 (msg=\"test\") at core_test.cpp:8 #1 0x00005893c17b7365 in func1 (msg=\"test\") at core_test.cpp:11 #2 0x00005893c17b73d4 in main () at core_test.cpp:14 若發生錯誤的是在c++的函式庫中，怎麼查找錯誤？ 將程式碼 *ptr = 97; 修改成c++函式strcpy strcpy(ptr, msg.c_str()); 修改程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 strcpy(ptr, msg.c_str()); } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 重新編譯 $ g++ -o demo03 core_test.cpp -g $ ./demo03 程式記憶體區段錯誤 (核心已傾印 $ coredumpctl $ coredumpctl debug demo03 使用bt，就可以查找出來發生錯誤的函式，main()呼叫func1，func1呼叫func2，func2呼叫strcpy #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 warning: 127 ../sysdeps/x86_64/multiarch/strcpy-avx2.S: 沒有此一檔案或目錄 (gdb) bt #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 #1 0x000055a25facd37f in func2 (msg=\"test\") at core_test.cpp:8 #2 0x000055a25facd3c0 in func1 (msg=\"test\") at core_test.cpp:11 #3 0x000055a25facd42f in main () at core_test.cpp:14 行數請比對如下 1 #include 2 #include 3 using namespace std; 4 void func2(const string msg) { 5 // 宣告nullptr的ptr指標 6 char * ptr = nullptr; 7 // 試圖給nullptr設值 8 strcpy(ptr, msg.c_str()); 9 } 10 void func1(const string msg) { 11 func2(msg); 12 } 13 int main() { 14 func1(\"test\"); 15 return 0; 16 } &lt;/pre&gt;"
  },"/pages/c/compile/gdb/": {
    "title": "gdb",
    "keywords": "",
    "url": "/pages/c/compile/gdb/",
    "body": "何謂gdb 可以在linux系統下，debug c++程式碼，也可以debug正在運作的c++程式碼。 安裝gdb sudo apt install gdb gdb除錯 欲除錯的程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; void printParam(const char *param1, const char *param2, const char *param3) { cout &lt;&lt; \"姓名1 = \" &lt;&lt; param1 &lt;&lt; endl; cout &lt;&lt; \"姓名2 = \" &lt;&lt; param2 &lt;&lt; endl; cout &lt;&lt; \"姓名3 = \" &lt;&lt; param3 &lt;&lt; endl; } int main(int argc, char *argv[], char *envp[]) { cout &lt;&lt; \"參數有\" &lt;&lt; argc &lt;&lt; \"個\" &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) { cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; } if (argc != 4) { cout &lt;&lt; \"使用方法:./demo 參數1 參數2 參數3 \\n\"; return -1; } printParam(argv[1], argv[2], argv[3]); cout &lt;&lt; \"程式即將結束\" &lt;&lt; endl; return 0; } 編譯語法 編譯執行檔時要加上-g，產生原始檔而不是只有機器語言指令。 g++ -o demo02 print_param.cpp -g 執行gdb gdb demo02 離開gdb 按q q 設置參數 語法 set args 參數1 參數2 參數3 參數N (gdb) set args cici bill mary vi看行數 法1:移到想斷點的行數，按 ctl + g 法2: 按esc，輸入 :set number 關閉number :set nonumber 設置斷點break point b 行數 (gdb) b 11 我在以下這行加上斷點 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; 運行程式 程式運行到斷點的位置會停下來，若沒有斷點，程式會直接運行到結束。 r 執行 執行當前程式碼語句，不會進入函式內部。 n Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) n 參數0 = /home/cici/test/app/demo02 執行下一行 再按一次n，就會執行下一行，不會進入函式內部，注意！最左側11與10是目前執行的行數 Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) n 參數0 = /home/cici/test/app/demo02 10 for (int i = 0; i &lt; argc; i++) { (gdb) n Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) 印出變數 p 變數 Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) p i $1 = 1 設置變數(法1) 離開gdb，重新執行gdb，設置參數set args cici bill mary，並把斷點設成11行，按下r，移到斷點 p 變數=值 因參數有4個(demo02,cici,bill,mary) 假設把i值直接設成3，再執行一次n(移到第10行)，再執行一次n(移到13行)，就會跳離迴圈，中間直接略過i=1,i=2 (gdb) p i=3 Breakpoint 1, main (argc=1, argv=0x7fffffffe348, envp=0x7fffffffe358) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) p i $1 = 0 (gdb) p i=3 $2 = 3 (gdb) n 參數3 = PWD=/home/cici/test/app 10 for (int i = 0; i &lt; argc; i++) { (gdb) n 13 if (argc != 4) { 設置變數(法2) set var i=3 與 p i=3 是相同效果 直接運行到下一個斷點 輸入c會直接跳到下個斷點，若沒有下一個斷點，程式會直接運行到結束。 c 以下重新gdb，並設置斷點b 13與b 17，r是運行(會運行到第1個斷點13行)，再按c運行到下一個斷點(17行)。 cici@cici-vm:~/test/app$ g++ -o demo02 print_param.cpp -g cici@cici-vm:~/test/app$ gdb demo02 (gdb) set args cici bill mary (gdb) b 13 Breakpoint 1 at 0x1350: file print_param.cpp, line 13. (gdb) b 17 Breakpoint 2 at 0x1376: file print_param.cpp, line 17. (gdb) r 參數有4個 參數0 = /home/cici/test/app/demo02 參數1 = cici 參數2 = bill 參數3 = mary Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:13 13 if (argc != 4) { (gdb) c Continuing. Breakpoint 2, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:17 17 printParam(argv[1], argv[2], argv[3]); (gdb) 進入函式 17行剛好是呼叫函式printParam()的程式碼，按s，進入函式 s Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:13 13 if (argc != 4) { (gdb) c Continuing. Breakpoint 2, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:17 17 printParam(argv[1], argv[2], argv[3]); (gdb) s printParam (param1=0x7fffffffe5d5 \"cici\", param2=0x7fffffffe5da \"bill\", param3=0x7fffffffe5df \"mary\") at print_param.cpp:4 4 cout &lt;&lt; \"姓名1 = \" &lt;&lt; param1 &lt;&lt; endl; (gdb) p param1 $1 = 0x7fffffffe5d5 \"cici\" (gdb) p param2 $2 = 0x7fffffffe5da \"bill\" (gdb) c Continuing. 姓名1 = cici 姓名2 = bill 姓名3 = mary 程式即將結束 [Inferior 1 (process 22467) exited normally] (gdb)"
  },"/pages/c/compile/makefile/": {
    "title": "makefile",
    "keywords": "",
    "url": "/pages/c/compile/makefile/",
    "body": "編譯c++ 原理 將原始檔案變成執行檔，以下把這個過程分為二個步驟。 首先將個別原始檔(.cpp)編譯成個別目的檔(object file)，目的檔的內容是可被電腦執行的機器語言指令。 第二步便是鏈結(linking)，將上一步好幾個原始檔案編譯完後有多個目的檔，由於原始檔案中會用到c++的函式庫指令，如std::cout，將多個目的檔與函式庫機器語言指令全部鏈結一起，就形成可執行檔。 gcc與g++分別 gcc編譯c g++編譯c++ g++語法 g++ -o 執行檔名 原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 常用選項: -o 設定\"執行檔名\" -std=c++11 支援c++11 -c 只編譯，不鏈結 產生執行檔 建立檔案 $ vi hello.cpp 將以下的內容貼上 1 2 3 4 5 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; } 產生執行檔 $ g++ -o demo hello.cpp 執行 $ ./demo Hello world! 沒有-o 執行檔名 沒有-o 執行檔名，會產生a.out的檔案 $ g++ hello.cpp $ ls a.out 使用2個cpp產生執行檔 $ vi public.h 1 2 #include &lt;iostream&gt; void func(); $ vi public.cpp 1 2 3 4 5 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"call func()\" &lt;&lt; endl; } $ vi hello.cpp 1 2 3 4 5 6 7 #include &lt;iostream&gt; #include \"public.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); } $ g++ -o demo hello.cpp public.cpp $ ./demo Hello world! call func() 靜態庫 將cpp檔案整理成一個程式庫，產生執行檔可以指定庫名.a，就不用寫很多原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 多個process(行程)用到同一個靜態庫中的函式或類別，每個process(行程)拷貝一份，多個process(行程)就有多個拷貝。 靜態庫是二進制檔案(機器語言指令) 主程式在鏈結時會把靜態庫加入，產生執行檔。 若某個靜態庫更新了，所有使用它的程式都需要重新編譯。 語法 g++ -c -o lib庫名.a 原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp -c -c 只編譯，不鏈結 lib庫名.a .a代表靜態庫 lib是固定 庫名可以自由變換 檔案放置路徑 cici@cici-vm:~/test$ tree . ├── app │   └── hello.cpp └── tools ├── public.cpp └── public.h 3 directories, 3 files 將以下檔案依上方目錄結構放置。 public.h 1 2 3 4 5 6 #include &lt;iostream&gt; void func(); class Student { public: void print(); }; public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"call func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"msg....\" &lt;&lt; endl; } hello.cpp 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; #include \"../tools/public.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); } 產生靜態庫 進入tools目錄 $ cd tools 產生靜態庫 $ g++ -c -o libpublic.a public.cpp 使用靜態庫 法1 回到上層 $ cd.. 產生demo01執行檔，原始檔案有libpublic.a的靜態庫 $ g++ -o demo01 app/hello.cpp tools/libpublic.a 執行 $ ./demo01 法2 語法 g++ -o 執行檔名 原始檔案1.cpp -L 靜態庫目錄位址 -l 庫名 $ g++ -o demo01 app/hello.cpp -L tools -l public 動態庫 語法 g++ -fPIC -shared -o lib庫名.so 來源檔案1.cpp -fPIC -shared 這二句代表製作動態庫 -o 產生檔案 lib庫名.so lib與.so是固定寫法，庫名可以自已取名。 $ cd tools $ g++ -fPIC -shared -o libpublic.so public.cpp 使用動態庫 將cpp檔案整理成一個庫，產生執行檔可以指定庫名.so，就不用寫很多原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 動態庫是二進制檔案 多個procee用到同一個動態庫中的函式或類別，在記憶體中只有一份，多個process共享相同程式碼，也稱共享庫，因為只有一份程式碼，不會占用記憶體。 主程式在執行時，才把動態庫程式碼載入到記憶體。 優點，動態庫更新，有用到動態庫的程式不用重新編譯，只需要更新動態庫。 動態庫與靜態庫同時存在，優先使用動態庫。 法1 $ g++ -o demo01 app/hello.cpp tools/libpublic.so $ ./demo01 法2 先增加LD_LIBRARY_PATH環境變數，設定放置動態庫的目錄 $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/cici/test/tools $ g++ -o demo01 app/hello.cpp -L tools -l public $ ./demo01 -L 動態庫目錄位址 -l 庫名 模擬更新動態庫 將public.cpp的程式碼更新。 增加update的字 public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"update all func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"update msg....\" &lt;&lt; endl; } 重新建立動態庫 $ cd tools $ g++ -fPIC -shared -o libpublic.so public.cpp 執行主程式 $ ./demo01 Hello world! update call func() update msg.... 總結 以上的過程，都不必重新編譯主程式。 makefile 建立makefile $ cd tools $ vi makefile 產生靜態庫,動態庫 用空格分開 all: libpublic.a libpublic.so 換行用\\ 注意！第二行是用tab，不是空格 all: libpublic.a \\ libpublic.so 動態庫或靜態庫中的cpp更新，重新編譯 編譯靜態庫libpublic.a，需要依賴public.h和public.cpp 若public.h或public.cpp更新，需要重新編譯 注意！第二行是用tab，不是空格 libpublic.a:public.h public.cpp g++ -c -o libpublic.a public.cpp 編譯動態庫libpublic.so，需要依賴public.h和public.cpp 若public.h或public.cpp更新，需要重新編譯 注意！第二行是用tab，不是空格 libpublic.so:public.h public.cpp g++ -fPIC -shared -o libpublic.so public.cpp clean刪除編譯完的檔案 clean: rm -f libpublic.a libpublic.so 使用makefile 清理 語法 make clean cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h cici@cici-vm:~/test/tools$ make clean rm -f libpublic.a libpublic.so cici@cici-vm:~/test/tools$ ls makefile public.cpp public.h 產生靜態庫,動態庫 語法 make cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp g++ -fPIC -shared -o libpublic.so public.cpp cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h 若沒有修改任何.cpp或.h，再次make不會進行動作 cici@cici-vm:~/test/tools$ make make: 對「all」無需做任何事。 修改public.cpp 將\"update\"改成\"update2\" public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"update2 all func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"update2 msg....\" &lt;&lt; endl; } 若有更改.cpp，make就會重新編譯 cici@cici-vm:~/test/tools$ vi public.cpp cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp g++ -fPIC -shared -o libpublic.so public.cpp 若刪除靜態檔，再make，就會重新產生靜態檔 cici@cici-vm:~/test/tools$ rm libpublic.a cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h 多動態庫使用 建立myapi庫 回到最上層目錄，建立api的目錄，並在api目錄中，建立myapi.h $ mkdir api $ cd api $ vi myapi.h 路徑如下 cici@cici-vm:~/test$ tree . ├── api │   ├── makefile │   ├── myapi.cpp │   └── myapi.h ├── app │   ├── demo01 │   ├── hello │   ├── hello.cpp │   └── makefile ├── makefile └── tools ├── libpublic.a ├── libpublic.so ├── makefile ├── public.cpp └── public.h myapi.h 1 2 3 4 5 6 #include &lt;iostream&gt; void func1(); class Teacher { public: void print(); }; myapi.cpp 1 2 3 4 5 6 7 8 #include \"myapi.h\" using namespace std; void func1() { cout &lt;&lt; \"call func1()\" &lt;&lt; endl; } void Teacher::print() { cout &lt;&lt; \"teacher ... msg ...\" &lt;&lt; endl; } 進入api目錄，並建立makefile 1 2 3 4 5 6 7 all:libmyapi.a libmyapi.so libmyapi.a:myapi.h myapi.cpp g++ -c -o libmyapi.a myapi.cpp libmyapi.so:myapi.h myapi.cpp g++ -fPIC -shared -o libmyapi.so myapi.cpp clean: rm -f libmyapi.a libmyapi.so cici@cici-vm:~/test/api$ make g++ -c -o libmyapi.a myapi.cpp g++ -fPIC -shared -o libmyapi.so myapi.cpp app目錄下的hello.cpp修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include \"../tools/public.h\" #include \"../api/myapi.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); //新增修改 func1(); Teacher teacher; teacher.print(); } api目錄加到LD_LIBRARY_PATH $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/cici/test/api 回到test目錄下，執行以下語句，設定myapi動態檔放置的目錄(-L)與庫名(-l) $ g++ -o demo01 app/hello.cpp -L tools -l public -L api -l myapi $ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... -I 修改hello.cpp的include public.h與myapi.h路徑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include \"public.h\" #include \"myapi.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); //新增修改 func1(); Teacher teacher; teacher.print(); } 使用-I，指定.h檔案的路徑 cici@cici-vm:~/test$ g++ -o demo01 app/hello.cpp -L tools -l public -L api -l myapi -I /home/cici/test/tools -I /home/cici/test/api cici@cici-vm:~/test$ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... 為demo01寫makefile 路徑如下 cici@cici-vm:~/test$ tree . ├── api │   ├── libmyapi.a │   ├── libmyapi.so │   ├── makefile │   ├── myapi.cpp │   └── myapi.h ├── app │   ├── demo01 │   ├── hello │   ├── hello.cpp │   └── makefile ├── makefile └── tools ├── libpublic.a ├── libpublic.so ├── makefile ├── public.cpp └── public.h 在/home/cici/test目錄下撰寫的makefile: 1 2 3 4 5 all:demo01 demo01:app/hello.cpp g++ -o demo01 app/hello.cpp -L /home/cici/test/tools -l public -L /home/cici/test/api -l myapi -I /home/cici/test/tools -I /home/cici/test/api clean: rm -f demo01 在/home/cici/test/app目錄下撰寫的makefile: 1 2 3 4 5 all:demo01 demo01:hello.cpp g++ -o demo01 hello.cpp -L /home/cici/test/tools -l public -L /home/cici/test/api -l myapi -I /home/cici/test/tools -I /home/cici/test/api clean: rm -f demo01 多個檔案 在makefile定義變數 INCLUDEDIR=-I /home/cici/test/tools -I /home/cici/test/api LIBDIR=-L /home/cici/test/tools -L /home/cici/test/api 使用變數 $(變數) 多個檔案 1 2 3 4 5 6 7 8 9 10 11 INCLUDEDIR=-I /home/cici/test/tools -I /home/cici/test/api LIBDIR=-L /home/cici/test/tools -L /home/cici/test/api all:demo01 demo02 demo03 demo01:hello.cpp g++ -o demo01 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi demo02:hello.cpp g++ -o demo02 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi demo03:hello.cpp g++ -o demo03 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi clean: rm -f demo01 demo02 demo03 $ vi makefile $ make g++ -o demo02 hello.cpp -I /home/cici/test/tools -I /home/cici/test/api -L /home/cici/test/tools -L /home/cici/test/api -l public -l myapi g++ -o demo03 hello.cpp -I /home/cici/test/tools -I /home/cici/test/api -L /home/cici/test/tools -L /home/cici/test/api -l public -l myapi $ ls demo01 demo02 demo03 hello hello.cpp makefile $ vi makefile $ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ ./demo02 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ ./demo03 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ make clean rm -f demo01 demo02 demo03 $ ls hello hello.cpp makefile"
  },"/pages/c/c11/init_list/": {
    "title": "初始化initializer list",
    "keywords": "",
    "url": "/pages/c/c11/init_list/",
    "body": "Prerequisites: 維基介紹 初始化串列 整數 c++11用大括號{},等於號可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; int main() { int a = 10; // c++98,用圓括號() int b = (10); int c(10); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //c++11用大括號{},等於號可省略 int d = {10}; int e{10}; cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; \"e = \" &lt;&lt; e &lt;&lt; endl; return 0; } a = 10 b = 10 c = 10 d = 10 e = 10 浮點數 1 2 double f{1.12}; cout &lt;&lt; \"f = \" &lt;&lt; f &lt;&lt; endl; f = 1.12 陣列 1 2 3 4 5 //陣列 int arr1[5]{1, 2, 3, 4, 5}; for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 arr1[4] = 5 new動態分配記憶體位址 1 2 3 4 int *arr_p = new int[5]{11, 12, 13, 14, 15}; for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; \"arr_p[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr_p[i] &lt;&lt; endl; } arr_p[0] = 11 arr_p[1] = 12 arr_p[2] = 13 arr_p[3] = 14 arr_p[4] = 15 建立物件 c++11用大括號{},等於號可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: Student(int number, string name):number(number),name(name){} private: int number; // 學號 string name; }; int main() { // c98 Student s1(10122, \"Bill\"); // c11 Student s2 = {10123, \"Mary\"}; //c11 省略等於號 Student s3{10124, \"Alice\"}; return 0; } 初始化容器 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { // 把v1初始化為10個元素 vector&lt;int&gt; v1(10); // v2只有1個元素10 vector&lt;int&gt; v2{10}; // v3有3個元素，分別是11 12 13 vector&lt;int&gt; v3{11, 12, 13}; return 0; } 函式參數 可以把大括號{}間的值，作為參數傳給函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; int func1(initializer_list&lt;int&gt; init_list) { int total = 0; for (int val : init_list) { total += val; cout &lt;&lt; val &lt;&lt; \",\"; } cout &lt;&lt; endl; return total; } int main() { int total = func1({1, 2, 3, 4, 5}); cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl; return 0; } 1,2,3,4,5, total = 15 iterator initializer_list模板類別，跟容器一樣，提供begin()與end() 編譯 makefile 若在linux編譯時，需要加上-std=c++11 g++ -o c11_init c11_init.cpp -std=c++11"
  },"/pages/c/compile/gdb_attach_pid/": {
    "title": "gdb attach pid",
    "keywords": "",
    "url": "/pages/c/compile/gdb_attach_pid/",
    "body": "Debug正在運行的程式 建立測試檔案 以下檔案每一秒印出1個數字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { for (int i = 0; i &lt; 1000000; i++) { sleep(1); cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; } } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下程式 $ g++ -o demo03 core_test.cpp -g $ ./demo03 ssh 遠端登入另一個終端機 ssh cici@192.168.235.128 ps -ef 列出跟demo03有關的process id 黃色標註就是demo03的pid cici@cici-vm:~/test/app$ ps -ef |grep demo03 cici 27615 26646 0 10:01 pts/7 00:00:00 ./demo03 cici 27618 26755 0 10:02 pts/5 00:00:00 grep --color=auto demo03 sudo gdb -p 以user的身份執行以下指令 sudo gdb /home/cici/test/app/demo03 -p 27615 會發現正在運行的程式停住了，輸入q離開gdb，正在運行的程式繼續運作。 bt 列出呼叫函式的堆疊(call stack) 由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2(), func2()呼叫__sleep() (gdb) bt #0 0x0000702da76eca7a in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78 #1 0x0000702da76f9a27 in __GI___nanosleep (req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/nanosleep.c:25 #2 0x0000702da770ec63 in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55 #3 0x0000595ced2493ac in func2 (msg=\"test\") at core_test.cpp:7 #4 0x0000595ced249437 in func1 (msg=\"test\") at core_test.cpp:12 #5 0x0000595ced2494de in main () at core_test.cpp:15 set var 目前i = 282 i = 268 i = 269 i = 270 i = 271 i = 272 i = 273 i = 274 i = 275 i = 276 i = 277 i = 278 i = 279 i = 280 i = 281 i = 282 將執行時的變數修改成500，以下黃色則為要輸入的 (gdb) n 80 in ../sysdeps/unix/sysv/linux/clock_nanosleep.c (gdb) n 83 in ../sysdeps/unix/sysv/linux/clock_nanosleep.c (gdb) n __GI___nanosleep (req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/nanosleep.c:26 warning: 26 ../sysdeps/unix/sysv/linux/nanosleep.c: 沒有此一檔案或目錄 (gdb) n __sleep (seconds=0) at ../sysdeps/posix/sleep.c:62 warning: 62 ../sysdeps/posix/sleep.c: 沒有此一檔案或目錄 (gdb) n 64 in ../sysdeps/posix/sleep.c (gdb) n func2 (msg=\"test\") at core_test.cpp:8 8 cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; (gdb) set var i=500 (gdb) n 6 for (int i = 0; i &lt; 1000000; i++) { (gdb) 另一個視窗已經變成 i = 268 i = 269 i = 270 i = 271 i = 272 i = 273 i = 274 i = 275 i = 276 i = 277 i = 278 i = 279 i = 280 i = 281 i = 282 i = 500"
  },"/pages/c/stl/pair/": {
    "title": "pair",
    "keywords": "",
    "url": "/pages/c/stl/pair/",
    "body": "Prerequisites: 函式模板 initializer list pair模板與make pair模板 pair模板 1 2 3 4 5 6 7 8 9 10 template &lt;class T1, class T2&gt; struct pair { T1 first; // key T2 second; // value。 pair(); // 建構子 pair(const T1 &amp;val1,const T2 &amp;val2); // 有二個參數建構子 pair(const pair&lt;T1,T2&gt; &amp;p); // 拷貝函式 void swap(pair&lt;T1,T2&gt; &amp;p); // 交換pair }; make pair模板 匿名物件 呼叫pair的二個參數建構子，傳回pair的匿名物件 1 2 3 4 5 template &lt;class T1, class T2&gt; make_pair(const T1 &amp;first,const T2 &amp;second) { return pair&lt;T1,T2&gt;(first, second); } 使用pair 呼叫2個參數的建構子 呼叫2個參數的建構子 1 2 3 4 5 6 7 #include &lt;iostream&gt; using namespace std; int main() { pair&lt;int,string&gt; p1(1,\"cici\"); cout &lt;&lt; \"p1 first = \" &lt;&lt; p1.first &lt;&lt; \", second = \" &lt;&lt; p1.second &lt;&lt; endl; return 0; } p1 first = 1, second = cici 使用initializer list { 2, “Bill” } 為匿名物件。 1 2 pair&lt;int,string&gt; p2 = {2, \"Bill\"}; cout &lt;&lt; \"p2 first = \" &lt;&lt; p2.first &lt;&lt; \", second = \" &lt;&lt; p2.second &lt;&lt; endl; p2 first = 2, second = Bill 呼叫拷貝函式 先建立匿名物件，呼叫2個參數建構子 再用拷貝函式，把匿名物件設給p3 1 2 pair&lt;int,string&gt; p3 = pair&lt;int,string&gt;(3, \"Jeff\"); cout &lt;&lt; \"p3 first = \" &lt;&lt; p3.first &lt;&lt; \", second = \" &lt;&lt; p3.second &lt;&lt; endl; p3 first = 3, second = Jeff makepair 以下是c++14運行的結果 先建立匿名物件，呼叫2個參數建構子 再用拷貝函式，把匿名物件拷貝到回傳值 再用拷貝函式，把回傳值拷貝到p4 1 2 pair&lt;int,string&gt; p4 = make_pair&lt;int,string&gt;(4, \"Ann\"); cout &lt;&lt; \"p4 first = \" &lt;&lt; p4.first &lt;&lt; \", second = \" &lt;&lt; p4.second &lt;&lt; endl; p4 first = 4, second = Ann"
  },"/pages/c/stl/map/": {
    "title": "map",
    "keywords": "",
    "url": "/pages/c/stl/map/",
    "body": "Prerequisites: pair initializer list iterator map介紹 include #include &lt;map&gt; map的值是pair map是以紅黑樹(AVL tree)排序，所以把map的值印出來會是以排序好的方式印出。 初始化 語法 map(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 1 2 3 4 5 6 7 8 9 10 11 12 13 // 建立空的map map&lt;int, string&gt; m1; // 使用initializer初始化值 // map(initializer_list&lt;pair&lt;K,V&gt;&gt;) map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; // 省略等於號寫法 // map&lt;int,string&gt; m2 { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; // 使用括號 // map&lt;int,string&gt; m2({ {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }); for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 使用[]印出元素 1 2 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"m2[10] = \" &lt;&lt; m2[10] &lt;&lt; endl; m2[10] = Mary 若key不存在map中，則會新增空值 1 2 3 4 5 6 7 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"m2[10] = \" &lt;&lt; m2[10] &lt;&lt; endl; cout &lt;&lt; \"m2[22] = \" &lt;&lt; m2[22] &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2[10] = Mary m2[22] = 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 22, 新增修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; // 新增 m2[5] = \"Eva\"; m2[4] = \"Iric\"; // 修改 m2[10] = \"Yoyo\"; m2[9] = \"Momo\"; cout &lt;&lt; \"修改後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 修改後 4,Iric 5,Eva 6,Ken 7,Alice 8,Juli 9,Momo 10,Yoyo 插入insert 傳回值為void 語法 void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2.insert({ {1, \"Ben\"}, {2, \"Cindy\"}, {3, \"Rita\"} }); cout &lt;&lt; \"插入後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 插入後 1,Ben 2,Cindy 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 若插入的key已存在map中，則不會插入，也不會提示錯誤 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2.insert({ {10, \"Ben\"}, {9, \"Cindy\"}, {3, \"Rita\"} }); cout &lt;&lt; \"插入後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 插入後 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 傳回值為pair 語法 pair&lt;iterator,bool&gt; insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 傳回值pair:first已插入的元素的iterator，second是插入的結果 1 2 3 4 5 6 7 8 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; auto ret = m2.insert({5, \"Julia\"}); if (ret.second == true) { cout &lt;&lt; \"成功\" &lt;&lt; \", first = \" &lt;&lt; ret.first-&gt;first &lt;&lt; \", second = \" &lt;&lt; ret.first -&gt; second &lt;&lt; endl; } else { cout &lt;&lt; \"失敗\" &lt;&lt; endl; } 成功, first = 5, second = Julia 使用emplace pair&lt;iterator,bool&gt; emplace(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 傳回值跟先前的一樣，不同的是使用emplace可以原地建構。 使用iterator建立map 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; m2.insert({ {1, \"Ben\"}, {2, \"Cindy\"}, {3, \"Rita\"} }); // 使用iterator建立map auto first = m2.begin(); first++; auto last = m2.end(); last--; map&lt;int, string&gt; m3(first, last); for (auto &amp; val:m3) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 2,Cindy 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill"
  }}

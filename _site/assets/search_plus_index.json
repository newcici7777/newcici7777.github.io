{"/pages/leetcode/240/": {
    "title": "Leetcode 240 剑指 Offer 04. 二维数组中的查找",
    "keywords": "",
    "url": "/pages/leetcode/240/",
    "body": "在一个 n * m 的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 思路 matrix每一列最右邊是最大 初始化: i代表row j代表col 一開始先把i設為第0 row j設最右邊欄位matrix[0].length - 1 用while去繞行i跟j，但要設置i與j繞行的邊界範圍 target先比最右欄，若matrix[i][最右欄]比target大，代表要把最右欄 去掉，最右欄往左移j– 若matrix[i][最右欄]比target小，代表此列的值不是搜尋範圍，移到下一個row i++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { //限制條件 if(matrix == null || matrix.length == 0 || matrix[0].length == 0) { return false; } //初始化 int row = matrix.length - 1; int col = matrix[0].length - 1; int i = 0; int j = col;//j設最右邊欄位matrix[0].length - 1 while(i &gt;= 0 &amp;&amp; i &lt;= row &amp;&amp; j &gt;= 0 &amp;&amp; j &lt;= col) { //1 //System.out.printf(\"i = %d , j = %d , num = %d \\n\", i , j, matrix[i][j] ); if(matrix[i][j] == target) { return true; } else if (target &lt; matrix[i][j]) { //2 j--; } else if (target &gt; matrix[i][j]) { //3 i++; } } return false; } }"
  },"/pages/leetcode/n01/": {
    "title": "產生N個01的組合",
    "keywords": "",
    "url": "/pages/leetcode/n01/",
    "body": "輸入n為3 產生出 000 001 010 011 100 101 110 111 這個程式的時間複雜度是 O(2^n)，因為每一個位元都有兩種可能 (0 或 1)，所以總共會產生 2^n 種不同的二進位字串。而空間複雜度是 O(n)，因為遞迴過程中每一個呼叫會創造一個新的字串，字串的最大長度為 n。因此，總共需要 O(n)的空間來存儲每個遞迴呼叫的輸入參數和產生的字串。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class GenerateBinaryNum { public static void main(String[] args) { GenerateBinaryNum ge = new GenerateBinaryNum(); ge.generate(3, \"\"); } private void generate(int n, String track) { if(n == 0) { System.out.println(track); return; } for(int i = 0; i &lt; 2; i++) { track += i; generate(n - 1, track); track = track.substring(0,track.length()-1); } } } 若要產生0-9的組合，二個數字，修改條件 ge.generate(2, “”); for(int i = 0; i &lt; 10; i++) { 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.test; public class GenerateBinaryNum { public static void main(String[] args) { GenerateBinaryNum ge = new GenerateBinaryNum(); ge.generate(2, \"\"); } private void generate(int n, String track) { if(n == 0) { System.out.println(track); return; } for(int i = 0; i &lt; 10; i++) { track += i; generate(n - 1, track); track = track.substring(0,track.length()-1); } } }"
  },"/pages/compose/template/": {
    "title": "Compose代碼模版",
    "keywords": "",
    "url": "/pages/compose/template/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != \"\")package ${PACKAGE_NAME} #end #parse(\"File Header.java\") import androidx.compose.runtime.Composable import androidx.compose.ui.tooling.preview.Preview #if (${Function_Name} == \"\" ) @Composable fun ${NAME}() { } @Preview @Composable fun ${NAME}Preview() { ${NAME}() } #end #if (${Function_Name} != \"\" ) @Composable fun ${Function_Name}() { } @Preview @Composable fun ${Function_Name}Preview() { ${Function_Name}() } #end 1 2 3 4 5 6 7 8 9 @androidx.compose.runtime.Composable fun $NAME$() { $END$ } @androidx.compose.ui.tooling.preview.Preview @androidx.compose.runtime.Composable fun $NAME$Preview() { $END$ }"
  },"/pages/leetcode/1367/": {
    "title": "1367",
    "keywords": "",
    "url": "/pages/leetcode/1367/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isSubPath(ListNode head, TreeNode root) { if(head == null) return true;//鏈表跑到null，代表整個鏈表都跑完，都有配對到 if(root == null) return false;//樹跑完，但鏈表沒跑完，代表不相同 if(isSame(head, root))//判斷鏈表與tree是不是一樣的 return true; return isSubPath(head, root.left) || isSubPath(head, root.right);//不是就比較左子樹 或 右子樹 有沒有存在跟鏈表相同的值 } private boolean isSame(ListNode head, TreeNode root) { if(head == null) return true;//鏈表跑到null，代表整個鏈表都跑完，都有配對到 if(root == null) return false;//樹跑完，但鏈表沒跑完，代表不相同 if(head.val != root.val) return false; return isSame(head.next, root.left) || isSame(head.next, root.right);//把鏈表的下一個值與左右子樹比一比 } }"
  },"/pages/leetcode/144/": {
    "title": "144 Binary Tree Preorder Traversal",
    "keywords": "",
    "url": "/pages/leetcode/144/",
    "body": "Binary Tree Preorder Traversal 遞迴寫法 終止條件，若為葉子，把結果返回 1 2 3 4 5 6 7 8 9 10 class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; res.add(root.val); res.addAll(preorderTraversal(root.left)); res.addAll(preorderTraversal(root.right)); return res; } }"
  },"/pages/leetcode/572/": {
    "title": "572 Subtree of Another Tree",
    "keywords": "",
    "url": "/pages/leetcode/572/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (root == null) { return subRoot == null; } // 判断以 root 为根的二叉树是否和 subRoot 相同 if (isSameTree(root, subRoot)) { return true; } // 去左右子树中判断是否有和 subRoot 相同的子树 return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); } public boolean isSameTree(TreeNode p, TreeNode q) { // 判断一对节点是否相同 if (p == null &amp;&amp; q == null) { return true; } if (p == null || q == null) { return false; } if (p.val != q.val) { return false; } // 判断其他节点是否相同 return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); } }"
  },"/pages/leetcode/linkedlist/": {
    "title": "MyLinkedList數據結構",
    "keywords": "",
    "url": "/pages/leetcode/linkedlist/",
    "body": "設置虛擬頭(head)尾(tail)結點，目的在於，不用去判斷頭尾是不是空 Add First 1.新增一個節點100，把prev指到head跟next指到head.next 2.head.next指到100 3.head的下一個 prev指向100 Add Last 新增200 4. Remove First要把100的節點刪掉 7 9圈起來的指標不用動它，因為沒有指標指向它，就會被垃圾回收掉 10.也可把100刪掉 RemoveLast 11 12 temp &lt;–&gt; tail Add(index, e) 13新增一個100的節點，要插入在1的位置 利用getNode(1)的方法，抓到1的節點，設為p，1的節點前面設為temp 14 把temp.next指向新節點， p.prev指向新節點。新節點的next指向p，prev指向temp Remove (index) 15 假設Remove(1)，把1的節點利用getNode(1)抓出來，把它設為p，p前面的節點是prev，後面的節點是next 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 package com.test; class ListNode{ int val; ListNode next; public ListNode(int val) { this.val = val; } } public class LinkedListSample { static void printLinkedList(ListNode head) { ListNode p = head;//指標p while(p != null) { System.out.println(p.val); p = p.next;//指標往後走 } } //把鏈表當成二元數在遍歷，二元數有left/right，鏈表有next static void printLinkedListR(ListNode head) { if(head == null) //遍歷到鏈表的尾部，就要結束，跟上面的for徝環離開的條件是一樣的p == null就離開while return; System.out.println(head.val); printLinkedListR(head.next);//指向下一個節點 } static void printArray(int[] nums) { for(int i = 0; i &lt; nums.length; i++) { System.out.println(nums[i]); } } static void printArrayR(int[] nums) { printArrayR(nums, 0); } static void printArrayR(int[] nums, int i) { if(i == nums.length) return; System.out.println(nums[i]); printArrayR(nums, i + 1);//i+1就視為下一個元素 } static ListNode addLast(ListNode head, int val) { if(head == null) return new ListNode(val); ListNode p = head;//指標p while(p.next != null) { p = p.next;//指標p不斷往後走，走到鏈表的最後一個節點 } p.next = new ListNode(val); return head; } /** * 原本:1-&gt;2-&gt;3-&gt;4-&gt;null * 遞歸流程 * 先呼叫(1)addLast(1,5) * 再呼叫(2)addLast(2,5) * 再呼叫(3)addLast(3,5) * 再呼叫(4)addLast(4,5) * (4的next為空已到鏈結的尾巴，觸發base case) * 把新節點5返回給前面接收的人(4.next) * 4.next 連結到 5，再返回4 * 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null * 4 會把自已return給3.next * 3 會把自已return給2.next * 2 會把自己return給1.next * 1 會把自己返回 * @param head * @param val * @return */ /** val加到最後一個空指標 原本:1-&gt;2-&gt;3-&gt;4-&gt;null 添加5之後:1-&gt;2-&gt;3-&gt;4-&gt;[5-&gt;null] 5接在4後面再接上一個空指標 先遞歸的走(1-&gt;2-&gt;3-&gt;4-&gt;null)到null這個位置，再考慮怎麼去插入5 addLast(head.next, int val) 遞歸的head.next就是在遞歸的往後走 當走到結尾null也就是head == null **/ static ListNode addLastR(ListNode head, int val) { if(head == null) //當走到鏈節的結尾為空，就會進來這，base case //new 出來新的ListNode(5)丟回去，讓前面的節點4來接收1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null return new ListNode(val); /**前面一個元素(4)要跟new出來的新節點接起來 前一個元素(4)的next= new出來的新節點 4.next去接新的節點5 遞歸的修改數據結構，每一個遞歸函式都有返回值，返回值得被數據結構自己去接收，遞歸調用head.next，就該由head.next去接收 **/ head.next = addLast(head.next, val); return head;//再把4返回給3.next， 3-&gt;4 3本來就連著4，再連一次 ，3再返回給2.next， 2再返回1.next } static ListNode removeLast(ListNode head) { if(head == null) return null; ListNode p = head; while(p.next.next != null) {//走到倒數倒數第二個節點 p = p.next; } p.next = null;//倒數第二個節點的下一個節點是最後一個節點，把它置為null，就刪掉了 return head; } /** * 原本:1-&gt;2-&gt;3-&gt;4-&gt;null * 遞歸流程 * * 先呼叫(1)removeLastR(1) * 再呼叫(2)removeLastR(2) * 再呼叫(3)removeLastR(3) * 再呼叫(4)removeLastR(4) * (4的next為空已到鏈結的尾巴，觸發base case) * 把null返回給前面接收的人(3.next) * 3.next = null，就把4刪掉了 * 1-&gt;2-&gt;3-&gt;null * 3 會把自已return給2.next * 2 會把自己return給1.next * 1 會把自己返回 * @param head * @param val * @return */ static ListNode removeLastR(ListNode head) { if(head.next == null) return null; //走到最後一個元素，就把自已給刪掉，怎麼刪除自己，return 一個空 //透過遞歸的方式在往後走removeLastR(head.next, int val) 遞歸的head.next就是在遞歸的往後走 //透過接收返回值就可以刪除最後一個節點 head.next = removeLastR(head.next); return head; } public static void main(String[] args) { ListNode head = null; head = addLastR(head,1); head = addLastR(head,2); head = addLastR(head,3); head = addLastR(head,4); printLinkedListR(head); } }"
  },"/pages/compose/animat_nav/": {
    "title": "AnimationNavgation",
    "keywords": "",
    "url": "/pages/compose/animat_nav/",
    "body": "首先確認匯入的package是對的 1 2 var navigation_animation_version = \"0.31.3-beta\" implementation \"com.google.accompanist:accompanist-navigation-animation:$navigation_animation_version\" 匯入的composable是com.google.accompanist.navigation.animation 其它的AnimatedNavHost/rememberAnimatedNavController也要檢查import的路徑是對的 1 2 3 import com.google.accompanist.navigation.animation.composable import com.google.accompanist.navigation.animation.AnimatedNavHost import com.google.accompanist.navigation.animation.rememberAnimatedNavController NavHostApp() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.example.project1.ui.components import android.util.Log import androidx.compose.animation.ExperimentalAnimationApi import androidx.compose.runtime.Composable import com.example.project1.ui.navigation.Destinations import com.example.project1.ui.screens.ArticleDetailScreen import com.google.accompanist.navigation.animation.composable import com.google.accompanist.navigation.animation.AnimatedNavHost import com.google.accompanist.navigation.animation.rememberAnimatedNavController import com.example.project1.ui.screens.MainFrame /** * 導航控制器 */ @OptIn(ExperimentalAnimationApi::class) @Composable fun NavHostApp() { val navController = rememberAnimatedNavController() AnimatedNavHost( navController = navController, startDestination = Destinations.HomeFrame.route ) { //HomeFrame作為起始頁 composable(Destinations.HomeFrame.route){ Log.d(\"xxxx\",\"here1\") MainFrame(onNavigateToArticle = { Log.d(\"xxxx\",\"here3\") navController.navigate(Destinations.ArticleDetail.route) }) } //文章詳細頁 composable(Destinations.ArticleDetail.route) { ArticleDetailScreen() } } } 其中startDestination指的是預設最開始的頁面 1 2 3 4 AnimatedNavHost( navController = navController, startDestination = Destinations.HomeFrame.route ) 建立HomeFrame是那個函式處理的 1 2 3 4 5 composable(Destinations.HomeFrame.route){ MainFrame(onNavigateToArticle = { navController.navigate(Destinations.ArticleDetail.route) }) } 要在MainActivity呼叫 1 NavHostApp()"
  },"/pages/compose/box/": {
    "title": "Box",
    "keywords": "",
    "url": "/pages/compose/box/",
    "body": "若沒任何組件，默認是堆疊佈局 寫在後面會把前面給疊上 box疊在起來 1 2 3 4 Box(){ Box(modifier = Modifier.size(200.dp).background(Color.Red)) //前面 Box(modifier = Modifier.size(100.dp).background(Color.Green)) //後面 } 置中 .align(Alignment.Center) 1 2 3 4 5 6 7 8 9 10 11 Box() { Box( modifier = Modifier .size(200.dp) .background(Color.Red) ) Box(modifier = Modifier .align(Alignment.Center) .size(100.dp) .background(Color.Green)) }"
  },"/pages/compose/btn/": {
    "title": "Btn",
    "keywords": "",
    "url": "/pages/compose/btn/",
    "body": "1 2 3 4 5 6 7 8 @Composable fun ButtonSample() { Button(onClick = { Log.d(\"====\", \"click button\") }, colors = ButtonDefaults.buttonColors(Color.Red)){//紅色 Text(text = \"click\")//字 } } 1 2 3 4 5 6 7 @Composable fun ButtonSample() { //文字Button TextButton(onClick = { /*TODO*/ }) { Text(text = \"test\") } } 1 2 3 4 5 6 @Composable fun ButtonSample() { OutlinedButton(onClick = { /*TODO*/ }) { Text(\"test\") } }"
  },"/pages/compose/clip/": {
    "title": "clip圓角",
    "keywords": "",
    "url": "/pages/compose/clip/",
    "body": "Clip圓角的作用區域 1 .clip(RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp))//頂端二邊有圓角 要放在 .fillMaxSize()與.background()之前 1 2 3 4 5 6 7 Column(modifier = Modifier .clip(RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp))//頂端二邊有圓角 .fillMaxSize() //填滿 .background(Color.White)//白色 ){ Text(text = \"明細\") }"
  },"/pages/compose/column/": {
    "title": "Column",
    "keywords": "",
    "url": "/pages/compose/column/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //SpaceEvenly每一個佈局間的間隔是一樣的 Column( modifier = Modifier .size(200.dp) .background(Color.Green), verticalArrangement = Arrangement.SpaceEvenly ){ //Modifier.weight(1f) 比重 fill預設為TRUE，填滿所有空間 //先佈局沒有分配比重的Text()，剩餘的空間就分配給有比重 Text( \"Column First Item\", modifier = Modifier.weight(1f, true) ) Text(\"Column Second Item\") } 1 modifier = Modifier.weight(1f, false) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //SpaceEvenly每一個佈局間的間隔是一樣的 Column( modifier = Modifier .size(200.dp) .background(Color.Green), verticalArrangement = Arrangement.SpaceEvenly ){ //Modifier.weight(1f) 比重 fill預設為TRUE，填滿所有空間 //先佈局沒有分配比重的Text()，剩餘的空間就分配給有比重 Text( \"Column First Item\", modifier = Modifier.weight(1f, true) ) Text(\"Column Second Item\", modifier = Modifier.weight(1f, true)) } 增加spacer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Column( modifier = Modifier .size(200.dp) .background(Color.Green) ){ //Modifier.weight(1f) 比重 fill預設為TRUE，填滿所有空間 //先佈局沒有分配比重的Text()，剩餘的空間就分配給有比重 Text( \"Column First Item\", modifier = Modifier.background(Color.Red) ) Spacer(modifier = Modifier.height(10.dp)) Text(\"Column Second Item\", modifier = Modifier.background(Color.Red)) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //SpaceEvenly每一個佈局間的間隔是一樣的 Column( modifier = Modifier .size(200.dp) .background(Color.Green), verticalArrangement = Arrangement.SpaceEvenly ) { //Modifier.weight(1f) 比重 fill預設為TRUE，填滿所有空間 //先佈局沒有分配比重的Text()，剩餘的空間就分配給有比重 Text( \"Column First Item\", modifier = Modifier.weight(1f, false) ) Text(\"Column Second Item\") }"
  },"/pages/compose/horizontalpager/": {
    "title": "輪播",
    "keywords": "",
    "url": "/pages/compose/horizontalpager/",
    "body": "假設實際只有3筆 但virtualCount虛擬數量設為9 page頁數 0 1 2 虛擬index 0,1,2 3,4,5 6,7,8 實際下標 [0,1,2] [0,1,2] [0,1,2] 分為4頁，每一頁的下標分別為真實的數量0,1,2 虛擬index-[第幾頁(虛擬index/實際總筆數)*實際總筆數]= 實際下標 如何取得真正下標的公式假設虛擬index為3-[第幾頁(虛擬index3/實際總筆數3)*實際總筆數3] = 實際下標0 如何取得真正下標的公式假設虛擬index為4-[第幾頁(虛擬index4/實際總筆數3)*實際總筆數3] = 實際下標1 如何取得真正下標的公式假設虛擬index為5-[第幾頁(虛擬index5/實際總筆數3)*實際總筆數3] = 實際下標2 但現在有一個問題，初始值index，假設虛擬總筆數為8 初始值為8/2 = 4 4為虛擬初始值，套上面的公式 4-[(4/3)*3]=下標1 但希望下標是從0開始 原本 page頁數 0 1 2 虛擬index 0,1,2 3,4,5 6,7,8 實際下標 [0,1,2] [0,1,2] [0,1,2] 下標往後推移,初始值由4開始 page頁數 0 1 虛擬index 4,5,6, 7 實際下標 [0,1,2] [0] 如何取得真正下標的公式假設(虛擬index為4-4為虛擬初始值)-[第幾頁((虛擬index為4-4為虛擬初始值)/實際總筆數3)*實際總筆數3] = 實際下標0 如何取得真正下標的公式假設(虛擬index為5-4為虛擬初始值)-[第幾頁((虛擬index為5-4為虛擬初始值)/實際總筆數3)*實際總筆數3] = 實際下標1 如何取得真正下標的公式假設(虛擬index為6-4為虛擬初始值)-[第幾頁((虛擬index為6-4為虛擬初始值)/實際總筆數3)*實際總筆數3] = 實際下標2 如何取得真正下標的公式假設(虛擬index為7-4為虛擬初始值)-[第幾頁((虛擬index為7-4為虛擬初始值)/實際總筆數3)*實際總筆數3] = 實際下標0 1 2 3 4 5 6 //虛擬數量設最大值 val virtualCount = Int.MAX_VALUE //實際數量 val actualCount = vm.swiperData.size //初始圖片下標，假設虛擬總筆數為8 初始值為8/2 = 4 val initialIndex = virtualCount / 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** *擴展函式 * *@paramother實際總筆數 *@return */ private fun Int.floorMod(other:Int) : Int = when(other) { //index.floorMod(actualCount) 呼叫方式 //this就是上一行註解中的index , 若總數為0 直接返回0 0 -&gt; this //(index.floorDiv(actualCount)) * actualCount else -&gt; { //虛擬index為4-[第幾頁(虛擬index4/實際總筆數3)*實際總筆數3] = 實際下標1 this -floorDiv(other) * other } } 透過以下方式，呼叫上面的擴展函式 val actualIndex = (index - initialIndex).*floorMod*(actualCount) 如何取得真正下標的公式假設(虛擬index為4-4為虛擬初始值)-[第幾頁((虛擬index為4-4為虛擬初始值)/實際總筆數3)*實際總筆數3] = 實際下標0 將初始化的值變remember 1 val pagerState = rememberPagerState(initialIndex) 輪播 import 1 2 3 import androidx.compose.foundation.pager.HorizontalPager import androidx.compose.foundation.pager.rememberPagerState import coil.compose.AsyncImage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 HorizontalPager( pageCount = virtualCount, state = pagerState, pageSpacing = 16.dp, //圖跟圖之間有空白 modifier = Modifier .padding(horizontal = 8.dp) //圖片不會貼滿左右二邊 .clip(RoundedCornerShape(8.dp)) //圓角 ){index-&gt; 取得真正下標 val actualIndex = (index - initialIndex).floorMod(actualCount) AsyncImage( model = vm.swiperData[actualIndex].imageUrl, contentDescription = null, modifier = Modifier .fillMaxWidth() //填滿 .aspectRatio(7 / 3f) //比例7比3 , contentScale = ContentScale.Crop //裁剪 ) } 無限輪播 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.Timer import java.util.TimerTask import androidx.compose.runtime.DisposableEffect import androidx.compose.runtime.rememberCoroutineScope import kotlinx.coroutines.launch val coroutineScope = rememberCoroutineScope() //自動輪播 //監聽什麼時候創建 什麼時候銷毀 DisposableEffect(Unit){ val timer = Timer() //創建定時器 timer.schedule(object : TimerTask(){ override fun run() { coroutineScope.launch{ // 滾動到當前頁(currentPage)的下一頁(+1) pagerState.animateScrollToPage(pagerState.currentPage + 1) } } },3000,3000) //每三秒循環一次 onDispose{//銷毀定時器 timer.cancel() } }"
  },"/pages/compose/icon/": {
    "title": "Icon",
    "keywords": "",
    "url": "/pages/compose/icon/",
    "body": "checked checked變數設為false 可使用來把變數變相反 checked = !checked 也可以使用it來取得switch是true 或false 1 2 3 4 5 6 7 8 @Composable fun SwitchSample() { var checked by remember{ mutableStateOf(false)} Switch(checked = checked, onCheckedChange = { //checked = !checked checked = it }) } ICON使用官方圖庫 build.gradle(Module :app)中 dependencies { implementation \"androidx.compose.material:material-icons-extended:1.4.2\" } Icon tint Icon(imageVector = Icons.Default.Translate, contentDescription = null, tint = Color.Red) 可換成 Icons.Default.AccountBox 參考以下網址 https://fonts.google.com/icons?icon.query=Account tint = Color.Red背景顏色紅色 1 2 3 4 @Composable fun IconSample() { Icon(imageVector = Icons.Default.Translate, contentDescription = null, tint = Color.Red) } ICON使用painterResource 1 2 3 4 @Composable fun IconSample() { Icon(painter = painterResource(id = ic_android_black_24dp), contentDescription = null) } ImageView 1 2 3 4 5 6 Image( painter = painterResource(id = R.drawable.ic_android_black_24dp), contentDescription = null, modifier = Modifier.size(50.dp),//大小 colorFilter = ColorFilter.tint(Color.Red, blendMode = BlendMode.Color)//紅色背景 )"
  },"/pages/compose/image_fullmax/": {
    "title": "圖片全瑩幕",
    "keywords": "",
    "url": "/pages/compose/image_fullmax/",
    "body": "圖片尚未擴張前 1 2 3 4 5 6 7 Box(modifier = Modifier.fillMaxSize()) { Image( painter = painterResource(id = R.drawable.img1), contentDescription = null, modifier = Modifier.fillMaxSize() ) } 圖片尚未擴張後 1 2 3 4 5 6 7 8 Box(modifier = Modifier.fillMaxSize()) { Image( painter = painterResource(id = R.drawable.img1), contentDescription = null, modifier = Modifier.fillMaxSize(), contentScale = ContentScale.Crop ) }"
  },"/pages/compose/image_loader/": {
    "title": "ImageLoader",
    "keywords": "",
    "url": "/pages/compose/image_loader/",
    "body": "參考以下網址: https://github.com/coil-kt/coil#jetpack-compose https://developer.android.com/jetpack/compose/graphics/images/loading?hl=zh-cn gradle匯入 1 implementation(\"io.coil-kt:coil-compose:2.4.0\") 記得在AndroidManifest加上權限 1 &lt;uses-permission android:name=\"android.permission.INTERNET\"&gt;&lt;/uses-permission&gt; 把圖片匯入 1 2 3 4 AsyncImage( model = \"https://example.com/image.jpg\", contentDescription = null, )"
  },"/pages/compose/lazycolumn/": {
    "title": "LazyColumn水平置中",
    "keywords": "",
    "url": "/pages/compose/lazycolumn/",
    "body": "1 2 LazyColumn(horizontalAlignment = Alignment.CenterHorizontally) { } 設置前 設置後"
  },"/pages/compose/listitem/": {
    "title": "ListItem",
    "keywords": "",
    "url": "/pages/compose/listitem/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @OptIn(ExperimentalMaterial3Api::class) @Composable fun ListItemSample() { var list by remember{mutableStateOf(listOf( false, false, false, false, false) ) } Column(){ list.forEachIndexed(){rawIndex, listItem-&gt; ListItem( leadingContent ={Icon(Icons.Default.AccountBox, contentDescription = \"Localized description\") }, headlineText ={ Text(text = \"ccc $rawIndex\") }, supportingText ={ Text(text = \"aaa\") }, trailingContent ={ Checkbox(checked = listItem, onCheckedChange ={ list = list.mapIndexed{newIndex, listItem-&gt; if (rawIndex == newIndex) { !listItem } else { listItem } } Log.i(\"====\", \"${list}\") }) }, overlineText ={ Text(text = \"ggg\") }) } // end of forEachIndexed } // end of ListItem"
  },"/pages/compose/modifier/": {
    "title": "Modifier",
    "keywords": "",
    "url": "/pages/compose/modifier/",
    "body": "border/background/padding放置的位置不同，會有不同效果 1 2 3 4 5 6 7 8 9 10 11 12 13 @Composable fun ModifierSample() { Text( text = \"text\", modifier = Modifier .border(1.dp, Color.Red) .background(Color.Yellow) .padding(8.dp) .clickable { Log.i(\"-----\",\"click me\") } ) }"
  },"/pages/compose/mutablestate/": {
    "title": "Compose mutableStateOf",
    "keywords": "",
    "url": "/pages/compose/mutablestate/",
    "body": "如果只使用var count = 1; 變數再重新繪製手機介面時就又變成1，所以要使用 by remeber 以下count為mutable類別，要使用count.value讀取 1 2 3 4 5 6 7 var count = remember { mutableStateOf(1) } Text(text = \"xx${count.value}xxx\", Modifier.clickable { count.value++ Log.d(\"xxxx\",\"I comin\") } ) 以下count為int類別，就不用count.value 1 2 3 var count by remember { mutableStateOf(1) } 1 2 3 4 5 6 7 8 9 10 11 @Composable fun StateSample() { var count by remember { mutableStateOf(1) } Log.d(\"xxxx\",\"outter${count}\") Text(text = \"xx${count}xxx\", Modifier.clickable { count++ Log.d(\"xxxx\",\"I comin\") } ) }"
  },"/pages/compose/nav_back/": {
    "title": "Navigation 回到上一頁轉場",
    "keywords": "",
    "url": "/pages/compose/nav_back/",
    "body": "先參考之前的AnimationNavigation的文章 還有App Top bar添加上一頁的文章 在NavHost加上navController.popBackStack() 1 2 3 4 5 composable(Destinations.ArticleDetail.route) { ArticleDetailScreen(onBack = { navController.popBackStack() }) } 在詳細頁添加 fun()中丟入lambda的參數onBack: () -&gt; Unit 在navigation的.clickable加上onBack()，記得要尾部括號()，不然不會執行lambda 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fun ArticleDetailScreen(onBack: () -&gt; Unit) { Scaffold( topBar = { TopAppBar( title = { Text( text = \"Detail\", modifier = Modifier.fillMaxWidth(), textAlign = TextAlign.Center ) }, navigationIcon = { Icon( imageVector = Icons.Default.NavigateBefore, contentDescription = null, //增加返回的方法 modifier = Modifier .clickable { onBack() } .padding(8.dp) ) }, actions = { Icon(imageVector = Icons.Default.TextFields, contentDescription = null, modifier = Modifier .clickable { //TODO 字體放大 } .padding(8.dp) ) } ) }, modifier = Modifier .background(MaterialTheme.colors.primary) .statusBarsPadding() ) { Text(text = \"文章詳情\") } }"
  },"/pages/compose/padding/": {
    "title": "padding",
    "keywords": "",
    "url": "/pages/compose/padding/",
    "body": "1 2 3 4 5 6 7 Column( modifier = Modifier .fillMaxSize() //填滿 .background(Color.White)//白色 .padding(top = 8.dp) //與上面的元間有8dp的距離 .padding(horizontal = 8.dp, vertical = 8.dp) //與左邊及下面有8dp距離 )"
  },"/pages/compose/pullrefresh/": {
    "title": "PullRefresh",
    "keywords": "",
    "url": "/pages/compose/pullrefresh/",
    "body": "在ArticleViewModel加上 1 2 3 4 5 6 var refreshing by mutableStateOf(false) private set suspend fun refresh() { pageOffset = 1 refreshing = true fetchArticleList() } 修改既有方法 1 2 3 4 5 6 7 8 9 suspend fun fetchArticleList(){ val res = articleService.list(pageOffset = pageOffset, pageSize = pageSize) delay(3000) if(res.code == 0 &amp;&amp; res.data != null) { list = res.data listLoaded = true //是否載入完畢 refreshing = false } } 在StudyScreen先import 1 2 3 4 5 6 7 8 import androidx.compose.material.pullrefresh.PullRefreshIndicator import androidx.compose.material.pullrefresh.pullRefresh import androidx.compose.runtime.getValue import androidx.compose.runtime.mutableStateOf import androidx.compose.runtime.remember import androidx.compose.runtime.rememberCoroutineScope import androidx.compose.runtime.setValue import kotlinx.coroutines.launch 1 2 3 4 5 6 7 8 9 val lazyListState = rememberLazyListState() val coroutineScope = rememberCoroutineScope() var refreshing by remember { mutableStateOf(articleViewModel.refreshing) } val pullRefreshState = rememberPullRefreshState(refreshing, { coroutineScope.launch { articleViewModel.refresh() } }) Box(Modifier.pullRefresh(pullRefreshState)) { LazyColumn(state = lazyListState) { } PullRefreshIndicator(refreshing, pullRefreshState, Modifier.align(Alignment.TopCenter)) }"
  },"/pages/compose/radiobtn/": {
    "title": "RadioButton",
    "keywords": "",
    "url": "/pages/compose/radiobtn/",
    "body": "1 2 3 4 5 6 7 8 //單個按鈕 var selected by remember{ mutableStateOf(false) //Ò默認為false } RadioButton(selected = selected, onClick ={ //預設false，點擊變true selected = !selected }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var checkedList by remember { mutableStateOf(listOf(false, false)) //2個RadioButton，預設false } Column() { checkedList.forEachIndexed { index, item -&gt; RadioButton(selected = item, onClick = { //透過index判斷當前點擊的是那一個 checkedList = checkedList.mapIndexed{ j,_ -&gt; index == j } }) } }"
  },"/pages/compose/retrofit/": {
    "title": "Retrofit",
    "keywords": "",
    "url": "/pages/compose/retrofit/",
    "body": "grandle import以下內容 1 2 3 4 5 6 def retrofit = \"2.9.0\" implementation \"com.squareup.retrofit2:retrofit:$retrofit\" implementation \"com.squareup.retrofit2:converter-gson:$retrofit\" implementation \"com.squareup.retrofit2:converter-moshi:$retrofit\" def moshi_version = \"1.13.0\" implementation \"com.squareup.moshi:moshi-kotlin:$moshi_version\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import com.squareup.moshi.Moshi import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory import retrofit2.Retrofit import retrofit2.converter.moshi.MoshiConverterFactory object Network { //文件位置:https://docs.apipost.cn/preview/1a28e17fa3c8f473/16838456ae6dc5c7 private const val baseUrl = \"https://mock.apipost.cn/app/mock/project/ced69cf2-9206-4a42-895e-dd7442a888df/\" //創建一個Retrofit builder private val retrofit = Retrofit .Builder() .baseUrl(baseUrl) .addConverterFactory( //建立Moshi工廠 MoshiConverterFactory.create( Moshi.Builder() .add(KotlinJsonAdapterFactory()) .build() ) ).build() //傳進來什麼類型，返回就是什麼類型 fun &lt;T&gt; createService(clazz: Class&lt;T&gt;):T { return retrofit.create(clazz) } } 圖中先建立ArticleService 先建一個interface 在Service的目錄下 生成伴生物件 進到https://docs.apipost.cn/preview/1a28e17fa3c8f473/16838456ae6dc5c7 點進文章列表 使用/article/list 參數有pageOffset跟pageSize，如下圖 1 2 3 4 5 @GET(\"article/list\") suspend fun list( @Query(\"pageOffset\") pageOffset: Int, @Query(\"pageSize\") pageSize: Int ) 建立基礎的Response 1 2 3 4 5 package com.example.project1.model.entity open class BaseResponse { var code:Int = -1 var message:String = \"\" } 建立繼承的Response 1 2 3 4 5 6 7 8 9 10 11 import com.squareup.moshi.Json import com.squareup.moshi.JsonClass @JsonClass(generateAdapter = true) data class ArticleEntity( val title: String, var source: String, @Json(name = \"time\") var timestamp: String ) //因為data有可能為空，所以類型設空值List&lt;ArticleEntity&gt;? data class ArticleListResponse(val data: List&lt;ArticleEntity&gt;?):BaseResponse() 回到Article Service 繼承:ArticleListResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import com.example.project1.model.entity.ArticleListResponse import retrofit2.http.GET import retrofit2.http.Query interface ArticleService { @GET(\"article/list\") suspend fun list( @Query(\"pageOffset\") pageOffset: Int, @Query(\"pageSize\") pageSize: Int ): ArticleListResponse companion object { //創建Home Service的實例 fun instance(): ArticleService { return Network.createService(ArticleService::class.java) } } } 在viewmodel中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class ArticleViewModel : ViewModel() { private val articleService = ArticleService.instance() val pageSize = 10 //每頁10筆 private var pageOffset = 1 //預設從第1頁讀取 var list by mutableStateOf( listOf( ArticleEntity( title = \"test3\", source = \"source3\", timestamp = \"2023-01-01\" ), ArticleEntity( title = \"test4\", source = \"source4\", timestamp = \"2023-01-01\" ) ) ) private set //不讓人修改 var listLoaded by mutableStateOf(false) private set suspend fun fetchArticleList(){ val res = articleService.list(pageOffset = pageOffset, pageSize = pageSize) if(res.code == 0 &amp;&amp; res.data != null) { list = res.data listLoaded = true //是否載入完畢 } } } 在screen畫面使用 在LaunchedEffect使用(fetchArticleList) 因為有”是否載入完畢”，要做placeholder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 fun ArticleItem(article: ArticleEntity, loaded: Boolean, modifier: Modifier = Modifier) { Column(modifier = modifier.padding(8.dp)) { Text( article.title, color = Color(0xFF333333), fontSize = 16.sp, maxLines = 2, overflow = TextOverflow.Ellipsis, modifier = Modifier .padding(bottom = 8.dp) .placeholder( visible = !loaded, color = Color.Gray, highlight = PlaceholderHighlight.shimmer(highlightColor = Color.Gray) ) ) Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier .fillMaxWidth() .placeholder( visible = !loaded, color = Color.Gray, highlight = PlaceholderHighlight.shimmer(highlightColor = Color.Gray) )) { Text( text = \"來源:${article.source}\", color = Color(0xFF999999), fontSize = 10.sp, maxLines = 1, overflow = TextOverflow.Ellipsis ) Text(text = article.timestamp) } Spacer(Modifier.height(8.dp)) Divider() } } 在呼叫ArticleItem時添加loaded 1 2 3 4 5 6 7 8 9 10 11 if (vm.showArticleList) { //列表 items(articleViewModel.list) { article -&gt; ArticleItem(article, articleViewModel.listLoaded, modifier = Modifier.clickable { //Log.d(\"======\",\"here\") onNavigateToArticle.invoke() }) } }"
  },"/pages/compose/round_image/": {
    "title": "圓形圖片",
    "keywords": "",
    "url": "/pages/compose/round_image/",
    "body": "圓角主要由以下二個部分製成 .clip(CircleShape) contentScale = ContentScale.Crop, 1 2 3 4 5 6 7 8 Image( painter = painterResource(id = R.drawable.*img1*), contentDescription = null, contentScale = ContentScale.Crop, modifier = Modifier .size(62.dp) .clip(CircleShape) )"
  },"/pages/compose/row/": {
    "title": "Row",
    "keywords": "",
    "url": "/pages/compose/row/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 Row( modifier = Modifier .size(200.dp) .background(Color.Green) ){ Text( \"Column First Item\", modifier = Modifier.weight(1f, true) ) Text(\"Column Second Item\", modifier = Modifier.weight(1f, true)) }"
  },"/pages/compose/screen_info/": {
    "title": "瑩幕寬高",
    "keywords": "",
    "url": "/pages/compose/screen_info/",
    "body": "1 2 3 4 5 6 var screenWidth :Float var screenHeight :Float with(LocalDensity.current){ screenWidth = LocalConfiguration.current.screenWidthDp.dp.toPx() screenHeight = LocalConfiguration.current.screenHeightDp.dp.toPx() }"
  },"/pages/compose/sidebar/": {
    "title": "Compose sidebar",
    "keywords": "",
    "url": "/pages/compose/sidebar/",
    "body": "1 2 3 4 5 6 7 8 9 @Composable fun SliderSample() { var values by remember{ mutableStateOf(0f) } Slider(value = values, onValueChange = { values = it }, valueRange = 0f..100f, steps = 4) } 可以選擇一個範圍 預設mutableStateOf的範圍為0f..1f 1 2 3 4 5 6 7 8 9 10 @OptIn(ExperimentalMaterial3Api::class) @Composable fun SliderSample() { var values by remember { mutableStateOf(0.2f..0.8f) } RangeSlider(value = values, onValueChange ={ values = it } ) }"
  },"/pages/compose/system_bar/": {
    "title": "system bar",
    "keywords": "",
    "url": "/pages/compose/system_bar/",
    "body": "為什麼system bar會變白色 原因是因為在MainActivity的Surface使用到MaterialTheme的 background預設是白色 1 2 3 4 5 6 7 8 9 10 11 12 //使用這個會讓buttonNavigation被遮住 WindowCompat.setDecorFitsSystemWindows(window,false) setContent { Project1Theme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { NavHostApp() } } } MainActivity修改成 1 2 3 4 5 6 7 8 9 10 11 12 13 import androidx.compose.material.MaterialTheme import androidx.compose.material.Surface WindowCompat.setDecorFitsSystemWindows(window,false) setContent { Project1Theme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.primary ) { NavHostApp() } } } Article詳細頁修改成使用系統的TopAppBar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.example.project1.ui.screens import androidx.compose.foundation.layout.statusBarsPadding import androidx.compose.material.Scaffold import androidx.compose.material.Text import androidx.compose.material.TopAppBar import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier @Composable fun ArticleDetailScreen() { Scaffold( topBar = { //系統的TopAppBar TopAppBar( title = { Text(text = \"Detail\") } ) }, //system status bar的高度 modifier = Modifier.statusBarsPadding() ) { Text(text = \"文章詳情\") } } 法二 MainActivity 仍可使用預設白色 1 2 3 4 5 6 7 8 9 10 11 12 //使用這個會讓buttonNavigation被遮住 WindowCompat.setDecorFitsSystemWindows(window,false) setContent { Project1Theme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { NavHostApp() } } } 直接在Scaffold中的modifier寫入background，記得順序要在statusBarPadding()前面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.project1.ui.screens import androidx.compose.foundation.background import androidx.compose.foundation.layout.statusBarsPadding import androidx.compose.material.MaterialTheme import androidx.compose.material.Scaffold import androidx.compose.material.Text import androidx.compose.material.TopAppBar import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier @Composable fun ArticleDetailScreen() { Scaffold( topBar = { TopAppBar( title = { Text(text = \"Detail\") }, ) }, modifier = Modifier .background(MaterialTheme.colors.primary) .statusBarsPadding() ) { Text(text = \"文章詳情\") } }"
  },"/pages/compose/textfield/": {
    "title": "TextField",
    "keywords": "",
    "url": "/pages/compose/textfield/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Composable fun TextFieldSample() { //使用by remember才會記憶value var value by remember { mutableStateOf(\"\") } TextField( value = value, onValueChange = { //把輸入的值放在value變數 value = it }, label = {//標籤 Text(\"name\") }, placeholder = { Text(text = \"請輸入\") }, leadingIcon = {//前置圖片 Icon(imageVector = Icons.Default.AccountBox, contentDescription = null) }, keyboardActions = KeyboardActions(onDone = { //處理按下完成 }), singleLine = true,//單行 keyboardOptions = KeyboardOptions( imeAction = ImeAction.Done,//回車鍵有完成的按鈕 keyboardType = KeyboardType.Number//數字 ) ) } @Preview @Composable fun TextFieldSamplePreview() { TextFieldSample() }"
  },"/pages/compose/top_bar/": {
    "title": "自制App Top Bar",
    "keywords": "",
    "url": "/pages/compose/top_bar/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 Row( modifier =Modifier .statusBarsPadding() //系統列 .height(appBarHeight),//appbar的高度 verticalAlignment = Alignment.CenterVertically//垂直置中 ){ Text( \"TaskContent\", modifier = Modifier.fillMaxWidth(),//一定要設定不然不能居中 textAlign = TextAlign.Center,//置中 color = Color.White, fontSize = 18.sp ) }"
  },"/pages/compose/top_bar_back/": {
    "title": "App Top bar添加上一頁跟action的按鈕",
    "keywords": "",
    "url": "/pages/compose/top_bar_back/",
    "body": "透過navigationIcon 透過actions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 Scaffold( topBar = { TopAppBar( title = { Text( text = \"Detail\", modifier = Modifier.fillMaxWidth(), textAlign = TextAlign.Center ) }, navigationIcon = { Icon( imageVector = Icons.Default.NavigateBefore, contentDescription = null, //增加返回的方法 modifier = Modifier .clickable { onBack() } .padding(8.dp) ) }, actions = { Icon(imageVector = Icons.Default.TextFields, contentDescription = null, modifier = Modifier .clickable { //TODO 字體放大 } .padding(8.dp) ) } ) }, modifier = Modifier .background(MaterialTheme.colors.primary) .statusBarsPadding() ) { Text(text = \"文章詳情\") }"
  },"/pages/compose/top_bar_center/": {
    "title": "Topbar置中",
    "keywords": "",
    "url": "/pages/compose/top_bar_center/",
    "body": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Scaffold( topBar = { TopAppBar( title = { Text( text = \"Detail\", modifier = Modifier.fillMaxWidth(), textAlign = TextAlign.Center ) },) }, modifier = Modifier .background(MaterialTheme.colors.primary) .statusBarsPadding() ) { Text(text = \"文章詳情\") }"
  },"/pages/note/git/sourcetree_create/": {
    "title": "SourceTree新增git repository",
    "keywords": "",
    "url": "/pages/note/git/sourcetree_create/",
    "body": "參考 https://hackmd.io/@09oU3M6LTU-7M6MkSqRj1A/Bymbf3y2?type=view 先增加本地端 最後把目錄裡的東西都commit 然後選push"
  },"/pages/note/git/sourcetree_token/": {
    "title": "SourceTree token",
    "keywords": "",
    "url": "/pages/note/git/sourcetree_token/",
    "body": "先到github 個人檔案選setting 選Developer Setting 選Fine-grained tokens 選Generate new token 輸入token name 有效期限 還有權限都開access &amp;wirte 把token複製起來 開啟SourceTree 選setting 選Remotes，選edit網址 這一步最重要，把token複製到github前面，github前面加一個@，@前面是Token github_pat_xxx"
  },"/pages/note/laravel/": {
    "title": "Laravel基本介紹",
    "keywords": "",
    "url": "/pages/note/laravel/",
    "body": "首先，使用 Composer 下載 Laravel installer： composer global require \"laravel/installer\" 請確定把 $HOME/.composer/vendor/bin 路徑放置於環境變數 $PATH 裡，這樣你的系統才能找到 laravel 執行檔。 一旦安裝完成後，就可以使用 laravel new 指令在指定的目錄建立一份全新安裝的 Laravel。例如：laravel new blog 將會建立一個名稱為 blog 的目錄，裡面存放著全新安裝的 Laravel 和相依程式碼： laravel new blog 名詞介紹: routes路徑表:網址路由，指定某個網址要由哪個 controller 來負責處理。 controllers控制器:MVC 中的 controller 的程式碼檔案，你的程式碼會在這裡處理各種資料後丟給 View (HTML 網頁模版)來顯示。 views畫面:MVC 中的 view ， HTML 網頁模版。 目錄介紹: Public 目錄 安裝完 Laravel 之後，需要將您的網站伺服器根目錄指向 public 目錄，HTTP 請求的進入點。 Resource目錄 放置JS原始檔案/Image/font …等等。 放置HTML網頁模版的View目錄 Http/Controllers目錄 放置Controller程式 Routes 放置所有網址路由檔案(api.php/web.php) 基本 GET 路由 1 2 3 4 Route::get('/', function() { return 'Hello World'; }); 基本 POST 路由 1 2 3 4 Route::post('foo/bar', function() { return 'Hello World'; }); Controller控制器 1 2 3 4 5 6 7 8 9 10 class TestController extends Controller { public function showUser($id,$name) { echo 'UserId:'.$id.'/UserName:'.$name; } public function Index() { return view('User.userinfo',['name' =&gt; 'CiCi']); } } Route路由 1 2 Route::get('showUser/{id}/{name}', [TestController::class, 'showUser']); Route::get('showUser', [TestController::class, 'index']); webpack.mix.js JS檔案放置在resouces/js目錄下，透過webpack.mix.js會把js檔案打包並放置在public/js目錄下。 mix.js('resources/js/User/user.js', 'public/js/User'); 執行以下指令 composer update php artisan key:generate npm install npm run dev 會打包resouces/js到public/js 打包成功頁面 Vue.js 範例1: https://jsbin.com/tujicecano/edit?html,js,output 範例2: https://jsbin.com/vesucohani/edit?html,js,output date convert to utc+8 https://jsbin.com/darebapafe/edit?html,js,output Laravel若無法執行，可先執行這行 export PATH=\"$PATH:$HOME/.composer/vendor/bin\" vim ~/.zshrc . ~/.zshrc npm相關 ADD \"webpack\": \"^5.23.0\" in package.json npm uninstall sass npm uninstall sass-loader rm -rf node_modules rm package-lock.json npm cache clear --force npm install"
  },"/pages/android/intellij_coroutine/": {
    "title": "Intellij 安裝Coroutine",
    "keywords": "",
    "url": "/pages/android/intellij_coroutine/",
    "body": "進入Project後，選File&gt;Project Structure 選Modules 按+ 選Libery&gt;From Maven 去官網查最新的coroutine的版號 把網址貼上，然後按”ok” 再按ok"
  },"/pages/compose/bottom_nav/": {
    "title": "BottomNavigation",
    "keywords": "",
    "url": "/pages/compose/bottom_nav/",
    "body": "在方法的前面必須加上@OptIn(ExperimentalMaterialApi::class 否則無法使用BottomNavigation的套件 import的前面是material，並非material3 實驗性的@OptIn是加ExperimentalMaterialApi 並非ExperimentalMaterial3Api"
  },"/pages/compose/canvas_chart/": {
    "title": "畫半圓Canvas chart",
    "keywords": "",
    "url": "/pages/compose/canvas_chart/",
    "body": "二個點連成一條線 0度與180度的二個點連成一條線 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = 0f, sweepAngle = 180f, useCenter = true, //0度與180度的二個點連成一條線 style = Stroke(30f) // 邊框 ) } 往下畫180半圓 0度是水平面 往下畫180半圓 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = 0f, sweepAngle = 180f, useCenter = false, //圓點之間連起來 style = Stroke(30f) // 邊框 ) } 沒設置邊框 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = 0f, sweepAngle = 180f, useCenter = false, //圓點之間連起來 //style = Stroke(30f) // 邊框 ) } 產生邊框圓角 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = 0f, sweepAngle = 180f, useCenter = false, //圓點之間連起來 style = Stroke(30f,cap = StrokeCap.Round) // 邊框圓角 ) } 從-10度到180度，框住的部分就是-10度 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = -10f, sweepAngle = 180f, useCenter = false, //圓點之間連起來 style = Stroke(30f,cap = StrokeCap.Round) // 邊框 ) } 0到200度，從180度至200度為框出來的部分 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = 0f, sweepAngle = 200f, useCenter = false, //圓點之間連起來 style = Stroke(30f,cap = StrokeCap.Round) // 邊框 ) } -10度到200度，把1000point的字差不多高，而且二邊端點是平的 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = -10f, sweepAngle = 200f, useCenter = false, //圓點之間連起來 style = Stroke(30f,cap = StrokeCap.Round) // 邊框 ) } 把下面的半圓整個翻轉變成上面半圓 1 2 3 4 5 6 7 8 9 10 11 12 13 Canvas(modifier = Modifier.size(boxWidthDp.dp)) { //翻轉180度 rotate(180f) { drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 //0度是水平面 往下畫180半圓 startAngle = -10f, sweepAngle = 200f, useCenter = false, //圓點之間連起來 style = Stroke(30f, cap = StrokeCap.Round) // 邊框 ) } } 去掉rotate(180f) {} 從起點160度開始畫200度的弧形 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 startAngle = 160f, sweepAngle = 200f, useCenter = false, //圓點之間連起來 style = Stroke(30f, cap = StrokeCap.Round) // 邊框 ) } 把終點設成220，剛好成一個半圓 1 2 3 4 5 6 7 8 9 10 Canvas(modifier = Modifier.size(boxWidthDp.dp)){ drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 startAngle = 160f, sweepAngle = 220f, useCenter = false, //圓點之間連起來 style = Stroke(30f, cap = StrokeCap.Round) // 邊框 ) } 再疊上一個白色，起點位置相同，蓋上2/3的部分 原本200 一半是100 2/3是133 sweepAngle = 200f sweepAngle = 133f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Canvas(modifier = Modifier.size(boxWidthDp.dp)) { //方式一 //翻轉180度 rotate(180f) { drawArc( Color(0, 0, 0, 33),//黑色rgb都0，%3透明度設33 startAngle = -10f, sweepAngle = 200f, useCenter = false, //圓點之間連起來 style = Stroke(30f, cap = StrokeCap.Round) // 邊框 ) } //覆寫同樣的位置就可以部分蓋住 rotate(180f) { drawArc( Color.White, startAngle = -10f, sweepAngle = 133f,//原本200 一半是100 2/3是133 useCenter = false, //圓點之間連起來 style = Stroke(30f, cap = StrokeCap.Round) // 邊框 ) } }"
  },"/pages/compose/line_chart/": {
    "title": "折線圖",
    "keywords": "",
    "url": "/pages/compose/line_chart/",
    "body": "以下是y軸位置 第一個圓心與y軸0有2.5的偏移量 最後一個圓心也有2.5的偏移量 原本的y軸線條位置應該是如下，中間隔24，但因為有圓心，所以y軸的線條往下偏移2.5的半徑距離 0 24 48 72 96 120 1 2 3 4 5 6 7 8 9 10 11 12 13 //每一row的高度 val heightForRow = 24 //總row數 val countForRow = 5 //小圓圈半徑 val circleRadius = 2.5 //總高度 //每一row的高度*總row數+上下小圓的半徑(因為最底會突出來小半圓，最高會突出小半圓) // 24 * 5 + (2.5 * 2) val canvasHeight = heightForRow * countForRow + (circleRadius * 2) //畫布寬度 = 營幕寬度 - 左邊padding - 右邊padding //畫布寬度 = 營幕寬度 - padding*2 val canvasWidth = LocalConfiguration.current.screenWidthDp - (8 * 2) 先畫 畫布 1 2 3 4 5 6 Canvas( modifier = modifier.size( width = canvasWidth.dp, height = canvasHeight.dp ) ) {} 產生每個直線的x,y座標，從0 .. 5開始畫6條直線 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //畫直線 for(index in 0 .. countForRow) { //canvas只接受px，要記得轉成px //最底部跟最頂部有小圓半徑的大小，所以y軸的位置都要往下偏移 // 24 * index + 2.5 val y = (heightForRow * index + circleRadius).dp.toPx() //每一個row的y值 從0的位置往下偏移2.5圓的半徑 // index 0 y = 2.5 // index 1 y = 26.5 // index 2 y = 50.5 // index 3 y = 74.5 // index 4 y = 98.5 // index 5 y = 122.5 drawLine(Color(0xFFEEEEEE), start = Offset(0f, y), //x從0開始畫直線 end = Offset(size.width, y), //x為畫布最大寬度 size.width為直接抓到畫布的大小 strokeWidth = 2.5f, cap = StrokeCap.Round ) } 畫圓圈 先把畫布分七等份，因一周有七天 1 2 //一周有7天，要把畫布的寬度分成7等份，然後讓圓點座落在每一等份的中間位置 val averageOfWidth = canvasWidth / 7 計算每一個點的圓心 圓心的x座標 一周有7天，要把畫布的寬度分成7等份，index為第幾等份 * 平均寬度 求出每一等份的中間位置 averageOfWidth * index"
  },"/pages/compose/linear_gradient/": {
    "title": "背景顏色漸變",
    "keywords": "",
    "url": "/pages/compose/linear_gradient/",
    "body": "背景顏色漸變 1 2 Brush.verticalGradient( listOf(Color(0xFF149EE7), Color.White)) 完整程式碼 1 2 3 4 5 6 7 8 9 Column( modifier = Modifier .fillMaxSize() //鋪滿全屏 .background( //背景漸變色從上到下垂直漸變 從藍變白 Brush.verticalGradient( listOf(Color(0xFF149EE7), Color.White)) ) ){} 右上往左下漸變 1 2 3 4 5 6 7 Brush.linearGradient( listOf(Color(0xffbb8378), Color.Transparent), //x值為屏幕的寬度 y值為頂端0 start = Offset(x = screenWidth, y = 0f), //x值為0 y值為屏幕的高度 end = Offset(x = 0f, y = screenHeight) ) 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var screenWidth: Float //螢幕寬度 var screenHeight: Float //螢幕高度 with(LocalDensity.current) { screenWidth = LocalConfiguration.current.screenWidthDp.dp.toPx() screenHeight = LocalConfiguration.current.screenHeightDp.dp.toPx() } //右上往左下漸變 Box( modifier = Modifier .fillMaxSize() .background( Brush.linearGradient( listOf(Color(0xffbb8378), Color.Transparent), //x值為屏幕的寬度 y值為頂端0 start = Offset(x = screenWidth, y = 0f), //x值為0 y值為屏幕的高度 end = Offset(x = 0f, y = screenHeight) ) ) ) 左下往右上漸變 1 2 start = Offset(x = 0f, y = screenHeight), end = Offset(x = screenWidth, y = 0f) 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 //左下往右上漸變 Box( modifier = Modifier .fillMaxSize() .background( Brush.linearGradient( listOf(Color(0xFF149EE7), Color.Transparent), start = Offset(x = 0f, y = screenHeight), end = Offset(x = screenWidth, y = 0f) ) ) )"
  },"/pages/compose/xml_layout/": {
    "title": "Compose共用xml佈局",
    "keywords": "",
    "url": "/pages/compose/xml_layout/",
    "body": "新增xml layout res目錄按滑鼠右鍵-&gt;New-&gt;Android Resource File 輸入File名 &gt; 選Layout&gt; 按ok 點Code的功能 加上android id 在MainActivity中寫程式 記得是用Activity 去run 選app，再選啟動的按鈕. 如下圖"
  },"/pages/compose/permission/": {
    "title": "Permission",
    "keywords": "",
    "url": "/pages/compose/permission/",
    "body": "Protection Leveld是危險才出現對話 在Manifest.permission.CAMERA前面要加上anroid. 不然會CAMERA會出現紅色 reference不到 如下圖 anroid.Manifest.permission.CAMERA 還要參考ADB設定 官方說，要讓模擬器有permission的功能要用 -g 先把apk匯出再透過下面指令安裝，以後就不用這樣了 adb install -g app-debug.apk 然後參考run Activity文件 打開模擬器，想辦法把Setting弄出來(到主頁從下往上拉) 選擇Pemissions 選擇如下圖see all apps…… 往下滑動，看到MyApplicationApp，點進去 選擇ask everytime，才方便測試跳出權限使用的對話框 跳出的對話框 第二種方法 點擊Camera 要全部重新來過Permission設定 可以刪除App重新來過"
  },"/pages/compose/change_statusbar_color/": {
    "title": "Change status bar color",
    "keywords": "",
    "url": "/pages/compose/change_statusbar_color/",
    "body": "顏色 把夜覽跟日覽的顏色修改 修改res/values/colors.xml 修改res/values/themes.xml 效果如下 加入處理狀態欄的accompanist 透過自製App Bar把標題頂上"
  },"/pages/compose/change_statusbar_height/": {
    "title": "Change status bar height",
    "keywords": "",
    "url": "/pages/compose/change_statusbar_height/",
    "body": "參考此篇 https://stackoverflow.com/questions/73455192/android-jetpack-compose-statusbar-height 1 2 3 4 5 6 7 var systemUiController = rememberSystemUiController() LaunchedEffect(key1 = Unit) { //第二個參數可以設置系統列上的文字顏色，先設置默認 systemUiController.setStatusBarColor(Color.Transparent) } //標題欄高度 val appBarHeight = 56.dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Row( modifier = Modifier .background( Brush.linearGradient( listOf( Blue700, Blue200, ) ) ) .fillMaxWidth() //設最寬 .height(appBarHeight + statusBarHeightDp) //設高度 //Modifier.padding(all: Dp) 要一個類型dp的參數 .padding(top = statusBarHeightDp) .then(modifier) //then的功能是把不同的modifier合併 top bar的modifier跟row的modifier合併 , //標題垂直置中 horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically ) { content() }"
  },"/pages/note/git/remove_commit/": {
    "title": "刪除commit",
    "keywords": "",
    "url": "/pages/note/git/remove_commit/",
    "body": "刪除commit，參考此篇 https://gitbook.tw/chapters/using-git/reset-commit.html git reset HEAD^ git push -f origin develop 拉remote的code git branch -a git checkout develop git pull --rebase ec-console develop git checkout 1.7.0 git pull --rebase ec-console 1.7.0"
  },"/pages/android/adb/": {
    "title": "ADB",
    "keywords": "",
    "url": "/pages/android/adb/",
    "body": "在終端機輸入以下 cd ~/ touch .bash_profile open .bash_profile 打開Android Studio-&gt;File-&gt;Preferences中，搜尋輸入sdk，點選Android SDK 把/Users/cici/Library/Android/sdk 這段複製起來 在.bash_profile輸入以下，記得export要小寫 export ANDROID_HOME=/Users/cici/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools 上一張圖儲存後，輸入source .bash_profile 輸入adb 如下圖 打開AndroidStudio 按Build-&gt;Build Bundle-&gt;Build APKs 點擊locate 產生的位置如下，也可以選取app-debug.apk，按option鍵，拷貝位置 /Users/cici/AndroidStudioProjects/MyApplication2/app/build/outputs/apk/debug/app-debug.apk 打開終端機 cd /Users/cici/AndroidStudioProjects/MyApplication2/app/build/outputs/apk/debug/ 再來adb install -g app-debug.apk 用-g是官方說，這樣可以使用permission"
  },"/pages/android/kdoc/": {
    "title": "kdoc",
    "keywords": "",
    "url": "/pages/android/kdoc/",
    "body": "kotlin在as沒辦法生成@param解決方法 下載kdoc 在Preferences-&gt;Plugins-&gt;搜尋kdoc 如下圖，選擇install 參考 https://stackoverflow.com/questions/40574195/generate-kdoc-for-methods-in-android-studio"
  },"/pages/compose/text_error/": {
    "title": "Compose Text Error",
    "keywords": "",
    "url": "/pages/compose/text_error/",
    "body": "建立Compose Text出現Error 出現以下錯誤 2 issues were found when checking AAR metadata: 1. Dependency 'androidx.core:core:1.12.0-alpha03' requires libraries and applications that depend on it to compile against codename \"UpsideDownCake\" of the Android APIs. :app is currently compiled against android-33. Recommended action: Use a different version of dependency 'androidx.core:core:1.12.0-alpha03', or set compileSdkPreview to \"UpsideDownCake\" in your build.gradle file if you intend to experiment with that preview SDK. 2. Dependency 'androidx.core:core-ktx:1.12.0-alpha03' requires libraries and applications that depend on it to compile against codename \"UpsideDownCake\" of the Android APIs. :app is currently compiled against android-33. Recommended action: Use a different version of dependency 'androidx.core:core-ktx:1.12.0-alpha03', or set compileSdkPreview to \"UpsideDownCake\" in your build.gradle file if you intend to experiment with that preview SDK. 解決方法: 把app的build.gradle中的 androidx.core:core-ktx:+改成1.9.0 https://developer.android.com/jetpack/androidx/releases/compose-kotlin?hl=zh-tw Compose 修改成1.4.2，kotiln改成1.8.1 出現Duplicate Error 參考此篇 Duplicate class kotlin.collections.jdk8.CollectionsJDK8Kt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.internal.jdk7.JDK7PlatformImplementations found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.internal.jdk8.JDK8PlatformImplementations found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.io.path.ExperimentalPathApi found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathRelativizer found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt__PathReadWriteKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt__PathUtilsKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.jdk7.AutoCloseableKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.jvm.jdk8.JvmRepeatableKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.random.jdk8.PlatformThreadLocalRandom found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$1 found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$2 found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$3 found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$4 found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.text.jdk8.RegexExtensionsJDK8Kt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.time.jdk8.DurationConversionsJDK8Kt found in modules jetified-kotlin-stdlib-1.8.0 (org.jetbrains.kotlin:kotlin-stdlib:1.8.0) and jetified-kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0)"
  },"/pages/compose/view_model/": {
    "title": "View Model",
    "keywords": "",
    "url": "/pages/compose/view_model/",
    "body": "參考以下網址 https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=zh-cn 將lifecycle的包打入 var lifecycle_version = \"2.5.1\" // Lifecycles only (without ViewModel or LiveData) implementation(\"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\") // ViewModel utilities for Compose implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version\") dataClass 建view"
  },"/pages/compose/top_bar_err/": {
    "title": "Topbar error",
    "keywords": "",
    "url": "/pages/compose/top_bar_err/",
    "body": "系統的TopAppBar Error androidx.compose.material.TopAppBar 處理方式，把括號去掉，不能有最後的括號 處理後的效果"
  },"/pages/compose/preferences_datastore/": {
    "title": "preferencesDataStore Flow找不到",
    "keywords": "",
    "url": "/pages/compose/preferences_datastore/",
    "body": "Grandle implementation \"androidx.datastore:datastore-preferences-android:1.1.0-alpha04\" Flow找不到 要用到以下 import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.map Data Store 要用到以下套件 import android.content.Context import androidx.datastore.core.DataStore import androidx.datastore.preferences.core.Preferences import androidx.datastore.preferences.core.booleanPreferencesKey import androidx.datastore.preferences.core.edit import androidx.datastore.preferences.core.stringPreferencesKey import androidx.datastore.preferences.preferencesDataStore"
  },"/pages/leetcode/118/": {
    "title": "118,119 Pascal’s Triangle",
    "keywords": "",
    "url": "/pages/leetcode/118/",
    "body": "给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 注意！index是由1開始 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); res.get(0).add(1);//先建立第一層1 for(int i = 2; i &lt;= numRows; i++) {//從第二層依序到numRows，注意！這邊是小於等於，如果少了等於，就會少建一層 //注意，這邊是res.size()-1取出最後的res，不是i-1，因為初始時res只有一層，也就是res.get(0)，若用i-1，i=2的時候，res.get(2-1)是會造成Array out of boundry List list = generateRow(res.get(res.size()-1), i); res.add(list); } return res; } private List&lt;Integer&gt; generateRow(List&lt;Integer&gt; prevRow, int numRows) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1);//第一欄添加1 //注意，numRows等於2的時候，以下for loop不會進入因為 j = 1 , 1 不小於(2-1)，直接到list.add(1) for(int j = 1; j &lt; numRows - 1; j++) { list.add(prevRow.get(j-1) + prevRow.get(j));//前一個row的上一欄與同欄相加。 } list.add(1);//最後一欄添加1 return list; } } 這段程式碼是用來生成帕斯卡三角形（Pascal’s Triangle）的，時間複雜度為 O(n^2)，空間複雜度為 O(n^2)。以下是詳細的分析： 時間複雜度分析： 外層迴圈執行 numRows 次，內層迴圈執行 numRows - 1 次，所以總共執行次數為 (1 + 2 + … + numRows) * (numRows - 1) = numRows^2 - numRows，因此時間複雜度為 O(n^2)。 空間複雜度分析： 程式中建立了一個二維的 List，用來存儲帕斯卡三角形，大小為 numRows * numRows，因此空間複雜度為 O(n^2)。 遞迴寫法 注意！index是由1開始。所以終止條件為numRows == 1 注意！list.add(1)在終止條件增加一次，再做新的row, 也要再添加一次list.add(1); 是因為假設第3層，會跑i= 1 到 i = 2 (3-1) 输入: numRows = 1 输出: [[1]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); generateRow(res, numRows); return res; } private List&lt;Integer&gt; generateRow(List&lt;List&lt;Integer&gt;&gt; res, int numRows) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(numRows == 1) { list.add(1); res.add(list); return list; } list.add(1); List&lt;Integer&gt; prevRow = generateRow(res, numRows - 1); for(int i = 1; i &lt; numRows - 1; i++) { list.add(prevRow.get(i - 1) + prevRow.get(i)); } list.add(1); res.add(list); return list; } } 注意！不能寫成以下方式，因為它只把[1, 4, 6, 4, 1] ，存到res，但實際上，每一次遞迴所產生的 list如下: [1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] 必須在return前把生成的list存在res 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(generateRow(numRows)); return res; } private List&lt;Integer&gt; generateRow(int numRows) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(numRows == 1) { list.add(1); return list; } list.add(1); List&lt;Integer&gt; prevRow = generateRow(res, numRows - 1); for(int i = 1; i &lt; numRows - 1; i++) { list.add(prevRow.get(i - 1) + prevRow.get(i)); } list.add(1); return list; } } 時間複雜度分析： generate() 方法中，調用了 generateRow() 方法 numRows 次，每次 generateRow() 方法的時間複雜度是 O(numRows)，因為每次都要遞歸呼叫 numRows - 1 次，並且在 for 迴圈中遍歷 numRows - 1 次，所以 generate() 方法的時間複雜度為 O(numRows^2)。 空間複雜度分析： generate() 方法中，創建了一個大小為 numRows 的二維動態數組 res，所以 generate() 方法的空間複雜度為 O(numRows^2)。同時，generateRow() 方法中也使用了遞歸，但每次只創建了一個大小為 numRows 的一維動態數組 list，所以 generateRow() 方法的空間複雜度為 O(numRows)。 另一個遞歸寫法(我覺得比較好)，直接回傳List&lt;List&gt; 要思考當numRows=1回傳1 當numRows=2，不要讓它進入for loop，產生二次(for迴圈前與for迴圈後)newRow.add(1) 當numRows=3，只需要進for loop一次，也就i=1 一次，所以要把numRows-1(3-1 = 2)但i=1小於2進入一次，接下來i=2，沒有小於2就會離開迴圈了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(numRows == 1) { res.add(Arrays.asList(new Integer[]{1})); return res; } res = generate(numRows - 1);//抓前面的所有資料 List&lt;Integer&gt; prevRow = res.get(res.size() - 1);//抓最後一筆row的資料 List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;(); newRow.add(1); for(int i = 1; i &lt; numRows - 1; i++) { newRow.add(prevRow.get(i - 1) + prevRow.get(i)); } newRow.add(1); res.add(newRow); return res; } 在這個程式碼中，我們使用遞迴來產生帕斯卡三角形，而這個遞迴函數的執行次數是 numRows，因為我們要生成 numRows行的帕斯卡三角形。對於每一行，我們需要執行 i 次運算，其中 $i$ 是當前行的行號。因此，總的運算次數為： 因此時間複雜度是 O(numRows^2)。 需要注意的是，在這個遞迴函數中，我們建立了一個列表來存儲結果，因此空間複雜度也是 O(numRows^2)。 為什麼空間複雜度是O(numRows^2)，是因為LIst中又在存List嗎 是的，空間复杂度是因为在每一行都存储了一个长度为该行元素个数的列表，而该列表中又存储了该行所有的元素。因此，列表的总长度为1+2+…+numRows，即n*(n+1)/2，也就是O(numRows^2)。 Pascal’s Triangle II 注意！rowIndex是由0開始 Example 1: Input: rowIndex = 3 Output: [1,3,3,1] Example 2: Input: rowIndex = 0 Output: [1] Example 3: Input: rowIndex = 1 Output: [1,1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(rowIndex == 0) {//rowIndex是由0開始 list.add(1); return list; } List&lt;Integer&gt; preRow = getRow(rowIndex - 1); list.add(1); //rowIndex為1的時候不會進入以下for loop for(int i = 1; i &lt; rowIndex; i++) { list.add(preRow.get(i - 1) + preRow.get(i)); } list.add(1); return list; } }"
  },"/pages/c/editor/xcode/": {
    "title": "Xcode",
    "keywords": "",
    "url": "/pages/c/editor/xcode/",
    "body": "輸入Project的名字 選擇要放置的位置，並點選New Folder 輸入新目錄的名稱 要勾不勾git自行決定，按create 點擊main，再按下執行的按鈕"
  },"/pages/jekyll/install/how_to_install_ruby/": {
    "title": "安裝 Ruby on Mac",
    "keywords": "",
    "url": "/pages/jekyll/install/how_to_install_ruby/",
    "body": "打開終端機，輸入下面指令 $brew install ruby 檢查安裝路徑 $brew list ruby homebrew安裝ruby的路徑列表，注意版號是否為3.0以上，目前是3.3.0。 /usr/local/Cellar/ruby/3.3.0/bin/bundle /usr/local/Cellar/ruby/3.3.0/bin/bundler /usr/local/Cellar/ruby/3.3.0/bin/erb /usr/local/Cellar/ruby/3.3.0/bin/gem /usr/local/Cellar/ruby/3.3.0/bin/irb /usr/local/Cellar/ruby/3.3.0/bin/racc /usr/local/Cellar/ruby/3.3.0/bin/rake /usr/local/Cellar/ruby/3.3.0/bin/rbs /usr/local/Cellar/ruby/3.3.0/bin/rdbg /usr/local/Cellar/ruby/3.3.0/bin/rdoc /usr/local/Cellar/ruby/3.3.0/bin/ri /usr/local/Cellar/ruby/3.3.0/bin/ruby /usr/local/Cellar/ruby/3.3.0/bin/syntax_suggest /usr/local/Cellar/ruby/3.3.0/bin/typeprof /usr/local/Cellar/ruby/3.3.0/include/ruby-3.3.0/ (191 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.3.3.dylib /usr/local/Cellar/ruby/3.3.0/lib/pkgconfig/ruby-3.3.pc /usr/local/Cellar/ruby/3.3.0/lib/ruby/ (4276 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.dylib /usr/local/Cellar/ruby/3.3.0/libexec/gembin/ (2 files) /usr/local/Cellar/ruby/3.3.0/share/emacs/site-lisp/ruby/ruby-style.el /usr/local/Cellar/ruby/3.3.0/share/man/ (4 files) /usr/local/Cellar/ruby/3.3.0/share/ri/ (15158 files) 檢查本機ruby的安裝的位置是否與homebrew一致。 $which ruby 我的mac顯示的位置是∶ /usr/bin/ruby 顯然是不一樣，修改環境變數。 $vi ~/.zshrc 添加homebrew 安裝ruby的路徑，注意!以下的位置是你的brew list ruby的路徑，不能直接拷貝我的。 export PATH=\"/usr/local/Cellar/ruby/3.3.0/bin:$PATH\" 修改完.zshrc檔案，在終端機執行以下指令。 $source ~/.zshrc 檢查ruby的路徑是否為homebrew安裝的路徑。 $which ruby"
  },"/pages/c/basic/charType/": {
    "title": "char字元",
    "keywords": "",
    "url": "/pages/c/basic/charType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long char char是正整數，雖然顯示是字元，但實際存放在記憶體位置的資料型態是整數。 char所對映的整數是顯示在瑩幕上的ASCII碼。https://zh.wikipedia.org/zh-tw/ASCII 若輸入單引號''包住的字元，編譯器會自動把單引號包住的字元轉成整數。 比如'a'，記憶體位址存放的十進位值是97，二進位是01100001 整數型態 占用Byte數量 數值範圍 格式符 輸出格式 char 1 0~127 %c 字元 char 1 0~127 %d 整數 字元變數設為數字。 程式碼 1 2 3 char c = 97; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 第一行，直接給整數到c變數。 執行結果 97 a 印出char可用%c格式字串或%d格式字串 1 2 3 char c = 'a'; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 執行結果 97 a int變數設為字元。 在c++中，可以直接給int變數賦值單引號''包住的字元 1 2 3 4 5 int main() { int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; c1 &lt;&lt; endl; return 0; } 執行結果 65 int轉型字元 想印出字元，就把int轉型成char 1 2 int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 執行結果 A 字元運算 也可字元加整數做運算。 1 2 int c1 = 'A' + 2; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 第一行，字元+2。 執行結果 c1=C 字元轉整數 參考https://zh.wikipedia.org/zh-tw/ASCII 字元 ascii code 0 48 1 49 2 50 3 51 4 52 5 53 6 54 7 55 8 56 9 57 字元'0'的ascii code為48 字元'0'到'9'的ascii code - 48 = 整數0到9 舉個例子，'9'的ascii code是57，'0'的ascii code為48， 57 - 48 = 整數9 而char屬於整數，可以直接用字元相減，'9' - '0' = 9 字元'0'到'9'減'0'，則會變成整數0-9。 1 2 3 4 int main() { int num = '9' - '0'; cout &lt;&lt; num &lt;&lt; endl; } 9 大小寫轉換 字元 ascii code 字元 ascii code a 97 A 65 b 98 B 66 c 99 C 67 d 100 D 68 e 101 E 69 f 102 F 70 從上表可以發現小寫的ascii code與大寫的ascii code中間的差距是32。 97 - 65 = 32 98 - 66 = 32 99 - 66 = 32 小寫轉大寫 1 2 char upper = 'a' - 32; cout &lt;&lt; upper &lt;&lt; endl; A 大寫轉小寫 1 2 char lower = 'A' + 32; cout &lt;&lt; lower &lt;&lt; endl; a 判斷字母區間 判斷0-9 1 2 char c = 'A'; if (c &lt; '0' || c &gt; '9') cout &lt;&lt; \"不是數字\" &lt;&lt; endl; 不是數字 判斷a-z 1 2 char c = 'A'; if (c &lt; 'a' || c &gt; 'z') cout &lt;&lt; \"不是小寫字母\" &lt;&lt; endl; 不是小寫字母 判斷A-Z 1 2 char c = 'a'; if (c &lt; 'A' || c &gt; 'Z') cout &lt;&lt; \"不是大寫字母\" &lt;&lt; endl; 不是大寫字母 跳脫字元 重要有以下幾種 Ascii碼 跳脫字元 描述 0 \\0 空，字元變數可設定0 9 \\t TAB鍵對齊 10 \\n 換行 13 \\r 移動到最前面 設定空字元 1 2 char c4 = 0; cout &lt;&lt; \"c4=\" &lt;&lt; c4 &lt;&lt; endl; 執行結果 c4= 關於斜線 因為\"與'與\\，被編譯器作為以下用途。 \"\"，把字串包起來。 ''，把字元包起來。 \\，換行\\n 所以不能直接使用\"與'與\\，必須加上\\“與\\‘與\\\\。 雙引號 1 2 3 char c2 = '\"'; cout &lt;&lt; \"c2=\" &lt;&lt; c2 &lt;&lt; endl; cout &lt;&lt; \"我說，\\\"跑!\\\"\" &lt;&lt; endl; 第1行，當作字元的雙引號，前面不用加斜線'\\\"'，直接寫雙引號就可以'\"'。 第3行，當作字串中的的雙引號，前面要加斜線。 執行結果 c2=\" 我說，\"跑!\" 單引號 1 2 3 char c3 = '\\''; cout &lt;&lt; \"c3=\" &lt;&lt; c3 &lt;&lt; endl; cout &lt;&lt; \"我說，'跑!'\" &lt;&lt; endl; 第1行，當作字元的單引號，前面要加斜線'\\''。 第3行，當作字串中的的單引號，前面不用加斜線。 執行結果 c3=' 我說，'跑!'"
  },"/pages/c/basic/printformat/": {
    "title": "整數與浮點數",
    "keywords": "",
    "url": "/pages/c/basic/printformat/",
    "body": "整數 整數資料型態 整數型態 占用Byte數量 格式字串 取值範圍 int 4 %d -2,147,483,648 至 2,147,483,647 unsinged int 4 %u 0 到 4,294,967,295 short 2 %hd -32,768 至 32,767 unsinged short 2 %hu 0 到 65,535 long 4 %ld -2,147,483,648 至 2,147,483,647 unsinged long 4 %ud 0 到 18,446,744,073,709,551,615 long long 8 %lld -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 unsinged long long 8 %llu 0 到 18,446,744,073,709,551,615 整數相除，去掉小數點，只留正數，不會四捨五入 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; 8/5 &lt;&lt; endl; 執行結果 8/5 = 1 運算式中有低精準度與高精準度，低精準度會自動轉成高精準度，不需要強制轉型。 1 2 3 4 char c7 = 97; int i1 = 25; long long llong1 = 150000000000; cout &lt;&lt; \"97 + 25 + 150000000000 = \" &lt;&lt; c7 + i1 + llong1 &lt;&lt; endl; 執行結果 97 + 25 + 150000000000 = 150000000122 等號(=)左邊是高精準度，右邊是低精準度，低精準度會自動轉成高精準度，不需要強制轉型。 1 2 3 char c7 = 97; int i2 = c7; cout &lt;&lt; \"i2 = \" &lt;&lt; i2 &lt;&lt; endl; 執行結果 i2 = 97 等號(=)左邊是整數，右邊是浮點數，浮點數小數點直接去掉，轉換成整數。 1 2 int i3 = 23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 等號(=)右邊超出範圍。 unsigned int最大的值是4294967295。 1 2 3 4 5 6 unsigned int ui1 = 4294967295; unsigned int ui2 = 4294967295 + 1; unsigned int ui3 = 4294967295 + 2; cout &lt;&lt; \"ui1 = \" &lt;&lt; ui1 &lt;&lt; endl; cout &lt;&lt; \"ui2 = \" &lt;&lt; ui2 &lt;&lt; endl; cout &lt;&lt; \"ui3 = \" &lt;&lt; ui3 &lt;&lt; endl; 執行結果 ui1 = 4294967295 ui2 = 0 ui3 = 1 unsigned int最大的值是4294967295，若超出的二進位會被去掉。 超出的二進位 二進位 十進位 輸出結果   11111111 11111111 11111111 11111111 4294967295 4294967295 00000001 00000000 00000000 00000000 00000000 4294967295 + 1 0 00000001 00000000 00000000 00000000 00000001 4294967295 + 2 1 強制轉型 使用強制轉型編譯器不會出現警告。 語法 (資料型態)值、變數、常數、運算式 1 2 int i3 = (int)23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 1 cout &lt;&lt; \"(double)8/5 = \" &lt;&lt; (double)8/5 &lt;&lt; endl; 執行結果 (double)8/5 = 1.6 括號的優先級別比較高 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; (double)(8/5) &lt;&lt; endl; 執行結果 8/5 = 1 以上程式碼先執行(8/5)，也就是整數相除會直接去掉小數點，變成1，1再轉成double資料型態。 整數資料型態都可以使用%d印出，只是印出的精準度不同。 浮點數 浮點數資料型態 有效數字是指準確度的數字，例如float，有7位數字會是正確的，超過7位以上，第8位以後就會不正確。 有效數字範圍:包含小數點前面與後面的所有數字。 浮點數型態 占用Byte數量 格式字串 有效數字範圍 float 4 %f 7位有效數字 double 8 %lf 15-16位有效數字 long double 不少於double %Lf 不少於double 數字有小數點就視為double資料型態 1 2 cout &lt;&lt; \"size of int = \" &lt;&lt; sizeof(8) &lt;&lt; endl; cout &lt;&lt; \"size of double = \" &lt;&lt; sizeof(8.0) &lt;&lt; endl; 執行結果 size of int = 4 size of double = 8 數字最後面有f視作float資料型態 1 cout &lt;&lt; \"size of float = \" &lt;&lt; sizeof(8.0f) &lt;&lt; endl; 執行結果 size of float = 4 float格式字串輸出 1 2 3 float f1 = 3.8f; printf(\"f1 = %f \\n\", f1); printf(\"f1 = %.2f \\n\", f1); 執行結果 f1 = 3.800000 f1 = 3.80 double格式字串輸出 1 2 3 4 float f1 = 3.8; double d1 = 3.8; printf(\"f1 = %f , d1 = %f , d1 = %lf\\n\", f1, d1, d1); printf(\"f1 = %.2f , d1 = %.2f , d1 = %.2lf\\n\", f1, d1, d1); 執行結果 f1 = 3.800000 , d1 = 3.800000 , d1 = 3.800000 f1 = 3.80 , d1 = 3.80 , d1 = 3.80 運算式中有浮點數，其它整數會自動轉型浮點數，不需要強制轉型。 1 cout &lt;&lt; \"8.0/5 = \" &lt;&lt; 8.0/5 &lt;&lt; endl; 執行結果 8/5 = 1.6 有效位數 float有效位數 1 2 float f1 = 123456789.123f;//float 有效數字範圍為7位 printf(\"f1 = %f \\n\", f1); 執行結果 f1 = 123456792.000000 從執行結果可以發現第8位以後數字就不正確。 double有效位數 1 2 double d1 = 123456789.123456789; printf(\"d1 = %lf \\n\", d1); 執行結果 d1 = 123456789.123457 從執行結果可以發現小數點第6位以後數字就不正確。 long dobule有效位數 1 2 long double Ld1 = 123456789.123456789; printf(\"Ld1 = %Lf \\n\", Ld1); 執行結果 Ld1 = 123456789.123457 從執行結果可以發現跟double的結果相同，long double取決於系統是Linux/Mac/Windows，會呈現不同結果。"
  },"/pages/c/basic/scope/": {
    "title": "變數可見範圍與生命週期",
    "keywords": "",
    "url": "/pages/c/basic/scope/",
    "body": "可見範圍(Scope)與生命週期(Lifetime) 區域變數 一對花括號{}包起來的就是程式碼區塊(block)或函式主體(Body)。程式碼區塊可以是if (){}或while(){}的程式碼區塊，但這篇要探討的是只有花括號{}包起來的程式碼區塊。 1 2 3 4 5 6 7 8 9 int main() { int var11 = 100; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 outer var11 = 100 第3行至第6行 在程式碼區塊中{}，所定義的變數都是區域變數，離開{}區塊就不能再讀取了，因為{}區塊中的區域變數已經被系統回收掉。可以想像{}就像是函式一樣。在函式中，函式中定義的變數都是區域變數，離開函式就不能被外部讀取區域變數，因為區域變數已經被系統回收了。 外部變數 在{}區塊中，可以讀取外部變數 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int var11 = 100; int var12 = 200; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; //在`{}`區塊中，可以讀取外部變數 cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 在程式區塊中{}無法讀取同名的外部變數 因為在{}區塊中，同名的外部變數會先被暫時隱藏，直到程式執行時離開{}區塊，區塊內的區域變數被系統回收掉，同名的變數就會將記憶體位置指向外部變數。 程式區塊中{}讀取跟區域變數同名的全域變數 使用::可以讀取全域變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //定義全域變數var11 int var11 = 100; int main() { //定義區域變數var11 int var12 = 200; { //印出區域變數var11 int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; //印出全域變數var11 cout &lt;&lt; \"outer var11 = \" &lt;&lt; ::var11 &lt;&lt; endl; } return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 for程式區塊中的區域變數 變數i的有效範圍，只有在{}程式區塊中，離開{}程式區塊，區域變數i就無法在外部讀取。 1 2 3 for (int i = 0; i &lt; 10; i++) { } 若要變數i也可以在外部使用，可把變數i放在外部。 1 2 3 4 int i = 0; for (; i &lt; 10; i++) { } cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; 執行結果 i = 10 虛擬碼 可以在程式區塊寫虛擬碼，進行驗證，作為之後正式的函式使用。 以下程式碼是在寫參數為指標，將指標宣告記憶體空間。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 { int** pp = &amp;p;//存放指標的位址，要用雙指標 *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } //印出p指標的位址，去p指標的記憶體位址取值，並印出來 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第6行，去雙指標pp的記憶體位址取值，取出來是p的指標記憶體位址，使用new來分配動態配置記憶體空間，並且設值”3”，動態配置完成會傳回記憶體位址，由指標去存位址。 執行結果 p=0x60000000c000,*p=3 虛擬碼執行成功後，將{}程式碼區塊移到main()函式之外，並宣告成函式。 1 2 3 4 5 6 7 8 9 10 11 void initMemory(int** pp) //存放指標的位址，要用雙指標 { *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 initMemory(&amp;p);//指標的位址傳入函式。 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 p=0x600000008030,*p=3"
  },"/pages/c/editor/cmake/": {
    "title": "Cmake on Mac",
    "keywords": "",
    "url": "/pages/c/editor/cmake/",
    "body": "前往下載Cmake 解壓好放在應用程式中 打開CMAKE 按照下圖，選擇Tool-&gt;How to Install For Command Line Use 將以下紅框的部分複製，打開終端機，貼上 貼上後再輸入以下指令 $which cmake 再輸入以下指令 $cmake --version 切記，把版本資訊記起來，如我的版本資訊是cmake version 3.27.5 在你所在.cpp的目錄下建立build目錄 跟build目錄同階層建立CMakeLists.txt的文件 在CMakeLists.txt的文件中輸入以下內容 #VERSION編號是之前查詢的 cmake_minimum_required(VERSION 3.27.5) #第一參數為Project名稱 #Project的版本是1.0.0 project(CPPLessons VERSION 1.0.0) #第一個參數是Project名稱 第二個參數為所使用的cpp add_executable(CPPLessons test.cpp Student.cpp) 建立檔案，依xcode為例，在工作列按滑鼠右鍵，選”New File” 依照下圖建立頭文件 再來建立cpp文件 記得不要勾選要建立頭文件 在test.cpp輸入以下內容 1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; #include \"test.h\" int main() { int a[] = {1,2,3,4}; printf(\"cmake test\"); int b[] = {7,8,9,100}; printf(\"cmake test2\"); return 0; } 打開終端機，進入build的目錄 輸入以下內容(要在build的目錄下做喔) cmake .. 產生以下資訊 輸入make make 輸入./CPPLessons 測試成功"
  },"/pages/c/editor/supportc11/": {
    "title": "Xcode支援C++11以上",
    "keywords": "",
    "url": "/pages/c/editor/supportc11/",
    "body": "選擇專案名 選擇Build Settings 選擇Apple Clang 選擇C++ Language Dialect"
  },"/pages/c/editor/vscode/": {
    "title": "VS on Mac",
    "keywords": "",
    "url": "/pages/c/editor/vscode/",
    "body": "可以參考其它人的影音檔。 https://www.youtube.com/watch?v=iIPST6HQgSc 參考文章 Visual Studio on macOS Using Clang in Visual Studio 若code.沒反應 code . is not working in on the command line for Visual Studio on OS X/Mac"
  },"/pages/c/template/class_template/": {
    "title": "類別模板",
    "keywords": "",
    "url": "/pages/c/template/class_template/",
    "body": "語法 宣告模板 宣告資料型態參數 資料型態參數名 逗號 template &lt; class T1 , class T2&gt; 宣告模板從關鍵字template開始，後接資料型態參數列表（template parameter list），資料型態參數是以class開頭，後接資料型態參數名(T1)。資料型態參數列表是用尖括號括住的一個資料型態參數或者多個資料型態參數，資料型態參數之間以逗號分隔。class也可以用typename互相替換。 宣告類別模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template &lt;class K, class V&gt; class MyMap{ public: MyMap(){} MyMap(K key1, V value1):key(key1),value(value1){} K getKey(){ return key; } V getValue(){ return value; } private: K key; V value; }; 第1行，template為類別模板宣告，&lt;class K, class V&gt;資料型態參數宣告(type parameter)。 第2行，類別模板的名稱為MyMap。 第5行，建構式，初始私有成員key與value。 第6行，取得私有成員key。 第9行，取得私有成員value。 第13行，私有成員key。 第14行，私有成員value。 使用類別模板 1 2 3 4 5 6 7 8 9 10 int main() { MyMap&lt;int,string&gt; myMap(3, \"test\"); cout &lt;&lt; \"myMap key=\" &lt;&lt; myMap.getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap value=\" &lt;&lt; myMap.getValue() &lt;&lt; endl; MyMap&lt;string, string&gt; *myMap_P1 = new MyMap&lt;string,string&gt;(\"abc\",\"def\"); cout &lt;&lt; \"myMap_P1 key=\" &lt;&lt; myMap_P1-&gt;getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap_P1 value=\" &lt;&lt; myMap_P1-&gt;getValue() &lt;&lt; endl; return 0; } 第2行，建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為int，V的資料型態為string，呼叫二個參數的建構式。 第3行，印出值。 第4行，印出值。 第6行，動態配置建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為string，V的資料型態為string，使用new動態配置建立物件，( “abc”,”def”)呼叫二個參數的建構式。 第7行，使用-&gt;印出值。 第8行，使用-&gt;印出值。"
  },"/pages/c/template/stack_template/": {
    "title": "Stack實作(int Array)",
    "keywords": "",
    "url": "/pages/c/template/stack_template/",
    "body": "Stack int陣列實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Stack{ private: int *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new int[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const int&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(int&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; 第3行，私有成員屬性items，資料型態為int指標，指向int陣列的第0筆位址。 第4行，私有成員屬性stacksize，資料型態為int，存放stack最大的容量。 第5行，私有成員屬性top，資料型態為int，記錄目前stack最頂端的index位置。 第8行，建構式，初始化成員stacksize與top。 第10行，動態配置int陣列。 第12行，解構式。 第13行，從記憶體回收items的空間。 第14行，將回收的空間指向null。 第20行，若top位置在0，表示為空。 第25行，若top位置在stacksize代表空間已滿。 第31行，函式是將item推入stack，參數為參考資料型態。 第33行，目前stack最頂端的index位置小於stack最大容量就做if的區塊。 第34行，先做items[top] = item的動作，再做top++的動作。 第42行，參數為參考資料型態，stack彈出頂端的值暫時放置的變數。 第44行，先將top–的動作，再做items[top]的動作。 使用Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } 第2行，建立stack物件，最大存放數量為5。 第3~7行，依序塞入1~5。 第8行，宣告暫時存放變數item。 第9行，若stack不為空就進入循環。 第10行，將stack的頂端拿出來，放在變數item。 第11行，印出item。 執行結果 item = 5 item = 4 item = 3 item = 2 item = 1 Stack typedef實作 將上面的程式修改成自訂資料型態DataType。以下有黃色的部分是有變更的程式碼。 typedef int DataType; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); DataType item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } Stack 模板實作 將上面的程式再修改成模板，以下有黃色的部分是有變更的程式碼。 template &lt;class DataType&gt; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack&lt;int&gt; myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; }"
  },"/pages/c/basic/typicalRange/": {
    "title": "資料型態範圍",
    "keywords": "",
    "url": "/pages/c/basic/typicalRange/",
    "body": "記憶體的最小單位為bit，每一個bit可以存0或1，32位元電腦的cpu有32個bit(4byte)的存放區塊可以存放記憶體位址。 位元bit與位元組byte bit正整數範圍 以下列出1到8個bit可以存放的最大正整數值與正整數範圍。 以下減1代表扣掉0這個數字。 bit 組合 最大正整數(2進制) 最大正整數(10進制) 可以存放的正整數範圍 1 0/1 1 \\(2^1-1 = 1\\) 0-1 2 00/01/10/11 11 \\(2^2-1 = 3\\) 0-3 3 000/001/010/100/110/101/111 111 \\(2^3-1 = 7\\) 0-7 4 0000/0001/0010…1111 1111 \\(2^4-1 = 15\\) 0-15 5 00000/00001/…11111 11111 \\(2^5-1 = 31\\) 0-31 6 000000/000001/…111111 111111 \\(2^6-1 = 63\\) 0-63 7 0000000/0000001/…1111111 1111111 \\(2^7-1 = 127\\) 0-127 8 00000000/00000001/…11111111 11111111 \\(2^8-1 = 255\\) 0-255 byte正整數範圍 由上表可以推斷，1個byte由8個bit組成，可存放最大正整數為255，可以存放的正整數範圍從0-255，共256個數字。 以下列出1byte到4byte最大可存放的數字。 byte bit 最大正整數(10進制) 1byte 11111111 255 2byte 11111111 11111111 65535 3byte 11111111 11111111 11111111 16777216 4byte 11111111 11111111 11111111 11111111 4294967295 科學記號法顯示，以下減1代表扣掉0這個數字。 byte bit 科學記號法 1byte 11111111 $2^8-1$ 2byte 11111111 11111111 $2^8 * 2^8 -1= 2^{8+8}-1 = 2 ^{16}-1 $ 3byte 11111111 11111111 11111111 $2^8 * 2^8 * 2^8-1 = 2^{8+8+8}-1$ 4byte 11111111 11111111 11111111 11111111 $2^8 * 2^8 * 2^8 * 2^8-1 = 2^{8+8+8+8}-1 = 2 ^{32}-1 $ 正負數 負數2的補數 若資料型態是包含正負數，會將最大整數減半。 在 8-bit 下，把\\(2^8 = 256\\)切一半，正整數 0 - 127 共 128 個正整數，負數 -1 至 -128 共 128個負數，128 正整數 + 128 負數 = 256個數字。 正整數二進位表示方式，最左邊的第1個bit為0，代表正整數。 負數的表示方式，最左邊的第1個bit為1，代表負數，把正整數的二進位0和1互換，再加上1。 二進位 正負數 01111111 127 10000001 -127 01111111 11111111 32767 10000000 00000001 -32767 01111111 11111111 11111111 8388607 10000000 00000000 00000001 -8388607 01111111 11111111 11111111 11111111 2147483647 10000000 00000000 00000000 00000001 -2147483647 正負數範圍 把二進位最左邊的1個byte作為正負數符號，0表示正整數，1表示負數，因此有1個bit會變成正負符號， 8 bit中，只能用剩下7 bit存放數值，因此正數範圍變成$2^7 - 1$，減1代表扣掉0這個數字。 正整數 正整數二進位表示方式，最左邊的第1個bit為0，代表正整數。 以下是最大正整數，減1代表扣掉0這個數字。 byte bit 科學記號法 1byte 01111111 $2^7-1 = 127 $ 2byte 01111111 11111111 $2^7 * 2^8 -1= 2^{7+8}-1 = 2 ^{15}-1 = 32767$ 3byte 01111111 11111111 11111111 $2^7 * 2^8 * 2^8-1 = 2^{7+8+8}-1 = 2 ^{23}-1 = 8388607 $ 4byte 01111111 11111111 11111111 11111111 $2^7 * 2^8 * 2^8 * 2^8-1 = 2^{7+8+8+8}-1 = 2 ^{31}-1 = 2147483647 $ 負數 最左邊的第1個bit為1，代表負數，以下為最小負數。 byte bit 科學記號法 1byte 10000000 $-2^7 = -128 $ 2byte 10000000 00000000 $-2^7 * -2^8 = -2^{7+8} = -2 ^{15} = -32768$ 3byte 10000000 00000000 00000000 $-2^7 * -2^8 * -2^8 = -2^{7+8+8} = -2 ^{23} = -8388608 $ 4byte 10000000 00000000 00000000 00000000 $-2^7 * -2^8 * -2^8 * -2^8 = -2^{7+8+8+8} = -2 ^{31} = -2147483648 $ 正負數範圍 占用Byte數量 正負數範圍 科學記號法 1byte -128 至 -1 ~ 0 至 127 $-2^7$ 至 $2^7 - 1$ 2byte -32768 至 -1 ~ 0 至 32767 $-2 ^{15}$ 至 $2 ^{15} - 1$ 3byte -8388608 至 -1 ~ 0 至 8388607 $-2 ^{23}$ 至 $2 ^{23} -1$ 4byte -2147483648 至 -1 ~ 0 至 2147483647 $-2 ^{31}$ 至$2 ^{31} - 1$ unsinged正整數 unsigned代表沒有符號，所以只有正整數，不會有負號。 占用Byte數量 正數範圍 1byte 0~255 2byte 0~65535 3byte 0~16777216 4byte 0~4294967295"
  },"/pages/c/basic/boolType/": {
    "title": "bool",
    "keywords": "",
    "url": "/pages/c/basic/boolType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long 整數型態 占用Byte數量 數值範圍 格式字串 輸出格式 bool 1 0 1 %d 整數 0是false，非0為true。 1 2 3 bool b3 = '0'; bool b4 = 0; cout &lt;&lt; \"b3=\" &lt;&lt; b3 &lt;&lt; \",b4=\" &lt;&lt; b4 &lt;&lt; endl; 執行結果 b3=1,b4=0 可使用true跟false設定bool變數 編譯器會自動把true翻譯成整數1，false翻譯成整數0。 1 2 bool b1 = true, b2 = false; cout &lt;&lt; \"b1=\" &lt;&lt; b1 &lt;&lt; \",b2=\" &lt;&lt; b2 &lt;&lt; endl; 執行結果 b1=1,b2=0 bool整數運算 因為bool是整數，所以bool能做整數運算。但bool顯示出來只會是0或1，即便設的值是2，顯示出來的值仍是1。 1 2 3 4 bool b5 = 1; bool b6 = 2; cout &lt;&lt; \"b5 = \" &lt;&lt; b5 &lt;&lt; \", b6 = \" &lt;&lt; b6 &lt;&lt; endl; cout &lt;&lt; \"b5 + b6 = \" &lt;&lt; b5 + b6 &lt;&lt; endl; 執行結果 b5 = 1, b6 = 1 b5 + b6 = 2 cin只能輸0或1，不能輸入true或false 1 2 3 bool b7; cin &gt;&gt; b7; cout &lt;&lt; \"b7 = \" &lt;&lt; b7 &lt;&lt; endl; 執行結果 1 b7 = 1 執行結果 true b7 = 0 證明bool為整數 1 2 3 4 bool b8 = false; char* c5 = (char*)&amp;b8; *c5 = 8; cout &lt;&lt; \"b8 = \" &lt;&lt; b8 &lt;&lt; endl;"
  },"/pages/c/dynamicMemory/memoryLayout/": {
    "title": "記憶體配置",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memoryLayout/",
    "body": "記憶體起始與結束位址。 記憶體開始位址由下表最下方開始，記憶體結束位址在最上方。 開始與結束 位址高低 位址 結束 高 0xFFFFFFFF 0xFFFFFFFE 0xFFFFFFFD 0xFFFFFFFC &#8593; ...... ...... ...... ...... 低 0x00000004 0x00000002 0x00000001 開始0x00000000 記憶體區段 記憶體區段根據位址由高到低分別為Kernel, Stack, 尚位使用區域, Heap, bass, data, code。 位址高低 記憶體區塊 位址成長方向 儲存項目 高 Kernel 作業系統核心 &#8593; Stack &#8595; 區域變數 尚未使用區域 Heap &#8593; 動態配置記憶體 bss segment 未初始化全域變數, 靜態變數 data segment 已初始化全域變數, 靜態變數 低 code segment 常數與程式執行檔 作業系統核心 處理cpu記憶體Devices與應用程式運作。 stack(堆疊) 儲存區域變數的記憶體區塊 儲存區域變數與函式參數與函式傳回值，記憶體大小只有8M，記憶體位址成長的方向是向下成長。 Heap(堆積) 儲存動態配置變數的記憶體區塊 儲存由動態配置(new與malloc)產生的變數，記憶體大小取決電腦實體記憶體大小(可能8GB或更大)，記憶體位址成長的方向是向上成長。 bss segment 記憶體區塊 儲存未初始化全域變數與靜態變數。 data segment 記憶體區塊 儲存已初始化全域變數與靜態變數。 code segment 記憶體區塊 儲存常數與程式執行檔。 變數記憶體位址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;stdio.h&gt; const int global_x = 1; // 儲存於 code segment(常數) int global_y = 1; // 儲存於 data segment(已初始化全域變數） int global_z; // 儲存於 bss(未初始全域變數) int fun1(int param1) { // 儲存於 stack (函式參數) return param1; // 儲存於 stack (函式傳回值) } int main() { const static int x = 1; // 儲存於 code segment(常數) static int y = 1; // 儲存於 data segment(已初始化靜態變數） static int z; // 儲存於 bss(未初始靜態變數) int w = 1; // 儲存於 stack (區域變數) fun1(w); // 儲存於 heap (動態分配指標) char *buf = (char*) malloc(sizeof(char) * 100); // ... free(buf); int* p = new int(3); // 儲存於 heap (動態分配指標) delete p; return 0; } Stack 儲存在Stack的變數，變數離開有效範圍(Scope)後，會由系統自動回收記憶體位址。 Stack記憶體容量8M。 記憶體位址向下成長。 不會memory leak。 以下程式碼在函式中建立三個變數，並觀察三個變數的記憶體位址是由大至小遞減。證明記憶體位址向下成長。 1 2 3 4 5 6 7 8 void funcMemoryLocation() { int var1 = 10; int var2 = 20; int var3 = 30; cout &lt;&lt; \"va1 = \" &lt;&lt; (long long)&amp;var1 &lt;&lt; endl; cout &lt;&lt; \"va2 = \" &lt;&lt; (long long)&amp;var2 &lt;&lt; endl; cout &lt;&lt; \"va3 = \" &lt;&lt; (long long)&amp;var3 &lt;&lt; endl; } 執行結果 va1 = 140702053822444 va2 = 140702053822440 va3 = 140702053822436 Heap 儲存動態配置(new與malloc)產生的變數，由程式設計師手動回收記憶體位址，或待主程式生命周期結束後被系統回收記憶體位址。 Heap記憶體容量取決於電腦的記憶體大小。 記憶體位址向上遞增。 會memory leak。 以下程式碼動態分配建立三個變數，並觀察三個變數的記憶體位址是由小至大增長。證明動態分配記憶體位址向上成長。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int* p1 = new int(10); int* p2 = new int(20); int* p3 = new int(30); cout &lt;&lt; \"p1 address = \" &lt;&lt; (long long)p1 &lt;&lt; endl; cout &lt;&lt; \"p2 address = \" &lt;&lt; (long long)p2 &lt;&lt; endl; cout &lt;&lt; \"p3 address = \" &lt;&lt; (long long)p3 &lt;&lt; endl; delete p1; delete p2; delete p3; p1 = nullptr; p2 = nullptr; p3 = nullptr; return 0; } 執行結果 p1 address = 105553116315664 p2 address = 105553116315680 p3 address = 105553116315696 尚未使用區域 變數在Stack記憶體區塊，位址增長的方向是向下，變數在Heap記憶體區塊，位址增長的方向是向上，未避免Stack與Heap的記憶體位址成長時互相交疊，中間有一個區域是分隔Stack與Heap。"
  },"/pages/c/conversion/explicit/": {
    "title": "強制轉型",
    "keywords": "",
    "url": "/pages/c/conversion/explicit/",
    "body": "基本類型的強制轉型 將等號(=)右邊的值強制轉型，明確告訴編譯器等號(=)右邊的值的資料型態。 1 int a = (int)8.3; 另一種強制轉型的方式，將值放在括號中()。 1 int a = int(8.3);"
  },"/pages/c/conversion/implicit/": {
    "title": "自動轉型",
    "keywords": "",
    "url": "/pages/c/conversion/implicit/",
    "body": "編譯器根據等號(=)左邊的變數資料型態，決定調用那個轉型函式。 1 int a = 8.3; 等號(=)左邊的變數資料型態是int，等號(=)右邊的值是double，編譯器根據等號(=)左邊的變數資料型態int，把等號(=)右邊的資料型態double轉成int。"
  },"/pages/c/pointer/pointer/": {
    "title": "指標基本觀念",
    "keywords": "",
    "url": "/pages/c/pointer/pointer/",
    "body": "變數位址 每個變數系統會分配”一塊”記憶體位址存放變數，位址通常是用16進制表示。 變數占用的記憶體大小，根據變數的資料型態決定。 假設有一個int資料型態的變數i，占用記憶體4 byte，變數i占的開始位址0x00000008至結束位址0x0000000B，總共占4Byte。 int i = 55; 記憶體開始與結束記憶體位址占用記憶體位址範圍 結束0xFFFFFFFF &#8593;...... 0x0000000E 0x0000000D 0x0000000C 0x0000000Bint i = 55; 0x0000000A 0x00000009 0x00000008 0x00000007 0x00000006 0x00000005 0x00000004 0x00000003 0x00000002 0x00000001 開始0x00000000 取出變數的開始記憶體位址 取位址運算子&amp; &amp;變數 在變數前面加上&amp;可以取出變數的開始記憶體位址，如上一個表格中的例子，變數i的開始位址是0x00000008。 1 2 3 4 5 6 7 int main() { int a = 0; double b = 10.5; cout &lt;&lt; \"變數a位址 = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"變數b位址 = \" &lt;&lt; &amp;b &lt;&lt; endl; return 0; } 執行結果 變數a位址 = 0x7ff7bfeff468 變數b位址 = 0x7ff7bfeff460 指標是一種變數，存放的內容是位址。 以下為宣告一個i1的整數變數，初始值為10。 1 int i1 = 10; 指標變數存放的內容是位址，以下為宣告一個p1的指標變數，存放i1的開始位址。 1 int* p1 = &amp;i1; 指標的大小8byte 指標變數的大小8byte，使用sizeof(指標變數)可以取得指標的大小，不管是什麼資料型態的指標，佔用記憶體的大小全部為8byte。 1 cout &lt;&lt; sizeof(p1) &lt;&lt; endl; 執行結果 8 位址放入指標變數 指標存放的內容是位址，所以要先取得變數的開始位址，再放入指標變數中，使用&amp;可以取得變數開始位址。 1 2 3 4 5 6 7 int main() { int i1 = 10; int* p1 = &amp;i1; cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; return 0; } 第2行，宣告i1整型變數。 第3行，宣告p1整型指標變數，使用取位址運算子&amp;，取出i1變數的記憶體開始位址，將位址放入p1指標。 第4行，印出i1的位址。 第5行，印出p1所存放的內容。 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 從執行結果可以發現，印出的結果是一樣。 宣告指標的各種寫法 宣告指標可以把*放置在變數前面或資料型態後面或資料型態與變數中間，以下都是正確的。 一行宣告一個指標 1 2 3 4 5 6 7 8 9 10 11 int main() { int i1 = 10; int *p1 = &amp;i1; //*在變數前面 int* p2 = &amp;i1; //*在資料型態後面 int * p3 = &amp;i1; //*在資料型態與變數中間 cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; \"p2存放的位址 =\" &lt;&lt; p2 &lt;&lt; endl; cout &lt;&lt; \"p3存放的位址 =\" &lt;&lt; p3 &lt;&lt; endl; return 0; } 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 p2存放的位址 =0x7ff7bfeff468 p3存放的位址 =0x7ff7bfeff468 一行同時宣告多個指標 1 2 3 4 5 6 7 #include &lt;iostream&gt; using namespace std; int main() { char* ptr1,* ptr2,* ptr3; char *ptr4, *ptr5, *ptr6; return 0; } 一行同時宣告指標與整數變數(容易搞混淆的宣告) 1 2 3 4 5 6 7 8 int* p4, num3; //p4是指標 p4 = &amp;ii; //num3為int資料型態的變數 num3 = 20; cout &lt;&lt; \"p4 位址=\" &lt;&lt; p4 &lt;&lt; endl; cout &lt;&lt; \"p4 值=\" &lt;&lt; *p4 &lt;&lt; endl; cout &lt;&lt; \"num3 值=\" &lt;&lt; num3 &lt;&lt; endl; 執行結果 p4 位址=0x7ff7bfdff274 p4 值=10 num3 值=20 取值運算子* 取值運算子*是取得位址中存放的值。指標存放位址，指標也就等於位址。 *指標 以上語法為，取出位址中存放的值，而指標就是位址。 1 2 3 4 5 6 int main() { int i1 = 10; int *p1 = &amp;i1; //將i1變數的位址存到p1指標變數 cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; //取出位址存放的值。 return 0; } 執行結果 取出p1位址的值 = 10 修改位址存放的值* *指標 = 修改的內容 把*放在指標變數前面，就可以在等於(=)後面放入要修改的內容。 1 2 3 4 5 6 7 8 9 10 int main() { int i1 = 10; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; int *p1 = &amp;i1; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; *p1 = 20; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; return 0; } 第6行，把*放在指標變數p1前面，等於(=)後面放入要修改的內容20。 執行結果 取出i1的值 = 10 取出p1位址的值 = 10 取出p1位址的值 = 20 指標資料型態要與值一致 指標是存放位址，不能存放不是位址的值，會編譯錯誤。 1 2 3 4 5 int main() { int i1 = 10; int *p1 = i1; return 0; } 第2行，i1變數是整數10。 第3行，把10塞入指標，因為指標是存放位址，不能放10這個整數，產生編譯錯誤。 印出位址 十六進制 以下的方式印不出char變數的位址。 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; &amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = a 使用(void*)就可以印出16進制的位址 (void*)指標變數 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = 0x7ff7bfeff46b 十進制 (long long)指標變數 因為int只有4byte，位址轉成int整數會超出範圍，使用long long 8byte，就不會有超出數值範圍的問題。 c語言 printf(\"%#x\",指標變數); 使用%#x格式字串就可印出16進制的記憶體位址。 程式碼範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int i1 = 10; int *p1 = &amp;i1; cout &lt;&lt; \"16進制 &amp;i1 = \" &lt;&lt; (void*)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"16進制 p1 = \" &lt;&lt; (void*)p1 &lt;&lt; endl; cout &lt;&lt; \"10進制 &amp;i1 = \" &lt;&lt; (long long)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"10進制 p1 = \" &lt;&lt; (long long)p1 &lt;&lt; endl; printf(\"c語言 &amp;i1 = %#x \\n\",&amp;i1); printf(\"c語言 p1 = %#x \\n\",p1); return 0; } 執行結果 16進制 &amp;i1 = 0x7ff7bfeff468 16進制 p1 = 0x7ff7bfeff468 10進制 &amp;i1 = 140702053823592 10進制 p1 = 140702053823592 c語言 &amp;i1 = 0xbfeff468 c語言 p1 = 0xbfeff468 指標資料型態 指標的資料型態要與記憶體位址中的內容相符。 1 2 3 4 int i = 10; int* p1 = &amp;i; double d = 15.5; double* p2 = &amp;d;"
  },"/pages/c/function/func_param/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/function/func_param/",
    "body": "Prerequisites: 引數 指標參數 函式的參數是指標，代表參數是位址。指標參數語法為資料型態* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是位址，代表可以透過取值運算子*,取出位址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(位址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //函式的參數是指標，代表參數是位址 void func1(int* param1) { //透過取值運算子*,取出位址存放的內容 cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; //使用`*指標 = 修改內容`，修改指標的內容 *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; //使用取位址運算子&amp;，取出var1變數的記憶體開始位址，將位址作為引數Argument傳進函式fun1() func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把位址&amp;var1傳進函式，下面的程式碼是先將位址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式傳回值 如果有一個功能要求函式返回多個值，只有一個函式傳回值根本不夠用，可以把參數作為傳回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include &lt;iostream&gt; using namespace std; //宣告Student類別 class Student { public: //Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} //取出name, mathScore, engScore, historyScore公有方法 string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: //私有成員屬性 string name; double mathScore; double engScore; double historyScore; }; //宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { //找出數學 英文 歷史最大的分數 if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { //建立3個學生物件，利用名字,數學英文歷史成績建立物件 Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; //宣告三個存最大數學 英文 歷史成績的指標 double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); //將Student陣列，陣列大小，最大數學 英文 歷史成績的指標傳入getMax函式 compare(studentArr, 3, mathMax, engMax, historyMax); //印出各科最大分數 cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; return 0; } 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/function/func_param_pointer/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/function/func_param_pointer/",
    "body": "Prerequisites: 引數 指標參數 傳指標是把原始變數的記憶體位址傳給呼叫的函式，傳指標的好處是函式可以存取原始變數。 函式的參數是指標，代表參數是位址。指標參數語法為資料型態* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是位址，代表可以透過取值運算子*,取出位址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(位址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //函式的參數是指標，代表參數是位址 void func1(int* param1) { //透過取值運算子*,取出位址存放的內容 cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; //使用`*指標 = 修改內容`，修改指標的內容 *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; //使用取位址運算子&amp;，取出var1變數的記憶體開始位址，將位址作為引數Argument傳進函式fun1() func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把位址&amp;var1傳進函式，下面的程式碼是先將位址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式傳回值 如果有一個功能要求函式返回多個值，只有一個函式傳回值根本不夠用，可以把參數作為傳回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;iostream&gt; using namespace std; //宣告Student類別 class Student { public: //Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} //取出name, mathScore, engScore, historyScore公有方法 string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: //私有成員屬性 string name; double mathScore; double engScore; double historyScore; }; //宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { //找出數學 英文 歷史最大的分數 if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { //建立3個學生物件，利用名字,數學英文歷史成績建立物件 Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; //宣告三個存最大數學 英文 歷史成績的指標 double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); //將Student陣列，陣列大小，最大數學 英文 歷史成績的指標傳入getMax函式 compare(studentArr, 3, mathMax, engMax, historyMax); //印出各科最大分數 cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; // release momery delete mathMax; mathMax = nullptr; delete engMax; engMax = nullptr; delete historyMax; historyMax = nullptr; return 0; } 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/pointer/pointerConst/": {
    "title": "const與指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerConst/",
    "body": "以下二種十分容易混淆，而且十分難記。 Pointer to Const (const*) const右邊是星號* 代表指標位址中的內容是常數，常數不能修改，以下語法不能使用。 *指標 = 修改的內容 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int var1 = 10; //將var1的位址給指標變數p int const * p = &amp;var1; //p指標位址中的內容是常數，常數不能修改，所以不能使用*指標 = 修改的內容 //*p = 11; //印出var1的值與p指標位址中的值 cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=10,p=10 int const * p可以更改成const int* p，二者為一樣的意思，只要記得const右邊若先出現星號*而不是變數名，代表指標位址中的內容是常數，常數沒有辦法修改。 1 2 3 4 5 6 int main() { int var1 = 10; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第3行，int const * p可以更改成const int* p。 可以修改指標指向的記憶體位址 1 2 3 4 5 6 7 8 9 10 11 int main() { int var1 = 10; int var2 = 20; //將var1的位址給指標p const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; //將var2的位址給指標p p = &amp;var2; cout &lt;&lt; \"var2=\" &lt;&lt; var2 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=10,p=10 var2=20,p=20 Const Pointer (const 指標名) const右邊是指標名 代表指標名是常數，需要初始化常數名(初始化設位址)，不能再更改指標指向的記憶體位址。 1 2 3 4 5 6 7 8 9 10 11 int main() { int var1 = 10; int var2 = 11; //const右邊是指標名p，代表指標名p是常數，常數需要初始化，不能是nullptr，將var1的位址給指標p。 int* const p = &amp;var1; //將var2的位址給指標p，會編譯失敗，因為指標p是常數，不能被修改位址。 //p = &amp;var2; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 可以修改內容 可使用*指標 = 修改的內容修改指標位址的值，因為只有指標名是常數，不能變更初始位址，但指標位址中的內容並非常數，所以可以改變指標位址中的內容。 1 2 3 4 5 6 7 int main() { int var1 = 10; int* const p = &amp;var1; *p = 55; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=55,p=55"
  },"/pages/c/basic/simpleTraditionC/": {
    "title": "台陸指標相關名詞差異",
    "keywords": "",
    "url": "/pages/c/basic/simpleTraditionC/",
    "body": "文件相關 英文 台灣 大陸 head file 標頭檔案 頭文件 source file 原始檔案 源文件 source code 原始碼 源代碼 C++ STL = Standard Template Librar C++函式庫 C++庫函數 C libc = standard library C函式庫 C庫函數 object file 目的檔 目標檔 binary file 二進位檔 二進制檔案 linking 鏈結 鏈結 comment 註解 註釋 buffer 緩衝區 緩沖區 cache 暫存區 緩存 補數 英文 台灣 大陸 Binary(bin) 二進位 二進制 Octal(oct) 8進位 8進制 Decimal(dec) 10進位 10進制 Hexadecimal(hex) 16進位 16進制 Sign-Magnitude Representation 正負號2進位 原碼 1’s Complement 1的補數 反碼 2’s Complement 2的補數 補碼 資料型態相關 英文 台灣 大陸 Data 資料 數據 Data Type 資料型態 數據類型 typedef 類型別名 別名 int 整數 整型 char 字元 字符 string 字串 字符串 Byte 位元組 字節 bit 位元 位 %d %s 格式化字串或格式化數值輸出 占位符 escape sequence 跳脫字元或逸出字元 轉義字符 運算式相關 英文 台灣 大陸 Operator 運算子 運算符 condition 條件判斷式 表達式 For Loop 巢狀 嵌套 while(true) 無窮迴圈 無限循環 Code block 程式碼區塊 語句塊 Expression 運算式 表達式 Statement 陳述式 表達式 assign = 指派或設為 賦值 變數相關 英文 台灣 大陸 Variable 變數 變量 Constant 常數 常量 scope 生命周期，可見性，有效範圍 作用域 L-value 等號左邊 左值 R-value 等號右邊 右值 Local Variable 區域變數 局部變量 Global Variable 全域變數，外部變數 全局變量 Parameter 參數 形參 Argument 引數 實參 declaration 宣告 聲明 definition 定義 定義 #define 前置指令 宏 Preprocessor 前置處理器 預處理器 default 預設值 缺省 Temp Variable 暫存變數或臨時變數 臨時變量 custom 自訂 自定義 陣列相關 英文 台灣 大陸 Array 陣列 數組 index 索引 下標 row 列 行 column 行 列 函式相關 英文 台灣 大陸 Function 函式 函數 callback 回呼函式 回調函數 return 函式傳回 函數返回 Function Call 呼叫函式 函數調用 Function caller 函式呼叫者 函數調用者 指標相關 英文 台灣 大陸 Pointer 指標 指針 pointer to pointer** 指標的指標，雙重指標，指指標 二級指針 Wild pointers   野指針 Dangling pointers   懸空指針 Pointer to Const   常量指針 Const Pointer   指針常量 *dereferences a pointer 取值運算子或間接運算子(indirection) 解引用運算符 &amp; 取位址運算子 取址運算符 &amp;reference variable 參考 引用 call by value 傳值 傳值 call by pointer 傳址 傳地址 call by reference 傳參考 傳引用 記憶體相關 英文 台灣 大陸 Memory 記憶體 內存 Dynamic memory allocation 動態配置記憶體 動態內存分配 free 記憶體回收 記憶體釋放 Stack 堆疊 棧 Heap 堆積 堆 Memory layout 記憶體布局 內存布局 資料結構相關 英文 台灣 大陸 struct 結構 結構體 Linked list 鏈結串列 鏈表 head node 首節點 頭節點 Queue 佇列 隊列 佇列front 前端 頭節點 佇列rear 後端 尾節點 iterator 疊代器 迭代器 circular queue 環狀佇列 循環佇列   循序結構   物件相關 英文 台灣 大陸 Template 樣板 模板 constructor 建構式或建構子 構造方法 deconstructor 解構式或解構子 析構方法或析構函數 override 覆寫 重寫 overload 多載 重載 enum 列舉 枚舉 class 類別 類 member variable 成員屬性 成員變量 member function 成員方法 成員函數 ::scope resolution operator 範圍運算子 域作用符 Functor 物件函式 仿函數 conversion 轉型 轉換 explicit conversion 強制轉型 顯式轉換或手動轉換 implicit conversion 自動轉型 隱式轉換 Parent class 父類別 基類 Child class 子類別 派生類 virtual function 虛擬函式 虛函數 pure virtual function 抽象函式或純虛擬函式 純虛函數 polymorphism 多型 多態 process相關 英文 台灣 大陸 process 程序 進程 signal 訊號 信號 command 指令 命令 fork 複製程序   foreground 前景 前台 background 背景 後台   多工 多進程 kernel 核心 內核 exec 離開 退出 網路相關 英文 台灣 大陸 client 用戶端 客戶端 Data packet 封包 報文 Network 網路 網絡   通訊 通信 thread相關 英文 台灣 大陸 thread 執行緒 線程 Main Thread 主要執行緒 主線程 background Thread 背景執行緒 子線程 work Thread 工作執行緒 子線程 Concurrency Control 同步 同步 synchronous 同步 同步 synchronous block 同步程式碼區域 同步塊 asynchronous 非同步 異步 lock 同步鎖 鎖 Message 訊息 信息 影音相關 英文 台灣 大陸 video 視訊 視頻 redio 音訊 音頻 packet 封包 包 Java相關 英文 台灣 大陸 Object-oriented programming 物件導向 面向對像 constructor 建構式或建構子 構造器 Upcasting object 向上轉型物件 上轉型對象 Downcasting object 向下轉型物件 下轉型對象 Reference 參考 引用 Interface 介面 接口 implements 實作 實現 Exception 例外 異常 catch 補捉 補獲 Runtime Exception 執行時錯誤 運行時期錯誤 Method chaining 鏈式呼叫 鏈式調用 Method Calls 呼叫方法 函數調用 Method caller 函式呼叫者 調用者 package 套件 包 byte code .class檔 位元碼 字節碼 machine code 機器碼 二進制代碼 Annotation 標註 注釋 enum 列舉 枚舉 decompile 反編譯 反組譯 thread 執行緒 線程 blocked 阻斷 阻塞 Kotlin 英文 台灣 大陸 constructor 建構函式 構造函式 Primary constructor 主要建構函式 主構造函式 Secondary constructor 次要建構函式 次構造函式"
  },"/pages/c/dynamicMemory/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會傳回記憶體占用的開始位址。 資料型態* 指標變數 = new 資料型態(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"位址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"位址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 位址是 = 0x600000004010 位址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行回收，否則會產生memory leak，記憶體一直沒被回收，記憶體愈占愈多，最後就會當機。 回收記憶體位址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何位址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/nullptr/": {
    "title": "0 == nullptr == NULL",
    "keywords": "",
    "url": "/pages/c/pointer/nullptr/",
    "body": "nullptr代表沒有指向任何位址 如果對沒有指向任何位址的指標，也就是指標 = nullptr，對這個指標使用*取值運算子，試圖取出位址中的內容，編譯可以通過，但執行時將會出現錯誤。 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第7行，宣告指標p，沒有指向任何位址。 第8行，將指標p傳入函式。 第4行，將指標p使用*取值運算子試圖取出位址中的內容，但由於指標沒有指向任何位址，執行時會產生錯誤。 檢查nullptr 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { if(param1 == nullptr) return; cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第4行，判斷指標是不是沒有指向任何位址，若沒有指向任何位址，函式直接返回，不再往下執行。 delete nullptr delete nullptr 不會有編譯錯誤與執行錯誤，以下程式不會有任何錯誤。 1 2 3 4 5 int main() { int* p = nullptr; delete p; return 0; } NULL 在c的標準函式庫中stddef.h定義了常數NULL就是0與nullptr。 1 2 3 #define NULL 0 //since C++11 #define NULL nullptr 第1行定義常數NULL的值為0，代表沒有指向任何記憶空間 第3行，c++11以後，定義常數NULL為nullptr，代表沒有指向任何記憶空間 0 0，代表沒有指向任何記憶空間 以下為同名函式，但參數不同，一個為int資料型態，一個為int指標，呼叫函式(0)，呼叫的是參數為整數資料型態的函式。 1 2 3 4 5 6 7 8 9 10 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); return 0; } 執行結果 n = 0 轉型 把指標參數設為NULL，呼叫參數為指標的函式，以下這樣寫會出錯。 1 func3(NULL);//指標參數設為NULL 因為編譯不知道你的NULL是整數指標資料型態的NULL，轉型就可以編譯成功，以下三行都可以。 1 2 3 func3(nullptr); func3((int *)nullptr); func3(static_cast&lt;int *&gt;(nullptr)); 第1行，nullptr代表所有資料型態的NULL。 第2行，轉型int指標。 第3行，使用static_cast轉型成int指標，與上一行意思相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); func3((int *)NULL); func3(static_cast&lt;int *&gt;(NULL)); func3(nullptr); return 0; } 執行結果 n = 0 位址 = 0 位址 = 0 位址 = 0 nullptr位址為0 以下程式碼印出nullptr指標的位址，會印出0。 1 2 3 4 5 6 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; delete p; return 0; } 執行結果 0x0 nullptr記憶體位址 0x00000000-0x0000FFFF記憶體位址區間是放置nullptr指標，無法讀取這段記憶體位址區間。 原文 Each process’ virtual address space is split into partitions. On x86 32-Bit Windows, the partition of 0x00000000 - 0x0000FFFF (inclusive) is called NULL-Pointer Assignment Partition. This partition is set aside to help programmers catch NULL-pointer assignments. If a thread in your aprocess attempts to read from or write to a memory address in this partition, an access violoation is raised. 容易混淆寫法 1 2 3 4 int a = 0 ; int * p1 = 0 ; //right int * p2 = NULL ; //right int * p3 = a;//error 第1行定義整數資料型態的a變數，值為0 第2行定義p1指標沒有指向任何記憶體空間 第3行定義p2指標沒有指向任何記憶體空間 第4行錯誤，指標是存放位址，而不是值，不能把整數值0放進指標"
  },"/pages/c/pointer/pointerVoid/": {
    "title": "void*任何資料型態的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerVoid/",
    "body": "(void*)印出16進制的位址 使用(void*)就可以印出16進制的位址 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 變數c位址 = 0x7ff7bfeff46b 函式的參數為void*指標(位址) 函式的參數為void*指標，表示任何資料型態的指標(位址)都可以傳進函式，而且不需要轉型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //宣告printAddr的函式，參數資料型態為void*指標 void printAddr(void* p) { //印出位址 cout &lt;&lt; p &lt;&lt; endl; } int main() { int i = 10; //將整數i變數的位址傳入 printAddr(&amp;i); char c = 'a'; //將字元c變數的位址傳入 printAddr(&amp;c); double d = 150.222; //將浮點數d變數的位址傳入 printAddr(&amp;d); return 0; } 執行結果 0x7ff7bfeff468 0x7ff7bfeff467 0x7ff7bfeff458 函式傳回值為void*指標 表示可以傳回任何資料型態的指標(位址)，可以轉型成任何資料型態指標。 以下為malloc的傳回資料型態void指標(位址)，void指標可以轉成任何資料型態指標，參數size_t __size代表設定空間大小。 1 void* malloc(size_t __size) 使用方式 在heap區段，建立10 byte的記憶體空間，將傳回的位址轉成char資料型態的指標。 1 char *name = (char *)malloc(10);//10byte 在heap區段，建立1mb的記憶體空間，將傳回的位址轉成int資料型態的指標。 1 int *num = (int *)malloc(1 * 1024 * 1024);//1byte*1024 = 1kb -&gt;1kb*1024=1mb 不能對void*指標使用取值運算子* 不能對void*指標使用取值運算子*，需要轉換成其它資料型態的指標才可以使用取值運算子* 1 2 3 4 void printAddr(void* p) { //編譯失敗，不能對p指標使用取值運算子*，因為它是void*指標資料型態，必須轉型後才能對指標取出內容 cout &lt;&lt; *p &lt;&lt; endl; } 1 2 3 4 5 6 7 8 9 void printAddr(void* p) { //先將p指標轉型成char*指標，接著使用`取值運算子*`取出指標位址中的內容 cout &lt;&lt; *(char*)p &lt;&lt; endl; } int main() { char c = 'a'; printAddr(&amp;c); return 0; } 執行結果 a 函式的參數為void 函式的參數為void，代表不接受任何參數。 rand()產生亂數，以下為rand函式的定義，不接受任何參數，傳回int 1 int rand (void); 產生0-100的亂數 1 2 int num = rand()%100; printf(\"rand = %d \\n\", num);"
  },"/pages/c/pointer/wildPointer/": {
    "title": "指標位址是無效內容",
    "keywords": "",
    "url": "/pages/c/pointer/wildPointer/",
    "body": "回收記憶體後的指標 回收指標記憶體位址中的內容，但指標仍指在原本的位址上。 1 2 3 4 5 6 7 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x600000004060 記憶體回收後的位址 = 0x600000004060 如果對已經被回收(清空)的位址進行讀取，讀取的內容不知道是什麼。 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 第7行，讀取已回收記憶體的位址中的內容。 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x60000000c010 讀取位址內容 = -559038448 為避免上面的情況，回收完記憶體，要把記憶體位址設為nullptr 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; p = nullptr; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x0 未初始化的指標 1 2 3 4 5 int main() { int* p; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告未初始化的指標。 第3行,印出位址，印出不知道何處的位址。 執行結果 0x1e 建議把宣告指標要設初始值。 1 2 3 4 5 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告指標，初始化nullptr。 第3行,印出位址，印出0。 執行結果 0x0 函式返回區域變數位址 1 2 3 4 5 6 7 8 9 10 int* func() { int i = 10; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", &amp;i = \" &lt;&lt; &amp;i &lt;&lt; endl; return &amp;i; } int main() { int* p = func(); cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; \", p = \" &lt;&lt; p &lt;&lt; endl; return 0; } 第1行,宣告函式，返回指標。 第3行,印出區域變數i的值與位址。 第4行,返回變數i的位址。 第7行,宣告指標p，取得函式返回的位址。 第8行,印出函式返回的位址中的值，與位址。 執行結果 i = 10, &amp;i = 0x7ff7bfeff44c *p = 32760, p = 0x7ff7bfeff44c 由以上執行結果可以發現區域變數i的位址與返回的位址不同，而且值也不一樣。"
  },"/pages/c/function/functionPointer/": {
    "title": "函式指標",
    "keywords": "",
    "url": "/pages/c/function/functionPointer/",
    "body": "函式指標指向函式的記憶體位址，通過函式指標使用函式。 函式資料型態 函式資料型態是由函式的傳回值資料型態/參數資料型態/參數的數量所組成。 如果多個函式的傳回值資料型態/參數資料型態/參數的數量都一樣，代表這些函式是同一個資料型態。 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 bool func4(string param1); bool func5(string msg); bool func6(string name); 以下二個函式不是相同資料型態。 int func1(int code, string msg); bool func4(string param1); 以下三個函式的函式資料型態為 int (*pf1)(int,string)，其中pf1為函式指標的變數名，可以為任意名稱，名稱前面要有星號*，要用括號()包起來，int為傳回值資料型態，(int,string)為函式參數資料型態與參數數量。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式的函式資料型態為 bool (*pf2)(string)，其中pf2為函式指標的變數名，可以為任意名稱。 bool func4(string param1); bool func5(string msg); bool func6(string name); 宣告函式指標 1 2 3 4 5 6 7 8 9 10 int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { int (*pf1)(int,string); //宣告函式指標變數pf1 pf1 = func1; //將func1函式設給pf1函式指標變數 pf1(404, \"Page not found.\"); //使用函式指標pf1呼叫函式 return 0; } 第1行,宣告函式。 第6行,宣告函式指標變數pf1。 第7行,將func1函式設給pf1函式指標變數。 第8行,使用函式指標pf1呼叫函式。 執行結果 Err code = 404, msg = Page not found. typedef函式指標類型別名 typedef類型別名 語法 typedef 傳回值(*類型別名)(參數1,參數2,參數3 ...); 將前一個宣告函式指標的程式碼 1 int (*pf1)(int,string); 改成下方的程式碼，前面添加typedef，並把pf1改成Func1，Func1可以為任意名字，並放在程式的開頭。 1 typedef int (*Func1)(int,string); 修改完的程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; //宣告Func1類型別名 typedef int (*Func1)(int,string); int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { //宣告指標變數pf1為Func1類型 Func1 pf1; //宣告函式指標變數pf1 pf1 = func1; //函式指標變數pf1設定函式 pf1(404, \"Page not found.\");//使用函式指標pf1呼叫函式 return 0; } 執行結果 Err code = 404, msg = Page not found. 函式參數是函式指標 宣告函式print404Msg()，第一個參數為函式指標，函式的資料型態是傳回值為int，函式指標名為pf1，2個參數資料型態分別為int跟string。 1 2 3 void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } 第1行,宣告函式print404Msg()，第一個參數為函式指標，第二個參數為string資料型態。 第2行,使用函式指標pf1呼叫函式，並把404整數與msg的參數傳進函式。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 執行結果 Err code = 404, msg = Page not Found 函式參數是typedef函式指標類型別名 也可以使用typedef函式指標類型另取別名。 1 2 3 4 5 6 //宣告Func1類型別名 typedef int (*Func1)(int,string); //第一個參數資料型態為Func1 void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; typedef int (*Func1)(int,string); void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 函式指標應用 自訂二個函式指標類型別名 1 2 3 4 5 //宣告類型別名 //傳回值為void，別名為Success，參數資料型態char*指標 typedef void (*Success)(char*); //傳回值為void，別名為Failure，參數類型分別為int，char*指標 typedef void (*Failure)(int, char*); 1 2 3 4 5 6 void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } 第1行,宣告函式，傳回值與參數資料型態都符合函式指標類型別名Success 第4行,宣告函式，傳回值與參數資料型態都符合函式指標類型別名Failure 1 2 3 4 5 6 7 8 9 10 11 12 void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 第1行,宣告函式，第1個參數資料型態int，第2個參數函式指標類型別名Success，第3個參數函式指標類型別名Failure。 第3行,使用函式指標Success呼叫函式。 第5行,使用函式指標Failure呼叫函式，並傳入參數。 第9行,呼叫http函式，並把函式傳回值參數與自訂Success函式資料型態一樣的httpOk函式傳入。 第10行,呼叫http函式，並把函式傳回值參數與自訂Failure函式資料型態一樣的httpFailure函式傳入。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; //函式指標類型別名 typedef void (*Success)(char*); typedef void (*Failure)(int, char*); void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 執行結果 成功，結果:取得資料成功 失敗505，原因:網路連線有問題"
  },"/pages/c/array/array/": {
    "title": "陣列",
    "keywords": "",
    "url": "/pages/c/array/array/",
    "body": "初始化值 資料型態 陣列名[長度] = {值1, 值2, 值3 …}; 若值的數量比長度小，沒有在括號{}中的值預設為0。 1 2 3 4 5 6 7 int main() { int arr[10] = {0,1,2,3}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 資料型態 陣列名[] = {值1, 值2, 值3 …}; 陣列長度 陣列的長度可以用常數、運算式。 常數 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; //使用常數 const int ARR_MAX = 10; int main() { int arr[ARR_MAX] = {0,1,2,3}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 運算式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { double d = 10; //使用運算式設定陣列長度 int arr[sizeof(d)/2] = {0,1,2,3}; int size = sizeof(arr)/sizeof(int); cout &lt;&lt; \"arr size = \" &lt;&lt; size &lt;&lt; endl; for (int i = 0; i &lt; size; i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr size = 4 arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 陣列中有多少元素？ sizeof(陣列名) / sizeof(陣列資料型態) = 元素個數 sizeof(陣列名) 是取得這個陣列占記憶體的大小。 sizeof(資料型態) 是取得資料資料型態占的記憶體大小，如int占4byte，double占8byte，char占1byte。 陣列中每一個值都初始化為整數0 以下二種寫法都是一樣，初始化為整數0。 資料型態 陣列名[長度] = {0}; 資料型態 陣列名[長度] = {}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {0}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } int arr1[10] = {}; for (int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 arr1[0] = 0 arr1[1] = 0 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0 memset陣列清空 陣列中每個元素記憶體位址的值設為00000000。 void* memset(void *s, int c, size_t n); 參數1 : 陣列名 參數2 : 整數0 參數3 : 陣列記憶體大小 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } memset(arr, 0, sizeof(arr)); for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 0 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 memcpy() 複製陣列，記憶體內容複製 複製全部元素 陣列中全部的元素(來源陣列)複製到另一個大小相同的陣列(目標陣列)。 需要引入函式庫#include void* memcpy(void* dest, const void* src, size_t n) 參數1 : 目標陣列 參數2 : 來源陣列 參數3 : 陣列記憶體大小，或使用者自行定義要複製的byte。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 int arr1[sizeof(arr) / sizeof(int)]; memcpy(arr1, arr, sizeof(arr)); for (int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 arr1[4] = 5 arr1[5] = 6 arr1[6] = 7 arr1[7] = 8 arr1[8] = 9 arr1[9] = 10 複製部分元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 //元素全初始化為整數0 int arr1[sizeof(arr) / sizeof(int)] = {0}; //只複製arr陣列8byte的元素 //(8byte/每個元素是4byte)=2，只複製2個元素 memcpy(arr1, arr, 8); for (int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0"
  },"/pages/c/array/pointerToArray/": {
    "title": "一維陣列與指標",
    "keywords": "",
    "url": "/pages/c/array/pointerToArray/",
    "body": "陣列的記憶體位址是連續的。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; (long long) &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; (long long) &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; (long long) &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; (long long) &amp;array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4]地址 = \" &lt;&lt; (long long) &amp;array[4] &lt;&lt; endl; return 0; } 執行結果 array[0]地址 = 140702053823568 array[1]地址 = 140702053823572 array[2]地址 = 140702053823576 array[3]地址 = 140702053823580 array[4]地址 = 140702053823584 從以上的執行結果可以知道每個位址差距4byte，而且是連續的。 陣列名就是陣列第0個元素的記憶體位址 C++將陣列名視為陣列第0個元素的記憶體位址。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 從以上的執行結果可以知道印出陣列名與使用&amp;取址運算子+陣列名與印出陣列第0個元素位址的結果是一樣的。 陣列運算 陣列名 + 1 陣列名 + 1，位址移動的範圍取決於陣列的資料型態。 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 從以上的執行結果可以知道每次陣列名 + n，移動的位址n * 4byte(陣列的資料型態為int)。 陣列第n個元素的記憶體位址 = 陣列名 + n (&amp;陣列名 + 1) 若是(&amp;陣列名+1)，移動的是整個陣列的記憶體位置。 1 2 3 4 5 6 7 8 9 int main() { int arr[10]; cout &lt;&lt; \"arr位址=\" &lt;&lt; (long long)arr &lt;&lt; endl; //印出arr+1的位址 cout &lt;&lt; \"arr+1位址=\" &lt;&lt; (long long)(arr + 1) &lt;&lt; endl; //印出&amp;arr + 1的位址 cout &lt;&lt; \"&amp;arr + 1位址=\" &lt;&lt; (long long)(&amp;arr + 1) &lt;&lt; endl; return 0; } arr位址=140702053823552 arr+1位址=140702053823556 &amp;arr + 1位址=140702053823592 arr+1是從 arr的記憶體位址(140702053823552)移動4byte，移到140702053823556。 (&amp;arr+1)是移動陣列長度10*4byte = 40 byte，從140702053823552移到140702053823592。 陣列名[索引] 等同 *(陣列名 + 索引) 透過*取值運算子，可以取出記憶體位址存放的內容。 C++編譯器將陣列名[索引] 解釋為 *(陣列名 + 索引) arr[0]與*(arr + 0)是相同的意思，都是對陣列第0個元素的記憶體位址取出存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr值=\" &lt;&lt; *(arr) &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr+0值=\" &lt;&lt; *(arr+0) &lt;&lt; endl; //印出arr[1]的值 cout &lt;&lt; \"arr+1值=\" &lt;&lt; *(arr+1) &lt;&lt; endl; //印出arr[2]的值 cout &lt;&lt; \"arr+2值=\" &lt;&lt; *(arr+2) &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 arr值=10 arr+0值=10 arr+1值=100 arr+2值=200 指標指向陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //印出指標變數p，也就是印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 p指標內容 = 0x7ff7bfeff450 p指標內容為陣列名的地址。 指標運算與陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //指標變數p + 0，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //指標變數p + 1，印出第1個元素記憶體位址 cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //指標變數p + 2，印出第2個元素記憶體位址 cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //指標變數p + 3，印出第3個元素記憶體位址 cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 array[1]地址 = 0x7ff7bfeff454 array[2]地址 = 0x7ff7bfeff458 array[3]地址 = 0x7ff7bfeff45c p指標內容 = 0x7ff7bfeff450 p指標+0 = 0x7ff7bfeff450 p指標+1 = 0x7ff7bfeff454 p指標+2 = 0x7ff7bfeff458 p指標+3 = 0x7ff7bfeff45c 由以上的結果可知，指標 + 1 與 &amp;array[1]的結果是一樣的。 指標運算取值 透過*取值運算子，可以取出記憶體位址存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; //指標變數p + 0使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; //指標變數p + 1使用取值運算子，取出第1個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; //指標變數p + 2使用取值運算子，取出第2個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; //指標變數p + 3使用取值運算子，取出第3個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; //指標變數p + 4使用取值運算子，取出第4個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 *(指標 + 索引) 等同 指標[索引] C++編譯器將指標[索引] 解釋為 *(指標 + 索引) 指標就是存放記憶體位址，陣列名就是陣列第0個元素的記憶體位址，陣列名也是記憶體位址，所以陣列名[索引]等同記憶體位址[索引]，而指標是記憶體位址，等同記憶體位址[索引]，二者是相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; int* p = array; cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; //使用指標[索引]的方式，把記憶體位址存放的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引3] = \" &lt;&lt; p[3] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引4] = \" &lt;&lt; p[4] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 p指標[索引0] = 1 p指標[索引1] = 2 p指標[索引2] = 3 p指標[索引3] = 4 p指標[索引4] = 5 記憶體位址[索引] 等同 *(記憶體位址 + 索引) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //印出陣列名[索引2]的記憶體位址 cout &lt;&lt; \"記憶體位址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; //&amp;陣列名[索引2]，代表取出陣列名[索引2]的記憶體位址，使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址 = \" &lt;&lt; *(&amp;array[2]) &lt;&lt; endl; //&amp;陣列名[索引2]+0，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+0 = \" &lt;&lt; *(&amp;array[2] + 0) &lt;&lt; endl; //&amp;陣列名[索引2]+1，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+1 = \" &lt;&lt; *(&amp;array[2] + 1) &lt;&lt; endl; //&amp;陣列名[索引2]+2，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+2 = \" &lt;&lt; *(&amp;array[2] + 2) &lt;&lt; endl; //(&amp;陣列名[索引2])[0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引0] = \" &lt;&lt; (&amp;array[2])[0] &lt;&lt; endl; //(&amp;陣列名[索引2])[1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引1] = \" &lt;&lt; (&amp;array[2])[1] &lt;&lt; endl; //(&amp;陣列名[索引2])[2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引2] = \" &lt;&lt; (&amp;array[2])[2] &lt;&lt; endl; //取出陣列名[索引2]的記憶體位址指派給指標變數p int* p = &amp;array[2]; //指標[索引0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; //指標[索引1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; //指標[索引2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 3 *p指標+0 = 3 *p指標+1 = 4 *p指標+2 = 5 記憶體位址[索引0] = 3 記憶體位址[索引1] = 4 記憶體位址[索引2] = 5 p指標[索引0] = 3 p指標[索引1] = 4 p指標[索引2] = 5 陣列與指標與迴圈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); for (int i = 0; i &lt; size; i++) { //印出array[i]記憶體位址 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 記憶體位址 = \" &lt;&lt; &amp;array[i] &lt;&lt; endl; //印出array + i記憶體位址 cout &lt;&lt; \"array+\"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; array + i &lt;&lt; endl; //印出array[i]的值 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 的值 = \" &lt;&lt; array[i] &lt;&lt; endl; //印出*(array + i)的值 cout &lt;&lt; \"*(array+\"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(array + i) &lt;&lt; endl; } //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for (int i = 0; i &lt; size; i++) { //印出p + i的記憶體位址 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; p + i &lt;&lt; endl; //印出*(p + i)記憶體位址存放的值 cout &lt;&lt; \"*(p + \"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(p + i) &lt;&lt; endl; } return 0; } 執行結果 array[0] 記憶體位址 = 0x7ff7bfeff450 array+0 記憶體位址 = 0x7ff7bfeff450 array[0] 的值 = 1 *(array+0) 的值 = 1 array[1] 記憶體位址 = 0x7ff7bfeff454 array+1 記憶體位址 = 0x7ff7bfeff454 array[1] 的值 = 2 *(array+1) 的值 = 2 array[2] 記憶體位址 = 0x7ff7bfeff458 array+2 記憶體位址 = 0x7ff7bfeff458 array[2] 的值 = 3 *(array+2) 的值 = 3 array[3] 記憶體位址 = 0x7ff7bfeff45c array+3 記憶體位址 = 0x7ff7bfeff45c array[3] 的值 = 4 *(array+3) 的值 = 4 array[4] 記憶體位址 = 0x7ff7bfeff460 array+4 記憶體位址 = 0x7ff7bfeff460 array[4] 的值 = 5 *(array+4) 的值 = 5 p + 0 記憶體位址 = 0x7ff7bfeff450 *(p + 0) 的值 = 1 p + 1 記憶體位址 = 0x7ff7bfeff454 *(p + 1) 的值 = 2 p + 2 記憶體位址 = 0x7ff7bfeff458 *(p + 2) 的值 = 3 p + 3 記憶體位址 = 0x7ff7bfeff45c *(p + 3) 的值 = 4 p + 4 記憶體位址 = 0x7ff7bfeff460 *(p + 4) 的值 = 5 陣列與指標遞增遞減 指標++ int array[5] = {1,2,3,4,5}; int* p = array; 將陣列第0個元素的記憶體位址指定至指標變數p。 指標運算 記憶體位址 記憶體位址存放的值 p + 0 140702053823568 1 p + 1 140702053823572 2 p + 2 140702053823576 3 p + 3 140702053823580 4 p + 4 140702053823584 5 指標變數p指向的是一個整數資料型態(4byte)的地址，每一次p + 1，指標變數p就會移動4byte。 p++也就是等於 p = p + 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for (int i = 0; i &lt; size; i++) { //印出指標變數p的內容(指標存放的內容是記憶體位址) cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; (long long)p &lt;&lt; endl; //印出指標變數p記憶體位址存放的值 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 的值 = \" &lt;&lt; *p &lt;&lt; endl; //p = p + 1，指標變數移動4byte，將移動後的記憶體位址指派給指標變數p p++; } return 0; } 執行結果 p + 0 記憶體位址 = 140702053823568 p + 0 的值 = 1 p + 1 記憶體位址 = 140702053823572 p + 1 的值 = 2 p + 2 記憶體位址 = 140702053823576 p + 2 的值 = 3 p + 3 記憶體位址 = 140702053823580 p + 3 的值 = 4 p + 4 記憶體位址 = 140702053823584 p + 4 的值 = 5 *ptr++ 指標先取出記憶體位址存放的值，再往下一個位址移動。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for (int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*ptr++); } 執行結果 值= 10 值= 100 值= 200 *++ptr 指標先往下一個記憶體位址移動，再取出記憶體位址存放的值。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for (int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*++ptr); } 執行結果 值= 100 值= 200 值= 0 ptr--指標遞減 將指標指向前一個記憶體位址 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //取得陣列中最後一個值的記憶體位址 int *ptr = &amp;arr[2]; for (int i = 3; i &gt; 0; i--) { printf(\"arr[%d]:記憶體位址= %#x\\n\",i ,ptr); printf(\"arr[%d]:值= %d\\n\",i ,*ptr); //將指標指向前一個記憶體位址 ptr--; } 執行結果 arr[3]:記憶體位址= 0xbfdff37c arr[3]:值= 200 arr[2]:記憶體位址= 0xbfdff378 arr[2]:值= 100 arr[1]:記憶體位址= 0xbfdff374 arr[1]:值= 10 陣列名是常數，不可修改 指標變數p可以設為其它記憶體位址。 p = p + 1; p++; 陣列名無法再設為其它記憶體位址，以下的語法無法編譯成功。 array = array + 1; array++; 記憶體位址轉型 以下程式碼將字元陣列轉型成整數陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //宣告字元陣列 大小20byte char array[20]; //將字元陣列的記憶體空間轉型成整數資料型態的記憶體空間 //把轉型成整數型態的陣列[0]位址，指派給整數型態的指標變數p int* p = (int*)array; //sizeof(陣列名)取得陣列全部記憶體大小為20byte //再除以整數資料型態的大小sizeof(int) = 4byte int size = sizeof(array)/sizeof(int); cout &lt;&lt; \"size = \" &lt;&lt; size &lt;&lt; endl; for (int i = 0; i &lt; size; i++) { p[i] = i;//修改記憶體位址中存放的值 //上面的寫法與下面的寫法是相同意思 //*(p + i) = i; } for (int i = 0; i &lt; size; i++) { //印出記憶體位址存放的值 cout &lt;&lt;\"*(p + \"&lt;&lt; i &lt;&lt;\") = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } 執行結果 *(p + 0) = 0 *(p + 1) = 1 *(p + 2) = 2 *(p + 3) = 3 *(p + 4) = 4 函式的參數為指向陣列的指標 參數的寫法有下面二種，因為傳入的參數是指標，對指標用sizeof(指標)，只會得到8byte，所以一定要傳入陣列的長度，或者把陣列的長度設為常數。 void func(int* arr, int len); 參數1，指標變數名arr。 參數2，陣列長度。 void func(int arr[], int len); 參數1，指標變數名arr[]，使用陣列表示法不代表是陣列，而是指標。 參數2，陣列長度。 以下程式碼為傳陣列給函式的寫法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; void func(int arr[], int len) { cout &lt;&lt; \"arr指標大小 = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; for (int i = 0; i &lt; len; i++) { //使用*(陣列名 + 索引)印出陣列元素，也可以使用陣列名[索引]的方式印出陣列元素 cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; *(arr + i) &lt;&lt; endl; } } int main() { int array[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; //參數1傳入陣列名，陣列名為陣列第0個元素的記憶體位址，參數2傳入陣列大小 func(array,sizeof(array)/sizeof(int)); } 執行結果 arr指標大小 = 8 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr[10] = 11 arr[11] = 12 arr[12] = 13 arr[13] = 14 arr[14] = 15"
  },"/pages/c/pointer/pointerArithmetic/": {
    "title": "指標運算",
    "keywords": "",
    "url": "/pages/c/pointer/pointerArithmetic/",
    "body": "指標 + 1，位址增減取決於記憶體位址中存放內容的資料型態。 為了方便看出來差異，以下的位址全轉型成long long長整數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; int main() { char c; //印出char的大小 cout &lt;&lt; \"sizeof(char) = \" &lt;&lt; sizeof(c) &lt;&lt; endl; //印出變數c的位址 cout &lt;&lt; \"c的地址 = \" &lt;&lt; (long long)&amp;c &lt;&lt; endl; //印出變數c的地址往後移動一格的位址，與變數c的位址相差為1byte cout &lt;&lt; \"c的地址 + 1 = \" &lt;&lt; (long long)(&amp;c + 1) &lt;&lt; endl; int i; //印出int的大小 cout &lt;&lt; \"sizeof(int) = \" &lt;&lt; sizeof(i) &lt;&lt; endl; //印出變數i的位址 cout &lt;&lt; \"i的地址 = \" &lt;&lt; (long long)&amp;i &lt;&lt; endl; //印出變數i的地址往後移動一格的位址與變數i的位址相差為4byte cout &lt;&lt; \"i的地址 + 1 = \" &lt;&lt; (long long)(&amp;i + 1) &lt;&lt; endl; double d; //印出double的大小 cout &lt;&lt; \"sizeof(double) = \" &lt;&lt; sizeof(d) &lt;&lt; endl; //印出變數d位址 cout &lt;&lt; \"d的地址 = \" &lt;&lt; (long long)&amp;d &lt;&lt; endl; //印出變數d的地址往後移動一格的位址，與變數d的位址相差為8byte cout &lt;&lt; \"d的地址 + 1 = \" &lt;&lt; (long long)(&amp;d + 1) &lt;&lt; endl; return 0; } 執行結果 sizeof(char) = 1 c的地址 = 140702053823595 c的地址 + 1 = 140702053823596 sizeof(int) = 4 i的地址 = 140702053823588 i的地址 + 1 = 140702053823592 sizeof(double) = 8 d的地址 = 140702053823576 d的地址 + 1 = 140702053823584"
  },"/pages/c/pointer/pointerToPointer/": {
    "title": "指標的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerToPointer/",
    "body": "Prerequisites: 引數 指標的指標，意思是指標的記憶體位址。 指標的位址 1 2 3 4 5 6 7 8 9 10 int main() { int i = 40; cout &lt;&lt; \"i的值 = \" &lt;&lt; i &lt;&lt; \"，i的位址 = \" &lt;&lt; &amp;i &lt;&lt; endl; int *p = &amp;i; cout &lt;&lt; \"指標p指向的位址 = \" &lt;&lt; p &lt;&lt; \"，指標p的位址 = \" &lt;&lt; &amp;p &lt;&lt; \"，指標p指向位址的值=\" &lt;&lt; *p &lt;&lt; endl; int **pp = &amp;p; cout &lt;&lt; \"指標pp指向的位址 = \" &lt;&lt; pp &lt;&lt; \"，指標pp的位址 = \" &lt;&lt; &amp;pp &lt;&lt; \"，指標pp指向的位址(p)指向的位址(i)=\" &lt;&lt; *pp &lt;&lt; endl; cout &lt;&lt; \"指標pp指向的位址(p)指向的位址(i)的值=\" &lt;&lt; **pp &lt;&lt; endl; return 0; } i的值 = 40，i的位址 = 0x7ff7bfeff468 指標p指向的位址 = 0x7ff7bfeff468，指標p的位址 = 0x7ff7bfeff460，指標p指向位址的值=40 指標pp指向的位址 = 0x7ff7bfeff460，指標pp的位址 = 0x7ff7bfeff458，指標pp指向的位址(p)指向的位址(i)=0x7ff7bfeff468 指標pp指向的位址(p)指向的位址(i)的值=40 其它程式碼解釋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { int i4 = 40; //宣告一個指標存i4的位址 int *p2 = &amp;i4; //將p2指標的位址傳給pp2 int **pp2 = &amp;p2; //1.把pp2存放的位址，使用取值運算子*，也就是指標p2的位址 //*pp2; //2.再把p2位址，使用取值運算子*，也就是40 //**pp2 printf(\"解出pp2的值:%d\\n\",**pp2); return 0; } 執行結果 解出pp2的值:40 函式參數為指標的指標 在函式中若要修改指標所指向的記憶體位址，就要用到指標的指標。 引數為指標的位址，函式參數宣告為指標資料型態** 指標變數，這樣才可以接收指標的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函式並嘗試對其進行修改，則對指標所做的更改不會反映回該函式外部。這是因為僅將指標的副本傳遞給函式。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函式內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變數，而原始指標保持不變。 函式語法 傳回型態 函式名(指標資料型態** 指標) { *指標 = 其它記憶體位址 } 呼叫函式語法 函式(&amp;指標位址) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &amp;global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &amp;var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 指標的指標與new 參考文章 參考指向指標與new new會返回動態配置記憶體的開始位址，將p_to_p使用*取值運算子修改p指向的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 指標是p_to_p，指向外部指標的位址 void initAddress(int** p_to_p){ //印出指向外部指標p的記憶體位址 cout &lt;&lt; \"Before p address = \" &lt;&lt; *p_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 //使用*取值運算子修改指標p指向的位址 *p_to_p = new int(10); //印出指向外部指標的記憶體位址與值 cout &lt;&lt; \"After p address= \" &lt;&lt; *p_to_p &lt;&lt; \",After p value = \" &lt;&lt; **p_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p的位址 initAddress(&amp;p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before p address = 0x0 After p address= 0x60000000c010,After p value = 10 == outside == outside pointer address = 0x60000000c010，outside pointer value = 10"
  },"/pages/c/array/dynamicArrays/": {
    "title": "陣列與動態配置記憶體",
    "keywords": "",
    "url": "/pages/c/array/dynamicArrays/",
    "body": "參考文件 new/delete 建立陣列記憶體位址 資料型態 *陣列名 = new 資料型態[長度]; new傳回值是陣列第0筆元素記憶體位址，由指標(*陣列名)接收傳回的記憶體位址。 記憶體回收 delete[] 指標變數; 不能使用sizeof() 因為陣列名是指標，使用sizeof(陣列名)只會傳回8btye 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int main() { //分配連續100個int的記憶體空間 int *arr_p = new int[100]; cout &lt;&lt; \"使用陣列索引:\" &lt;&lt; endl; //使用索引修改陣列的元素 for (int i = 0; i &lt; 100; i++) { arr_p[i] = i; } //使用索引印出陣列的元素 for (int i = 0; i &lt; 100; i++) { cout &lt;&lt; arr_p[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; cout &lt;&lt; \"使用指標:\" &lt;&lt; endl; //使用指標修改陣列的元素 for (int i = 0; i &lt; 100; i++) { *(arr_p + i) = i + 100; } //使用指標印出陣列的元素 for (int i = 0; i &lt; 100; i++) { cout &lt;&lt; *(arr_p + i) &lt;&lt; \",\"; } cout &lt;&lt; endl; //陣列記憶體回收 delete[] arr_p; //指標設為nullptr代表不指向任何記憶體位址 arr_p = nullptr; return 0; } 執行結果 使用陣列索引: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99, 使用指標: 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199, 陣列其它用法 全設為0 int *arr_p1 = new int[3](); 設定初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; int main() { //全設0 int *arr_p1 = new int[3](); // 0,0,0 //設初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 //用索引取值 cout &lt;&lt; arr_p1[0] &lt;&lt; \",\" &lt;&lt; arr_p1[1] &lt;&lt; \",\" &lt;&lt; arr_p1[2] &lt;&lt; endl; //用指標取值 cout &lt;&lt; *(arr_p2 + 0) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 1) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 2) &lt;&lt; endl; //記憶體回收 delete [] arr_p1; delete [] arr_p2; //指標設為不指向任何記憶體位址 arr_p1 = nullptr; arr_p2 = nullptr; return 0; } 執行結果 0,0,0 1,2,3"
  },"/pages/c/array/charArray/": {
    "title": "char 字串",
    "keywords": "",
    "url": "/pages/c/array/charArray/",
    "body": "空字元(null character) char字串必須以’\\0’做結尾，若不是’\\0’做結尾則稱為char陣列。 宣告字串，必須留1個字元，放結尾\\0，以下宣告最多可以放5個字元，而第6個字元則是放\\0。 char str[6]; 以下二種宣告是完全不同，一個是字串，一個是陣列。 1 2 3 4 5 6 7 8 //char字串 // \\0 代表結尾 char str1[6] = {'h','e','l','l','o','\\0'}; cout &lt;&lt; \"str1 長度 = \" &lt;&lt; strlen(str1) &lt;&lt; \",內容 = \" &lt;&lt; str1 &lt;&lt; endl; //char 陣列 char arr[6] = {'h','e','l','l','o','o'}; cout &lt;&lt; \"arr 長度 = \" &lt;&lt; strlen(arr) &lt;&lt; \",內容 = \" &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; \"arr sizeof = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; 執行結果 str1 長度 = 5,內容 = hello arr 長度 = 11,內容 = helloohello arr sizeof = 6 字串常數 注意!以下”“雙引號包住的字串是常數，編譯器會自動加上’\\0’作結尾，不用手動加’\\0’。 1 2 //字串常數 char str1[] = \"hello\" 字串常數宣告 以下程式碼，cstr1沒有初始化字串常數，執行程式時會從cstr1的記憶體位址開始輸出值，直到遇到記憶體位址的值為\\0(空字元)才會停止輸出，不會因為超過宣告字串的長度而停止印出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; int main() { char cstr1[21];//cstr1沒有初始化字串常數 //遇到記憶體位址的值為\\0(空字元)才會停止輸出 cout &lt;&lt; \"cstr1 長度 = \" &lt;&lt; strlen(cstr1) &lt;&lt; \",內容 = \" &lt;&lt; cstr1 &lt;&lt; endl; //以下結尾編譯器會自動加上\\0 char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; char cstr3[6] = \"hello\"; cout &lt;&lt; \"cstr3 長度 = \" &lt;&lt; strlen(cstr3) &lt;&lt; \",內容 = \" &lt;&lt; cstr3 &lt;&lt; endl; char cstr4[] = {\"hello\"}; cout &lt;&lt; \"cstr4 長度 = \" &lt;&lt; strlen(cstr4) &lt;&lt; \",內容 = \" &lt;&lt; cstr4 &lt;&lt; endl; char cstr5[6] = {\"hello\"}; cout &lt;&lt; \"cstr5 長度 = \" &lt;&lt; strlen(cstr5) &lt;&lt; \",內容 = \" &lt;&lt; cstr5 &lt;&lt; endl; char cstr6[6] {\"hello\"}; cout &lt;&lt; \"cstr6 長度 = \" &lt;&lt; strlen(cstr6) &lt;&lt; \",內容 = \" &lt;&lt; cstr6 &lt;&lt; endl; //設為nullptr char cstr7[6] = {0}; cout &lt;&lt; \"cstr7 長度 = \" &lt;&lt; strlen(cstr7) &lt;&lt; \",內容 = \" &lt;&lt; cstr7 &lt;&lt; endl; return 0; } 執行結果 cstr1 長度 = 6,內容 = p\\364\\357\\277\\367 cstr2 長度 = 5,內容 = hello cstr3 長度 = 5,內容 = hello cstr4 長度 = 5,內容 = hello cstr5 長度 = 5,內容 = hello cstr6 長度 = 5,內容 = hello cstr7 長度 = 0,內容 = 字串清空 使用memset，第二個參數設為0，代表把字串的記憶體位址的值全設為\\0。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; memset(cstr2,0,sizeof(cstr2)); cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } 執行結果 cstr2 長度 = 5,內容 = hello cstr2 長度 = 0,內容 = 字串拷貝 strcpy char * strcpy ( char * destination, const char * source ); 要從來源的字串，拷貝到目的字串。 參數1:目的字串(拷貝到那裡？) 參數2:來源字串(要拷貝的字串) 拷貝完成後，會自動在目的字串最後面加上\\0。 1 2 3 4 char c_str1[6] = {'h','e','l','\\0'}; char c_str4[20] = {'t','e'}; strcpy(c_str4, c_str1); cout &lt;&lt; \"c_str4:\" &lt;&lt; c_str4 &lt;&lt; endl; 執行結果 c_str4:hel 字串指標拷貝 strcpy 1 2 3 4 5 6 char* c_str1 = new char[100]; strcpy(c_str1, \"abcdefg\"); char* c_str2 = new char[100]; strcpy(c_str2, c_str1); cout &lt;&lt; \"c_str1 = \" &lt;&lt; c_str1 &lt;&lt; endl; cout &lt;&lt; \"c_str2 = \" &lt;&lt; c_str2 &lt;&lt; endl; c_str1 = abcdefg c_str2 = abcdefg 字串修改 不能使用等於=修改字串，以下語法會編譯錯誤。 1 2 char c_str1[6] = \"Hello\"; c_str1 = \"abc\"; 使用strcpy修改字串。 1 2 3 4 char c_str1[6] = \"Hello\"; cout &lt;&lt; \"Before = \" &lt;&lt; c_str1 &lt;&lt; endl; strcpy(c_str1,\"Dog\"); cout &lt;&lt; \"After = \" &lt;&lt; c_str1 &lt;&lt; endl; Before = Hello After = Dog 字元個數拷貝 strncpy char *strncpy(char *string1, const char *string2, size_t count); 參數1:目的字串(拷貝到那裡？) 參數2:來源字串(要拷貝的字串) 參數3:要拷貝多少個字元 若參數3(拷貝多少個字元)比參數2(來源字串長度)小，拷貝完成後，不會在參數1(目的字串)的結尾加上\\0。 1 2 3 4 5 6 7 8 9 10 11 12 13 char c_str4[10]; //拷貝2個字元至c_str4 strncpy(c_str4,\"hello\",2); cout &lt;&lt; \"c_str4[0] = \" &lt;&lt; c_str4[0] &lt;&lt; endl; cout &lt;&lt; \"c_str4[1] = \" &lt;&lt; c_str4[1] &lt;&lt; endl; cout &lt;&lt; \"c_str4[2] = \" &lt;&lt; c_str4[2] &lt;&lt; endl; cout &lt;&lt; \"c_str4[3] = \" &lt;&lt; c_str4[3] &lt;&lt; endl; cout &lt;&lt; \"c_str4[4] = \" &lt;&lt; c_str4[4] &lt;&lt; endl; cout &lt;&lt; \"c_str4[5] = \" &lt;&lt; c_str4[5] &lt;&lt; endl; cout &lt;&lt; \"c_str4[6] = \" &lt;&lt; c_str4[6] &lt;&lt; endl; cout &lt;&lt; \"c_str4[7] = \" &lt;&lt; c_str4[7] &lt;&lt; endl; cout &lt;&lt; \"c_str4[8] = \" &lt;&lt; c_str4[8] &lt;&lt; endl; cout &lt;&lt; \"c_str4[9] = \" &lt;&lt; c_str4[9] &lt;&lt; endl; 以下XCode可以正常執行，會在第2個字元以後補上\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = \u001e c_str4[3] = VS Code執行時，不會在第2個字元以後自動補\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = &amp; c_str4[3] = x00 c_str4[4] = x00 c_str4[5] = x00 c_str4[6] = x00 c_str4[7] = x00 c_str4[8] = x00 c_str4[9] = x00 若一開始把字串的記憶體位址的值全設為ascii code 0，就不會出現上述問題。 1 2 char c_str4[10] = {0}; strncpy(c_str4,\"hello\",2); 字串長度 strlen strlen()是計算字串中有幾個字元，不包含字串結尾\\0。 sizeof()是計算字串變數全部記憶體大小。 1 2 3 4 5 6 int main() { char c_str4[10] = \"hello!\"; cout &lt;&lt; \"c_str4 size:\" &lt;&lt; sizeof(c_str4) &lt;&lt; endl; cout &lt;&lt; \"c_str4長度:\" &lt;&lt; strlen(c_str4) &lt;&lt; endl; return 0; } c_str4 size:10 c_str4長度:6 字串連接 strcat 1 2 3 4 5 6 7 char c_str1[6] = {'h','e','l','\\0'}; //[]可為空 char c_str2[] = {'h','e','l','l','o','\\0'}; char c_str3[10]; char c_str4[20] = {'t','e'}; strcpy(c_str3, c_str1); cout &lt;&lt; \"c_str3 + c_str4 = \" &lt;&lt; strcat(c_str3,c_str4) &lt;&lt; endl; 執行結果 c_str3 + c_str4 = helte 字串比較 strcmp 二個字串，字元逐字元比較ascii code，直到比完或分出大小為止。 strcmp(s1,s2) s1==s2傳回0 1 2 3 4 5 6 int main() { char* s1 = \"abc\"; char* s2 = \"abc\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } 0 s1&gt;s2傳回正數ascii code 1 2 3 4 5 6 int main() { char* s1 = \"abc\"; char* s2 = \"ab\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } 99 s1&lt;s2傳回負數ascii code 1 2 3 4 5 6 int main() { char* s1 = \"ab\"; char* s2 = \"abc\"; cout &lt;&lt; strcmp(s1,s2) &lt;&lt; endl; return 0; } -99 二維陣列字串 參考 二維陣列 印出禮拜一至禮拜天的英文字母 以下的例子是建立二維的字串，總共有7個字串，每個字串最大長度為10，Wednesday是最長字串，長度為9，加上\\0就等於10。 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; for (int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } Sunday Monday Tuesday Wednesday Thursday Friday Saturday 判斷數字，印出月份英文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //12個月 const int MAX_MONTH = 12; //最長字母September //9個字元+\\0 const int MAX = 10; int main() { char mon_arr[MAX_MONTH][MAX] = {\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"}; int month; cout &lt;&lt; \"請輸入數字月份(1~12):\"; cin &gt;&gt; month; //陣列索引介於0..11，所以要把month-1 cout &lt;&lt; mon_arr[month-1] &lt;&lt; endl; return 0; } 請輸入數字月份(1~12):12 December"
  },"/pages/c/array/qsort/": {
    "title": "qsort排序",
    "keywords": "",
    "url": "/pages/c/array/qsort/",
    "body": "qsort使用方法 void qsort ( void * base , size_t nitems , size_t size , int (* compar )( const void *, const void *)) 參數1，陣列名。 參數2，陣列大小。 參數3，陣列中每個元素的大小。 參數4，callback函式，判斷比大小的函式。 int compar( const void *p1, const void *p2) 傳回值為int整數。 傳回值 &gt; 0 ,p1會排在p2前面 傳回值 == 0 ,p1與p2相等 傳回值 &lt; 0 ,p1會排在p2後面 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int compare(const void* p1, const void* p2) { //void*指標代表接收任何資料型態的參數 //把void*指標轉成int*指標 int* pi1 = (int*) p1; int* pi2 = (int*) p2; //把pi1指標使用*取值運算子，取出pi1記憶體位址存放的值 //把pi2指標使用*取值運算子，取出pi2記憶體位址存放的值 //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回-1 if (*pi1 &lt; *pi2) return -1; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回0 else if (*pi1 == *pi2) return 0; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回1 //else if (*pi1 &gt; *pi2) else return 1; } int main() { //宣告大小為10的整數陣列 int arr[10] = {8,1,7,2,6,3,5,5,1,10}; //陣列大小 int size = sizeof(arr)/sizeof(int); //排序 qsort(arr, size, sizeof(int), compare); for (int i = 0; i &lt; size; i++) { //印出每個元素 cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 執行結果 1,1,2,3,5,5,6,7,8,10,"
  },"/pages/c/basic/typedef/": {
    "title": "typedef類型別名",
    "keywords": "",
    "url": "/pages/c/basic/typedef/",
    "body": "不同作業系統基本資料型態記憶體大小 C++建立不同作業系統(跨平台)可以支援的資料型態。 作業系統 short int long long long Linux 2byte 4byte 8byte 8byte Windows 2byte 4byte 4byte 8byte 由上表可以發現，Linux與Windows在long資料型態占用記憶體大小不同。 類型別名 為了解決long的資料型態在不同作業系統是不同記憶體大小，因此為類型取別名。 在寫程式時，資料型態使用類型別名，不再使用基本資料型態int，short，long，long long，避免不同作業系統資料型態記憶體大小不同的問題。 語法如下 typedef 資料型態 類型別名 Windows類型別名 以下程式碼 int16_t是short的類型別名 int32_t是int的類型別名 int64_t是long long的類型別名 1 2 3 4 //windows typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long long int64_t;//64位元整數 Linux類型別名 int16_t是short的類型別名 int32_t是int的類型別名 int64_t是long的類型別名 1 2 3 4 //Linux typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long int64_t;//64位元整數 size_t 無符號整數類型 在32位元電腦size_t是unsigned int的類型別名 在64位元電腦size_t是unsigned long long的類型別名 電腦 整數 byte數 範圍大小 32位元 unsigned int 4byte 0~4294967295 64位元 unsigned long long 8byte 0 到 18,446,744,073,709,551,615 由上表可以發現不同位元的電腦，C++顯示的整數型態不一樣。 32位元的size_t類型別名 size_t是unsigned int類型別名 1 typedef unsigned int size_t; 64位元的size_t類型別名 size_t是unsigned long long類型別名 1 typedef unsigned long long size_t;"
  },"/pages/c/dynamicMemory/nothrow/": {
    "title": "記憶體不足",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/nothrow/",
    "body": "std::nothrow 可以判斷若記憶體太小導致記憶體空間分配失數，會傳回nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int *arr = new (std::nothrow)int[10000000000000001]; if(arr == nullptr){ cout &lt;&lt; \"記憶體配置失敗\"; } else { arr[10000000000000001] = 100; delete[] arr; arr = nullptr; } return 0; } 執行結果 記憶體配置失敗"
  },"/pages/c/array/array2dimen/": {
    "title": "二維陣列",
    "keywords": "",
    "url": "/pages/c/array/array2dimen/",
    "body": "初始化 初始化方法1 1 2 3 4 5 6 7 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 初始化方法2 1 2 3 4 5 6 7 int arr[2][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; 初始化方法3 第1個[]中不用寫長度，第2個[]中要寫長度。 1 2 3 4 5 6 7 int arr[][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; C11之後不用有等號 1 int arr[][3]{1,2,3,4,5,6}; 以上印出結果都是一樣。 sizeof sizeof在二維陣列的使用方式是取出陣列占記憶體全部的byte。 以下的例子二維陣列有6個元素，每個元素是整數4byte，所以陣列占的記憶體大小為6*4 = 24 1 2 int arr[][3] {1,2,3,4,5,6}; cout &lt;&lt; \"arr size = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; arr size = 24 二維陣列轉成一維陣列 2維陣列記憶體位址是連續 把陣列名指派給指標，是把陣列[0][0]的記憶體位址指派給指標 使用指標把連續的記憶體位址中的值印出來。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;iostream&gt; using namespace std; int main() { //宣告陣列長度，初始化陣列全部元素為整數0 int arr[2][3] = {0}; //指派值到二維陣列 arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; //印出值 cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; //記憶體位址是連續 cout &lt;&lt; \"arr[0][0]位址 = \" &lt;&lt; (long long)&amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1]位址 = \" &lt;&lt; (long long)&amp;arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2]位址 = \" &lt;&lt; (long long)&amp;arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0]位址 = \" &lt;&lt; (long long)&amp;arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1]位址 = \" &lt;&lt; (long long)&amp;arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2]位址 = \" &lt;&lt; (long long)&amp;arr[1][2] &lt;&lt; endl; //因為記憶體位址都是連續的，把二維陣列[0][0]記憶體位址指派給指標p int* p = (int*)arr; //取得arr變數記憶體大小 int size = sizeof(arr) / sizeof(int); for (int i = 0; i &lt; size; i++) { //使用指標運算印出每個元素的值 cout &lt;&lt; \"*(p + \" &lt;&lt; i &lt;&lt; \") = \" &lt;&lt; *(p+i) &lt;&lt; \",\"; //使用索引方式印出值 cout &lt;&lt; \" [\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 arr[0][0]位址 = 140702053823568 arr[0][1]位址 = 140702053823572 arr[0][2]位址 = 140702053823576 arr[1][0]位址 = 140702053823580 arr[1][1]位址 = 140702053823584 arr[1][2]位址 = 140702053823588 *(p + 0) = 1, [0] = 1 *(p + 1) = 2, [1] = 2 *(p + 2) = 3, [2] = 3 *(p + 3) = 4, [3] = 4 *(p + 4) = 5, [4] = 5 *(p + 5) = 6, [5] = 6 從以上結果可以發現，記憶體位址的差距為4byte，而且是連續的。 可以使用指標把二維陣列轉成一維指標陣列，印出值。 指標指向二維陣列 二維陣列可以解釋為，一維陣列，裡面每一個元素又指向一維陣列。 宣告方式 資料類型 (*指標變數)[二維陣列每個元素所指向的一維陣列大小] = 二維陣列變數名; 使用二維陣列指標一定要把*指標變數用括號()包起來，因為有運算子優先順序的問題。 1 2 3 4 5 6 7 int main() { //[3]代表二維陣列每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; //[3]代表二維陣列每個元素是大小為3的一維陣列。 int (*p)[3] = arr; return 0; } 上一個程式碼例子 ，指標是指向二維陣列int[2][3]，無法轉成指向一維陣列的指標int*，所以要強制轉型成指向一維陣列的指標(int*)二維陣列變數名 以下程式碼原本指向一維陣列的指標，指向二維陣列會編譯錯誤。 //二維陣列 int arr[2][3] = {0}; //原本指向一維陣列的指標，直接指向二維陣列會編譯錯誤 int* p = arr; Cannot initialize a variable of type ‘int *’ with an lvalue of type ‘int[2][3]’ 二維陣列先轉成一維陣列，使用(int*)，再讓指標指向轉型成一維的陣列。 int arr[2][3] = {0}; int* p = (int*)arr; 二維陣列傳函式 方法有二種 指標方式 void func(int (*p)[3], int len); 陣列方式 void func(int p[][3], int len); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; void func(int (*p)[3], int len) { for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i][j] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } } int main() { //[3]代表每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; func(arr, 2); return 0; } p[0][0] = 1 p[0][0] = 2 p[0][0] = 3 p[1][1] = 4 p[1][1] = 5 p[1][1] = 6 指標指向三維陣列 宣告方式 資料類型 (*指標變數)[陣列個數][元素個數] = 三維陣列變數名; 三維陣列傳函式的方法有二種 指標方式 void func(int (*p)[2][3], int len); 陣列方式 void func(int p[][2][3], int len); 印出陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; void func(int (*p)[2][3], int len) { for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 3; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } } int main() { int arr[2][2][3] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; func(arr, 2); return 0; } p[0][0][0] = 1 p[0][0][1] = 2 p[0][0][2] = 3 p[0][1][0] = 4 p[0][1][1] = 5 p[0][1][2] = 6 p[1][0][0] = 7 p[1][0][1] = 8 p[1][0][2] = 9 p[1][1][0] = 10 p[1][1][1] = 11 p[1][1][2] = 12 修改陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &lt;iostream&gt; using namespace std; const int firstMax = 2; const int secondMax = 2; const int thirdMax = 3; void modifyArr(int p[][secondMax][thirdMax], int len) { for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; secondMax; j++) { for (int k = 0; k &lt; thirdMax; k++) { //修改指標記憶體位址的值 p[i][j][k] += 10; } }// end of j }// end of i } void printArr(int (*p)[secondMax][thirdMax], int len) { for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; secondMax; j++) { for (int k = 0; k &lt; thirdMax; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; }// end of j cout &lt;&lt; endl; }//end of i } int main() { int arr[firstMax][secondMax][thirdMax] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; modifyArr(arr, firstMax); printArr(arr, firstMax); return 0; } p[0][0][0] = 11 p[0][0][1] = 12 p[0][0][2] = 13 p[0][1][0] = 14 p[0][1][1] = 15 p[0][1][2] = 16 p[1][0][0] = 17 p[1][0][1] = 18 p[1][0][2] = 19 p[1][1][0] = 20 p[1][1][1] = 21 p[1][1][2] = 22"
  },"/pages/c/array/arrayOfPointers/": {
    "title": "指標陣列存放多個記憶體位址",
    "keywords": "",
    "url": "/pages/c/array/arrayOfPointers/",
    "body": "指標陣列 1 2 3 4 5 int i1 = 10; int i2 = 20; int i3 = 30; //宣告指標陣列存放3個記憶體位址 int *p_array[3] = {&amp;i1, &amp;i2, &amp;i3}; 取址與取值 方式有二種 指標方式 使用指標+i迴圈印出，用取值運算子*(p_array + i)取出記憶體位址，再把取出的記憶體位址再次使用*取值運算子，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i= %d的位置%#x, 值為%d\\n\",i, *(p_array + i), *(*(p_array + i))); } i= 0的位置0xbfeff3fc, 值為100 i= 1的位置0xbfeff3cc, 值為20 i= 2的位置0xbfeff3c8, 值為30 陣列方式 使用[索引]取出陣列存放的記憶體位址，再對記憶體位址使用取值運算子*，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i=%d的位置%#x, 值為%d\\n\",i, p_array[i], *p_array[i]); } 指標陣列存放多個字串常數位址 參考 指標陣列存放多個字串常數位址"
  },"/pages/c/array/pointerCharArr/": {
    "title": "char字串指標",
    "keywords": "",
    "url": "/pages/c/array/pointerCharArr/",
    "body": "字串常數 字串常數是包在二個雙引號之間”” \"http://www.google.com\" 以下皆為字串常數 例1 s指標指向字串常數，常數占在記憶體唯讀空間，常數是放在code segment 記憶體區塊，只能讀取，無法修改。 1 char * s = \"http://www.google.com\"; 例2 程式碼中的”abcdefg”是字串常數。 1 2 3 4 5 6 7 8 //使用new動態配置記憶體空間，new會傳回char陣列記憶體區塊的開始記憶體位址。 char* message = new char[100]; //把字串常數abcdefg拷貝至char陣列 strcpy(message, \"abcdefg\"); //記憶體回收 delete[] message; //將指標指向null，代表不指向任何記憶體位址 message = nullptr; 無法透過*取值運算子，把字串常數指派給指標 無法透過*取值運算子，把字串常數指派給指標，以下會編譯錯誤，只能使狦strcpy複製字串常數。 1 2 char* message = new char[100]; *message = \"abcdefg\";//編輯錯誤 字串常數記憶體大小 因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小，注意！strlen不包含結尾\\0的大小，所以計算記憶體空間要再+1，加上結尾\\0的大小 1 2 3 char* s = \"http://www.google.com\";//21個字元(不含結尾\\0) //因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小 size_t s_size = strlen(s) + 1;//strlen不包含結尾\\0的大小 字元陣列不是常數 字元陣列不是常數，以下寫法不是常數，是有占stack堆疊的記憶體空間 1 2 3 char s1[] = \"http://www.google.com\"; cout &lt;&lt; \"s1堆疊記憶體大小=\" &lt;&lt; sizeof(s1) &lt;&lt; endl; cout &lt;&lt; \"s1長度=\" &lt;&lt; strlen(s1) &lt;&lt; endl; s1記憶體大小=22 s1長度=21 指向字串常數的指標 參考 字串常數宣告 指標陣列++ 陣列名是常數，不可修改 以下程式分別為字串陣列與指標初始化字串常數，不可以使用字串陣列名++，因為陣列名是指向陣列記憶體的開始位址，到程式結束前都不會改變，陣列名是常數，就像我們不可能寫成7++的意思是一樣的，而指標是變數，變數就是可以改變值(在這裡是改變存放的記憶體位址)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //cstr1陣列名是記憶體起始位址 char cstr1[] = \"Hello World!\"; //cstr2是指標變數，指向字串常數\"Hello World!\" //常數是放在code segment 記憶體區塊，不可以使用指標指向常數記憶體位址 char* cstr2 = \"Hello World!\"; cout &lt;&lt; \"cstr1 = \" &lt;&lt; cstr1 &lt;&lt; endl; cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; //cstr1陣列名是記憶體起始位址，是常數，不可以++ //cstr1++; //指標是變數，可以修改 //指標原本指向起始位址\"H\"，++移動1byte，指標指向\"e\"的記憶體位址 cstr2++; //印出ello World!，直到遇到\\0結尾字元，就停止輸出 cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } cstr1 = Hello World! cstr2 = Hello World! cstr2 = ello World! 字串指標與函式 參考 空字元 strlen *ptr++ size_t 寫一個傳進指標的函式，函式是把來源字串(src)拷貝到目標字串(desc)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* *desc = *src; desc++;//指標往下一個位址移動，移動1byte src++;//指標往下一個位址移動，移動1byte } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的來源字串 char* src = \"Hello World!\"; //+1是為了加上結尾空字元\\0，strlen預設是不含\\0 size_t len = strlen(src) + 1; //拷貝的目標字串 char* desc = new char[len]; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; //記憶體釋放陣列 delete[] desc; //desc指標不指向任何記憶體位址 desc = nullptr; return 0; } desc = Hello World! 另一種寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* //desc與src指標往下一個位址移動，移動1byte *desc++ = *src++; } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } 指標字串拷貝 參考 字串拷貝-strcpy const右邊是星號 char * strcpy ( char * destination, const char * source ); 使用函式庫strcpy來進行字串拷貝，參數2指標前面有const，代表strcpy()函式不能修改source指標所指向的字元，因為指向的字元是常數，但可以改變指標src指向的位址。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; strcpy(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } desc = Hello World! 指標陣列存放多個字串常數位址 參考 指標陣列存放多個記憶體位址 二維陣列字串 之前二維陣列字串的範例中，定義陣列的大小是7個字串陣列，每個字串固定10byte，記憶體空間就會是70byte，但每個字母有長有短，就會造成記憶體空間上的浪費。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; //印出二維陣列字串的記憶體大小 //7個字串 * 每個字串最大長度10byte cout &lt;&lt; \"str size = \" &lt;&lt; sizeof(str) &lt;&lt; endl; for (int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } str size = 70 Sunday Monday Tuesday Wednesday Thursday Friday Saturday 使用指標陣列，存放多個字串常數的記憶體位址，每個字串常數都有起始記憶體位址，即字串常數的第一個字元的位址，就不用定義二維陣列大小去存放字元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //陣列裡的指標個數 int main() { //陣列存放7個指標，每個指標指向字串常數的第一個字元的位址 char *arr_ptrs[DAYS] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"};//字串指標陣列 //指標的固定大小是8byte，指標陣列存放7個指標，總共大小為8byte*7 cout &lt;&lt; \"arr_ptrs size = \" &lt;&lt; sizeof(arr_ptrs) &lt;&lt; endl; for (int i = 0; i &lt; DAYS; i++) cout &lt;&lt; arr_ptrs[i] &lt;&lt; endl; return 0; } arr_ptrs size = 56 Sunday Monday Tuesday Wednesday Thursday Friday Saturday"
  },"/pages/c/function/callByRef/": {
    "title": "函式傳參考",
    "keywords": "",
    "url": "/pages/c/function/callByRef/",
    "body": "Prerequisites: 參考 傳值與傳參考的程式碼幾乎一模一樣，差別只在於，傳值無法修改傳入的參數，傳值的意義在於不要讓函式修改傳入的參數，而傳參考是允許函式存取傳入的參數。 宣告 語法 函式傳回資料型態 函式名(資料型態&amp; 別名, ...); void callByRef(int&amp; param1, int&amp; param2); 參數宣告為資料型態&amp;，參數就變成別名，引數 就變成原始變數。 傳值 1 2 3 4 5 6 7 8 9 10 11 12 void callByValue(int param1, int param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByValue(i,j); cout &lt;&lt; \"callByValue:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByValue: i = 10, j = 20 傳參考 呼叫函式時，引數不用加&amp; callByRef(i,j); 1 2 3 4 5 6 7 8 9 10 11 12 void callByRef(int&amp; param1, int&amp; param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByRef(i,j); cout &lt;&lt; \"callByReference:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByReference: i = 100, j = 200 傳值與傳參考的差別 二者只有參數不同。 傳值 void callByValue(int param1, int param2) 傳參考 void callByRef(int&amp; param1, int&amp; param2)"
  },"/pages/c/reference/refToPointer/": {
    "title": "參考指向指標",
    "keywords": "",
    "url": "/pages/c/reference/refToPointer/",
    "body": "Prerequisites: 指標的指標 引數 參考指向指標，代表參考可以像指標一樣，使用*取值運算子，取出原指標指向的記憶體位址中的值，也可以修改原指標指向的記憶體位址中的值，或更改原指標指向的記憶體位址。 宣告參考 資料型態*&amp; 別名 = 原指標; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int i = 10; cout &lt;&lt; \"i address:\" &lt;&lt; &amp;i &lt;&lt; endl; int j = 100; cout &lt;&lt; \"j address:\" &lt;&lt; &amp;j &lt;&lt; endl; //宣告指標 int* ptr_i = &amp;i; //宣告參考 // 原指標指派給參考 int*&amp; ptr_ref = ptr_i; cout &lt;&lt; \"== Change value ==\" &lt;&lt; endl; cout &lt;&lt; \"Before i value:\" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"Before value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; //修改原指標指向的記憶體位址中的值 *ptr_ref = 20; cout &lt;&lt; \"After i value:\" &lt;&lt; i &lt;&lt; endl; //取出原指標指向的記憶體位址中的值 cout &lt;&lt; \"After value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; cout &lt;&lt; \"== Change address ==\" &lt;&lt; endl; cout &lt;&lt; \"Before address:\" &lt;&lt; ptr_ref &lt;&lt; endl; //更改原指標指向的記憶體位址 ptr_ref = &amp;j; cout &lt;&lt; \"after address:\" &lt;&lt; ptr_ref &lt;&lt; endl; return 0; i address:0x7ff7bfeff468 j address:0x7ff7bfeff464 == Change value == Before i value:10 Before value:10 After i value:20 After value:20 == Change address == Before address:0x7ff7bfeff468 after address:0x7ff7bfeff464 參考以下文章 https://www.geeksforgeeks.org/different-ways-to-use-const-with-reference-to-a-pointer-in-c/?ref=ml_lbp References to pointers is a modifiable value that’s used same as a normal pointer. (google翻譯)對指標的參考是一個可修改的值，其使用方式與普通指標相同。 函式參數為指向指標的參考 如果要在函式中修改指標指向的記憶體位址，就需要使用指標的指標，也可以使用參考。 引數為指標，函式參數宣告為指標資料型態*&amp; 別名，這樣才可以修改指標指向的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函式並嘗試對其進行修改，則對指標所做的更改不會反映回該函式外部。這是因為僅將指標的副本傳遞給函式。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函式內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變數，而原始指標保持不變。 語法 函式語法 傳回型態 函式名(資料型態*&amp; 別名) { 別名 = 其它記憶體位址 } 呼叫函式語法 函式(指標) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &amp;global_var; } int main() { int var = 1; int* pointer_to_var = &amp;var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 函式參數指標的指標與指標的別名程式差異 指標的別名 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &global_var; } int main() { int var = 1; int* pointer_to_var = &var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 指標的指標 int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 參考指向指標與new 參考文章 指標的指標與new new會返回動態配置記憶體的開始位址，將別名指向new返回的新位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 別名是ref_to_p，指向外部傳入的指標 void initAddress(int*&amp; ref_to_p){ //印出別名指向的記憶體位址 cout &lt;&lt; \"Before address = \" &lt;&lt; ref_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 ref_to_p = new int(10); //印出別名指向的記憶體位址 cout &lt;&lt; \"After address= \" &lt;&lt; ref_to_p &lt;&lt; \",After value = \" &lt;&lt; *ref_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p initAddress(p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before address = 0x0 After address= 0x600000004010,After value = 10 == outside == outside pointer address = 0x600000004010，outside pointer value = 10"
  },"/pages/c/reference/reference/": {
    "title": "參考",
    "keywords": "",
    "url": "/pages/c/reference/reference/",
    "body": "宣告方法 資料型態&amp; 參考別名 = 原始變數; 注意事項 宣告參考別名時，要初始化原始變數。 初始化後不可改變原始變數。 別名可以存取原始變數，參考別名與原始變數都是指向相同記憶體位址。 宣告 1 2 3 4 5 int i = 10;//原始變數 //宣告參考 int&amp; ref = i;//初始化原始變數，ref是i的別名 cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 由執行結果可知，i跟ref的記憶體位址相同，值也相同。 一定要初始化 以下的程式寫法會編譯錯誤，因為ref參考別名沒有初始化。 1 2 3 int i = 10;//原始變數 //宣告參考 int&amp; ref; 參考別名跟原始變數功能一樣，可以修改跟讀取記憶體內容。 參考別名跟原始變數都指向相同記憶體位址，所以可以做一樣的操作。 1 2 3 4 5 6 7 8 9 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; ref = 30; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 i的記憶體位址 = 0x7ff7bfeff468, i = 30 ref的記憶體位址 = 0x7ff7bfeff468, ref = 30 由執行結果可以發現修改ref參考別名，就等於修改變數i，i跟ref的值都變成30。 一個變數可以多個參考別名 1 2 3 4 5 6 7 8 9 10 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int&amp; ref2 = i; cout &lt;&lt; \"ref2的記憶體位址 = \" &lt;&lt; &amp;ref2 &lt;&lt; \", ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; int&amp; ref3 = i; cout &lt;&lt; \"ref3的記憶體位址 = \" &lt;&lt; &amp;ref3 &lt;&lt; \", ref3 = \" &lt;&lt; ref3 &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 ref2的記憶體位址 = 0x7ff7bfeff468, ref2 = 10 ref3的記憶體位址 = 0x7ff7bfeff468, ref3 = 10 各種寫法 &amp;只要介於資料型態與參考別名之間就可以，以下的宣告別名的方式都可以。 1 2 3 4 5 6 int i = 10;//原始變數 //宣告參考別名 int&amp;ref = i; int &amp;ref2 = i; int &amp; ref3 = i; int&amp; ref4 = i; 資料型態要一致，參考別名無強制轉型 以下是錯誤的參考別名宣告 1 2 3 int i = 10;//原始變數 //宣告參考別名 double&amp; ref = i; 原始變數i是int，無法轉成double的資料型態，也沒辦法像指標有強制轉型的功能。 初始化後不可改變原始變數 1 2 3 4 5 6 7 8 9 10 11 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int j = 20; ref = j; //將j變數 指派給 ref別名 cout &lt;&lt; \"j的記憶體位址 = \" &lt;&lt; &amp;j &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", i = \" &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; 上方的程式碼 int j = 20; ref = j; //將j變數的值 指派給 ref參考別名 以上意思並非把原始變數設為j，實際上是變數i修改成20，ref是變數i的參考別名，就等同於變數i，所以上述程式碼可以看成i = 20; 執行結果 i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 j的記憶體位址 = 0x7ff7bfeff45c, j = 20 ref的記憶體位址 = 0x7ff7bfeff468, i = 20 i的記憶體位址 = 0x7ff7bfeff468, i = 20 由執行結果可以發現，執行ref = j;參考別名j的記憶體位址跟i相同，但j的值變成20，i的值也變成20，修改ref就等同於修改i，所謂的參考別名就是給變數i另一個假名ref，但指向的都是相同記憶體位址。"
  },"/pages/c/basic/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/basic/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; }"
  },"/pages/c/basic/lvalue/": {
    "title": "等號左邊lvalue",
    "keywords": "",
    "url": "/pages/c/basic/lvalue/",
    "body": "等號左邊(lavlue)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 常數可以是字串常數、表達式。"
  },"/pages/c/c11/rvalue/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 區別方式 有名字一律為左值l-value，沒有名字一律為右值r-value 可以取得記憶體位址一律為左值，沒有辦法取得記憶體位址一律為右值 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; } 函式傳回值為物件的值 函式傳回值是值 以下的程式碼，main()和getStudente()都各別有存放傳回值student的記憶體位址，待getStudent()的student變數傳回給main()的student變數後，getStudent()的student變數的記憶體位址就會被釋放。 被記憶體釋放，不會被保留住的物件，也是右值r-value。 傳回物件 1 2 3 4 5 6 7 8 Student getStudent() { Student student; return student; } int main() { Student student = getStudent(); return 0; } 傳回值是臨時物件 臨時物件 臨時物件是右值。 臨時物件建立語法 類別名() Student() 1 2 3 4 5 6 7 Student getStudent() { return Student(); } int main() { Student student = getStudent(); return 0; }"
  },"/pages/c/c11/rvalue/constRef/": {
    "title": "const與參考",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/constRef/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 const參考 const參考可以放左值(l-value)，也可以放右值(r-value)，也可以放常數。 const參考放左值 1 2 3 4 5 6 7 int main() { // i 是l-value int i = 100; // 100 is r-value const int&amp; ref_i = i; cout &lt;&lt; \"ref_i = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_i = 100 const參考放右值 1 2 3 4 5 int main() { const int&amp; ref_r = 100; // 100 is r-value cout &lt;&lt; \"ref_r = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_r = 100 const參考放右值&amp;&amp;變數名 1 2 3 4 5 6 int main() { int&amp;&amp; r = 100; const int&amp; ref_r = r; cout &lt;&lt; \"ref_r = \" &lt;&lt; ref_i &lt;&lt; endl; return 0; } ref_r = 100 const參考放常數名 1 2 3 4 5 6 7 int main() { //con 是常數 const int con = 100; const int&amp; ref = con; cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; return 0; } ref = 100 const參考放常數值 1 2 3 4 5 int main() { const int&amp; ref = 100; //100是常數 cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; return 0; } ref = 100 函式參數為const參考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void func(const int&amp; ref) { cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; } int main() { // i is l-value int i = 10; //l-value func(i); //r-value int&amp;&amp; r = 20; func(r); func(100);// 常數 100 , 100 is r-value func('A');// 常數 'A' , A is r-value return 0; } ref = 10 ref = 20 ref = 100 ref = 65"
  },"/pages/c/c11/rvalue/l_r_ref/": {
    "title": "l-value參考與r-value參考",
    "keywords": "",
    "url": "/pages/c/c11/rvalue/l_r_ref/",
    "body": "Prerequisites: l-value與r-value l-value參考 l-value參考指向變數 1 2 3 4 5 6 7 8 9 int main() { int i = 10; int&amp; l_ref = i; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; l_ref = 55; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; return 0; } l-value ref = 10 === modify ref === l-value ref = 55 r-value參考 幫右值取名字 語法 右值資料型態&amp;&amp; 右值變數名 = 右值; int&amp;&amp; r_ref = 100; r-value參考指向數字 1 2 3 4 5 6 7 8 int main() { int&amp;&amp; r_ref = 100; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; r_ref = 1000; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; return 0; } r-value ref = 100 === modify ref === r-value ref = 1000 取出右值記憶體位址 右值取名字後，名字就變成左值，就可以取出記憶體位址。 1 2 3 4 5 int main() { int&amp;&amp; r = 10; cout &lt;&lt; \"r address = \" &lt;&lt; &amp;r &lt;&lt; endl; return 0; } r address = 0x7ff7bfeff45c 修改右值 右值取名字後，名字就變成左值，可以修改值。 1 2 3 4 5 6 int main() { //r-value int&amp;&amp; r = 10; cout &lt;&lt; \"Before r = \" &lt;&lt; r &lt;&lt; endl; r = 20; cout &lt;&lt; \"After r = \" &lt;&lt; r &lt;&lt; endl; Before r = 10 After r = 20 左值不能放在右值參考 以下程式碼會編譯錯誤 1 2 3 4 5 6 7 int main() { //l_val是l-value int l_val = 10; //定義右值參考 int&amp;&amp; r_val_ref = l_val; return 0; } 右值不能放在左值參考 以下程式碼會編譯錯誤 1 2 3 4 5 int main() { // 10 is r-value int&amp; l_val_ref = 10; return 0; } 函式參數為l-value參考 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; void func(int&amp; l_ref) { l_ref = 20; } int main() { int i = 10; cout &lt;&lt; \"before i = \" &lt;&lt; i &lt;&lt; endl; func(i); cout &lt;&lt; \"after i = \" &lt;&lt; i &lt;&lt; endl; return 0; } before i = 10 after i = 20 函式參數為r-value參考 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; void func(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func(1000); return 0; } r-value = 1000 引數與參數r-value參考資料型態不同 引數與參數的資料型態不同，若自動轉型可以轉成功，也可以使用r-value參考。 1 2 3 4 5 6 7 void func1(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func1('B'); return 0; } r-value = 66 函式傳回值為右值 臨時物件 語法 類別名&amp;&amp; 變數名 = 函式(); Student&amp;&amp; s1 = getStudent1(); 把右值取了名字，這個名字就是左值，可以做左值能做的事，比如存取物件成員變數，呼叫成員函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Student { public: string name; }; Student getStudent1() { Student s; s.name = \"Bill\"; return s; } Student getStudent2() { //臨時物件 return Student(); } int main() { Student&amp;&amp; s1 = getStudent1(); cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.name &lt;&lt; endl; Student&amp;&amp; s2 = getStudent2(); s2.name = \"Mary\"; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.name &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Mary"
  },"/pages/c/function/callByValue/": {
    "title": "函式傳值與傳回值",
    "keywords": "",
    "url": "/pages/c/function/callByValue/",
    "body": "Prerequisites: 引數 函式傳遞值 Call by value 解釋1 函式會建立新的變數將引數拷貝到新的變數，將新的變數作為參數，所以在函式對參數做的任何操作，實際上是對新的變數做操作，而不是對引數做操作。 解釋2 參數一進入函式，函式即建立新的變數保管這些參數值，同時新變數的資料型態完全吻合參數的資料型態，這種傳遞參數的方式會先把參數複製一份，稱為傳值呼叫(call by value)。 解釋3 以傳值方式傳遞參數的函式會建立一個與參數型態相同的變數，然後把參數的值複製到該變數，因此，函式不能存取原來的變數，僅能存取其拷貝值。當函式無須修改原來的變數值時，傳值的方法很實用，同時保證函式不會破壞原來的變數值。 以下程式碼是將引數x傳遞給函式setX()，將引數x拷貝到參數r，對參數r進行修改，並不會影嚮x引數。 1 2 3 4 5 6 7 8 9 10 11 12 //r為參數 void setX(int r){ r = 1000; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x為引數 setX(x); cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 10 函式傳回值是值 解釋1 以下的程式碼，main()和getValue()都各別有存放傳回值r的記憶體位址，待getValue()的r變數傳回給main()的r變數後，getValue()的r變數的記憶體位址就會被釋放。 解釋2 記憶體配置 函式會將傳回值拷貝到暫存器或stack中，然後再傳回拷貝到暫存器或stack中的值，接下來再把函式中區域變數記憶體釋放。 1 2 3 4 5 6 7 8 9 int getValue(){ int r = 1000; return r; } int main() { int r = getValue(); cout &lt;&lt; \"r = \" &lt;&lt; r &lt;&lt; endl; return 0; } r = 1000"
  },"/pages/c/function/func_return_ref/": {
    "title": "函式傳回值是參考",
    "keywords": "",
    "url": "/pages/c/function/func_return_ref/",
    "body": "Prerequisites: 傳參考 函式傳回值是值 若傳回值是參考別名，將不會拷貝傳回值到暫存器或stack。 函式宣告語法 資料型態&amp; 函式名(資料型態&amp; 參考別名) int&amp; getValue(int&amp; z); 函式呼叫方式 y是原始變數的參考別名。 資料型態&amp; 參考別名 = 函式(原始變數); int&amp; y = getValue(原始變數); 以下程式碼z與y都是x(原始變數)的參考別名，z與y與x三者都指向相同記憶體位址。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/reference/l_ref_func/": {
    "title": "等號左邊的函式",
    "keywords": "",
    "url": "/pages/c/reference/l_ref_func/",
    "body": "Prerequisites: 引數 函式傳回值是參考 函式傳回值是參考別名 以下程式碼是將全域變數x的參考別名作為傳回值。 1 2 3 4 5 6 //全域變數 int x = 10; //返回全域變數x的參考別名 int&amp; setX(){ return x; } 將setX() = 99可以視作為int&amp; x_ref = 99; 二者是相同意思。 1 setX() = 99; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 //全域變數 int x = 10; //返回全域變數x的參考 int&amp; setX(){ return x; } int main() { cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //將x全域變數參考，設值成99 setX() = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 不能傳回區域變數的參考 以下程式碼會出錯，因為區域變數x在函式結束的時候就會被系統記憶體釋放，無法作為參考。 1 2 3 4 int&amp; setX(){ int x = 10; return x; } 引數作為參考 以下程式碼將main()函式中的x變數傳進setX()的函式，並傳回x變數的匿名參考別名。 將x的參考設值99。 1 2 3 4 5 6 7 8 9 10 11 12 13 //傳回值為參考別名 //參數r為x的參考別名 int&amp; setX(int&amp; r){ return r; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x傳入函式，傳回x的參考 setX(x) = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 函式不想放在等號左邊 若不想被人修改傳回值，可將傳回值設為const，但函式呼叫者也需要加上const。 函式語法 const 資料型態&amp; 函式名(資料型態&amp; 原始變數); const int&amp; getValue(int&amp; z); 函式呼叫者 const 資料型態&amp; 別名 = 函式名(原始變數); const int&amp; y = getValue(x); 以下程式碼將編譯錯誤，函式無法放在等號左邊。 getValue(x) = 100; 以下為完整程式碼 1 2 3 4 5 6 7 8 9 10 11 const int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; const int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/struct/struct_def/": {
    "title": "定義結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_def/",
    "body": "想要建立只有資料的物件時，使用 struct；其他狀況一律使用 class。 結構是變數的集合，變數可以不是不同型態，例如有的是int，有的是float，結構中每一個變數都是該結構的成員。 定義結構有以下三種方式 方式1 宣告結構 關鍵字struct宣告，緊號於struct後的是結構名稱，變數的宣告都在大括號{}內，大括號{}結尾一定要加上分號; struct 結構名 { 變數宣告 }; 1 2 3 4 5 6 struct Student { //學生姓名 char* name; //學號 int id; }; 結構放置位置 放在main()上面，或者放在標頭檔。 定義結構變數 結構可想像成一種新的資料型態，int也是一種資料型態，定義結構變數會在記憶體配置空間。 結構名 變數名; 1 2 3 4 int main() { Student student; return 0; } 存取結構成員 存取方式有二種 點運算子 使用點運算子(dot operator)指派或修改結構成員的值。 1 2 3 Student student; student.name = \"Mary\"; student.id = 1; cout讀取結構成員。 1 2 cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; }; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 1 大括號 使用大括號修改結構。 結構名 = {值1,值2,值3, ...}; 1 student = {\"Bill\",2}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; }; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; \"Before:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; student = {\"Bill\",2}; cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 方式2 同時宣告結構與定義結構變數 在大括號的結尾輸入結構變數，在main()函式不用定義結構變數，直接使用結構變數。 struct 結構名{ 變數宣告 }結構變數; 1 2 3 4 5 6 struct Student { //學生姓名 char* name; //學號 int id; }student; 存取結構成員 在main()函式不用定義結構變數，直接使用結構變數。 1 2 3 4 5 6 7 int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; struct Student { //學生姓名 char* name; //學號 int id; } student; int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 方式3 宣告結構 使用typedef(型別定義)關鍵字，後面緊跟著struct關鍵字，再來是大括號{}，變數的宣告在大括號{}中，結構名放在大括號結尾，最後加上分號;結束。 typedef struct { 變數宣告 } 結構名; 1 2 3 4 5 6 typedef struct { //學生姓名 char* name; //學號 int id; } Student; 定義結構變數 結構名 變數名; 1 Student student; 存取結構成員 與方式一相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; typedef struct { //學生姓名 char* name; //學號 int id; } Student; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; }"
  },"/pages/c/struct/struct_pointer/": {
    "title": "指標指向結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_pointer/",
    "body": "宣告指標 結構 指標變數 = 結構變數地址; Student *ptr = &amp;student; 存取結構成員 使用取值運算子 (*指標變數).成員 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"marry\", 1}; Student *ptr = &amp;student; cout &lt;&lt; \"姓名 : \" &lt;&lt; (*ptr).name &lt;&lt; endl; cout &lt;&lt; \"學號 : \" &lt;&lt; (*ptr).id &lt;&lt; endl; return 0; } 使用-&gt; 指標變數-&gt;成員 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"marry\", 1}; Student *ptr = &amp;student; cout &lt;&lt; \"姓名 : \" &lt;&lt; ptr-&gt;name &lt;&lt; endl; cout &lt;&lt; \"學號 : \" &lt;&lt; ptr-&gt;id &lt;&lt; endl; return 0; }"
  },"/pages/c/struct/struct_init/": {
    "title": "初始化結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_init/",
    "body": "使用大括號{}初始化 結構 變數名 = {值1, 值2 ...} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {\"Mary\", 1}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 1 定義結構時初始化 struct 結構名{ 變數宣告 }結構變數={值1, 值2 ...}; 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {\"Bill\", 2}; int main() { cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Bill 2 結構成員記憶體位址的值全初始化成00000000 方式1 {0}把成員初始化00000000。 struct 結構名{ 變數宣告 }結構變數={0}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {0}; int main() { return 0; } 結構 變數名 = {0} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {0}; return 0; } 方式2 只寫大括號也是把成員初始化00000000。 struct 結構名{ 變數宣告 }結構變數={}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student = {}; int main() { return 0; } 結構 變數名 = {} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student = {}; return 0; } 方式3 c11之徫可以省略等於= struct 結構名{ 變數宣告 }結構變數{}; 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student{}; int main() { return 0; } 結構 變數名{} 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student{}; return 0; } 方式4 使用memset() memset(結構變數地址,0,sizeof(結構變數)); 1 2 3 4 5 int main() { Student student; memset(&amp;student, 0, sizeof(student)); return 0; }"
  },"/pages/c/struct/struct_array/": {
    "title": "結構陣列",
    "keywords": "",
    "url": "/pages/c/struct/struct_array/",
    "body": "Prerequisites: 陣列清空 陣列運算 結構陣列的宣告方式 結構 陣列名[陣列大小]; Student students[size]; 結構陣列指定元素 使用.運算子 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); strcpy(students[0].name,\"Bill\"); students[0].id = 1; strcpy(students[1].name,\"Mary\"); students[1].id = 2; strcpy(students[2].name,\"Jeff\"); students[2].id = 3; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; students[i].id; cout &lt;&lt; \", name = \" &lt;&lt; students[i].name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用大括號{} C++11以上才能使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); students[0] = {\"Bill\",1}; students[1] = {\"Mary\",2}; students[2] = {\"Jeff\",3}; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; students[i].id; cout &lt;&lt; \", name = \" &lt;&lt; students[i].name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用指標運算取值 使用箭頭-&gt;方式取值，括號()前面不需要加上星號* (陣列名 + 元素索引index)-&gt;結構成 1 (students+0)-&gt;id 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); students[0] = {\"Bill\",1}; students[1] = {\"Mary\",2}; students[2] = {\"Jeff\",3}; cout &lt;&lt; \"id = \" &lt;&lt; (students+0)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+0)-&gt;name &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; (students+i)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+i)-&gt;name &lt;&lt; endl; } return 0; } id = 1, name = Bill id = 1, name = Bill id = 2, name = Mary id = 3, name = Jeff 使用指標運算指定值 *(陣列名 + 元素索引index) = {值1,值2, ...}; 1 2 3 *(students + 0) = {\"Bill\",1}; *(students + 1) = {\"Mary\",2}; *(students + 2) = {\"Jeff\",3}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { int size = 3; //建立三個學生 Student students[size]; //清空資料 //參數1是地址，student陣列名就是陣列記憶體的開始位址 memset(students, 0, sizeof(students)); *(students + 0) = {\"Bill\",1}; *(students + 1) = {\"Mary\",2}; *(students + 2) = {\"Jeff\",3}; cout &lt;&lt; \"id = \" &lt;&lt; (students+0)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+0)-&gt;name &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"id = \" &lt;&lt; (students+i)-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; (students+i)-&gt;name &lt;&lt; endl; } return 0; }"
  },"/pages/c/struct/struct_char/": {
    "title": "結構與字串",
    "keywords": "",
    "url": "/pages/c/struct/struct_char/",
    "body": "Prerequisites: 字串常數 字串修改 字串指標 結構成員與char字串 以下結構成員name為char字串。 1 2 3 4 5 6 typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; 使用char字串，不能使用等於=指定值，以下語法將編譯錯誤。 1 student.name = \"Mary\"; 正確使用的方式是使用strcpy拷貝字串到char字串。 1 strcpy(student.name, \"Mary\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //學號 int id; }Student; int main() { Student student; //清空資料 //student記憶體位址的值全設為00000000 memset(&amp;student, 0, sizeof(student)); //姓名 strcpy(student.name, \"Mary\"); //學號 student.id = 100; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 100 結構成員與char字串指標 以下結構成員name為char字串指標。 1 2 3 4 5 6 typedef struct{ //學生姓名 char* name; //學號 int id; }Student; 使用char字串指標，可以使用等於=指定值。 1 student.name = \"Mary\"; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student; //清空資料 //student記憶體位址的值全設為00000000 memset(&amp;student, 0, sizeof(student)); //姓名 student.name = \"Mary\"; //學號 student.id = 100; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 100 結構成員與char字串與字串指標(c11) 使用大括號的方式，不管是字串或字串指標都可以用雙引號”“指定值。 1 student = {\"Mary\",\"桃園市XX區XX號\", 1}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //地址 char* address; //學號 int id; }Student; int main() { Student student; student = {\"Mary\",\"桃園市XX區XX號\", 1}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.address &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 桃園市XX區XX號 1 無法使用大括號修改單獨成員是字串陣列 以下的寫法會編譯錯誤 1 student.name = {\"Bill\"}; 必須使用strcpy修改單獨成員是字串陣列 1 strcpy(student.name, \"Bill\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char name[100]; //地址 char* address; //學號 int id; }Student; int main() { Student student; student = {\"Mary\",\"桃園市XX區XX號\", 1}; strcpy(student.name, \"Bill\"); cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.address &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Bill 桃園市XX區XX號 1"
  },"/pages/c/struct/arrayInStruct/": {
    "title": "結構中的陣列",
    "keywords": "",
    "url": "/pages/c/struct/arrayInStruct/",
    "body": "結構中定義陣列 定義成員score[3] 1 2 3 4 5 6 7 struct Student{ //學生姓名 char* name; //學號 int id; int score[3]; }; 初始化結構中的陣列 方式一 1 Student student = {\"Mary\", 1, {60,70,80}}; 方式二 1 Student student = {\"Mary\", 1, 60,70,80}; 存取結構中的陣列 修改的寫法 結構.成員[索引] = 值 1 2 3 student.score[0] = 50; student.score[1] = 60; student.score[2] = 70; 讀取寫法 cout &lt;&lt; 結構.成員[索引] &lt;&lt; endl; 1 2 3 for(int i = 0; i &lt; 3; i++) { cout &lt;&lt; \"score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt;student.score[i] &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; //結構中的陣列 int score[3]; }; int main() { //初始化 Student student = {\"Mary\", 1, 60,70,80}; //修改結構中的陣列 student.score[0] = 50; student.score[1] = 60; student.score[2] = 70; //印出陣列元素 for(int i = 0; i &lt; 3; i++) { cout &lt;&lt; \"score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt;student.score[i] &lt;&lt; endl; } return 0; } 傳遞結構中的陣列給函式 不管結構中的陣列是一維或多維，傳遞結構中的陣列給函式，函式參數都是指向結構的指標。 傳回值 函式名(結構指標* 指標變數名); void printParent(Student* student); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; const int PARENT_SIZE = 2; struct Student{ //學生姓名 char* name; //學號 int id; //定義二維陣列 char parent[PARENT_SIZE][100]; }; //函式參數是指向結構的指標 void printParent(Student* student) { for(int i = 0; i &lt; PARENT_SIZE; i++) { //因為是指標，所以存取成員使用-&gt; cout &lt;&lt; student-&gt;parent[i] &lt;&lt; endl; } } int main() { //初始化 Student student = {\"Mary\", 1, {\"Alice\",\"Bill\"}}; //把結構的位址傳入函式 printParent(&amp;student); return 0; } Alice Bill"
  },"/pages/c/struct/nestedStruct/": {
    "title": "巢狀結構",
    "keywords": "",
    "url": "/pages/c/struct/nestedStruct/",
    "body": "Prerequisites: 無法使用大括號修改單獨成員是字串陣列 巢狀結構指的是結構中還有結構。 定義巢狀結構 結構中的結構要先定義。 1 2 3 4 5 6 7 8 9 10 11 struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; 初始化巢狀結構 初始化方式有2種。 方式一 巢狀結構的值放進大括號中。 結構 變數名 = {值1,值2,巢狀值1,巢狀值2}; 1 Student student = {\"Mary\", 1,338, \"桃園市xxx\"}; 方式二 大括號中有大括號包著巢狀結構。 結構 變數名 = {值1,值2,{巢狀值1,巢狀值2}}; 1 Student student = {\"Mary\", 1,{338, \"桃園市xxx\"}}; 修改巢狀結構 方式有二種。 大括號 變數名 = {值1,值2,巢狀值1,巢狀值2}; 1 student = {\"Bill\", 2, 100, \"台北市xxx\"}; 點運算子 結構變數.巢狀結構成員 = {巢狀值1,巢狀值2}; 1 2 3 student.name = \"Jeff\"; student.id = 3; student.address = {300,\"新竹縣xxxx\"}; 單獨修改巢狀結構中的成員 若巢狀結構中的成員是字串，修改方式如下 1 strcpy(student.address.addr, \"新竹縣xxxx\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; int main() { Student student = {\"Mary\", 1, {338, \"桃園市xxx\"}}; student.name = \"Jeff\"; student.id = 3; student.address.zip = 300; strcpy(student.address.addr, \"新竹縣xxxx\"); cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; return 0; } After: Jeff 3 300 新竹縣xxxx 讀取巢狀結構成員 結構變數.巢狀結構成員.成員 student.address.zip 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; struct Address{ int zip; char addr[100]; }; struct Student{ //學生姓名 char* name; //學號 int id; Address address; }; int main() { Student student = {\"Mary\", 1, {338, \"桃園市xxx\"}}; cout &lt;&lt; \"Before:\" &lt;&lt; endl; student = {\"Bill\", 2, 100, \"台北市xxx\"}; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; student.name = \"Jeff\"; student.id = 3; student.address = {300,\"新竹縣xxxx\"}; cout &lt;&lt; \"After:\" &lt;&lt; endl; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; cout &lt;&lt; student.address.zip &lt;&lt; endl; cout &lt;&lt; student.address.addr &lt;&lt; endl; return 0; } Before: Bill 2 100 台北市xxx After: Jeff 3 300 新竹縣xxxx"
  },"/pages/c/dynamicMemory/memset/": {
    "title": "memset",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memset/",
    "body": "memset主要目的是把記憶體位址的內容(值)，設成00000000。 字串清空 資料型態為char，設成00000000，就等同設成\\0空字元(null character)，ascii code為0 陣列清空 結構清空 結構中指標清空 資料型態為指標，設成00000000，是把指標所指向的記憶體位址的內容(值)，設成00000000，等同於釋放記憶體空間，並非把指標的指向的位址改為00000000。"
  },"/pages/c/struct/pointerInStruct/": {
    "title": "結構中的指標",
    "keywords": "",
    "url": "/pages/c/struct/pointerInStruct/",
    "body": "Prerequisites: new/delete null 記憶體區間 memset與結構中的指標 要把結構中的指標釋放記憶體，光是把結構使用memset把結構記憶體的值全設為00000000是不夠的，因為只是把指標指向的位置指到00000000(null 記憶體區間)，原本指標指向的位置的值仍未清空成0，會造成記憶體洩露。 錯誤作法 memset(&amp;student, 0, sizeof(student)); 以下為錯誤作法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;iostream&gt; using namespace std; const int SCORE_MAX = 3; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 int *score; }; int main() { Student student; strcpy(student.name, \"Mary\"); student.id = 1; student.score = new int[SCORE_MAX]; for(int i = 0; i &lt; SCORE_MAX; i++) { student.score[i] = i; } //100 byte(name) + 4 byte(id) + 8 byte(*score指標) //總共占 112 byte記憶體大小 cout &lt;&lt; \"結構大小 = \" &lt;&lt; sizeof(student) &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; //將student.score的記憶體位址先暫存下來 int* pp = student.score; //將結構的成員全清成00000000 memset(&amp;student, 0, sizeof(student)); cout &lt;&lt; \"After memset :\" &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; cout &lt;&lt; \"原結構成員指標指向的記憶體位址 = \" &lt;&lt; pp &lt;&lt; endl; //原結構成員指標指向的記憶體位址中的值 for(int i = 0; i &lt; SCORE_MAX; i++) { cout &lt;&lt; \"student.score[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; *(pp + i) &lt;&lt; endl; } return 0; } 結構大小 = 112 結構成員指標指向的記憶體位址 = 0x600000008040 After memset : 結構成員指標指向的記憶體位址 = 0x0 原結構成員指標指向的記憶體位址 = 0x600000008040 student.score[0] = 0 student.score[1] = 1 student.score[2] = 2 正確作法 memset(student.score, 0, sizeof(int)*SCORE_MAX); memset第3個參數不可以寫成成員指標，因為指標的記憶體大小永遠是8。 以下是錯誤寫法 memset(student.score, 0, sizeof(student.score)); 以下的作法才是真正做到結構中指標的記憶體釋放。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;iostream&gt; using namespace std; const int SCORE_MAX = 3; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 int *score; }; int main() { Student student; strcpy(student.name, \"Mary\"); student.id = 1; student.score = new int[SCORE_MAX]; for(int i = 0; i &lt; SCORE_MAX; i++) { student.score[i] = i; } //100 byte(name) + 4 byte(id) + 8 byte(*score指標) //總共占 112 byte記憶體大小 cout &lt;&lt; \"結構大小 = \" &lt;&lt; sizeof(student) &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"結構成員指標指向的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; //將student.score的記憶體位址先暫存下來 int* pp = student.score; //將結構的成員指向的記憶體位址的值全清成00000000 memset(student.score, 0, sizeof(int)*SCORE_MAX); //將結構的成員全清成00000000 memset(&amp;student, 0, sizeof(student)); cout &lt;&lt; \"After memset :\" &lt;&lt; endl; //印出score指標指向的記憶體位址 cout &lt;&lt; \"原score成員的記憶體位址 = \" &lt;&lt; *pp &lt;&lt; endl; cout &lt;&lt; \"score成員的記憶體位址 = \" &lt;&lt; student.score &lt;&lt; endl; return 0; } 結構大小 = 112 結構成員指標指向的記憶體位址 = 0x600000004060 After memset : 原score成員的記憶體位址 = 0 score成員的記憶體位址 = 0x0 結構中的指標是自己 注意看結構Student中的指標指向的是Student結構，也就是結構中的指標是自已。 1 2 3 4 5 6 7 8 struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; 不能寫成以下的寫法，會編譯失敗。 1 2 3 4 5 6 7 8 struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student next; }; 以上設計這種結構是表示每一個學生都有一個指標，指向下一個學生。 學生A-&gt;學生B-&gt;學生C-&gt;學生D-&gt;null 初始化 初始化有三種方法 方式一 1 2 3 4 Student *student = new Student; strcpy(student-&gt;name, \"Mary\"); student-&gt;id = 1; student-&gt;next = nullptr; 方式二 1 Student *student = new Student({ \"Mary\", 1, nullptr}); 1 2 Student *student = nullptr; student = new Student({ \"Mary\", 1, nullptr}); 方式三 1 2 Student *student; *(student) = {1, \"Mary\", nullptr}; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; int main() { Student *student = new Student({ \"Mary\", 1, nullptr}); return 0; }"
  },"/pages/c/struct/linked_list/": {
    "title": "鏈結串列",
    "keywords": "",
    "url": "/pages/c/struct/linked_list/",
    "body": "Prerequisites: 結構中的指標是自己 初始化頭節點/尾節點/暫存節點 1 2 3 4 5 6 //頭節點 Student *head = nullptr; //尾節點 Student *tail = nullptr; //暫存節點 Student *temp = nullptr; 建立節點 建立第一個節點 1 2 3 4 5 //建立第1個節點 temp = new Student({ \"Mary\", 1, nullptr}); //讓頭節點與尾節點全指向新分配的節點 head = tail = temp; 建立第二個節點 1 2 3 4 5 6 //建立第2個節點 temp = new Student({ \"Bill\", 2, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; 建立第三個節點 程式碼與前一個程式一樣。 1 2 3 4 5 6 //建立第3個節點 temp = new Student({ \"Eric\", 3, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; 遍歷鏈節串列 從頭節點開始，沿著next指標往後移動，直到next是nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 //遍歷鏈節串列 //從頭節點開始 //把頭節點指向temp指標 temp = head; //如果temp指標不是nullptr，就進去while while(temp != nullptr) { //印出姓名學號 cout &lt;&lt; \"id = \" &lt;&lt; temp-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; temp-&gt;name &lt;&lt; endl; //把temp指標移到下一個節點 temp = temp-&gt;next; } 刪除鏈節串列 從頭節點開始刪，沿著next指標往後移動，直到next是nullptr。 1 2 3 4 5 6 7 8 9 10 11 //刪除鏈節串列 //從頭節點開始刪除 //如果頭節點不為nullptr while(head != nullptr) { //頭節點先暫存到暫存節點 temp = head; //頭節點指標往後移動 head = head-&gt;next; //刪除暫存節點 delete temp; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char name[100]; //學號 int id; //結構中的指標 Student *next; }; int main() { //頭節點 Student *head = nullptr; //尾節點 Student *tail = nullptr; //暫存節點 Student *temp = nullptr; //建立第1個節點 temp = new Student({ \"Mary\", 1, nullptr}); //讓頭節點與尾節點全指向新分配的節點 head = tail = temp; //建立第2個節點 temp = new Student({ \"Bill\", 2, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //建立第3個節點 temp = new Student({ \"Eric\", 3, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //建立第4個節點 temp = new Student({ \"Jeff\", 4, nullptr}); //將上一個節點tail的next指向新建立的節點 tail-&gt;next = temp; //將tail指向新建立的節點; tail = temp; //遍歷鏈節串列 //從頭節點開始 //把頭節點指向temp指標 temp = head; //如果temp指標不是nullptr，就進去while while(temp != nullptr) { //印出姓名學號 cout &lt;&lt; \"id = \" &lt;&lt; temp-&gt;id; cout &lt;&lt; \", name = \" &lt;&lt; temp-&gt;name &lt;&lt; endl; //把temp指標移到下一個節點 temp = temp-&gt;next; } //刪除鏈節串列 //從頭節點開始刪除 //如果頭節點不為nullptr while(head != nullptr) { //頭節點先暫存到暫存節點 temp = head; //頭節點指標往後移動 head = head-&gt;next; //刪除暫存節點 delete temp; } return 0; } id = 1, name = Mary id = 2, name = Bill id = 3, name = Eric id = 4, name = Jeff"
  },"/pages/c/basic/loop/": {
    "title": "迴圈",
    "keywords": "",
    "url": "/pages/c/basic/loop/",
    "body": "while while條件判斷式 while(條件判斷式) { 迴圈主體(the body of an iteration statement) } 條件判斷式為True，就進入迴圈主體，執行完迴圈主體，再回到條件判斷式，若為True，再進入迴圈主體，直到條件判斷式為False，就離開迴圈。 while初始運算式 while的初始運算式是在while之前先定義好。 int i = 0; while遞增運算式 若條件判斷式一直為True，就會成為無窮迴圈，所以需要有改變條件判斷式的方法，讓條件變為False，離開迴圈。使用遞增遞減運算式改變條件判斷式，遞增運算式定義在while迴圈中。 while (i &lt;= 100) { i++; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 int main() { //初始運算式 int i = 0; //條件判斷式 while (i &lt;= 10) { cout &lt;&lt; i &lt;&lt; endl; //遞增運算式 i++; } return 0; } 也可以簡化成一行。 1 2 3 4 5 6 int main() { int i = 0; while (true) cout &lt;&lt; i++ &lt;&lt; endl; return 0; } 0 1 2 3 4 5 6 7 8 9 10 while無窮迴圈1 若條件判斷式一直為True，就會成為無窮迴圈，無法離開循環。 若上述範例缺少遞增運算式，就會變成無窮迴圈一直執行迴圈主體無法停止。 1 2 3 while (i &lt;= 100) { //無窮迴圈 } while無窮迴圈2 若條件判斷式為true，就會成為無窮迴圈。 1 2 3 while (true) { //無窮迴圈 } break跳出迴圈 若符合特定條件，就離開迴圈。 以下程式碼是若sum &gt;= 5000就離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int sum = 0; while (true) { int input = 0; cout &lt;&lt; \"請輸入數字:\"; cin &gt;&gt; input; sum += input; if (sum &gt;= 5000) { break; } } cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; return 0; } 請輸入數字:1001 請輸入數字:1002 請輸入數字:1003 請輸入數字:1004 請輸入數字:1005 sum = 5015 continue 回到迴圈的條件判斷式 若符合特定條件，就直接回到迴圈的條件判斷式，後面的程式碼就不執行。 以下程式碼是印出1-50是5的倍數。 若不是5的倍數，直接回到迴圈的條件判斷式， 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int i = 1; while (i &lt;= 50) { if ((i % 5) != 0) { i++; continue; } cout &lt;&lt; i &lt;&lt; endl; i++; } return 0; } 5 10 15 20 25 30 35 40 45 50 for for是while的變形。 條件判斷式與初始運算式與遞增運算式寫在同一行。 for (初始運算式;條件判斷式;遞增運算式) { } 以下程式碼印出5的倍數，遞增運算式是i = i + 5 1 2 3 4 5 6 int main() { for (int i = 0; i &lt;= 50; i = i + 5) { cout &lt;&lt; i &lt;&lt; endl; } return 0; } for初始運算式與遞增運算式 初始運算式可以寫在for之前。 1 2 3 4 5 6 7 8 int main() { //i寫在for之前 int i = 0; for (; i &lt;= 50; i = i + 5) { cout &lt;&lt; i &lt;&lt; endl; } return 0; } 初始運算式與遞增運算式可以有多個，用逗號分開，但條件判斷式只能一個。 1 2 3 4 5 6 7 int main() { for (int i = 0, j = 50; i &lt;= 50; i = i + 5, j = j - 5) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; } return 0; } 遞增運算式可以寫在迴圈主體中。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //初始運算式 定義在for之前 int i = 0, j = 50; for (; i &lt;= 50;) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", \"; cout &lt;&lt; \"j = \" &lt;&lt; j &lt;&lt; endl; //遞增運算式寫在迴圈主體 i = i + 5; j = j - 5; } return 0; } i = 0, j = 50 i = 5, j = 45 i = 10, j = 40 i = 15, j = 35 i = 20, j = 30 i = 25, j = 25 i = 30, j = 20 i = 35, j = 15 i = 40, j = 10 i = 45, j = 5 i = 50, j = 0 for無窮迴圈 條件判斷式與初始運算式與遞增運算式都不寫的狀況下是無窮迴圈，需要使用break離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 int main() { int sum = 0; for (;;) { int input = 0; cout &lt;&lt; \"請輸入數字:\"; cin &gt;&gt; input; sum+=input; if (sum &gt;= 5000) break; } cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; return 0; } 請輸入數字:1000 請輸入數字:1000 請輸入數字:1000 請輸入數字:1001 請輸入數字:1002 sum = 5003"
  },"/pages/c/basic/strLen/": {
    "title": "取得字串長度",
    "keywords": "",
    "url": "/pages/c/basic/strLen/",
    "body": "Prerequisites: 空字元 字串清空 迴圈 實作strlen()函式 取得字串長度 陣列法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int length(char* str) { //初始值 int len = 0; //條件判斷式為字元不等於\\0，進入迴圈 for (;str[len] != 0; len++); return len; } int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; cout &lt;&lt; \"字串長度:\" &lt;&lt; length(str) &lt;&lt; endl; return 0; } 請輸入字串:abcde 字串長度:5 指標法1 1 2 3 4 5 6 7 8 9 10 11 12 13 int length(char* str) { int len = 0; //指標移到字串陣列[0]的位址 char *ptr = str; //判斷字元 while(*ptr != 0) { //位址往下一個陣列索引移動 ptr++; //記錄字串長度 len++; } return len; } 精簡版 1 2 3 4 5 6 int length(char* str) { int len = 0; char *ptr = str; while(*ptr++) len++; return len; } 指標法2 1 2 3 4 5 int length(char* str) { int len = 0; for (char *pos = str; *pos; pos++, len++); return len; } 遞迴法 1 2 3 4 5 6 7 8 9 int length(char* str) { //離開遞迴基本條件base case if (*str == 0) return 0; //若字元不為空字元，就執行以下程式碼 //指標往下個位址移動 str++; //類似迴圈len++ return length(str) + 1; } 印出字串 100次迴圈 1 2 3 4 5 6 7 8 9 10 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for (char *pos = str; *pos; pos++) cout &lt;&lt; *pos; cout &lt;&lt; endl; return 0; } 請輸入字串:abcdef abcdef 1000次迴圈 for執行100次 strlen()執行100次 100*100 = 1000次迴圈 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for (int i = 0; i &lt; strlen(str); i++) { cout &lt;&lt; str[i]; } cout &lt;&lt; endl; return 0; } 200次迴圈 將以上程式碼改善，把strlen移到初始運算式或定義在for迴圈之前，初始運算式只執行一次。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for (int i = 0, len = strlen(str); i &lt; len; i++) { cout &lt;&lt; str[i]; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/string/reverseStr/": {
    "title": "原地反轉字串",
    "keywords": "",
    "url": "/pages/c/string/reverseStr/",
    "body": "原地的意思是只在原本的陣列移動並反轉字串。 不額外建立其它記憶體空間。 思路如下 偶數字串 字串abcd從中間切一半，並頭尾向中間逐一進行交換。 ab cd a與d交換 b與c交換 奇數字串 字串abcde，中間值為c，除了c不用變，其它字母，頭尾向中間逐一進行交換。 ab c de a與e交換 b與d交換 程式碼 以abcde為例，長度為5，迴圈次數 5 / 2 = 2次 以下為互相交換的陣列索引 迴圈次數 i len-1-i 第1次 0 4 第2次 1 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { char str[100]; //清空記憶體的值 memset(str,0,sizeof(str)); cout &lt;&lt; \"請輸入字串:\"; cin &gt;&gt; str; for(int i = 0, len = strlen(str); i &lt; len/2; i++) { char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; } cout &lt;&lt; str &lt;&lt; endl; return 0; }"
  },"/pages/c/string/integerToStr/": {
    "title": "整數轉成字串",
    "keywords": "",
    "url": "/pages/c/string/integerToStr/",
    "body": "Prerequisites: 原地反轉字串 字元運算 思路 輸入1234 轉成'1234' 定義字元陣列 char result[20]; 定義索引 int index = 0; 步驟1 1234 % 10 = 4 1234 / 10 = 123 將餘數4轉成字元存入陣列 result[0] = 4 + '0'; 步驟2 123 % 10 = 3 123 / 10 = 12 將餘數3轉成字元存入陣列 result[1] = 3 + '0'; 步驟3 12 % 10 = 2 12 / 10 = 1 將餘數2轉成字元存入陣列 result[2] = 2 + '0'; 步驟4 1 % 10 = 1 1 / 10 = 0 將餘數1轉成字元存入陣列 result[3] = 1 + '0'; 翻轉字串 將'4321'轉成'1234' 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { int input = 0; cout &lt;&lt; \"請輸入整數:\"; cin &gt;&gt; input; char result[20]; memset(result, 0, sizeof(result)); //取餘數 int index = 0; while(input &gt; 0) { //將餘數轉成字元存入陣列 result[index++] = input % 10 + '0'; input = input / 10; } cout &lt;&lt; \"result : \" &lt;&lt; result &lt;&lt; endl; //翻轉 for(int i = 0, len = strlen(result); i &lt; len/2; i++) { char temp = result[i]; result[i] = result[len - 1 - i]; result[len - 1 - i] = temp; } cout &lt;&lt; \"Reverse result : \" &lt;&lt; result &lt;&lt; endl; return 0; } 請輸入整數:1234 result : 4321 Reverse result : 1234"
  },"/pages/c/string/stringCat/": {
    "title": "字串連結",
    "keywords": "",
    "url": "/pages/c/string/stringCat/",
    "body": "Prerequisites: 記憶體間隔計算 strcat 字串連結 1 memcpy(dest + strlen(dest), src, strlen(src) + 1); 假設dest字串為\"Hello\\0\"，strlen(dest)傳回5，不包含'\\0'。 dest + 5的意思是，指標往右移動5格。 dest字元 H e l l o \\0 移動前 ^           移動+5格           ^ 此時dest指標的位置在'\\0'。 假設src字串為\"World\\0\"， strlen(src) + 1是指要拷貝src全部字串， + 1是包含src的'\\0'也一併拷貝到dest。 從dest所在的指標位址開始拷貝src的字元。 dest字元 H e l l o \\0           移動前 ^                     移動+5格           ^           拷貝src           W o r l d \\0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //參數2因為是常數字串，所以型態為const char* char* myStrCat(char* dest,const char* src) { //拷貝src字串 memcpy(dest + strlen(dest), src, strlen(src) + 1); //返回dest開始位址 return dest; } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello\"); myStrCat(str,\"World\"); cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; return 0; } str = HelloWorld strncat 拷貝n個字元 memcpy(dest + len, src, n); 參數1 = dest + len 將位址移動到要拷貝的起始位址 參數2 = src 從src[0]位址開始拷貝字元 參數3 = n 拷貝幾個字元 目的字串 = Hello 來源字串 = World 拷貝個數 = 2 將來源字串Wo(二個字元)，接到Hello字串後面。 將目的字串位址移到最後面 dest字元 H e l l o \\0           移動前 ^                     移動+5           ^           將Wo連到目的字串(Hello)位址最後面 dest字元 H e l l o \\0           拷貝src           W o         連結完來源字串Wo後，在最後面加上空字元 *(dest + len + n) = 0; dest字元 H e l l o \\0           加上空字元           W o \\0       1 2 3 4 5 6 7 char* myStrNCat(char* dest,const char* src,const size_t n) { //先把dest字串的長度先存下來 size_t len = strlen(dest); memcpy(dest + len, src, n); *(dest + len + n) = 0;//將目的字串與拷貝的字串最後面添加結尾字元0 return dest; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 char* myStrNCat(char* dest,const char* src,const size_t n) { //先把dest字串的長度先存下來 size_t len = strlen(dest); memcpy(dest + len, src, n); *(dest + len + n) = 0; return dest; } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello\"); myStrNCat(str,\"World\",2); cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; return 0; }"
  },"/pages/c/string/stringCopy/": {
    "title": "字串拷貝",
    "keywords": "",
    "url": "/pages/c/string/stringCopy/",
    "body": "Prerequisites: 記憶體間隔計算 陣列法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { //i為dest陣列的索引 //j為src陣列的索引 int i = 0, j = 0; // 如果來源字串不為0就進入迴圈 while(src[j]) { //將src[j]的值給dest[i]，然後i++,j++ dest[i++] = src[j++]; } //將dest結尾放上空字元 dest[i] = 0; return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } name = Bill 指標法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { //若src的值不為空就進入迴圈 while(*src) { //將src的值指派給dest，接著指標往下個位址移動 *dest++ = *src++; } //將dest的值放上空字元 *dest = 0; return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } memcpy 將來源字串copy到目的字串，拷貝字數由參數3決定。 memcpy(目的字串, 來源字串, 要拷貝字數); strlen(src)傳回是不包含'\\0'的長度，所以再+1，才會把src的結尾'\\0'拷貝到目的字串。 1 2 3 4 5 6 7 8 9 10 11 12 13 //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { memcpy(dest, src, strlen(src) + 1); return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrCpy(name, \"Bill\"); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; } 改良式strncpy 傳統的strncpy，若n的長度小於src的長度，不會在dest結尾加上'\\0'。 所以改良式strncpy，不管n是不是小於src的長度，都會在結尾加上'\\0'。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //參數2因為是常數字串，所以型態為const char* char* myStrnCpy(char* dest,const char* src,const size_t n) { memcpy(dest, src, n); *(dest + n) = 0;//增加結尾符號 return dest; } int main() { char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); myStrnCpy(name,\"Bill\",2); cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; }"
  },"/pages/c/string/stringToInt/": {
    "title": "字串轉成數字",
    "keywords": "",
    "url": "/pages/c/string/stringToInt/",
    "body": "思路 將`1234`轉成1234 定義int result = 0，作為乘數。 用迴圈遍歷字串 步驟1 input[0]是`1`，把`1`變成整數1。 '1' - '0' = 1 result = 0 (result * 10) + 1 = 1 result = 1 步驟2 input[1]是`2`，把`2`變成整數2。 '2' - '0' = 2 result = 1 (result * 10) + 2 = 12 result = 12 步驟3 input[2]是`3`，把`3`變成整數3。 '3' - '0' = 3 result = 12 (result * 10) + 3 = 123 result = 123 步驟4 input[3]是`4`，把`4`變成整數4。 '4' - '0' = 4 result = 123 (result * 10) + 4 = 1234 result = 1234 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 int main() { char input[10]; memset(input, 0, sizeof(input)); cout &lt;&lt; \"請輸入整數:\"; cin &gt;&gt; input; int result = 0; for(int i = 0, len = strlen(input); i &lt; len; i++) { result = (result * 10) + input[i] - '0'; } cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } 請輸入整數:1234 result = 1234"
  },"/pages/c/time/chrono/": {
    "title": "程式執行時間",
    "keywords": "",
    "url": "/pages/c/time/chrono/",
    "body": "include chrono #include &lt;chrono&gt; 執行的程式碼，放入要計算執行效率的程式 1 2 3 4 5 6 7 8 9 10 11 12 //start 計時開始 //end 計時結束 std::chrono::steady_clock::time_point start,end; //dt 時間差 std::chrono::nanoseconds dt; start = chrono::steady_clock::now(); for(int i = 0;i &lt; 100000;i++) { 執行的程式碼 } end = chrono::steady_clock::now(); dt = end - start; cout &lt;&lt; \"執行\" &lt;&lt; (double)dt.count()/(1000 * 1000 * 1000) &lt;&lt; \"秒\" &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;chrono&gt; using namespace std; //參數2因為是常數字串，所以型態為const char* char* myStrCpy(char* dest,const char* src) { memcpy(dest, src, strlen(src) + 1); return dest; } int main() { //start 計時開始 //end 計時結束 std::chrono::steady_clock::time_point start,end; //dt 時間差 std::chrono::nanoseconds dt; char name[20]; //清空陣列記憶體中的值 memset(name, 0, sizeof(name)); //開始計時 start = chrono::steady_clock::now(); for(int i = 0;i &lt; 10000;i++) { myStrCpy(name, \"Bill\"); } end = chrono::steady_clock::now(); dt = end - start; cout &lt;&lt; \"執行\" &lt;&lt; (double)dt.count()/(1000 * 1000 * 1000) &lt;&lt; \"秒\" &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; return 0; }"
  },"/pages/c/string/strchr/": {
    "title": "字元搜尋",
    "keywords": "",
    "url": "/pages/c/string/strchr/",
    "body": "strchr從字串左邊搜尋字元 從字串左邊搜尋字元，傳回從左邊搜尋的第一個字元位址，並印出字元位址之後所有的字元。 搜尋字串 = Hello World! 搜尋字元 = W 搜尋結果 = World! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char* mystrchr(const char* s,int c) { //將s開始位址給p指標 //const char*轉成char*要強制轉型 char* p = (char *)s; //若p指標的值不為\\0就進入迴圈 while(*p) { //若為指標的值與字元是相同，代表找到 //傳回p的位址 if(*p == c) return p; p++;//位址往右移一位 } return 0;//找不到就傳回null的位址 } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello World!\"); char* p1 = mystrchr(str,'W'); if(p1 != 0) { cout &lt;&lt; \"p1 = \" &lt;&lt; p1 &lt;&lt; endl; } return 0; } p1 = World! strrchr從字串右邊搜尋字元 從字串右邊搜尋字元，傳回從右邊搜尋的第一個字元位址，並印出字元位址之後所有的字元。 搜尋字串 = Hello World! 搜尋字元 = o 搜尋結果 = orld! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 char* mystrrchr(const char* s,int c) { //將s開始位址給p指標 //const char*轉成char*要強制轉型 char* p = (char *)s; char* p1 = 0; //若p指標的值不為\\0就進入迴圈 while(*p) { //若為指標的值與字元是相同，代表找到 //p的位址放入p1中 if(*p == c) p1 = p; p++;//位址往右移一位 } return p1;//傳回p1最後的位址 } int main() { char str[20]; //清空陣列記憶體中的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hello World!\"); char* p1 = mystrrchr(str,'o'); if(p1 != 0) { cout &lt;&lt; \"p1 = \" &lt;&lt; p1 &lt;&lt; endl; } return 0; } p1 = orld!"
  },"/pages/c/string/strcmp/": {
    "title": "字串比較",
    "keywords": "",
    "url": "/pages/c/string/strcmp/",
    "body": "strcmp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** 字串相等傳回0 str1字元&gt;str2字元 return 1 str1字元&lt;str2字元 return -1 **/ int mystrcmp(const char* str1,const char* str2) { //特別注意，使用while(true)，即便str1或str2是\\0也能比較 while(true){ //str1字元&gt;str2字元 if(*str1 &gt; *str2) return 1; //str1字元&lt;str2字元 if(*str1 &lt; *str2) return -1; //二個字元結尾相等 if(*str1 == 0 &amp;&amp; *str2 == 0) return 0; //比較下一個字元 str1++; str2++; } } int main() { cout &lt;&lt; mystrcmp(\"abc\",\"abcd\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"ab\",\"a\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"abc\",\"abc\") &lt;&lt; endl; cout &lt;&lt; mystrcmp(\"\",\"a\") &lt;&lt; endl; return 0; } -1 1 0 -1 strncmp int mystrncmp(const char* str1,const char* str2,const size_t n) 第一個參數是比較字串1。 第二個參數是比較字串2。 第三個參數n是要比較多少字元，若n為2，比較字串1與字串2前2個字元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int mystrncmp(const char* str1,const char* str2,const size_t n) { int i = 0; while(i &lt; n){ //str1字元&gt;str2字元 if(*str1 &gt; *str2) return 1; //str1字元&lt;str2字元 if(*str1 &lt; *str2) return -1; //二個字元結尾相等 if(*str1 == 0 &amp;&amp; *str2 == 0) return 0; //比較下一個字元 str1++; str2++; i++; } //比較n次仍比較不出來，就傳回0 return 0; } int main() { cout &lt;&lt; mystrncmp(\"abc\",\"abcd\",2) &lt;&lt; endl; cout &lt;&lt; mystrncmp(\"ab\",\"a\",2) &lt;&lt; endl; cout &lt;&lt; mystrncmp(\"abc\",\"abc\",2) &lt;&lt; endl; return 0; } 0 1 0"
  },"/pages/c/string/strstr/": {
    "title": "字串搜尋",
    "keywords": "",
    "url": "/pages/c/string/strstr/",
    "body": "Prerequisites: 記憶體間隔計算 目的字串 hdhelhelloWor 搜尋字串 hello\\0 要在目的字串中找到搜尋字串的開始位置。 目的字串 h d h e l h e l l o W o r ^                         搜尋字串 h e l l o 0               ^                         目的字串 + 1 h d h e l h e l l o W o r   ^                       搜尋字串 + 1 h e l l o 0                 ^                       發現不一樣，指標退回。 目的字串 + 0 h d h e l h e l l o W o r ^                         搜尋字串 + 0 h e l l o 0               ^                         目的字串往右移動 + 1 h d h e l h e l l o W o r   ^                       搜尋字串 + 0   h e l l o 0               ^                       發現二邊指標的值不同。 目的字串往右移動一格 + 1 h d h e l h e l l o W o r     ^                     搜尋字串 + 0     h e l l o 0               ^                     發現與搜查字串第1個字元相同，開始比較 目的字串 + 1 h d h e l h e l l o W o r       ^                   搜尋字串 + 1     h e l l o 0                 ^                   目的字串 + 1 h d h e l h e l l o W o r         ^                 搜尋字串 + 1     h e l l o 0                   ^                 目的字串 + 1 h d h e l h e l l o W o r           ^               搜尋字串 + 1     h e l l o 0                     ^               發現不一樣，退回最初一開始比較的地方 目的字串 - 3 h d h e l h e l l o W o r     ^                     搜尋字串 - 3     h e l l o 0               ^                     目的字串往右移，與搜尋字串不一致 + 1 h d h e l h e l l o W o r       ^                   搜尋字串 + 0       h e l l o 0               ^                   目的字串往右移，與搜尋字串不一致 + 1 h d h e l h e l l o W o r         ^                 搜尋字串 + 0         h e l l o 0               ^                 目的字串往右移，與搜尋字串一致，開始比對。 + 1 h d h e l h e l l o W o r           ^               搜尋字串 + 0           h e l l o 0               ^               目的字串 + 1 h d h e l h e l l o W o r             ^             搜尋字串 + 1           h e l l o 0                 ^             目的字串 + 1 h d h e l h e l l o W o r               ^           搜尋字串 + 1           h e l l o 0                   ^           目的字串 + 1 h d h e l h e l l o W o r                 ^         搜尋字串 + 1           h e l l o 0                     ^         目的字串 + 1 h d h e l h e l l o W o r                   ^       搜尋字串 + 1           h e l l o 0                       ^       目的字串 + 1 h d h e l h e l l o W o r                     ^     搜尋字串 + 1           h e l l o 0                         ^     比對到搜尋字串\\0，代表已經搜尋到了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const char* mystrstr(const char *dest, const char *search) { //i為dest的索引 size_t i = 0; //j為serch的索引 size_t j = 0; //目的字串長度 size_t dlen = strlen(dest); //搜尋字串長度 size_t slen = strlen(search); //若i超過目的字串長度，代表都找不到 //若j超過搜尋字串長度，代表找到 while((i &lt; dlen) &amp;&amp; (j &lt; slen)) { //目的字元與搜索字元相等 if(dest[i] == search[j]) { i++;//指標往下個字元移動 j++;//指標往下個字元移動 } else { //不相等 i = i - j; //指標移到最開始的位址 j = 0; //搜尋字串的索引移到最前面 i++ ; //目的字串指標往下一個位址移動 } } //若j等於搜尋字串的長度代表找到 if(j == slen) return dest + (i - j); return 0;//尋找失敗 } int main() { const char* p1 = mystrstr(\"hdhelhelloWor\", \"hello\") ; if(p1 != 0) cout &lt;&lt; p1 &lt;&lt; endl; return 0; } helloWor"
  },"/pages/c/string/delstr/": {
    "title": "刪除字元",
    "keywords": "",
    "url": "/pages/c/string/delstr/",
    "body": "Prerequisites: 記憶體間隔計算 刪除右邊多的字元 刪除前字串:Hellloyyyoooyyy 刪除右邊有y的字母 刪除後字串:Hellloyyyooo 思路 添加flag，判斷找到右邊的字元，flag變成1，並記錄位置，但如果右邊字元後面仍有其它字母就把flag變成0。 第一次找到y，flag變1，並記錄位址。 H e l l l o y y y o o o y y y             1                             p                 發現後面有不是y的字母，flag變0。 H e l l l o y y y o o o y y y                   0                       p                 第二次找到y，flag變1，並記錄位址。 H e l l l o y y y o o o y y y                         1                             p     將記錄的位址變成'\\0'結尾空字元，也就是0。 H e l l l o y y y o o o 0 y y                         1                             p     當印出字串時看到有結尾空字元0，就會停止輸出。 印出結果 Hellloyyyooo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void deleterchr(char* str, const int c) { //判斷位址為null就返回 if(str == 0) return; //記錄位址的指標 char *p = 0; //false為0，true為1，預設為0 bool flag = false; //若字元不為空字元就進入迴圈 while(*str) { //如果字元的值等於要刪的字母 if(*str == c) { //如果flag為0，才能進來 if(!flag) { //記錄要刪字母的位置 p = str; //把flag變成1 flag = true; } } else { //如果要刪的字母後面仍有其它不能刪的字母 //直接把flag變成0 flag = false; } //指標往下個位址移動 str++; } //若有找到刪除的字元 if(flag) { //把之前記錄的位址的值變成0 *p = 0; } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"Hellloyyyoooyyy\"); //刪除右邊為y的字母 deleterchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } Hellloyyyooo 刪除左邊的字元 刪除前字串:yyyyooooyy 刪除左邊有y的字母 刪除後字串:ooooyy 思路 找出第一個不是刪除字元的記憶體位址。 count變數，記錄有幾個字元要刪除。 p指標，主要記錄第一個不是要刪的字母。 p指標，初始化為字串陣列索引0的記憶體位址。 遍歷字串陣列的每一個字元，若等於要刪除的字元，就進入迴圈，然後p指標往下一個索引移動，若下一個字元等於刪除的字元，然後就進入迴圈，直到下一個字元不等於刪除的字元就離開迴圈，而p指標所指向的就是第一個不等於y的字元，同時count變數也會記錄要刪除的個數，每進入一次迴圈就代表要刪掉一個字元。 字串 y y y y o o o o y y p指標         p           count 0 1 2 3 4           將後面的字串往前移動至最前面 字串 y y y y o o o o y y 覆蓋的字串 o o o o y y         因為有覆蓋到原本的字串，所以要使用memmove memmove(目的位址, 來源位址, 拷貝個數); 程式碼1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void deletelchr(char* str, const int c) { if(str == 0) return; //p指標初始化str字串首位址 //p指標，記錄第一個不是要刪的字母。 char *p = str; //記錄有幾個字元要刪除 int count = 0; //若當前字元為要刪除的c則進入迴圈 while(*p == c) { //指標移到下一個字元 p++; count++; //離開迴圈的條件是字元不等於c //p會指向非刪除的字元 } //若p的位址，不等於str的首位址 //代表有進入上面while的迴圈 if(p != str) { //把來源字串移到目的字串 // memmove(str, p, strlen(str) - (p - str) + 1); //+1是把結尾空字元符號\\0也拷貝過來 memmove(str, p, strlen(str) - count + 1); } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"yyyyooooyy\"); deletelchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } ooooyy 程式碼2 字串 y y y y o o o o y y str指標 str                   p指標         p           memmove(目的位址, 來源位址, 拷貝個數); memmove(str, p, strlen(str) - (p - str) + 1); 假設str的位址是0x00000004 假設p的位址是0x00000008 p - str = 4 strlen(“yyyy0000yy”) = 10 memmove(str, p, 10 - 4 + 1); 最後的+1，是把來源字串的'\\0'也覆蓋目的字串。 也就是把'ooooyy\\0'共7個覆蓋到目的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void deletelchr(char* str, const int c) { if(str == 0) return; //p指標存放str字串首位址 char *p = str; //若當前字元為要刪除的c則進入迴圈 while(*p == c) { //指標移到下一個字元 p++; //離開迴圈的條件是字元不等於c //p會指向非刪除的字元 } //若p的位址，不等於str的首位址 //代表有進入上面while的迴圈 if(p != str) { //把來源字串移到目的字串 //+1是把結尾空字元符號\\0也拷貝過來 memmove(str, p, strlen(str) - (p - str) + 1); } } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"yyyyooooyy\"); deletelchr(str, 'y'); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 刪除中間字串 刪除前字串 = zzz123zzz 要刪除123 刪除後字串 = zzzzzz 指標解釋 str字串陣列第0個記憶體位址 find要刪除字串的第一個記憶體位址 slen為要刪除字串的長度，要刪除123，刪除字串大小為3 find+slen排除掉刪除字串的第一個記憶體位址。 z z z 1 2 3 z z z 0 str     find     find+slen       思路 聚焦在find要刪除字串。 把find字串覆蓋前後表格 覆蓋前 1 2 3 z z z 0 第一個位址 find             覆蓋後 z z z 0       find與find+slen指標位址 1 2 3 z z z 0 find     find+slen       目的字串位址是find = 123zzz0 來源字串位址是find + slen(3) = zzz0 要覆蓋幾個字元？find字串長度(6) - 要刪字串的長度(3) + '\\0' 空字元(1) = 4個字元 memmove(目的位址, 來源位址, 拷貝個數); memmove(find, find + slen, strlen(find) - slen + 1); 程式碼(while) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void delMiddle(char* str, const char* substr) { if(str == 0 || substr == 0) return; if(strlen(str) == 0) return; int slen = strlen(substr); if(slen == 0) return; while(true) { char* find = strstr(str, substr); if(find == 0) return; memmove(find, find + slen, strlen(find) - slen + 1); } //遞迴作法 //delMiddle(find, substr); } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"zzz123123zzz\"); delMiddle(str, \"123\"); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } zzzzzz 程式碼(遞迴) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void delMiddle(char* str, const char* substr) { if(str == 0 || substr == 0) return; if(strlen(str) == 0) return; int slen = strlen(substr); if(slen == 0) return; char* find = strstr(str, substr); if(find == 0) return; memmove(find, find + slen, strlen(find) - slen + 1); //遞迴作法 delMiddle(find, substr); } int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"zzz123123zzz\"); delMiddle(str, \"123\"); //印出刪除後的字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } zzzzzz"
  },"/pages/c/string/chineseAscii/": {
    "title": "ASCII與中文",
    "keywords": "",
    "url": "/pages/c/string/chineseAscii/",
    "body": "Ascii Code 1-31為控制碼 字元 Ascii code \\0 0 0-9 48-57 A-Z 65-90 a-z 97-122 空格 32 印出中文Ascii code 字元char的範圍為0-255，不包含負數，只有正整數。 中文的Ascii Code 128-255，數字、大小寫英文字母、空格、標點符號、空字元(\\0)介於Ascii Code 0-127。 字元char是0-255，沒有負數，在把中文字元轉換成整數之前，必須先轉成unsigned char，再轉成int，才會正確顯示中文的ascii碼。 1 (int)(unsigned char)str[i] 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); strcpy(str, \"西西\"); cout &lt;&lt; \"長度:\" &lt;&lt; strlen(str) &lt;&lt; endl; for(int i = 0, len = strlen(str); i &lt; len; i++) { cout &lt;&lt; \"str[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; (int)(unsigned char)str[i] &lt;&lt; endl; } //印出字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 長度:6 str[0]=232 str[1]=165 str[2]=191 str[3]=232 str[4]=165 str[5]=191 西西 使用中文Ascii Code指定陣列值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { char str[100]; //清空字串位址的值 memset(str, 0, sizeof(str)); str[0] = 232; str[1] = 165; str[2] = 191; str[3] = 232; str[4] = 165; str[5] = 191; //印出字串 cout &lt;&lt; str &lt;&lt; endl; return 0; } 西西 統計中文個數 寫一個程式，計算中文個數，一個中文字算1個，一個英文字算1個。 數字、大小寫英文字母、空格、標點符號、空字元(\\0)介於Ascii Code 0-127。 中文的Ascii Code 128-255。 不同的編碼方式中文個數不同。 utf-8 中文3個byte，英文1個byte。 unicode 中文2個byte，英文2個byte。 從之前的程式碼範例，「西西」二個中文字，但卻產生6個char，C++ 1個char是1byte，「西西」二個字占6byte，一個中文字占3byte，代表目前我的編譯器是使用utf-8。 以下程式碼是max_chinese_cnt = 3，代表一個中文字使用3個byte。 chinese_cnt計算byte數量，chinese_cnt = 1，由1開始，加到第3個byte代表一個中文字讀取完畢，可以count++。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int countChar(const char* str) { if(str == 0) return -1; int count = 0; int chinese_cnt = 1; int max_chinese_cnt = 3; for(int i = 0, len = strlen(str); i &lt; len; i++) { // cout &lt;&lt; \"str[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; (int)(unsigned char)str[i] &lt;&lt; endl; unsigned int tmp = (int)(unsigned char)str[i]; if(tmp &lt; 128) { count++; } else { if (chinese_cnt == max_chinese_cnt) { count++; chinese_cnt = 1; } else { chinese_cnt++; } } } return count; } int main() { cout &lt;&lt; countChar(\"西西abc\") &lt;&lt; endl; return 0; } 5 以下是另外一種寫法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int countChar(const char* str) { if(str == 0) return -1; int count = 0; int chinese_cnt = 1; int max_chinese_cnt = 3; while(*str) { //0 if((unsigned char) *str &lt; 128) { count++; } else { if (chinese_cnt == max_chinese_cnt) { count++; chinese_cnt = 1; } else { chinese_cnt++; } } str++; } return count; } int main() { cout &lt;&lt; countChar(\"西\") &lt;&lt; endl; return 0; } 5"
  },"/pages/c/editor/clang/": {
    "title": "安裝VS在MAC(實作)",
    "keywords": "",
    "url": "/pages/c/editor/clang/",
    "body": "安裝code 打開VS Code，按住(Cmd+Shift+P)，並在以下視窗輸入 &gt;shell command 安裝成功會顯示以下畫面。 安裝clang 打開VS Code，按住(⇧⌘X)，會出現延伸模組視窗。 並輸入c++ 選擇C/C++，並安裝 修改 ~/.bash_profile 打開終端機，輸入以下指令。 vi ~/.bash_profile 在最下方複製貼上以下內容。 # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" 儲存離開。 在終端機再繼續輸入以下指令 source ~/.bash_profile 修改 ~/.zprofile 在終端機再輸入以下指令。 cat &lt;&lt; EOF &gt;&gt; ~/.zprofile # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" EOF 檢查clang version 將終端機重開，輸入以下指令 clang --version 要確保出現如下圖示。 code . 從終端機進入自建放程式碼的目錄，並在終端機輸入以下指令。 code . 建立檔案 點擊新增檔案 命名為helloword.cpp，並將以下程式碼貼上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main() { vector&lt;string&gt; msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string&amp; word : msg) { cout &lt;&lt; word &lt;&lt; \" \"; } cout &lt;&lt; endl; } 執行 點擊圖下紅框處 修改tasks.json 確定command的路徑為/usr/bin/clang++，點擊helloworld.cpp再執行一次。 執行結果"
  },"/pages/c/editor/vsDebug/": {
    "title": "VS Debug",
    "keywords": "",
    "url": "/pages/c/editor/vsDebug/",
    "body": "F9設置/取消斷點 F5/F10開始調試 shift+F5放棄調試 F10逐過程執行 F11逐語句執行(進入函式) 設置中斷點 點擊圖下紅點位置。 執行斷點 F5 移到斷點 第一次迴圈 以下紅框的按鈕為跳到下一個斷點，但目前範例只有在迴圈中一個斷點，也就意味下一個斷點就是下一次迴圈。 左邊會有變數的變化，區域變數word，會根據每一次迴圈，值有所不同。 第二次迴圈 紅框的按鈕為跳到下一個斷點，區域變數word的值已經變成C++。 查詢變數的值 全部執行完斷點 在偵錯主控台並不會邊執行邊輸出，必須等到全部執行斷點，結果才會印出來。 F11 移到下一行程式碼"
  },"/pages/c/string/split/": {
    "title": "split 切割字串",
    "keywords": "",
    "url": "/pages/c/string/split/",
    "body": "Prerequisites: 記憶體間隔計算 切割字串 = aa,bb,cc,dd,ee,ff 切割符號 = , 儲存二維陣列 values[10][50] 第一次循環 字串 aa , bb , cc , dd , ee , ff p ^                     find   ^                   第二次循環 字串 aa , bb , cc , dd , ee , ff p     ^                 find       ^               最後一次循環，find已經找不到切割符號 字串 aa , bb , cc , dd , ee , ff p                     ^ find                       完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** str 要切割的字串 splitStr 切割符號 values儲存的結果陣列 **/ size_t splitstr(const char* str,const char* splitStr, char values[][50]) { //若位址為空，傳回0 if(str == 0 || splitStr == 0) return 0; size_t slen = strlen(splitStr);//split符號長度 if(slen == 0) return 0;//若符號長度為0，就不用切割 //強制轉型const char* str轉成char* char *p = (char*)str; //aa,bb,cc,dd,ee,ff //切割符號為逗號，切割的個數為6個，分別為aa|bb|cc|dd|ee|ff size_t size = 0;//記錄切割的個數 while(true) { //找尋切割符號第一個位置 char* find = strstr(p, splitStr); //如果找到 if(find != 0) { //截取p的位置到切割符號之前的字元個數 //參數1要儲存的位址 //參數2要拷貝的開始位址 //參數3要拷貝的個數 strncpy(values[size++], p, find - p); //將p指標移到切割符號右邊的字元 p = find + slen; } else { //如果找不到切割符號 //代表是最後一個字串 strcpy(values[size++], p); break;//跳出無限迴圈 } } return size; } int main() { char values[10][50]; memset(values, 0, sizeof(values)); //傳回切割個數 size_t count = splitstr(\"aa,bb,cc,dd,ee,ff\", \",\", values); cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; for(int i = 0; i &lt; count; i++) { cout &lt;&lt; \"values[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; values[i] &lt;&lt; endl; } return 0; } count = 6 values[0] = aa values[1] = bb values[2] = cc values[3] = dd values[4] = ee values[5] = ff"
  },"/pages/c/basic/rand/": {
    "title": "亂數",
    "keywords": "",
    "url": "/pages/c/basic/rand/",
    "body": "rand() rand() std函式庫，取得亂數，但只生成一次，每次產生的亂數不會有重覆。 以下程式碼，不管執行幾次，產生的亂數都一樣，但10個數字都不相同。 1 2 3 4 5 6 7 int main() { //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 srand() srand()，產生亂數種子，根據種子不同，會產生不同結果。 但亂數種子若都固定相同，每次執行產生相同結果。 1 2 3 4 5 6 7 8 int main() { srand(1); //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 1 2 3 4 5 6 7 8 int main() { srand(2); //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } 33614 564950498 1097816499 1969887316 140734213 940422544 202055088 768218109 770072199 1866991771 srand(time(0)) time(0) std函式，取得從1970-01-01累積到現在的秒數，也就是現在時間。 把time(0)作為srand()的參數，確保每次執行亂數都不會相同。 1 2 3 4 5 6 7 8 9 int main() { srand(time(0)); cout &lt;&lt; \"time(0)=\" &lt;&lt; time(0) &lt;&lt; endl; //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() &lt;&lt; endl; } return 0; } time(0)=1726015663 936144365 1313144633 332406612 1152962037 1088008978 343639041 957835304 800536416 630495257 1049470101 產生一定範圍的隨機數字 產生0~20之間的亂數 假設產生0~20之間的數字，直接把亂數 % 20 1 2 3 4 5 6 7 8 int main() { srand(time(0)); //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() % 20 &lt;&lt; endl; } return 0; } 10 7 14 1 17 13 10 12 8 8 產生50~70之間的亂數 把上一個範例0~20之間的隨機數字+50，就可以產生50~70之間的亂數。 50就是最小的數字 1 rand() % 20 + 50 完整程式碼 1 2 3 4 5 6 7 8 int main() { srand(time(0)); //產生10個亂數 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; rand() % 20 + 50 &lt;&lt; endl; } return 0; } 58 55 62 52 61 60 64 65 51 60 亂數取餘數會重覆 rand()函式產生的亂數是不會重覆。 但對rand() % 20，取餘數亂數就會重覆。 1 2 3 4 5 6 7 8 9 10 int main() { srand(time(0)); //產生10個亂數 for (int i = 0; i &lt; 10; i++) { int val = rand(); cout &lt;&lt; \"rand = \" &lt;&lt; val; cout &lt;&lt; \" , rand % 20 = \" &lt;&lt; val % 20 &lt;&lt; endl; } return 0; } rand = 976027376 , rand % 20 = 16 rand = 1612012646 , rand % 20 = 6 rand = 442850770 , rand % 20 = 10 rand = 1962054535 , rand % 20 = 15 rand = 1639170060 , rand % 20 = 0 rand = 1610974704 , rand % 20 = 4 rand = 178028752 , rand % 20 = 12 rand = 684514593 , rand % 20 = 13 rand = 566867572 , rand % 20 = 12 rand = 1105824512 , rand % 20 = 12"
  },"/pages/c/string/xml/": {
    "title": "xml搜尋",
    "keywords": "",
    "url": "/pages/c/string/xml/",
    "body": "Prerequisites: 記憶體間隔計算 要在一堆xml內容中尋找標籤名為name，並取出值。 &lt;id&gt;1&lt;/id&gt;&lt;name&gt;Cici&lt;/name&gt;&lt;age&gt;10&lt;/age&gt; 思路 組成name開始標籤與結束標籤 自已建立&lt;name&gt;字串，並在xml中尋找是否有相同的字串，函式會傳回&lt;name&gt;起始位址。 xml &lt; n a m e &gt; 傳回位址 ^           自已建立&lt;/name&gt;字串，並在xml中尋找是否有相同的字串，函式會傳回&lt;/name&gt;起始位址。 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 傳回位址                     ^             計算值的字元個數 假設位址以0x00000001開始 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; findEnd                     ^             findStart ^                                 值的字元個數計算方式，取得findEnd記憶體位址 - findStart記憶體位址 - 左右括號 - 標籤名 findEnd(11) - findStart(1) - `&lt;&gt;`左右括號(2) - xml標籤名name(4) = 4 1 size_t valueLen = findEnd - findStart - fieldLen - 2; 截取值 指標移動2格&lt;&gt;左右括號，再移動4格name標籤名的長度，就會移動到值的起始位址。 上一個步驟有算出，值的長度為4個字元，從移動後的指標，往後取得4個字元(包含移動後指標當前的值)。 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 移動前 ^                                 移動後             ^                     取值             x x x x               1 strncpy(values, findStart + 2 + fieldLen , valueLen); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** xmlbuffer xml字串 fieldname 要搜尋的 標籤名 values存放找到的值 **/ bool xmlSearch(const char* xmlbuffer, const char* fieldname, char* values) { //檢查參數有沒有值 if(xmlbuffer == 0 || fieldname == 0 || values == 0) return false; //搜尋的欄位名大小 size_t fieldLen = strlen(fieldname); //組成xml搜尋字串 //例，找xml標籤名是name的值 //開始 標籤名的字串 //&lt;name&gt;\\0 //字串大小為2個&lt;&gt;尖括號+1個結尾空字元0+標籤名name大小 char* startField = new char[2 + 1 + fieldLen]; //清空陣列 memset(startField, 0, sizeof(startField)); strcpy(startField, \"&lt;\"); strcat(startField, fieldname); strcat(startField, \"&gt;\"); //結束 標籤名的字串 //&lt;/name&gt;\\0 //字串大小為3個&lt;/&gt;符號+1個結尾空字元0+標籤名name大小 char* endField = new char[3 + 1 + fieldLen]; //清空陣列 memset(endField, 0, sizeof(endField)); strcpy(endField, \"&lt;/\"); strcat(endField, fieldname); strcat(endField, \"&gt;\"); //搜&lt;name&gt; char* findStart = (char*)strstr(xmlbuffer, startField); //搜&lt;/name&gt; char* findEnd = (char*)strstr(xmlbuffer, endField); //在xml字串中找到&lt;name&gt;與&lt;/name&gt; if(findStart &amp;&amp; findEnd) { //截取&lt;name&gt;.......&lt;/name&gt;中間的值，儲存在value字串 //計算&lt;name&gt;.......&lt;/name&gt;中間的值個數 size_t valueLen = findEnd - findStart - fieldLen - 2; //findStart + 2 + fieldLen 是指將指標移動到&lt;name&gt;的後面 //以下第三個參數代表拷貝個數 strncpy(values, findStart + 2 + fieldLen , valueLen); //清除記憶空間 delete[] startField; startField = nullptr; delete[] endField; endField = nullptr; return true; } //找不到 //清除記憶空間 delete[] startField; startField = nullptr; delete[] endField; endField = nullptr; return false; } int main() { char values[100]; //清空陣列 memset(values, 0, sizeof(values)); bool res = xmlSearch(\"&lt;id&gt;1&lt;/id&gt;&lt;name&gt;Cici&lt;/name&gt;&lt;age&gt;10&lt;/age&gt;\", \"name\", values); //如果有找到會傳回true if(res) { cout &lt;&lt; \"value = \" &lt;&lt; values &lt;&lt; endl; } return 0; } value = Cici"
  },"/pages/c/dataStruct/arrayList/": {
    "title": "ArrayList實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/arrayList/",
    "body": "Prerequisites: 記憶體間隔計算 名詞解釋 list.size 陣列有幾個元素？ 以下舉例的例子都是10個元素。 結構定義 1 2 3 4 5 6 7 8 9 //陣列最大的大小 #define MAXSIZE 100 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType data[MAXSIZE];//陣列 size_t size;//目前陣列中數量，由1開始 }; 清空所有元素 使用前確保所有元素都清空。 1 2 3 4 5 6 7 /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; memset(&amp;list, 0, sizeof(ElemType) * MAXSIZE); } 插入 位址轉成10進位，比較好理解 位址 1 2 3 4 5 6 7 8 9 10 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 假設要在索引4，插入一筆資料，必須將含索引4以後的資料往後移動1格。 list[index …] -&gt; list[index + 1 …] 移動資料前 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 移動資料後 索引 0 1 2 3 4 5 6 7 8 9 10 值 11 12 13 14 x 15 16 17 18 19 20 把x更換成要插入的值。 目的起始位址與來源起始位址 假設要在索引4，插入一筆資料，必須將含索引4以後的資料往後移動1格。 list[index …] 拷貝-&gt; list[index + 1 …] 來源起始位址 拷貝-&gt; 目的起始位址 memmove(目的起始位址, 來源起始位址, 拷貝個數) 位址 1 2 3 4 5 6 7 8 9 10 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 data指標 ^                   來源起始位址         ^           目的起始位址           ^         將(data指標 + 4)位址之後的資料，移到後一格(data指標 + (4 + 1))。 來源起始位址 list.data + index 目的起始位址 list.data + (index + 1) 拷貝個數 拷貝[含]索引4以後的個數 索引 0 1 2 3 4 5 6 7 8 9 值 11 12 13 14 15 16 17 18 19 20 拷貝個數         ^ ^ ^ ^ ^ ^ 求拷貝個數 全部數量為10，扣掉不用拷貝的4個數量，剩下的就是我們要拷貝的。 list.size = 10，代表全部有10個元素。 10(全部數量) - 4(不用拷貝的數量) = 6(要拷貝的數量) list.size - index 1 memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); 最後一個位址可以插入 參數index索引等於list.size，直接新增資料，不需搬移資料 1 memcpy(&amp;list.data[list.size], &amp;element, sizeof(ElemType)); 插入程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == MAXSIZE) return false; //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } 刪除 往前拷貝 刪除索引4，索引4以後的元素(5 … size-1)往前移一位 list[index + 1 …] 拷貝-&gt; list[index …] 要拷貝的數量 全部數量為10，扣掉不用拷貝的4個數量，剩下的就是我們要拷貝的。 list.size = 10，代表全部有10個元素。 剩下的就是我們要拷貝的，要減掉一個刪除元素。 10(全部數量) - 4(不用拷貝的數量) - 1(拷貝的數量中有1個要刪除) = 5(要拷貝的數量) list.size - index - 1 1 2 3 //list[index + 1 ...] 拷貝-&gt; list[index ...] //因為要刪除一個元素，所以拷貝的個數要-1 memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); 最後一個位址不用搬移資料 參數index索引等於list.size - 1，直接刪除資料，不需搬移資料 刪除程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } 印出所有元素 1 2 3 4 5 void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } 測試程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int main() { ArrayList list; //建立ArrayList ClearList(list);//清空 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); return 0; } 15 14 13 12 11 16 --------------------- 14 13 12 11 16 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 //陣列最大的大小 #define MAXSIZE 100 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType data[MAXSIZE];//陣列 size_t size;//目前陣列中數量，由1開始 }; /** 索引是否介於0... size-1 */ bool checkIndex(const ArrayList&amp; list, const size_t index) { return index &lt; list.size; } /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; memset(&amp;list, 0, sizeof(ElemType) * MAXSIZE); } /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == MAXSIZE) return false; //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } /** 返回索引 找不到就返回-1 */ int findElem(const ArrayList&amp; list, const ElemType&amp; e) { for(int i = 0; i &lt; list.size; i++) { if(list.data[i] == e) return i; } return -1; } /** 取得元素 參數2index:索引 參數3:e 返回元素 */ bool getElem(const ArrayList&amp; list, const size_t index,ElemType&amp; e) { if(!checkIndex(list, index)) return false; e = list.data[index]; return true; } int main() { ArrayList list; //建立ArrayList ClearList(list);//清空 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); return 0; }"
  },"/pages/c/dynamicMemory/memory_interval/": {
    "title": "記憶體間隔計算",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memory_interval/",
    "body": "Prerequisites: 數線間隔 間隔問題 數線上兩點的距離 計算間隔1 xml 指標指向0x00000001，若要指向0x00000005，請問指標要移動幾格？ 假設指標在0x00000005的位址，計算0x00000005到0x00000001之間有幾個間隔，不包含0x00000005 答案:0x00000005 - 0x00000001 = 4個間隔 0x00000001 0x00000002 0x00000003 0x00000004 0x00000005         ^ 計算間隔2 指標指向0x00000001，若要指向0x00000011，請問指標要移動幾格？ 把位址全變成10進位，比較好計算。 假設指標在11的位址，計算11到01之間有幾個間隔，不包含11 答案: 11 - 01 = 10個間隔 位址 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 xml &lt; n a m e &gt; C i c i &lt; / n a m e &gt; 指標                     ^             以下10個間隔，只想取出Cici四個間隔，要如何取？ 10個間隔 - 2個括號&lt;&gt; - name4個字元 = 4 位址 01 02 03 04 05 06 07 08 09 10 xml &lt; n a m e &gt; C i c i 指標             x x x x 計算間隔3 刪除左邊的字元 位址 01 02 03 04 05 06 07 08 09 10 字串 y y y y o o o o y y str指標 str                   p指標         p           計算p指標位址與str指標位址，不包含p指標，總共有多少間隔？ 答案:5 - 1 = 4個間隔 yyyyooooyy字串長度為10，扣掉最左邊yyyy，只要右邊ooooyy的6個字元，數學公式如何寫？ 步驟1: strlen(yyyyooooyy) = 10 ，字串長度為10 步驟2: 取出p指標與str指標之間有多少間隔，不含p指標，p(5) - str(1) = 4個間隔 步驟3: 步驟1答案(10) - 步驟2答案(4) = 6個字元 指標移動間隔 刪除中間字串 位址 01 02 03 04 05 06 07 字串 1 2 3 z z z 0 移動前 find             移動後       find+3       find的位址在01 find + 3的意思是，find指標往右移動3格，移到04的位址。"
  },"/pages/math/tree/tree/": {
    "title": "種樹問題",
    "keywords": "",
    "url": "/pages/math/tree/tree/",
    "body": "問題1 在長720公尺的道路上，從起點到終點，種了10棵樹，每個間隔都一樣長，每個間隔是幾公尺？ 假設只種3棵樹，樹與樹之間有幾個間隔 tree tree tree 三棵樹有二個間隔 3 - 1 = 2 所以，10棵樹有9個間隔 10 - 1 = 9 間隔數會比樹少一個 720公尺 / 9個間隔 = 80公尺"
  },"/pages/c/dataStruct/arrayListExtCap/": {
    "title": "ArrayList擴展容量",
    "keywords": "",
    "url": "/pages/c/dataStruct/arrayListExtCap/",
    "body": "預設ArrayList大小，與每一次擴展容量的大小 1 2 3 4 5 //預設 #define INIT_SIZE 10 //預設擴展大小 #define EXT_SIZE 5 在結構定義最大容量 ArrayList全部分配多少記憶體大小 size_t capacity;//陣列最大容量 1 2 3 4 5 6 7 8 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType *data;//陣列 size_t size;//目前陣列中數量，由1開始 size_t capacity;//陣列最大容量 }; 清空ArrayList 結構 * 最大容量 memset(&amp;list, 0, sizeof(ElemType) * list.capacity); 1 2 3 4 5 6 7 8 /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; //代入的是陣列的最大容量list.capacity memset(&amp;list, 0, sizeof(ElemType) * list.capacity); } 建立ArrayList 1 2 3 4 5 6 7 8 9 10 11 12 void initList(ArrayList&amp; list) { //初始化大小 list.capacity = INIT_SIZE; //動態分配記憶體 list.data = new ElemType[list.capacity]; ClearList(list); } int main() { ArrayList list; //建立ArrayList initList(list return 0; } 刪除ArrayList 1 2 3 4 5 6 7 8 void destroyList(ArrayList&amp; list) { //釋放記憶體 delete [] list.data; list.data = nullptr; //全部設0 list.capacity = 0; list.size = 0; } 擴展容量 步驟如下 建立新容量的陣列 將舊的陣列拷貝到新的陣列 刪掉舊的陣列 指標指向新的陣列 重新定義最大容量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 bool extList(ArrayList&amp; list) { int new_size = list.capacity + EXT_SIZE; //建立新的陣列(容量比較大的陣列) ElemType *new_data = new (std::nothrow) ElemType[new_size]; //如果記憶體分配失敗 if(new_data == nullptr) return false; //清空新的陣列 memset(new_data, 0, sizeof(ElemType) * new_size); //拷貝舊的陣列到新的陣列 memcpy(new_data, list.data, sizeof(ElemType) * list.size); //把舊的陣列進行記憶體釋放 delete [] list.data; //把結構中的陣列，指向新的陣列記憶體位址 list.data = new_data; //重新定義結構中最大容量 list.capacity = new_size; return true; } 插入 判斷是否超出最大容量 1 2 3 4 5 6 7 8 //判斷是否超出最大容量 if(list.size == list.capacity) { //超出容量就擴展容量 if(!extList(list)) { //若返回是false，代表建立新陣列記憶體配置產生問題 return false; } } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 //預設初始化大小 #define INIT_SIZE 10 //預設擴展大小 #define EXT_SIZE 5 //定義陣列中每一個元素的資料型態 typedef int ElemType; //結構成員定義 struct ArrayList { ElemType *data;//陣列 size_t size;//目前陣列中數量，由1開始 size_t capacity;//陣列最大容量 }; /** 索引是否介於0... size-1 */ bool checkIndex(const ArrayList&amp; list, const size_t index) { return index &lt; list.size; } /** 清空list */ void ClearList(ArrayList&amp; list) { list.size = 0; //代入的是陣列的最大容量list.capacity memset(&amp;list, 0, sizeof(ElemType) * list.capacity); } void initList(ArrayList&amp; list) { list.capacity = INIT_SIZE; list.data = new ElemType[list.capacity]; ClearList(list); } void destroyList(ArrayList&amp; list) { delete [] list.data; list.data = nullptr; list.capacity = 0; list.size = 0; } bool extList(ArrayList&amp; list) { int new_size = list.capacity + EXT_SIZE; //建立新的陣列(容量比較大的陣列) ElemType *new_data = new (std::nothrow) ElemType[new_size]; //如果記憶體分配失敗 if(new_data == nullptr) return false; //清空新的陣列 memset(new_data, 0, sizeof(ElemType) * new_size); //拷貝舊的陣列到新的陣列 memcpy(new_data, list.data, sizeof(ElemType) * list.size); //把舊的陣列進行記憶體釋放 delete [] list.data; //把結構中的陣列，指向新的陣列記憶體位址 list.data = new_data; //重新定義結構中最大容量 list.capacity = new_size; return true; } /** 插入元素 成功返回true，失敗返回false index為陣列索引，介於0 - list.size之間，index為list.size也可以插入 element為插入元素 搬移 list[index...] -&gt; list[index + 1 ...] */ bool insert(ArrayList&amp; list, const size_t index, const ElemType&amp; element) { //判斷是否超出最大容量 if(list.size == list.capacity) { //超出容量就擴展容量 if(!extList(list)) { //若返回是false，代表建立新陣列記憶體配置產生問題 return false; } } //檢查插入索引 if(index &gt; list.size) { cout &lt;&lt; \"insert的索引介於0-\" &lt;&lt; list.size &lt;&lt; endl; return false; } //insert的索引在中間，並非最後一個 //若插入的索引 == size，不用搬移資料，直接在最後面新增資料。 if(index &lt; list.size) { //搬移資料 //list[index...] -&gt; list[index + 1 ...] memmove(list.data + (index + 1), list.data + index , (list.size - index) * sizeof(ElemType)); } //插入資料 memcpy(&amp;list.data[index], &amp;element, sizeof(ElemType)); //list的增加一個 list.size++; return true; } /** 刪除元素 成功返回true，失敗返回false index為陣列索引，介於0 - (list.size-1) list[index+1...] 拷貝至-&gt; list[index ...] */ bool del(ArrayList&amp; list, const size_t index) { //大小為0，不用刪除任何資料 if(list.size == 0) return false; //檢查刪除索引 if(!checkIndex(list, index)) { cout &lt;&lt; \"delete索引介於0-\" &lt;&lt; list.size - 1 &lt;&lt; endl; return false; } //若index不為最後一筆，要進行搬移 if(index &lt; (list.size - 1)) { //list[index + 1 ...] 拷貝-&gt; list[index ...] memmove(list.data + index, list.data + (index + 1), (list.size - index - 1) * sizeof(ElemType)); } //總數量減1 list.size--; return true; } void printList(const ArrayList&amp; list) { for(size_t i = 0; i &lt; list.size; i++) { cout &lt;&lt; list.data[i] &lt;&lt; endl; } } /** 返回索引 找不到就返回-1 */ int findElem(const ArrayList&amp; list, const ElemType&amp; e) { for(int i = 0; i &lt; list.size; i++) { if(list.data[i] == e) return i; } return -1; } /** 取得元素 參數2index:索引 參數3:e 返回元素 */ bool getElem(const ArrayList&amp; list, const size_t index,ElemType&amp; e) { if(!checkIndex(list, index)) return false; e = list.data[index]; return true; } int main() { ArrayList list; //建立ArrayList initList(list);//初始化 //ElemType是int ElemType element; element = 11; //在索引0插入元素 insert(list, 0, element); element = 12; //在索引0插入元素 insert(list, 0, element); element = 13; //在索引0插入元素 insert(list, 0, element); element = 14; //在索引0插入元素 insert(list, 0, element); element = 15; //在索引0插入元素 insert(list, 0, element); element = 16; //在索引0插入元素 insert(list, list.size, element); printList(list); cout &lt;&lt; \"---------------------\" &lt;&lt; endl; del(list,0); printList(list); destroyList(list); return 0; }"
  },"/pages/c/dataStruct/linkedList/": {
    "title": "單向鏈結串列實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/linkedList/",
    "body": "頭節點 頭節點是沒有值，頭節點的next指向的是第一個節點，最後一個節點的next指向nullptr 結構定義 節點有二個欄位，分別是data與next，data是存放值，next是指向下一個節點 1 2 3 4 5 6 typedef int ElemType; //定義節點 struct Node { ElemType data; Node* next; }; 初始化 初始化判斷頭節點(head)記憶體位址有沒有建立成功 將頭節點(head)的next(下一個節點位址)設為nullptr 返回頭節點的記憶體位址(使用指標傳回)，new動態分配記憶體位址，會傳回位址，需要用指標來接。 在main()中建立頭節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; head-&gt;next = nullptr;//下一個節點是null return head; } int main() { //建立頭節點 Node* head = initLinkedList(); return 0; } 刪除鏈結串列 刪除所有鏈結串列，包含頭節點(head) 參數是頭節點(head)記憶體位址 繞行所有節點，先把下一個節點存到暫存節點，再刪掉頭節點，再把暫存節點設為頭節點，如此反覆進行，直至下一個節點為nullptr設到head，離開迴圈。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } int main() { //建立頭節點 Node* head = initLinkedList(); destroyLinkedList(head); return 0; } 新增在最前面 有一個資料要新增在最前面 頭節點的next指向新節點，新節點的next指向原本的第一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //頭節點的下一個是新節點 head-&gt;next = temp; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); destroyLinkedList(head); return 0; } 新增在最後面 要將3的資料新增在最後面 新增步驟如下 先遍歷到最後一個節點(不是nullptr) 建立新節點，將新節點的next設為nullptr 尾節點的next設為新節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } 刪除最前面 把頭節點(head)的next指向要刪除節點的下一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //把p刪掉 delete p; return true; } 刪除最後一個節點 要刪除最後一個節點，要先找到倒數第二個節點。 把倒數第二個節點的next指向nullptr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } 印出所有節點 因為頭節點head是沒有資料，所以一開始是把p指標指向head的下一個節點。 然後將p指標一直往next移動，直至指到nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); destroyLinkedList(head); return 0; } 新增節點在某個節點之前 Data3要新增Data2前面 破解傳統的方式，傳統的方式是用迴圈繞行鏈結串列，找到下一個節點是Data2，才把Data3插進去，新的方式如下: 步驟如下 Data2的值拷貝到新節點Data3 新節點Data3的next設為Data2的next Data2的next設為Data3 Data2的值設成新的資料內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //將節點的資料複製到新節點 new_node-&gt;data = node-&gt;data; new_node-&gt;next = node-&gt;next; //把節點的內容改成新的內容 node-&gt;data = e; //下一個節點指向新節點 node-&gt;next = new_node; return true; } 刪除某個節點 因為節點不知道上一個節點是那個？ 所以採用以下作法 把下一個節點的值複製在要刪除的節點 把要刪除的節點的next指向下一個節點的next 把下一個節點刪除 但要刪除的節點沒下一個節點的話，使用刪除最後一個節點的函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //若節點為最後一個節點 if(node-&gt;next == nullptr) { //使用其它函式removeLast() cout &lt;&lt; \"要刪除的節點是最後一個節點，請使用removeLast()\" &lt;&lt; endl; return false; } //取得後面節點 Node* after = node-&gt;next; //將後面的節點資料，複製到要刪除的節點中 node-&gt;data = after-&gt;data; node-&gt;next = after-&gt;next; //把後面的節點刪除 delete after; return true; } 取得鏈結串列長度 大小不包含頭節點(head)，將鏈結串列繞行一遍就會知道有多少節點。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } 取得某個節點 1 2 3 4 5 6 7 8 9 10 11 12 Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，傳回節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 typedef int ElemType; //定義節點 struct Node { ElemType data; Node* next; }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; head-&gt;next = nullptr;//下一個節點是null return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //頭節點的下一個是新節點 head-&gt;next = temp; return true; } bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //將節點的資料複製到新節點 new_node-&gt;data = node-&gt;data; new_node-&gt;next = node-&gt;next; //把節點的內容改成新的內容 node-&gt;data = e; //下一個節點指向新節點 node-&gt;next = new_node; return true; } /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //若節點為最後一個節點 if(node-&gt;next == nullptr) { //使用其它函式removeLast() cout &lt;&lt; \"要刪除的節點是最後一個節點，請使用removeLast()\" &lt;&lt; endl; return false; } //取得後面節點 Node* after = node-&gt;next; //將後面的節點資料，複製到要刪除的節點中 node-&gt;data = after-&gt;data; node-&gt;next = after-&gt;next; //把後面的節點刪除 delete after; return true; } Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，傳回節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //把p刪掉 delete p; return true; } /** 刪除鏈結串列，但頭節點不刪除 */ void clearList(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //不包含頭節點，頭節點下一個節點不存在 if(head-&gt;next == nullptr) { cout &lt;&lt; \"鏈結串列沒有節點\" &lt;&lt; endl; return; } Node* temp1; //從下一個節點開始刪，頭節點要保留 Node* temp2 = head-&gt;next; while(temp2 != nullptr) { //下一個節點先丟到temp1 temp1 = temp2-&gt;next; //刪掉temp2 delete temp2; //temp2變成下一個節點 temp2 = temp1; } head-&gt;next = nullptr; } /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); cout &lt;&lt; \"--------------\" &lt;&lt; endl; //增加節點 addLast(head, 5); //增加節點 addLast(head, 6); //增加節點 addLast(head, 7); //增加節點 addLast(head, 8); //印出所有節點 printList(head); cout &lt;&lt; \"size = \" &lt;&lt; size(head) &lt;&lt; endl; cout &lt;&lt; \"--------------\" &lt;&lt; endl; //取得資料為\"5\"的節點 Node* node = getNode(head, 5); //在資料為\"5\"的節點之前，新增54 insert(node, 54); //印出所有節點 printList(head); //刪除54節點 deleteNode(getNode(head, 54)); //印出所有節點 printList(head); //刪除第一個節點 removeFirst(head); //印出所有節點 printList(head); //刪除最後一個節點 removeLast(head); //印出所有節點 printList(head); //清空所有節點，(不包含頭節點) clearList(head); //釋放記憶體(包含頭節點) destroyLinkedList(head); return 0; }"
  },"/pages/c/dataStruct/doublelinkedList/": {
    "title": "雙向鏈結串列實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/doublelinkedList/",
    "body": "雙向鏈結串列代表的是結構中有二個指標，分別指向前面節點跟後面節點 結構定義 1 2 3 4 5 6 typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; 初始化 以下程式碼是指把指向前面節點與後面節點的指標設為nullptr 1 head-&gt;prev = head-&gt;next = nullptr; 1 2 3 4 5 6 7 8 9 10 11 12 /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } 最前面新增節點 資料3要插入在最前面 步驟如下 建立新節點 新節點的next指向第一個節點 新節點的prev指向頭節點 頭節點的next指向新節點 第一個節點的prev指向新節點(如果沒有第一個節點就不用做這個步驟) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } 刪除節點 步驟如下 將待刪除節點的前一個節點next指向待刪除節點的下一個節點 將待刪除節點的下一個節點的prev指向待刪除節點的前一個節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //node的前一個節點的next指向node的下一個節點 node-&gt;prev-&gt;next = node-&gt;next; if(node-&gt;next != nullptr) { //node的下一個節點的prve指向node的prev node-&gt;next-&gt;prev = node-&gt;prev; } delete node; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool addFirst(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } bool addLast(Node* head, const ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } //先找到尾節點 Node *p = head; //判斷節點的下一個是否是null while(p-&gt;next != nullptr) { p = p-&gt;next; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = e; //新節點的前面節點 temp-&gt;prev = p; //新節點的下一個節點是null temp-&gt;next = nullptr; //尾節點的下一個是新節點 p-&gt;next = temp; return true; } /** 在某個節點前插入元素 參數Node* node 某個節點前 參數ElemType&amp; e 插入元素 */ bool insert(Node* node, const ElemType&amp; e) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* new_node = new Node; //塞入資料 new_node-&gt;data = e; //新節點的前一個節點是插入節點的前一個 new_node-&gt;prev = node-&gt;prev; //插入節點的前個節點的下一個是新節點 node-&gt;prev-&gt;next = new_node; //插入節點的前一個節點是新節點 node-&gt;prev = new_node; return true; } /** 將節點刪除 */ bool deleteNode(Node* node) { if(node == nullptr) { cout &lt;&lt; \"節點不存在\" &lt;&lt; endl; return false; } //node的前一個節點的next指向node的下一個節點 node-&gt;prev-&gt;next = node-&gt;next; if(node-&gt;next != nullptr) { //node的下一個節點的prve指向node的prev node-&gt;next-&gt;prev = node-&gt;prev; } delete node; return true; } Node* getNode(const Node* head, const ElemType&amp; e) { Node* p = head-&gt;next;//排除頭節點，從第1個節點開始繞 while(p != nullptr) { //如果節點的資料與參數e相同，傳回節點 if(p-&gt;data == e) return p; //移到下一個節點 p = p-&gt;next; } //最後的是nullptr //返回nullptr return p; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool removeFirst(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; //把p刪掉 delete p; return true; } /** 刪除鏈結串列，但頭節點不刪除 */ void clearList(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //不包含頭節點，頭節點下一個節點不存在 if(head-&gt;next == nullptr) { cout &lt;&lt; \"鏈結串列沒有節點\" &lt;&lt; endl; return; } Node* temp1; //從下一個節點開始刪，頭節點要保留 Node* temp2 = head-&gt;next; while(temp2 != nullptr) { //下一個節點先丟到temp1 temp1 = temp2-&gt;next; //刪掉temp2 delete temp2; //temp2變成下一個節點 temp2 = temp1; } head-&gt;next = nullptr; } /** 刪除最後一個節點 參數頭節點 */ bool removeLast(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結不存在\" &lt;&lt; endl; return false; } Node *p = head; //判斷是不是至少有一個節點 if(head-&gt;next == nullptr){ cout &lt;&lt; \"鏈結沒結點\" &lt;&lt; endl; return false; } //先找到倒數第二個節點 while(p-&gt;next-&gt;next != nullptr) { p = p-&gt;next; } //刪掉最後一個節點 delete p-&gt;next; //把倒數第二個節點作為最後一個節點 //下一個節點為null p-&gt;next = nullptr; return true; } int main() { //建立頭節點 Node* head = initLinkedList(); //增加節點 addFirst(head, 1); //增加節點 addFirst(head, 2); //增加節點 addFirst(head, 3); //增加節點 addFirst(head, 4); //印出所有節點 printList(head); cout &lt;&lt; \"--------------\" &lt;&lt; endl; //增加節點 addLast(head, 5); //增加節點 addLast(head, 6); //增加節點 addLast(head, 7); //增加節點 addLast(head, 8); //印出所有節點 printList(head); cout &lt;&lt; \"size = \" &lt;&lt; size(head) &lt;&lt; endl; cout &lt;&lt; \"--------------\" &lt;&lt; endl; //取得資料為\"5\"的節點 Node* node = getNode(head, 5); //在資料為\"5\"的節點之前，新增54 insert(node, 54); //印出所有節點 printList(head); //刪除54節點 deleteNode(getNode(head, 54)); //印出所有節點 printList(head); //刪除第一個節點 removeFirst(head); //印出所有節點 printList(head); //刪除最後一個節點 removeLast(head); //印出所有節點 printList(head); //清空所有節點，(不包含頭節點) clearList(head); //釋放記憶體(包含頭節點) destroyLinkedList(head); return 0; }"
  },"/pages/c/dataStruct/stack/": {
    "title": "Stack實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/stack/",
    "body": "Stack是在同一個位置新增/刪除的動作。 新增在頭節點 Stack是新增節點在頭節點。 刪除在頭節點 Stack是刪除節點在頭節點。 函式解釋 Stack的新增，等同於鏈結串列的addFirst，此處改為push Stack的刪除，等同於鏈結串列的removeFirst，此處改為pop 程式碼與單向鏈結串列大致相同，刪除以下描述的函式。 新增在最後addLast()，插入在某個節點前面insert()，以上二種函式在Stack中都不需要。 刪除在最後removeLast()，刪除在某個節點deleteNode()，以上二種函式在Stack中都不需要。 getNode()，取得節點的函式，在Stack中也不需要。 pop 對Stack來說，刪除鏈結串列第1個節點之外，還要把值返回。 所以以下的程式碼參數有ElemType&amp; e，接收刪除後返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 bool pop(Node* head, ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; e = p-&gt;data; //把p刪掉 delete p; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *prev,*next;//前面節點與後面節點 }; /** 初始化鏈結串列 */ Node* initLinkedList() { //頭節點 Node* head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(head == nullptr) return nullptr; //前面節點與後面節點全設為nullptr head-&gt;prev = head-&gt;next = nullptr; return head; } /** 鏈結串列記憶體回收 參數為頭節點 */ void destroyLinkedList(Node* head){ if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } Node *temp; //暫存節點 //繞行鏈結串列 while(head != nullptr) { //先把下一個節點存起來 temp = head-&gt;next; //刪掉目前的節點 delete head; //把剛才存下來的節點作為頭節點 head = temp; } } bool push(Node* head, const ElemType&amp; ee) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; //新節點的下一個節點是頭節點的下一個 temp-&gt;next = head-&gt;next; //前面節點 temp-&gt;prev = head; //頭節點的下一個是新節點 head-&gt;next = temp; //下一個節點的前面節點，指向新建的節點 if(temp-&gt;next != nullptr) temp-&gt;next-&gt;prev = temp; return true; } void printList(const Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(Node* head) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } bool pop(Node* head, ElemType&amp; e) { if(head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //不包含頭節點，取得頭節點的下一個 Node* p = head-&gt;next; //頭節點的下一個是 p的下一個 head-&gt;next = p-&gt;next; //p的下一個節點的prev是頭節點 p-&gt;next-&gt;prev = head; e = p-&gt;data; //把p刪掉 delete p; return true; } int main() { //建立頭節點 Node* stack = initLinkedList(); //增加節點 push(stack, 1); //增加節點 push(stack, 2); //增加節點 push(stack, 3); //增加節點 push(stack, 4); //印出所有節點 printList(stack); ElemType e; pop(stack,e); cout &lt;&lt; \"pop 的值 = \" &lt;&lt; e &lt;&lt; endl; //釋放記憶體(包含頭節點) destroyLinkedList(stack); return 0; }"
  },"/pages/c/dataStruct/bubbleSort/": {
    "title": "氣泡排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/bubbleSort/",
    "body": "氣泡排序的重點: 陣列中，二個值比較，大的放後面。 第一輪 比5次。 6,5先比較，6比5大，放後面。 6,4比較，6比4大，放後面。 6,3比較，6比3大，放後面。 6,2比較，6比2大，放後面。 6,1比較，6比1大，放後面。 交換的方式如下圖。 準備一個暫存變數temp。 6放在temp。 5放在6的位置。 temp放在5的位置。 把以上的描述用程式寫死。 比5次。 都跟後面1個比，後面比較小進入下個步驟。 跟後面的值交換。 1 2 3 4 5 6 7 8 9 10 11 int arr[] = {6, 5, 4, 3, 2, 1}; // 比5次 for (int j = 0; j &lt; 5; j++) { // 2. 都跟後面1個比，後面比較小進入下個步驟。 if (arr[j] &gt; arr[j + 1]) { // 3. 跟後面的值交換。 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } 陣列內容變化 [5, 4, 3, 2, 1, 6] 第2輪 比4次。 5,4先比較，5比4大，放後面。 5,3比較，5比3大，放後面。 5,2比較，5比2大，放後面。 5,1比較，5比1大，放後面。 黃色方塊代表前一輪已排序好的，不用再排序。 1 2 3 4 5 6 7 8 9 10 // 比4次 for (int j = 0; j &lt; 4; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } 陣列內容變化 [4, 3, 2, 1, 5, 6] 第3輪 比3次。 4,3比較，4比3大，放後面。 4,2比較，4比2大，放後面。 4,1比較，4比1大，放後面。 比3次 1 2 3 4 5 6 7 8 9 10 // 比3次 for (int j = 0; j &lt; 3; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } 陣列內容變化 [3, 2, 1, 4, 5, 6] 第4輪 比2次。 3,2比較，3比2大，放後面。 3,1比較，3比1大，放後面。 1 2 3 4 5 6 7 8 9 10 // 比2次 for (int j = 0; j &lt; 2; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } 陣列內容變化 [2, 1, 3, 4, 5, 6] 第5輪 比1次。 2,1比較，2比1大，放後面。 1 2 3 4 5 6 7 8 9 10 // 比1次 for (int j = 0; j &lt; 1; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } 陣列內容變化 [1, 2, 3, 4, 5, 6] 重覆的程式碼 以下會出現5次內容一模一樣的程式碼，只有j &lt; ?是有變化的，其它都沒有變化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 int main() { int arr[] = {6, 5, 4, 3, 2, 1}; // 比5次 for (int j = 0; j &lt; 5; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 比4次 for (int j = 0; j &lt; 4; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 比3次 for (int j = 0; j &lt; 3; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 比2次 for (int j = 0; j &lt; 2; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 比1次 for (int j = 0; j &lt; 1; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 印出 for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; arr[i] &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 重覆5次的程式碼，一模一樣的程式碼，就由迴圈來省略重覆的程式碼。 j &lt; ?的變化是由5, 4, 3, 2, 1，由大到小遞減。 所以外層迴圈要用由大到小，5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { int arr[] = {6, 5, 4, 3, 2, 1}; // loop_count迴圈次數 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 int loop_count = 5; for (int i = loop_count; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } // 印出 for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; arr[i] &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 1, 2, 3, 4, 5, 6, 外層迴圈次數是陣列大小 - 1。 1 int loop_count = sizeof(arr)/sizeof(int) - 1;"
  },"/pages/c/dataStruct/queue/": {
    "title": "Queue實作",
    "keywords": "",
    "url": "/pages/c/dataStruct/queue/",
    "body": "在日常生活中，我們經常需要排隊做事，如:看電影前要排隊買票。 排隊最基本的規矩就是後到的人要排在隊伍的最後面，而先到的人可以接受服務。 新增在尾部 Queue是新增節點在尾部。 以下是新增節點的過程。 刪除在頭部 Queue是刪除節點在頭部。 以下是刪除節點的過程。 結構定義 Queue會定義頭節點與尾節點。 1 2 3 4 5 6 7 8 9 10 typedef int ElemType; //定義節點 struct Node { ElemType data; Node *next; }; struct queue { //定義頭節點與尾節點 Node *head,*tail; }; 初始化頭節點與尾節點 一開始頭節點與尾節點都指向頭節點 1 2 3 4 5 6 7 8 9 10 11 12 /** 初始化Queue */ bool initQueue(queue&amp; que) { //頭節點 que.head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(que.head == nullptr) return false; que.head-&gt;next = nullptr;//queue的下一個節點為null que.tail = que.head;//一開始頭節點與尾節點指向同一個記憶體位址 return true; } 新增 完全沒任何節點 在沒有任何節點的狀況下，新節點新增在tail尾節點後面。 步驟如下 建立新節點 新節點的next指向nullptr 新節點新增在tail尾節點後面 tail尾節點指向新節點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool inQueue(queue&amp; que, const ElemType&amp; ee) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; temp-&gt;next = nullptr; //將新節點插入到tail之後 que.tail-&gt;next = temp; //把tail指向temp que.tail = temp; return true; } 有節點 尾節點指向鏈結串列中最後一個節點(不是nullptr)。 在有節點的狀況下，新節點新增在tail尾節點後面。 程式步驟跟沒任何節點的步驟一模一樣。 刪除節點 刪除的方式跟鏈結串列removeFirst()一樣，從鏈結串列第一個節點刪除。 如果刪的節點是尾節點，刪除完節點後，要把尾節點指向頭節點，回到初始的狀況下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 bool deQueue(queue&amp; que, ElemType&amp; e) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(que.head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //鏈結串列中第一個節點，不包含頭節點 Node* first = que.head-&gt;next; //將第一個節點的值存在e，作為返回 e = first-&gt;data; //將第一個節點(不包含頭節點)指向first的下個節點 que.head-&gt;next = first-&gt;next; //如果刪的節點是tail節點 if(first == que.tail) //將tail指向head que.tail = que.head; //將第一個節點刪除 delete first; return true; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 using namespace std; typedef int ElemType; //定義節點 struct Node { ElemType data; Node *next; }; struct queue { Node *head,*tail; }; /** 初始化Queue */ bool initQueue(queue&amp; que) { //頭節點 que.head = new (std::nothrow)Node; //頭節點記憶體分配失敗 if(que.head == nullptr) return false; que.head-&gt;next = nullptr;//queue的下一個節點為null que.tail = que.head;//一開始頭節點與尾節點指向同一個記憶體位址 return true; } /** 摧毀Queue 參數為頭節點 */ void destroyQueue(queue&amp; que){ //暫存節點 Node* temp; while(que.head != nullptr) { //先暫存下一個節點 temp = que.head-&gt;next; //刪掉目前頭節點 delete que.head; //頭節點換成下一個節點 que.head = temp; } } bool inQueue(queue&amp; que, const ElemType&amp; ee) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //建立新節點 Node* temp = new (std::nothrow)Node; if(temp == nullptr) return false; //新節點設定傳進來的資料 temp-&gt;data = ee; temp-&gt;next = nullptr; //將新節點插入到tail之後 que.tail-&gt;next = temp; //把tail指向temp que.tail = temp; return true; } bool deQueue(queue&amp; que, ElemType&amp; e) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return false; } //只有頭節點，沒有後面的資料 if(que.head-&gt;next == nullptr) { cout &lt;&lt; \"沒有任何節點\" &lt;&lt; endl; return false; } //鏈結串列中第一個節點，不包含頭節點 Node* first = que.head-&gt;next; //將第一個節點的值存在e，作為返回 e = first-&gt;data; //將第一個節點(不包含頭節點)指向first的下個節點 que.head-&gt;next = first-&gt;next; //如果刪的節點是tail節點 if(first == que.tail) //將tail指向head que.tail = que.head; //將第一個節點刪除 delete first; return true; } void printQueue(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //從head的下一個節點開始 //head不存在值 Node *p = que.head-&gt;next; while(p != nullptr) { cout &lt;&lt; p-&gt;data &lt;&lt; \",\"; //節點p換成下一個節點 p = p-&gt;next; } cout &lt;&lt; endl; } size_t size(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return 0; } //不包含頭節點 Node* p = que.head-&gt;next; size_t size = 0; //繞行到null while(p != nullptr) { p = p-&gt;next; size++; } return size; //遞迴方式 //if(head == nullptr) return 0; //return size(head-&gt;next) + 1; } /** 清空鏈表，除了頭節點 */ void clear(queue&amp; que) { if(que.head == nullptr) { cout &lt;&lt; \"鏈結串列不存在\" &lt;&lt; endl; return; } //移到頭節點的下一個節點(清空不包含頭節點) Node* tmp = que.head-&gt;next,*tmpnext; //繞行所有節點 while(tmp != nullptr) { //把節點的下一個節點暫存 tmpnext = tmp-&gt;next; //刪除目前節點 delete tmp; //將下一個節點作為目前節點 tmp = tmpnext; } //頭節點的下一個設null que.head-&gt;next = nullptr; //尾節點與頭節點指向相同 que.tail = que.head; } int main() { //建立queue queue que; //清空 memset(&amp;que, 0, sizeof(que)); //初始化 initQueue(que); inQueue(que, 1); inQueue(que, 2); inQueue(que, 3); inQueue(que, 4); inQueue(que, 5); cout &lt;&lt; \"大小:\" &lt;&lt; size(que) &lt;&lt; endl; cout &lt;&lt; \"queue的內容:\" &lt;&lt; endl; printQueue(que); ElemType e; while(deQueue(que, e)) cout &lt;&lt; e &lt;&lt; endl; inQueue(que, 6); inQueue(que, 7); inQueue(que, 8); inQueue(que, 9); inQueue(que, 10); cout &lt;&lt; \"大小:\" &lt;&lt; size(que) &lt;&lt; endl; cout &lt;&lt; \"queue的內容:\" &lt;&lt; endl; printQueue(que); destroyQueue(que); return 0; }"
  },"/pages/c/dataStruct/insertSort/": {
    "title": "插入排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/insertSort/",
    "body": "插入過程圖 假設目前位置在5的數字，往前尋找比5還小的數字，把5放在比5還小的數字的後面，若尋找的過程中，數字比5還大，就把數字往後移一位。 i是目前位置 j就是往前尋找比5還小的數字的計數變數 數字比5還大，就把數字往後移一位 下圖arr[i] = 5，arr[j] = 44，44 &gt; 5，把44往後移一位，arr[j + 1] = 44 下圖arr[i] = 5，arr[j] = 38，38 &gt; 5，把38往後移一位，arr[j + 1] = 38 尋找比5還小的數字，把5放在比5還小的數字的後面 下圖arr[i] = 5，arr[j] = 3，3 &lt; 5，把5放在3的後面 變數起始位置 i起始位置為1，因為arr[0]前面沒有值可以比較，所以把i的一開始的位置定義在arr[1] j的起始位置為i-1，也就是從i的位置以前(不含i)去搜尋有沒有比arr[i]還小的數字，若比arr[i]大，就把arr[j]的值往後移動一格arr[j+1] 二個迴圈 外圍的迴圈，是遍歷每一個數字 內圍的迴圈，是尋找外圍數字之前有沒有比它小的數字。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void insertSort(int arr[], int len) { for(int i = 1; i &lt; len; i++) { int temp = arr[i]; int j = i - 1; for(; j &gt;= 0; j--) { if(arr[j] &gt; temp) { arr[j + 1] = arr[j]; } else { //若i=1,j=0 //6放進arr[0+1]之後，就會離開這個迴圈，因為j--，j=-1 //j=-1，就不會執行以下這一行 break; } } //若i=1,j=0 //6放進arr[j+1]之後，就會離開迴圈，j--，j=-1 //arr[1]=6 //arr[-1 + 1] = 5 //arr[0] = 5 arr[j + 1] = temp; } } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); insertSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 1,2,3,4,5,6,"
  },"/pages/c/dataStruct/quickSort/": {
    "title": "快速排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/quickSort/",
    "body": "陣列2,5,3,6,4,1 值將陣列0的資料作為基準 以下圖來說，陣列0的值是2，是作為比較大小的標準。 L指向陣列0的位址 R指向陣列最後的位址 比較R值，尋找比基準值小 預設先比對R的值 若陣列[R]&lt;2，將陣列[L]的值設成陣列[R]，並且L前進一格。 若以上條件不符合，R往後退一格。 if(陣列[R] &lt; 2) { 陣列[L] = 陣列[R] L++; } else { R--; } 下圖陣列[R]&lt;2，將陣列[L]的值設成陣列[R]，並且L前進一格 比較L值，尋找比基準值大 若陣列[L]&gt;2，將陣列[R]的值設成陣列[L]，並且R往後退一格。 若以上條件不符合，L往前一格。 if(陣列[L] &gt; 2) { 陣列[R] = 陣列[L] R--; } else { L++; } 下圖陣列[L]&gt;2，將陣列[R]的值設成陣列[L]，並且R後退一格 L==R 若陣列[R]一直找不到比2小，就會一直往後退移到跟L相同的位址。 將基準值2放入L==R的位址，第一個數字排序好 遞迴設定 下圖中從2(已排序好)作為中點，分為左右二半，左邊剩下1個，右邊剩下4個待排序。 左邊只剩下1個，至少要有2個數字才可以比較大小，因此視作排序完成。 把arr指標移動2格(arr+2)，從3的數字開始視作為陣列起點，大小為4個。 left的陣列位址為1，len(陣列長度)為6 quickSort(arr + left + 1, len - left - 1); 以上程式轉換如下 quickSort(arr + 2, 4); 重新設定L、R與基準值 將L指向數字3，並將比較基準值設為3，R指向陣列最尾部。 R找不到比基準值小的值 R指標找不到比基準值3小的，最後L==R L==R(2) 將基準值3放入L==R的位址，第二個數字排序好 重新設定L、R與基準值(2) 將L指向數字6，並將基準值設為6，R指向陣列最尾部。 比較R值，尋找比基準值小(2) 預設先比對R的值 若陣列[R]&lt;6，將陣列[L]的值設成陣列[R]，並且L前進一格。 L==R(3) 將基準值6放入L==R的位址，第三個數字排序好 重新設定L、R與基準值(3) 比較R值，尋找比基準值小(3) 預設先比對R的值 若陣列[R]&lt;5，將陣列[L]的值設成陣列[R]，並且L前進一格。 L==R(4) 將基準值5放入L==R的位址，第四個數字排序好 重點步驟 至少要有2個數字才可以比較大小 L指向陣列0的位址 R指向陣列最後的位址 將陣列0的值作為基準值 預設先比較R值 L&lt;R,比較R值，尋找比基準值小 L&lt;R,比較L值，尋找比基準值大 L==R，將基準值放入L==R的位址 基準值作為中點，陣列分為左右二半(不包含基準值的位址) 左右二半陣列繼續依上述文字進行，直至陣列個數小於2 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /** 參數1 陣列位址 參數2 陣列大小 */ void quickSort(int arr[], int len) { //至少要有2個數字才可以比較大小 if(len &lt; 2) return; int left = 0; int right = len - 1; //基準值都為arr[0] int pivot = arr[0]; //預設先比較R //action有L與R，預設先比對R的值 char action = 'R'; //若left&lt;right才進入循環 while(left &lt; right) { //比較R值，尋找比基準值小 if(action == 'R') { //比較R值，尋找比基準值小 //若陣列[R]&lt;基準值，將陣列[L]的值設成陣列[R]，並且L前進一格。 if(arr[right] &lt; pivot) { arr[left] = arr[right]; left++; //設定下一次是L移動 action = 'L'; } else { //若以上條件不符合，R往後退一格。 right--; } //比較L值，尋找比基準值大 } else if(action == 'L') { //比較L值，尋找比基準值大 //若陣列[L]&gt;基準值，將陣列[R]的值設成陣列[L]，並且R往後退一格。 if(arr[left] &gt; pivot) { arr[right] = arr[left]; right--; //設定下一次是R移動 action = 'R'; } else { //若以上條件不符合，L往前一格。 left++; } } } //L==R //將基準值放入L==R的位址 arr[right] = pivot; //遞迴設定 //基準值作為中點，分為左右二半陣列(不包含基準值) //參數1陣列起始位址,參數2分成左右二半的各別個數 //左半邊 quickSort(arr,left); //右半邊 //起始位址在基準值位址的下一格 //個數(請參照遞迴設定的說明與圖) quickSort(arr + left + 1, len - left - 1); } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); quickSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/dataStruct/mergeSort/": {
    "title": "合併排序",
    "keywords": "",
    "url": "/pages/c/dataStruct/mergeSort/",
    "body": "Prerequisites: 遞迴 傳遞函式前處理 在遞迴有討論過二種遞迴方式，合併排序結合二種遞迴方式。 首先，先把陣列切半拆分，直到切到只剩下一個元素，就不要再拆分了。 傳遞函式後處理 拆到只剩下一個元素，把一個一個的元素排序組回臨時的陣列，再copy到原本arr的陣列。 先處理已拆分成個別值6,5，二個數值比大小，比較小的放入臨時陣列(temp)，start為臨時陣列的計數器，每放進一個值，start就加1 因已經沒得比了，把剩下的6放入臨時陣列，此時start已經是1，將排好序的臨時陣列56拷貝至原本的arr陣列 處理已拆分成個別值3,2，二個數值比大小，比較小的放入臨時陣列(temp)，start為臨時陣列的計數器，start目前為3，每放進一個值，start就加1。 因已經沒得比了，把剩下的3放入臨時陣列，此時start已經是4，將排好序的臨時陣列23拷貝至原本的arr陣列 處理已拆分的二個陣列[56][4]，二個陣列分別有start1與start2，分別指著二個陣列的第1個元素。4(start2)比5(start1)小，目前start為0把4放進臨時陣列temp[0]start++ 與 start2++ 陣列[56]已經是有排序過的陣列，目前start為1，直接把陣列[56]所有元素放入臨時陣列 陣列[56]放入臨時陣列後，把臨時陣列[456]拷貝到原本arr的陣列中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void _mergeSort(int arr[], int temp[], int start, int end) { //列切半拆分，直到切到只剩下一個元素，start與end會是相同，就返回 if(start &gt;= end) return; //陣列切半拆分 //若拆的陣列為[654321]，拆成[654]與[321]，要再拆分[321]，3的陣列索引是3 // (5-3)/2 = 1 要再+3，拆分的中點索引才會在4，而不是在1 // 拆成[34] [1] int mid = start + (end - start)/2; //拆成二半，二個陣列的起始位置 int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; _mergeSort(arr, temp, start, mid); _mergeSort(arr, temp, mid+1, end); //臨時陣列計數器 int i = start; //判斷二個拆分陣列的值的大小 while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) { if(arr[start1] &lt; arr[start2]) { temp[i++] = arr[start1++]; } else { temp[i++] = arr[start2++]; } } //左半邊 while(start1 &lt;= end1) { temp[i++] = arr[start1++]; } //右半邊 while(start2 &lt;= end2) { temp[i++] = arr[start2++]; } memcpy(arr+start, temp+start, (end - start + 1) * sizeof(int)); } void mergeSort(int arr[],size_t len) { //小於2個不用比 if(len &lt; 2) return; int temp[len]; _mergeSort(arr, temp, 0, len-1); } int main() { int arr[] = {6,5,4,3,2,1}; int len = sizeof(arr)/sizeof(int); mergeSort(arr, len); for(int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; }"
  },"/pages/c/dataStruct/recursion/": {
    "title": "遞迴",
    "keywords": "",
    "url": "/pages/c/dataStruct/recursion/",
    "body": "什麼是遞迴？ 自己呼叫自己 從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？「從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？『從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？……』」 這個故事一直不停的說一直不停的說同一個故事，說到什麼時候停止？聽故事的人聽到不耐煩，不想再聽為止。 終止條件 所以要設定一個結束故事的條件，假設講了10次故事，聽故事的人就不想聽了，作為終止條件。 次數 每一次講故事的次數怎麼傳進去？通常使用參數傳進去講故事的函式，每講一次，就把前面講過的故事總次數加1，呼叫下一個講故事的函式中。 講故事(1) -&gt; 講故事(1+1) -&gt; 講故事(2+1) -&gt; 講故事(3+1) -&gt; 講故事(4+1) -&gt; 講故事(5+1) -&gt; 講故事(6+1) -&gt; 講故事(7+1) -&gt; 講故事(8+1) -&gt; 講故事(9+1) -&gt; 講故事(10+1) -&gt; 已經講了10次，終止講故事。 1 2 3 4 5 6 7 8 9 10 void story(int count) { if(count &gt; 10) return; cout &lt;&lt; \"第\" &lt;&lt; count &lt;&lt; \"次:\"; cout &lt;&lt; \"從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？\" &lt;&lt; endl; story(count + 1); } int main() { story(1); return 0; } 第1次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第2次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第3次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第4次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第5次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第6次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第7次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第8次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第9次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第10次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 二種遞迴 傳遞函式前處理 士兵長對10個士兵說，把前面的人的子彈總數加上自己手上的子彈，告訴下一個人，最後一個人把子彈的總數傳給上一個人。 每個士兵的代號跟擁有的子彈數是一致。 士兵代號1，有1個子彈。 士兵代號2，有2個子彈。 士兵代號3，有3個子彈。 . . . 士兵代號9，有9個子彈。 士兵代號10，有10個子彈。 1 2 3 4 5 6 int func1(士兵代號,士兵子彈數,前面的人的子彈數) { //判斷前面的士兵是否為最後一個人 //若前面的士兵為最後一個人 if(士兵代號 &gt; 10) 傳回全部子彈數給上一個人 return func1(告訴下一個士兵, 下一個士兵子彈數, 前面的人的子彈數 + 自已的子彈數); } 1 2 3 4 5 6 7 8 9 10 11 int func1(int i, int bullet, int total) { //判斷前面的士兵是否為最後一個人 if(i &gt; 10) return total; total = total + bullet; return func1(i + 1, bullet + 1, total); } int main() { int total = func1(1, 1, 0); cout &lt;&lt; total &lt;&lt; endl; return 0; } 55 傳遞函式後處理 士兵長對10個士兵說，告訴最後一個人把子彈數傳上來，後面傳上來的同時也加上自己的子彈數。 每個士兵的代號跟擁有的子彈數是一致。 士兵代號1，有1個子彈。 士兵代號2，有2個子彈。 士兵代號3，有3個子彈。 . . . 士兵代號9，有9個子彈。 士兵代號10，有10個子彈。 1 2 3 4 5 6 int func1(士兵代號,士兵子彈數) { //判斷前面的士兵是否為最後一個人 if(士兵代號 &gt; 10) return 0;//第11個士兵不存在，沒有子彈 //自己的子彈數 + 後面的人的子彈數 return 士兵自己的子彈數 + func1(告訴下一個士兵, 下一個士兵子彈數); } 1 2 3 4 5 int func1(int i, int bullet) { if(i &gt; 10) return 0; //自己的子彈數 + 後面的人的子彈數 return bullet + func1(i+1, bullet+1); } 55 類別與遞迴 若在類別中寫遞迴函式，參數不用傳遞，可直接使用成員屬性供遞迴使用，成員屬性可以保存值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Story { public: int times = 0; void tell() { if(times &gt; 10) return; cout &lt;&lt; \"第\" &lt;&lt; times &lt;&lt; \"次:\"; cout &lt;&lt; \"從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？\" &lt;&lt; endl; times++; tell(); } }; int main() { Story story; story.tell(); return 0; } 第0次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第1次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第2次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第3次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第4次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第5次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第6次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第7次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第8次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第9次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？ 第10次:從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？"
  },"/pages/c/basic/param/": {
    "title": "參數與引數",
    "keywords": "",
    "url": "/pages/c/basic/param/",
    "body": "Prerequisites: 維基參數和引數 引數 Argument 傳給函式的變數。 1 2 3 4 5 6 int main() { int var1 = 10; //將var1傳到func1()函式中，而var1就是引數Argument func1(var1); return 0; } 參數 Parameter 函式接收到的變數。 1 2 3 4 //函式接收到來自外面傳進來的變數，變數名param1，而param1就是參數 void func1(int param1) { cout &lt;&lt; \"param1=\" &lt;&lt; param1 &lt;&lt; endl; }"
  },"/pages/c/class/class/": {
    "title": "類別與物件",
    "keywords": "",
    "url": "/pages/c/class/class/",
    "body": "權限 類別權限預設是private，結構權限預設是public public與private與其它權限，可以在類別中出現很多次，以下public就出現2次，private出現2次 1 2 3 4 5 6 7 8 9 10 class Student { public: char name[50]; private: char address[100]; public: int age; private: char father[50]; }; 成員屬性命名 命名方式使用成員屬性_ 後綴加上底線_ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Student { public: string name_; public: Student() { } void print() { cout &lt;&lt; \"name: \" &lt;&lt; name_ &lt;&lt; endl; } }; int main() { Student s; s.name_ = \"Bill\"; s.print(); return 0; } name: Bill 類別作為函式參數 使用類別作為函式參數，都是使用參考&amp;的方式傳遞。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Student { public: string name_; public: Student() { } void print() { cout &lt;&lt; \"name: \" &lt;&lt; name_ &lt;&lt; endl; } }; void func1(const Student&amp; s) { cout &lt;&lt; s.name_ &lt;&lt; endl; } int main() { Student s; s.name_ = \"Bill\"; func1(s); return 0; } Bill 類別中的函式自動變為內嵌函式(inline) inline 類別中的函式自動變為內嵌函式，但不是在類別中的函式不會變成內嵌函式。 以下print()是內嵌函式 1 2 3 4 5 6 7 class Student { public: char name_[50]; //函式自動變為內嵌函式 void print() { } }; 成員函式在類別外定義 函式宣告與定義 print()成員函式程式碼在類別之外定義，定義方式如下。 傳回值 類別名::函式名(){程式碼} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: char name_[50]; //宣告函式 void print(); }; //類別外部定義 void Student::print() { cout &lt;&lt; \"test\" &lt;&lt; endl; } int main() { Student student; student.print(); return 0; } test"
  },"/pages/c/function/func_default_param/": {
    "title": "函式參數預設值",
    "keywords": "",
    "url": "/pages/c/function/func_default_param/",
    "body": "參數預設值 有預設值，呼叫函式時就可以不用代入參數。 1 2 3 4 5 6 7 8 void func1(const string&amp; msg = \"這是預設值\") { cout &lt;&lt; msg &lt;&lt; endl; } int main() { func1(\"test\"); func1(); return 0; } test 這是預設值test 這是預設值 宣告函式與定義函式分開，函式預設值只能在宣告 何謂宣告函式？ 宣告就是告訴編譯器我有一個函式藍圖模型(尚未實作)，又稱函式原型(prototype)，在程式的某處會引入此函式。 何謂定義函式？ 函式全部的程式碼。 何謂呼叫函式？ 程式執行到呼叫函式，程式的執行會移轉到函式定義(函式全部的程式碼)。 1 2 3 4 5 6 7 8 9 10 11 //宣告函式 void func1(); int main() { //呼叫函式 func1(); return 0; } //定義函式 void func1() { cout &lt;&lt; \"test\" &lt;&lt; endl; } 函式預設值只能在宣告 1 2 3 4 5 6 7 8 9 10 11 12 //宣告函式 void func1(const string&amp; msg = \"這是預設值\"); int main() { //呼叫函式 func1(\"test\"); func1(); return 0; } //定義函式 void func1(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; endl; } test 這是預設值 若有一個參數有預設值，排在它後面的參數也要有預設值 參數msg2排在參數msg1後面，參數msg1已設置預設值，若參數msg2不設置預設值會編譯錯誤。 呼叫函式，有預設值的參數，可以不用設置引數。 1 2 3 4 5 6 7 8 9 10 11 void func1(int error_code, const string&amp; msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } int main() { func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); func1(200); return 0; } Error code: 500, Msg1: Server Error!, Msg2: Server has some error. Error code: 404, Msg1: Not Found!, Msg2: 這是預設值2 Error code: 200, Msg1: 這是預設值1, Msg2: 這是預設值2 若某個參數設值，排在它之前的參數也要設值 下例中，傳值給第3個參數，前面2個參數都要設置。 func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); 1 2 3 4 5 6 7 8 9 10 void func1(int error_code, const string&amp; msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } int main() { func1(500, \"Server Error!\", \"Server has some error.\"); func1(404, \"Not Found!\"); return 0; }"
  },"/pages/c/function/func_inline/": {
    "title": "內嵌函式",
    "keywords": "",
    "url": "/pages/c/function/func_inline/",
    "body": "內嵌函式inline 函式會占記憶體空間，主程式呼叫函式時會跳到函式占用的記憶體位址，待函式結尾再跳回主程式，為了節省跳來跳去的執行時間，可在函式前面加上inline，編譯器一看到inline就會把函式拷貝一份插入在主程式之中。 在以下程式碼print()最前面加上inline，使print()函式變成內嵌函式。 1 2 3 4 5 6 7 8 9 inline void print(string s) { cout &lt;&lt; s &lt;&lt; endl; } int main() { print(\"test\"); print(\"abcdef\"); print(\"aaaa\"); return 0; } 轉變內嵌函式，程式在執行時就會變成以下這樣 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { { string s = \"test\"; cout &lt;&lt; s &lt;&lt; endl; } { string s = \"abcdef\"; cout &lt;&lt; s &lt;&lt; endl; } { string s = \"aaaa\"; cout &lt;&lt; s &lt;&lt; endl; } return 0; } 若是呼叫print() 1000次就會copy程式碼1000份在主程式中，占用記憶體空間。(變數也是占記憶體位址)"
  },"/pages/c/function/func_overload/": {
    "title": "函式多載",
    "keywords": "",
    "url": "/pages/c/function/func_overload/",
    "body": "多載overload 多載是指相同函式名，完成相似的工作。 函式名相同，傳回值相同，但參數的型態或數量不同，編譯時，編譯器會根據引數類型與函式參數類型，引數的數量與函式參數的數量，進行匹配。 int func(short a, string b); int func(int a, string b); int func(double a, string b); int func(int a, string b, int c); int func(string a, int b); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(int a, int b) { cout &lt;&lt; \"比較int\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } int main() { float a1 = 100.5f; float b1 = 100.3f; max(a1, b1); int a2 = 20; int b2 = 30; max(a2, b2); return 0; } 比較float a大 比較int b大 多載注意事項 函式名相同，參數型態與數量相同，但一個參數有const，這樣不是函式多載。 以下函式名、參數型態與數量相同，但有一個是const，這樣不是函式多載。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(const float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } 返回值要相同 函式名相同，參數型態與數量相同，但一個參數是參考，編譯器不知道要使用那一個 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void max(float a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } void max(float&amp; a, float b) { cout &lt;&lt; \"比較float\" &lt;&lt; endl; if(a &gt; b) cout &lt;&lt; \"a大\" &lt;&lt; endl; else cout &lt;&lt; \"b大\" &lt;&lt; endl; } int main() { float a1 = 100.5f; float b1 = 100.3f; max(a1, b1); return 0; } 使用預設值，編譯器不知道要使用那一個函式 以下有二個相同名稱的函式，一個是三個參數(但有預設值)，一個是二個參數(沒預設值)，若使用二個引數呼叫，編譯器不知道要使用那一個函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 void func1(int error_code, string msg1 = \"這是預設值1\", const string&amp; msg2 = \"這是預設值2\") { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; cout &lt;&lt; \"Msg2: \" &lt;&lt; msg2 &lt;&lt; endl; } void func1(int error_code, string msg1) { cout &lt;&lt; \"Error code: \" &lt;&lt; error_code &lt;&lt; \", \"; cout &lt;&lt; \"Msg1: \" &lt;&lt; msg1 &lt;&lt; \", \"; } int main() { func1(500,\"Server error!\"); return 0; }"
  },"/pages/c/class/enum/": {
    "title": "Enum列舉",
    "keywords": "",
    "url": "/pages/c/class/enum/",
    "body": "主程式 enum宣告 語法 enum 變數名稱{常數1, 常數2, 常數3, 常數4, ...}; 列舉型態在內部視為整數，通常集合第一個元素值為0，下一個為1，以此類推。 以下的寫法是錯誤，編譯器編不過。 day1 = 5; 完整程式碼 1 2 3 4 5 6 7 8 9 10 enum days_of_week {Sun, Mon, Tue, Wed, Thu, Fri, Sat}; int main() { days_of_week day1, day2; day1 = Mon; day2 = Thu; int diff = day2 - day1; cout &lt;&lt; \"Days between = \" &lt;&lt; diff &lt;&lt; endl; return 0; } Days between = 3 類別與Enum列舉 enum宣告 enum {girl = 0, boy = 1}; 變數存放enum 要記得存放enum值的變數 int sex; 指派enum給變數 在類別之外設定列舉 student.sex = student.girl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Student { public: char name[50]; int sex; enum {girl = 0, boy = 1}; private: char address[100]; public: int age; private: char father[50]; public: void setName(const char* name1) { strcpy(name, name1); } void setAge(const int age) { this-&gt;age = age; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; \"sex: \"; if(sex == girl) cout &lt;&lt; \"girl\" &lt;&lt; endl; else cout &lt;&lt; \"boy\" &lt;&lt;endl; } }; int main() { Student student; student.setName(\"Bill\"); student.setAge(20); student.sex = student.girl; student.print(); return 0; }"
  },"/pages/c/class/constructor/": {
    "title": "建構子與解構子",
    "keywords": "",
    "url": "/pages/c/class/constructor/",
    "body": "Prerequisites: RVO 建構子 語法 public: 類別名() { } Student(){ } 與類別的名字相同 沒有返回值 權限是public 可以有參數，參數也可以有預設值 參數為空的建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); } }; int main() { Student student; return 0; } 沒參數建構子 建構子參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); m_age = 0; } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student; Student student1(\"Bill\", 20); student1.print(); return 0; } 沒參數建構子 有參數建構子 name: Bill 解構子 物件記憶體釋放前，會執行解構子。 語法 public: ~類別名() { } ~Student(){ } 與類別的名字相同，前面加上~ 沒有返回值 權限是public 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student student; return 0; } 建構子 解構子 建構子參數只有一個，可使用指派運算子 建構子參數只有一個，可使用指派運算子=，呼叫只有一個參數的建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: string name; Student(){}; //參數只有一個建構子 Student(const char* name) { this-&gt;name = name; } }; int main() { //使用等於(=)指派運算子呼叫只有一個參數的建構子 Student student = \"Bill\"; cout &lt;&lt; \"name = \" &lt;&lt; student.name &lt;&lt; endl; return 0; } name = Bill 注意事項 建構子解構子自動生成 若沒實作建構子/解構子，編譯器會自動生成空的建構子與解構子，若實作建構子，不管建構子有沒有參數，編譯器不會自動生成空的建構子或解構子 如果沒有實作空的建構子，只實作有參數的建構子，以下程式碼編譯不過。 以下程式碼在主程式main函式，會尋找空的建構子。 Student student; 以下程式碼編譯不過 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Student { public: char m_name[50]; int m_age = 20; Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student; return 0; } 不要用變數名()建立物件 以下程式碼，會編譯成功，但不會呼叫建構子，建立物件失敗，編譯器認為是呼叫函式名為student()的函式。 注意！student()是小寫，是變數名，不是類別名Student Student student(); 執行結果為空，沒有印出”沒參數建構子” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); m_age = 0; } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; memset(m_name,0,sizeof(m_name)); strcpy(m_name, name); m_age = age; } //宣告成員函式 void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student student(); return 0; } 用以上student呼叫成員函式print()，會編譯失敗，因為根本沒有建立物件，沒有在記憶體產生物件存放的位址。 student.print(); 1 2 3 4 5 int main() { Student student(); student.print(); return 0; } 多個建構子使用的程式碼寫在成員函式中 以下建構子呼叫init()函式，清空成員變數，多個建構子可以使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Student { public: char m_name[50]; int m_age = 20; Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; init(); } Student(const char* name, const int age) { cout &lt;&lt; \"有參數建構子\" &lt;&lt; endl; init(); strcpy(m_name, name); m_age = age; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void init() { memset(m_name,0,sizeof(m_name)); m_age = 0; } }; int main() { Student student = Student(); Student student1 = Student(\"Bill\", 20); return 0; }"
  },"/pages/c/class/copy_constructor/": {
    "title": "拷貝函式",
    "keywords": "",
    "url": "/pages/c/class/copy_constructor/",
    "body": "Prerequisites: RVO 複製語法 已建立的物件成員變數的值，複製給另一個物件。 語法如下 類別 新物件變數名(已建立物件變數名); 類別 新物件變數名 = 已建立物件變數名; 拷貝函式程式會自動產生，會自動產生二個物件的成員變數拷貝程式碼。 呼叫拷貝函式 以下二種程式碼都是呼叫預設的拷貝函式 方式一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2 = s1; s2.print(); return 0; } 方式二 1 2 3 4 5 6 7 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1); s2.print(); return 0; } 由執行結果可以發現建立s1物件和s2物件只呼叫一次建構子。 s2.print()印出的值是複製s1的成員變數。 沒參數建構子 name: Cici 解構子 解構子 拷貝函式自行實作 類別名(const 類別名&amp; 參數名) {...} 權限為public 函式名必須與類別名相同 沒有傳回值，不寫void 如果自行實作拷貝函式，編譯器就不會自動產生預設拷貝函式 如果自行實作拷貝函式，但裡面都沒有程式碼，編譯器會自動產生預設的程式碼。 拷貝函式參數要包含const 類別名&amp;參考，不包含的話，就是建構子。 1 2 3 4 5 Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: char m_name[50]; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1); s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 name: Cici 解構子 解構子 函式參數的值是類別，會呼叫拷貝函式 函式參數是值 除了基本資料型態，在函式參數是值的時候會原始變數拷貝到新變數，若值是類別，也會把原始物件拷貝到新物件，此時就會呼叫到拷貝函式。 1 2 3 4 5 6 7 8 9 void func(Student s) { s.print(); } int main() { Student s1; strcpy(s1.m_name, \"Cici\"); func(s1); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 name: Cici 解構子 解構子 函式傳回值是臨時物件 函式傳回值是值 臨時物件 函式傳回值是臨時物件會呼叫拷貝函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } Student(const Student &amp;src) { cout &lt;&lt; \"拷貝函式\" &lt;&lt; endl; } Student&amp; operator=(const Student&amp; src) { cout &lt;&lt; \"指派運算子\" &lt;&lt; endl; return *this; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student func() { Student s; cout &lt;&lt; \"函式物件記憶體位址 = \" &lt;&lt; &amp;s &lt;&lt; endl; return s; } int main() { Student s1 = func(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; } 建構子 // 建立 func() 內的 s 函式物件記憶體位址 = 0x7ff7bfeff410 //由於 RVO 被關閉，s 不能直接被 s1 接收。 //函式返回值需要創建一個新的 Student 物件 來存放 s，這個新物件是函式返回的臨時變數。 //這導致拷貝建構函式被調用。 拷貝函式 // 拷貝函式返回的物件（臨時變數） 解構子 // func() 內的 s 被銷毀，s 是 func() 內部的變數，在函式執行結束時，該變數會被銷毀，執行 解構子 拷貝函式 // main() 裡的 Student s1 = func(); 會把 func() 返回的臨時 Student 再拷貝一次 到 s1 解構子 // func() 返回的 臨時 Student 物件 在 s1 建立後已無用，因此被銷毀，執行 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 // main() 執行完後，s1 離開作用域，被銷毀，執行 解構子 拷貝函式多載(Overload) 在拷貝函式增加參數str 1 2 3 4 5 6 Student(const Student &amp;s, string str) { memset(m_name,0,sizeof(m_name)); string temp = str + s.m_name; strcpy(m_name, temp.c_str()); cout &lt;&lt; \"呼叫Student(const Student &amp;s, string str)拷貝函式\" &lt;&lt; endl; } 執行的main函式 1 2 3 4 5 6 7 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); Student s2(s1, \"漂亮的\"); s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s, const char str[50])拷貝函式 name: 漂亮的Cici 解構子 解構子"
  },"/pages/c/class/deep_shallow_copy/": {
    "title": "深淺拷貝",
    "keywords": "",
    "url": "/pages/c/class/deep_shallow_copy/",
    "body": "淺拷貝 淺拷貝介紹 二個物件二個指標都指向同一個記憶體位址，一旦一個指標指向的記憶體位址釋放，使用到另一個指標就會執行錯誤，因為它指向的記憶體位址已經被釋放。 以下程式碼，在建構子時，對m_ptr指標動態分配記憶體位址，並把位址存放的值設為abcdef，在解構子中，把m_ptr指標記憶體釋放，若沒使用拷貝函式前，以下程式碼運作正常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = new char[100]; strcpy(m_ptr, \"abcdef\"); cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr m_ptr = s.m_ptr; cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.print(); return 0; } 沒參數建構子 name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = abcdef 解構子 淺拷貝刪除問題 一旦使用拷貝函式，在解構子時就會出現問題，因為s1與s2的m_ptr指向同一個記憶體位址，但s1的解構子把m_ptr記憶體釋放掉，s2的解構子就找不到m_ptr的記憶體位址。 1 2 3 4 5 6 7 8 int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.print(); Student s2(s1); s2.print(); return 0; } 沒參數建構子 name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = abcdef 呼叫Student(const Student &amp;s)拷貝函式 name: Cici m_ptr address:0x7ff7bfeff420 m_ptr value = abcdef 解構子 lsn11(15006,0x100098600) malloc: *** error for object 0x600002900000: pointer being freed was not allocated lsn11(15006,0x100098600) malloc: *** set a breakpoint in malloc_error_break to debug 淺拷貝修改同一個記憶體位址內容問題 以下程式碼，s1.m_ptr的指標內容為abcdef，s2.m_ptr也修改成zzzzz，造成s1.print()印出的結果也是zzzzz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = nullptr; cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr m_ptr = s.m_ptr; cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } }; int main() { Student s1; strcpy(s1.m_name, \"Cici\"); s1.m_ptr = new char[100]; strcpy(s1.m_ptr, \"abcdef\"); Student s2(s1); strcpy(s2.m_ptr, \"zzzzz\"); cout &lt;&lt; \"##### s1 #### \" &lt;&lt; endl; s1.print(); cout &lt;&lt; \"##### s2 #### \" &lt;&lt; endl; s2.print(); return 0; } 沒參數建構子 呼叫Student(const Student &amp;s)拷貝函式 ##### s1 #### name: Cici m_ptr address:0x7ff7bfeff460 m_ptr value = zzzzz ##### s2 #### name: Cici m_ptr address:0x7ff7bfeff420 m_ptr value = zzzzz 深拷貝 二個物件二個指標分別指向不同記憶體位址，複製的時候，把值複製到另一個記憶體位址。 以下程式碼在拷貝函式先判斷拷貝的對象是不是nullptr，若不是，才動態分配記憶體位址，並把字串指標的內容透過strcpy()拷貝到另一個字串指標。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Student { public: char m_name[50]; char* m_ptr; public: Student() { m_ptr = nullptr; cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(const Student &amp;s) { memset(m_name,0,sizeof(m_name)); strcpy(m_name, s.m_name); //拷貝m_ptr if(s.m_ptr) { m_ptr = new char[100]; strcpy(m_ptr, s.m_ptr); } else { m_ptr = nullptr; } cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } ~Student() { delete [] m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; m_ptr &lt;&lt; endl; } };"
  },"/pages/c/class/init_list/": {
    "title": "建構子初始化列表",
    "keywords": "",
    "url": "/pages/c/class/init_list/",
    "body": "語法 建構子初始化列表(Initialization list of constructors)，因為不知道繁體中文的名稱，先以大陸的名稱來替代。 成員變數已經在初始化列表，不應該再建構子中再設值 語法如下 類別名(資料型態 參數名1, 資料型態 參數名2, ...):成員變數1(參數名1),成員變數2(參數名2), ... {} 下方有參數的建構子，使用初始化列表，初使化成員變數。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: string m_name; int m_age; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(string name, int age):m_name(name),m_age(age) { cout &lt;&lt; \"初始化列表建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; m_age &lt;&lt; endl; } }; int main() { Student s1(\"cici\", 18); s1.print(); return 0; } 初始化列表建構子 name: cici age: 18 解構子 初始化列表與運算式 下方有參數的建構子，使用初始化列表並加上運算式，初使化成員變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student { public: string m_name; int m_age; public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; } Student(string name, int age):m_name(\"漂亮的\" + name),m_age(age + 10) { cout &lt;&lt; \"初始化列表建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"name: \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"age: \" &lt;&lt; m_age &lt;&lt; endl; } }; int main() { Student s1(\"cici\", 18); s1.print(); return 0; } 初始化列表建構子 name: 漂亮的cici age: 28 解構子"
  },"/pages/c/pthread/create_pthread/": {
    "title": "建立pthread",
    "keywords": "",
    "url": "/pages/c/pthread/create_pthread/",
    "body": ""
  },"/pages/c/thread/create_thread/": {
    "title": "建立thread",
    "keywords": "",
    "url": "/pages/c/thread/create_thread/",
    "body": "thread建構子介紹 匯入 #include &lt;thread&gt; 建立thread thread t1(func, \"test test\"); 第一個參數是函式名 第二個參數是呼叫函式代入的參數 sleep函式 使用sleep函式，需要匯入以下標頭檔，因為我是mac，所以匯入unistd.h #include &lt;unistd.h&gt; sleep函式使用方式 sleep(1); 在mac中，sleep是小寫，建構子代入參數1，代表1秒。 join 執行緒記憶體釋放 1 t1.join(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { for (int i = 0; i &lt;= 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } i = 0, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =test test i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 2, msg =test test i = 3, msg =abcdefg abcdefg i = 3, msg =test test i = 4, msg =abcdefg abcdefg i = 4, msg =test test i = 5, msg =abcdefg abcdefg i = 5, msg =test test i = 6, msg =i = 6, msg =test test abcdefg abcdefg i = 7, msg =test test i = 7, msg =abcdefg abcdefg i = 8, msg =test test i = 8, msg =abcdefg abcdefg i = 9, msg =test test i = 9, msg =abcdefg abcdefg i = 10, msg =abcdefg abcdefg i = 10, msg =test test thread與成員函式 thread 執行緒變數(&amp;類別名::成員函式, &amp;物件名, 傳進成員函式的參數1,傳進成員函式的參數2); 參數1為成員函式的記憶體位址 參數2為物件記憶體位址 參數3與參數4為函式的參數 以下的程式碼包含Student的類別，t3執行緒是呼叫Student物件的成員函式func()，並代入參數msg。 1 2 3 4 5 Student student;//建立物件 //第一個參數傳入成員函式位址，要有&amp;類別名::成員函式，注意！成員函式結尾不用括號 //第二個參數傳入物件地址 //第三個參數傳入函式的參數 thread t3(&amp;Student::func, &amp;student, \"ccccccc\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Student { public : void func(const string&amp; msg) { for (int i = 0; i &lt;= 10; i++) { cout &lt;&lt; \" i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; } } }; int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); Student student;//建立物件 //第一個參數傳入成員函式位址，要有&amp;類別名::成員函式，注意！成員函式結尾不用括號 //第二個參數傳入物件地址 //第三個參數傳入函式的參數 thread t3(&amp;Student::func, &amp;student, \"ccccccc\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); t3.join(); return 0; }"
  },"/pages/c/thread/join/": {
    "title": "執行緒記憶體釋放",
    "keywords": "",
    "url": "/pages/c/thread/join/",
    "body": "main()函式執行完成，執行中的執行緒強迫結束 執行緒函式返回，執行緒結束。 main程式退出，正在執行的執行緒都會被強迫結束。 以下範例，執行緒執行10秒結束，但main函式(主程式) 只執行5秒結束，明顯執行緒執行的時間比主程式久，重點是主程式結束，其它未執行完的執行緒也會強迫結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //每一秒印1次，這裡是執行5秒 for (int i = 0; i &gt; 5; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } return 0; } 釋放執行緒記憶體位址 多個執行緒共享Stack空間，每一個執行緒都會占記憶體空間，所以執行緒結束時要釋放它的記憶體位址。 執行緒記憶體釋放有2種方法 在main()函式使用join()，等待執行緒結束，記憶體位址釋放(也稱記憶體回收)後，返回main()主程式。 使用detach()執行緒與主程式分離，各別運行，執行緒結束後會自行使用joinalbe()把它占用的記憶體位址釋放。 即便以下程式，main()主程式執行時間改為12秒，比執行緒10秒久，但執行緒記憶體位址沒被釋放，仍會執行錯誤。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //每一秒印1次，這裡是執行12秒 for (int i = 0; i &gt; 12; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } return 0; } join() 以下程式碼，即便main()函式已經刪掉執行時間12秒的程式碼，也就是說main()函式的執行時間為0秒，但使用join()，main()函式仍會等待執行緒都執行完(包含記憶體釋放)，才會跟著結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } detach() 使用detach()分離執行緒，main()函式要執行的比執行緒久，不然的話，主程式執行結束，執行緒也會跟著執行結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //分離執行緒 t1.detach(); //分離執行緒 t2.detach(); //main()函式等留12秒，等待執行緒(執行緒10秒) sleep(12); return 0; }"
  },"/pages/c/thread/mutex/": {
    "title": "互斥鎖Mutex",
    "keywords": "",
    "url": "/pages/c/thread/mutex/",
    "body": "執行緒安全 多個執行緒搶同一個資源，就會發生問題，以下程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; using namespace std; void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } i = 0, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =test test i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 2, msg =test test i = 3i = 3, msg =test test, msg =abcdefg abcdefg i = 4i = 4, msg =abcdefg abcdefg, msg =test test i = 5, msg =test test i = 5, msg =abcdefg abcdefg i = 6, msg =test test i = 6, msg =abcdefg abcdefg i = 7, msg =test test i = 7, msg =abcdefg abcdefg i = 8, msg =abcdefg abcdefg i = 8, msg =test test i = 9, msg =abcdefg abcdefg i = 9, msg =test test 從執行結果來看，以下二句是二個執行緒搶cout(全域變數)這個資源，導致輸出的結果不正常。 i = 3i = 3, msg =test test, msg =abcdefg abcdefg i = 4i = 4, msg =abcdefg abcdefg, msg =test test 互斥鎖Mutex 同步(Concurrency Control)是指，多個執行緒協調如何使用同一個資源。 如下圖，每一個人代表一個執行緒，他們都在排隊上同一間廁所(同一個資源)，當一個人(一個執行緒)進入廁所，就要把門鎖上，當上完廁所，再把門打開，輪下一個人(下一個執行緒)進去上廁所(同一個資源)。 互斥鎖保證同一個時間只有一個人(一個執行緒)使用廁所(同一個資源)，當一個執行緒把門鎖上，其它執行緒就在門外排隊等候，等待廁所中的執行緒把門打開(開鎖)，輪下一個執行緒進去把門鎖上。 匯入標頭檔 #include &lt;mutex&gt; 互斥鎖全域變數 mutex mtx; lock() 鎖上 可以把mutex想像成是廁所那個門，若是門是鎖起來的狀態，代表有人(一個thread)在廁所裡面，其它人(threads)就要在門外排隊等待，直到門開鎖，沒有鎖起來的狀態，執行緒呼叫mutex.lock()會自行判斷鎖起來的狀態，若沒鎖上，執行緒會得到鎖，若鎖上，執行緒就要排隊等待。 unlock() 開鎖 只有在廁所中的執行緒才有開鎖的功能，其它在廁所門外排隊的執行緒是沒辦法開鎖。 程式碼 先前的程式，把cout想成廁所，程式碼修改如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; #include &lt;mutex&gt; using namespace std; //建立mutex互斥鎖 mutex mtx; void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { mtx.lock();//把門鎖上 cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 mtx.unlock();//使用完畢，把門開鎖 } } i = 0, msg =test test i = 1, msg =test test i = 2, msg =test test i = 3, msg =test test i = 4, msg =test test i = 5, msg =test test i = 0, msg =abcdefg abcdefg i = 1, msg =abcdefg abcdefg i = 2, msg =abcdefg abcdefg i = 3, msg =abcdefg abcdefg i = 4, msg =abcdefg abcdefg i = 5, msg =abcdefg abcdefg i = 6, msg =abcdefg abcdefg i = 7, msg =abcdefg abcdefg i = 8, msg =abcdefg abcdefg i = 9, msg =abcdefg abcdefg i = 6, msg =test test i = 7, msg =test test i = 8, msg =test test i = 9, msg =test test 判斷是那個thread加鎖/解鎖/申請鎖 1 2 3 4 5 6 7 8 9 10 11 12 void func(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"申請鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; mtx.lock(); cout &lt;&lt; \"鎖上的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 cout &lt;&lt; \"開鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; mtx.unlock(); } } 類別與mutex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { //私有成員變數互斥鎖 mutex m_mutex; public: void func(string msg) { for (int i = 0; i &lt; 10; i++) { m_mutex.lock(); cout &lt;&lt; \"msg = \" &lt;&lt; msg &lt;&lt; endl; m_mutex.unlock(); } } }; int main() { Student student;//建立物件 thread t1(&amp;Student::func, &amp;student, \"student1\"); thread t2(&amp;Student::func, &amp;student, \"student2\"); thread t3(&amp;Student::func, &amp;student, \"student3\"); thread t4(&amp;Student::func, &amp;student, \"student4\"); thread t5(&amp;Student::func, &amp;student, \"student5\"); t1.join(); t2.join(); t3.join(); t4.join(); t5.join(); return 0; } msg = student1 msg = student3 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 msg = student5 以下截斷 recursive_mutex 以下程式碼，func4()呼叫func3()，但執行結果只印出func4。 若是鎖中有鎖，會有死鎖(Dead lock)問題，mutex必須解鎖才能加鎖。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 mutex mtx; void func3() { mtx.lock();//加鎖 cout &lt;&lt; \"func3\" &lt;&lt; endl; mtx.unlock();//解鎖 } void func4() { mtx.lock();//加鎖 cout &lt;&lt; \"func4\" &lt;&lt; endl; func3();//呼叫func3 mtx.unlock();//解鎖 } int main() { //建立執行緒t1 thread t1(func4, \"test test\"); //執行緒t1被記憶體釋放 t1.join(); return 0; } func4 改成使用recursive_mutex，就不會有死鎖問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 recursive_mutex r_mtx; void func3() { r_mtx.lock();//加鎖 cout &lt;&lt; \"func3\" &lt;&lt; endl; r_mtx.unlock();//解鎖 } void func4() { r_mtx.lock();//加鎖 cout &lt;&lt; \"func4\" &lt;&lt; endl; func3();//呼叫func3 r_mtx.unlock();//解鎖 } int main() { //建立執行緒t1 thread t1(func4); //執行緒t1被記憶體釋放 t1.join(); return 0; } func4 func3 lock_guard lock_guard是mutex的樣板，只要管加鎖，不用管解鎖，它會在離開有效範圍(Scope)與生命週期(Lifetime)，自動解鎖。 語法 1 lock_guard&lt;mutex類別名&gt; mlock(mtx物件名); 把之前的程式碼修改成lock_guard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void func2(string msg) { //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"申請鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //有效範圍scope 開始 { lock_guard&lt;mutex&gt; mlock(mtx);//把門鎖上 cout &lt;&lt; \"鎖上的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//持有鎖後，再休眠1秒 cout &lt;&lt; \"開鎖的thread = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; } //有效範圍scope 結束 } } int main() { //建立執行緒t1 thread t1(func2, \"test test\"); //建立執行緒t2 thread t2(func2, \"abcdefg abcdefg\"); //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 0, msg =test test 申請鎖的thread = 0x700005ead000 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 1, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 2, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005e2a000 i = 3, msg =test test 開鎖的thread = 0x700005e2a000 申請鎖的thread = 0x700005e2a000 鎖上的thread = 0x700005ead000 i = 0, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 1, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 2, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 3, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 申請鎖的thread = 0x700005ead000 鎖上的thread = 0x700005ead000 i = 4, msg =abcdefg abcdefg 開鎖的thread = 0x700005ead000 以下截斷"
  },"/pages/c/thread/this_thread/": {
    "title": "this_thread",
    "keywords": "",
    "url": "/pages/c/thread/this_thread/",
    "body": "取得get_id() 像linux中每一個行程(Process)都有pid，執行緒也有自己的id。 取得main thread的id 在main()函式中，放入以下程式碼就可以取得main thread的id this_thread::get_id() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); cout &lt;&lt; \"get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } 取得thread的id 以下程式碼就可以取得執行緒的id 1 2 3 4 5 6 7 8 void func(string msg) { cout &lt;&lt; \"func get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; //每一秒印1次，這裡是執行10秒 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", msg =\" &lt;&lt; msg &lt;&lt; endl; sleep(1);//停1秒鐘 } } 也可以透過執行緒物件取得id 語法 執行緒物件.get_id() 程式碥 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { //建立執行緒t1 thread t1(func, \"test test\"); //建立執行緒t2 thread t2(func, \"abcdefg abcdefg\"); cout &lt;&lt; \"main() get_id() = \" &lt;&lt; this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; \"t1 get_id() = \" &lt;&lt; t1.get_id() &lt;&lt; endl; cout &lt;&lt; \"t2 get_id() = \" &lt;&lt; t2.get_id() &lt;&lt; endl; //執行緒t1被記憶體釋放 t1.join(); //執行緒t2被記憶體釋放 t2.join(); return 0; } sleep_for () 跟sleep()函式一樣，但sleep()會有作業系統不同造成寫法不同，匯入的標頭檔不同。但sleep_for ()解決這個問題。 以下是暫停1秒 1 this_thread::sleep_for (chrono::seconds(1));"
  },"/pages/c/thread/condition_variable/": {
    "title": "condition_variable",
    "keywords": "",
    "url": "/pages/c/thread/condition_variable/",
    "body": "通知與等待 想像一下，當有人寄簡訊給你，你的手機會收到簡訊的通知Notify，其它時候，你的手機一直處於等待Wait的狀態。 建立condition_variable condition_variable m_cond;//條件 通知接收訊息 通知一個執行緒 m_cond.notify_one(); 通知多個執行緒 m_cond.notify_all(); unique_lock unique_lock支援condition_variable(通知/等待) unique_lock支援解鎖功能。 1 2 unique_lock&lt;mutex&gt; lock(m_mtx);//加鎖 lock.unlock();//解鎖 也可使用scope有效範圍作為離開範圍解鎖 1 2 3 4 { unique_lock&lt;mutex&gt; lock(m_mtx);//加鎖 //離開scope{}就解鎖 } 等待有訊息傳過來 1 m_cond.wait(lock); Queue 建立一個Queue儲存訊息。 無限迴圈 手機無限迴圈等待有訊息通知 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;thread&gt; #include &lt;mutex&gt; #include &lt;queue&gt; #include &lt;condition_variable&gt; using namespace std; class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; public: void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while (true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while (m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if (msg == \"END\") break; } } }; int main() { //建立物件 SafeQueue safeQue; //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for (int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for (int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; } 執行緒:0x70000ff3d000,msg0 執行緒:0x70000ff3d000,msg1 執行緒:0x70000ff3d000,msg2 執行緒:0x70000ff3d000,msg3 執行緒:0x70000ff3d000,msg4 執行緒:0x70000ff3d000,msg5 執行緒:0x70000ff3d000,msg6 執行緒:0x70000ff3d000,msg7 執行緒:0x70000ff3d000,msg8 執行緒:0x70000ff3d000,msg9 執行緒:0x70000ff3d000,msg10 執行緒:0x70000ff3d000,msg11 執行緒:0x70000ffc0000,msg12 執行緒:0x70000ffc0000,msg13 執行緒:0x70000ffc0000,msg14 執行緒:0x70000ffc0000,msg15 以下截掉 證明wait()自帶解鎖功能 因為mutex互斥鎖一次只能把鎖給一個執行緒，拿到鎖的執行緒就可以執行互斥鎖mutex之後的程式碼，其它執行緒都在mutex之外排隊， 但wait()的參數中又需要有lock，只能有鎖的執行緒才能等待通知，這樣就只有一個執行緒在等待通知， 其它執行緒都在mutex之外排隊等待拿到鎖，因此wait()為了要讓其它執行緒能等待接收訊息，自帶解鎖功能，證明的過程在最後面。 在wait()之前增加一行，休眠一小時 this_thread::sleep_for (chrono::hours(1)); 目的是不要執行wait()，可以看到執行緒搶鎖的過程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void pop(){ //無限迴圈等待有訊息通知 while (true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //m_cond.wait()參數只支援unique_lock cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"排隊等待\" &lt;&lt; endl; unique_lock&lt;mutex&gt; lock(m_mtx); cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"加鎖成功\" &lt;&lt; endl; this_thread::sleep_for (chrono::hours(1)); // queue是空的才等待 while (m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if (msg == \"END\") break; } } }; 從執行結果可以看出，只有一個執行緒拿到鎖，並加鎖，其它執行緒都在外面排隊等待拿到鎖。 執行緒 = 執行緒 = 0x7000016b9000執行緒 = 0x700001636000排隊等待0x70000173c000排隊等待 排隊等待 執行緒 = 0x7000016b9000加鎖成功 把休眠一小時的程式碼拿掉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void pop(){ //無限迴圈等待有訊息通知 while (true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //m_cond.wait()參數只支援unique_lock cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"排隊等待\" &lt;&lt; endl; unique_lock&lt;mutex&gt; lock(m_mtx); cout &lt;&lt; \"執行緒 = \" &lt;&lt; this_thread::get_id() &lt;&lt; \"加鎖成功\" &lt;&lt; endl; // queue是空的才等待 while (m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //印出接收到的訊息 cout &lt;&lt; \"執行緒:\" &lt;&lt; this_thread::get_id() &lt;&lt; \",\" &lt;&lt; msg &lt;&lt; endl; //解鎖 lock.unlock(); //如果msg是end就不要再等待接收訊息 if (msg == \"END\") break; } } }; 從執行結果可以看到，三個執行緒都拿到鎖，證明wait()有自帶解鎖功能。 執行緒 = 執行緒 = 執行緒 = 0x70000ea07000排隊等待0x70000ea8a000 執行緒 = 排隊等待 0x70000ea07000加鎖成功 執行緒 = 0x70000ea8a000加鎖成功 0x70000e984000排隊等待 執行緒 = 0x70000e984000加鎖成功"
  },"/pages/c/class/member_class/": {
    "title": "成員變數是類別",
    "keywords": "",
    "url": "/pages/c/class/member_class/",
    "body": "在Java的世界中，只有new的那一刻才會呼叫類別的建構子。 但在C++的世界中，Family m_family;就會呼叫類別的建構子，並且在記憶體建立此物件的位址。 1 2 3 4 class Student { public: Family m_family; }; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Family { public: string mon; string dad; Family(){ cout &lt;&lt; \"Family 建構子\" &lt;&lt; endl; } }; class Student { public: Family m_family; }; int main() { Student student; return 0; } Family 建構子 由執行結果可以知道，建立student物件的時候，就會建立Family物件。"
  },"/pages/c/class/static_class/": {
    "title": "靜態類別變數與函式",
    "keywords": "",
    "url": "/pages/c/class/static_class/",
    "body": "Prerequisites: 記憶體配置 靜態類別變數與靜態類別函式不屬於物件，與物件是分開，靜態類別變數與靜態類別函式存放在靜態bss與data segment 靜態類別變數只有一個，無論物件有多少個，但靜態類別變數只有一個。 靜態類別變數 在變數前面加上static 語法 static int count; 靜態類別變數不會在建立物件的時候初始化，需要使用::範圍運算子在全域變數的位置初始化。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; class Student { public: static int count; }; //在這邊初始化靜態類別變數 int Student::count = 100; int main() { return 0; } 物件的成員變數需要建立物件才能讀寫。 讀取類別靜態變數不用建立物件，只需要類別名與::範圍運算子與變數名就可以讀取靜態類別變數。 類別::靜態類別變數 cout &lt;&lt; \"count = \" &lt;&lt; Student::count &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 class Student { public: static int count; }; int Student::count = 100; int main() { cout &lt;&lt; \"count = \" &lt;&lt; Student::count &lt;&lt; endl; return 0; } count = 100 靜態類別函式 在函式前面加上static 語法 static void getCount(){}; 呼叫靜態類別函式不用建立物件，只需要類別名與::範圍運算子與函式名就可以讀取靜態類別函式。 類別::靜態類別函式 Student::getCount(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student::getCount(); return 0; } 物件可以讀取靜態類別變數與靜態類別函式 物件可以直接讀取靜態類別變數與靜態類別函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student student; cout &lt;&lt; \"student.count = \" &lt;&lt; student.count &lt;&lt; endl; student.getCount(); return 0; } student.count = 100 count = 100 所有物件共享同一個靜態變數 以下的例子即便建了三個物件，但靜態類別變數在記憶體中只有一份，而不是三份，所以三個物件都只在同一個記憶體位址的靜態類別變數進行修改，所以最後一個人修改130，把每個物件的count印出來也全是130。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { Student student1; student1.count = 110; Student student2; student2.count = 120; Student student3; student3.count = 130; cout &lt;&lt; \"student1.count = \" &lt;&lt; student1.count &lt;&lt; endl; cout &lt;&lt; \"student2.count = \" &lt;&lt; student2.count &lt;&lt; endl; cout &lt;&lt; \"student3.count = \" &lt;&lt; student3.count &lt;&lt; endl; return 0; } student1.count = 130 student2.count = 130 student3.count = 130 靜態類別函式只能讀取靜態類別變數 靜態類別函式只能存取靜態類別變數，不能存取物件成員變數。 以下程式碼，試圖在靜態類別函式(getCount)中存取成員變數(name)，編譯出錯。 1 2 3 4 5 6 7 8 9 class Student { public: string name; static int count; static void getCount() { cout &lt;&lt; \"name =\" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; 靜態類別函式無法讀取物件成員函式 以下程式碼，試圖在靜態類別函式(getCount)呼叫成員函式(print)，編譯出錯。 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: string name; static int count; void print() { cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; } static void getCount() { print(); cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; 成員函式可以讀取靜態類別函式與靜態類別變數 以下程式碼，在成員函式(print)呼叫靜態類別函式(getCount)與靜態類別變數(count)，不會有問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Student { public: string name; static int count; void print() { cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; getCount(); cout &lt;&lt; \"2. count = \" &lt;&lt; count &lt;&lt; endl; } static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } }; int Student::count = 100; int main() { Student student1; student1.name = \"Bill\"; student1.count = 110; Student student2; student2.name = \"Mary\"; student2.count = 120; Student student3; student3.name = \"Tom\"; student3.count = 130; student1.print(); cout &lt;&lt; \"-----------------\" &lt;&lt; endl; student2.print(); cout &lt;&lt; \"-----------------\" &lt;&lt; endl; student3.print(); return 0; } name = Bill count = 130 2. count = 130 ----------------- name = Mary count = 130 2. count = 130 ----------------- name = Tom count = 130 2. count = 130 靜態類別函式沒有this 因為不是物件，所有不能用this private靜態類別變數與private靜態類別函式無法在類別之外被訪問 以下程式碼把count與getCount()移到private 可以使用全域的方式初始化靜態類別變數 int Student::count = 100; 但以下程式碼試圖在類別之外讀取私有靜態類別變數與私有類別函式，編譯失敗。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { static int count; static void getCount() { cout &lt;&lt; \"count = \" &lt;&lt; count &lt;&lt; endl; } public: string name; }; int Student::count = 100; int main() { cout &lt;&lt; Student::count &lt;&lt; endl; Student::getCount(); return 0; }"
  },"/pages/c/class/functor/": {
    "title": "operator()物件函式",
    "keywords": "",
    "url": "/pages/c/class/functor/",
    "body": "物件函式Functor 物件名本身就是函式名，但使用方法像呼叫函式一樣。 必須在類別裡面定義 以下傳回值型態與參數可自訂，沒有限制，但函式名必須為operator() 1 2 3 傳回值型態 operator()(參數) { cout &lt;&lt; \"要做的事\" &lt;&lt; endl; } 呼叫物件函式步驟 建立物件 呼叫物件函式 1 2 3 4 //建立物件 Student student; //呼叫物件函式，注意!這裡不是呼叫建構子 student(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; void operator()() { cout &lt;&lt; \"Hello\" &lt;&lt; endl; } }; int main() { //建立物件 Student student; //呼叫物件函式，注意!這裡不是呼叫建構子 student(); return 0; } Hello 全域函式與物件函式同名如何執行？ 有一個全域函式名為student() 有一個物件函式名為student() 如何區別，使用::範圍運算子，來進行區別。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; void operator()() { cout &lt;&lt; \"Hello\" &lt;&lt; endl; } }; void student() { cout &lt;&lt; \"abcdefghijkl......\" &lt;&lt; endl; } int main() { //建立物件 Student student; //呼叫全域student() ::student(); //呼叫物件函式 student(); return 0; } abcdefghijkl...... Hello"
  },"/pages/c/class/operator_add/": {
    "title": "operator+()",
    "keywords": "",
    "url": "/pages/c/class/operator_add/",
    "body": "addScore()函式 以下程式碼，在類別外定義addScore()函式，並在Student類別中把addScore()設為friend(友情/朋友)，代表addScore()類別外的函式可以使用Student的private成員變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void addScore(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void addScore(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 addScore(student, 15); //印出學生姓名與各科分數 student.print(); return 0; } name = Bill math = 65 english = 75 chinese = 85 operator+()函式 把addScore函式名全改成operator+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 operator+(student, 15); //印出學生姓名與各科分數 student.print(); return 0; } student + 15 如果函式名是operator+(student,30)，寫法就可以換成student + 30，student是operator+()第一個參數，30是operator+()第二個參數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend void operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 void operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student + 15; //印出學生姓名與各科分數 student.print(); return 0; } name = Bill math = 65 english = 75 chinese = 85 傳回值型態是物件 student = student + 15; 以上的程式碼，是要把運算的結果傳回給型態是Student的物件，所以必須把傳回值型態改成物件的參考。 1 Student&amp; operator+(Student&amp; s, int score) 運算的過程也可以是很多數字的相加，不變的是，要把運算的結果傳回給型態是Student的物件。 student = student + 15 + 5 + 5; 以上的運算過程，函式的呼叫如下 student = (((student + 15) + 5) + 5); 每一個括號就有一個傳回值，+加號左邊的參數是operator+()第一個參數，+加號右邊是operator+()第二個參數。 再次分解如下 student = operator+(operator+(operator+(student, 15), 5), 5); 程式的傳回值型態改寫如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = student + 15; //印出學生姓名與各科分數 student.print(); return 0; } operator+()成員函式 之前的方式是把類別之外的函式透過friend實現，接下來將operator+()在類別內實作。 把operator+()變為成員函式，成員函式本身就有隱藏的this指標，指向呼叫函式的物件，所以原本的第一個參數可以刪掉。 Student&amp; operator+(int score){} 而原本 1 2 3 s.m_math += score; s.m_chinese += score; s.m_english += score; 可以改為 1 2 3 m_math += score; m_chinese += score; m_english += score; 原本的friend函式也可以刪掉 1 friend Student&amp; operator+(Student&amp; s, int score); 傳回值也改為隱藏的this指標，this指標為物件存放的記憶體位址，使用取值運算子，傳回物件。 return *this; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } Student&amp; operator+(int score) { m_math += score; m_chinese += score; m_english += score; return *this; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = student + 15 + 5; //印出學生姓名與各科分數 student.print(); return 0; } operator+()參數替換 若想使用以下的方式，數值在加號+左邊，物件在加號+右邊。 student = 15 + student; 只能使用類別外的friend函式實現，無法使用成員函式實現。 增加函式如下 1 Student&amp; operator+(int score, Student&amp; s){...} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); friend Student&amp; operator+(int score, Student&amp; s); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(int score, Student&amp; s) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } int main() { //建立物件 Student student(\"Bill\", 50, 60, 70); //為每個分數增加15分 student = 15 + student; //印出學生姓名與各科分數 student.print(); return 0; } operator+()參數都為物件 若想使用以下的方式。 1 2 3 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + s2; 寫一個operator+傳入的參數為2個物件 1 Student&amp; operator+(Student&amp; s1, Student&amp; s2){} 程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include &lt;iostream&gt; using namespace std; class Student { //私有成員變數 int m_math; int m_english; int m_chinese; public: //將類別外的函式設為friend，才能讀取物件私有成員變數 friend Student&amp; operator+(Student&amp; s, int score); friend Student&amp; operator+(int score, Student&amp; s); friend Student&amp; operator+(Student&amp; s1, Student&amp; s2); string m_name; Student(){} //建構子，姓名，數學成績，英文成績，國文成績 Student(string name, int math, int english, int chinese) { m_name = name; m_math = math; m_english = english; m_chinese = chinese; } //印出學生姓名與分數 void print() { cout &lt;&lt; \"name = \" &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; \"math = \" &lt;&lt; m_math &lt;&lt; endl; cout &lt;&lt; \"english = \" &lt;&lt; m_english &lt;&lt; endl; cout &lt;&lt; \"chinese = \" &lt;&lt; m_chinese &lt;&lt; endl; } }; //為每個科目增加分數 Student&amp; operator+(Student&amp; s, int score) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(int score, Student&amp; s) { s.m_math += score; s.m_chinese += score; s.m_english += score; return s; } Student&amp; operator+(Student&amp; s1, Student&amp; s2) { s1.m_math += s2.m_math; s1.m_chinese += s2.m_chinese; s1.m_english += s2.m_english; return s1; } int main() { //建立物件 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + s2; //印出學生姓名與各科分數 s1.print(); return 0; } 混合使用 以上程式碼支援以下寫法 s1 = s1 + 10 + 5 + s2; 1 2 3 4 5 6 7 8 9 int main() { //建立物件 Student s1(\"Bill\", 50, 60, 70); Student s2(\"Tom\", 50, 60, 70); s1 = s1 + 10 + 5 + s2; //印出學生姓名與各科分數 s1.print(); return 0; }"
  },"/pages/c/class/operator_assign/": {
    "title": "operator=()",
    "keywords": "",
    "url": "/pages/c/class/operator_assign/",
    "body": "Prerequisites: RVO 指派運算子使用方式 二個物件都已經存在，其中一個物件指派另一個物件。 編譯器預設會有預設的指派運算子operator=()，使用者可改寫。 改寫operator=函式的語法如下 類別名&amp; operator=(const 類別名&amp; src來源物件); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; Student&amp; operator=(const Student&amp; s) { m_name = s.m_name; return *this; } }; int main() { //建立二個物件 Student s1,s2; s1.m_name = \"Bill\"; //使用operator=函式 s2 = s1; cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.m_name &lt;&lt; endl; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.m_name &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Bill 深拷貝 預設是淺拷貝。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { public: string m_name; int* m_ptr; Student(){m_ptr = nullptr;} ~Student(){if(m_ptr) delete m_ptr;} //參數為來源物件，也就是指要copy的物件 Student&amp; operator=(const Student&amp; src) { m_name = src.m_name; //如果來源物件的m_ptr指標是空 if(src.m_ptr == nullptr) { //要把目的物件清空(如果目的物件不是空的話) if(m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; } } else { //如果目的物件為空 if(m_ptr == nullptr) { //動態分配記憶體 m_ptr = new int; } //記憶體的值拷貝 memcpy(m_ptr, src.m_ptr, sizeof(int)); } return *this; } }; int main() { //建立二個物件 Student s1,s2; s1.m_name = \"Bill\"; s1.m_ptr = new int(15); //使用operator=函式 s2 = s1; cout &lt;&lt; \"s1 name = \" &lt;&lt; s1.m_name &lt;&lt; endl; cout &lt;&lt; \"s2 name = \" &lt;&lt; s2.m_name &lt;&lt; endl; cout &lt;&lt; \"s1 m_ptr = \" &lt;&lt; *s1.m_ptr &lt;&lt; endl; cout &lt;&lt; \"s2 m_ptr = \" &lt;&lt; *s2.m_ptr &lt;&lt; endl; return 0; } s1 name = Bill s2 name = Bill s1 m_ptr = 15 s2 m_ptr = 15"
  },"/pages/c/class/operator_equal/": {
    "title": "operator==()",
    "keywords": "",
    "url": "/pages/c/class/operator_equal/",
    "body": ""
  },"/pages/c/function/auto_func/": {
    "title": "auto與函式",
    "keywords": "",
    "url": "/pages/c/function/auto_func/",
    "body": "Prerequisites: 函式指標 auto的中文意思為自動推導類型，使用時不用特別寫準確的類型，編譯器會自動推導。 自動推導函式傳回值類型 注意！這邊的函式名後面有括號()，auto是函式傳回值類型。 語法 auto 變數 = 函式名(); auto var = func(); 1 2 3 4 5 6 7 8 9 10 //宣告一個函式為func()，傳回值為string類型 string func() { return \"test\"; } int main() { //使用函式的傳回值，由auto自動推導函式的傳回的類型string auto var = func(); cout &lt;&lt; \"var = \" &lt;&lt; var &lt;&lt; endl; return 0; } test 自動推導函式指標類型 函式指標設計複雜，可以使用auto簡化。 注意！這邊的函式名後面沒有括號，auto指的是函式指標類型。 語法 auto 函式指標名 = 函式名; auto f = func; 呼叫函式 f(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 string func() { cout &lt;&lt; \"abcdef\" &lt;&lt; endl; return \"test\"; } int main() { //注意!函式func後面沒有括號 auto f = func; //呼叫函式 cout &lt;&lt; f() &lt;&lt; endl; return 0; } abcdef 簡化函式指標 參數很多的函式，可用auto簡化函式指標。 未簡化前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //定義一個函式名為println，傳回值為int， //參數有二個，分別為char指標型別的參數msg1與msg2 int println(char* msg1, char* msg2) { printf(\"印出msg1:%s\\nmsg2:%s\\n\",msg1,msg2); return 1; } int main() { //(*funcPtr)宣告函式指標的名稱為funcPtr //傳回值為int //(char*,char*)代表參數型別 //實作函式指標的函式是println()的函式 //注意= println後面是沒有括號() int (*funcPtr)(char*,char*)= println; //呼叫函式指標，並把參數代入 funcPtr(\"test\",\"c++\"); return 0; } 印出msg1:test msg2:c++ 使用auto簡化函式指標 1 2 3 4 5 6 7 8 9 int println(char* msg1, char* msg2) { printf(\"印出msg1:%s\\nmsg2:%s\\n\",msg1,msg2); return 1; } int main() { auto func = println; func(\"test\",\"c++\"); return 0; } 以下程式碼未簡化前 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; void say(void (*p)(char*),char *msg) { p(msg); } void println(char* msg) { printf(\"印出結果:%s\\n\",msg); } int main() { void(*p)(char*) = println; say(p, \"hello\"); return 0; } 印出結果:hello 使用auto簡化函式指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //定義一個函式指標的類型為FuncPtr，傳回值為void的類型，參數是char指標 typedef void(*FuncPtr)(char*); //參數為FuncPtr類型(傳回值為void的類型，參數是char指標) void say(FuncPtr func1, char* msg) { //呼叫函式指標 func1(msg); } void printMsg(char* msg) { cout &lt;&lt; \"msg:\" &lt;&lt; msg &lt;&lt; endl; } int main() { auto say_fun = say; auto print_fun = printMsg; //注意print_fun後面沒有括號() say_fun(print_fun,\"test\"); return 0; } msg:test"
  },"/pages/c/function/lambda/": {
    "title": "lambda",
    "keywords": "",
    "url": "/pages/c/function/lambda/",
    "body": "Prerequisites: 函式指標 auto與函式 lambda又稱匿名函式，也就是沒有名字的函式。 語法介紹 []()-&gt;Int{ return 0; } [] 獲取外部的變數值或參考 () 函式參數 -&gt; 函式傳回值型態，若為void可以不寫， {} 函式主體 []傳入外部變數值或參考 auto與函式要先看過才看的懂以下程式碼。 傳變數值 以下程式碼是把外部變數name透過[name]的方式，傳入lambda。 若要傳多個，用逗號。 注意！傳值的方式是不能修改外部變數。 語法 [name, age, ...] 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; int age = 20; auto f1 = [name](){ cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; }; f1(); return 0; } name = Mary 傳變數參考 傳參考是可以修改變數的值 若要傳多個，用逗號。 語法 [&amp;name, &amp;age, ...] 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; auto f1 = [&amp;name](){ name = \"Bill\"; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; }; f1(); return 0; } name = Bill 傳值= 若lambda中有用到外部變數，就會直接以值的方式把有用到的外部變數傳入lambda 語法 [=] 1 2 3 4 5 6 7 8 9 10 int main() { string name = \"Mary\"; int age = 18; auto f1 = [=](){ cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Mary age = 18 傳參考&amp; 若lambda中有用到外部變數，就會直接以參考的方式把有用到的外部變數傳入lambda 傳參考是可以修改變數的值 語法 [&amp;] 1 2 3 4 5 6 7 8 9 10 11 12 int main() { string name = \"Mary\"; int age = 18; auto f1 = [&amp;](){ name = \"Bill\"; age = 30; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Bill age = 30 混合傳 語法 [&amp;, name] 除了name變數是傳值的方式，其它lambda中有用到的變數一律傳參考的方式代入。 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [&amp;, name](){ age = 30; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Mary age = 30 語法 [=, &amp;name] 除了name變數是傳參考的方式，其它lambda中有用到的變數一律傳值的方式代入。 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [=, &amp;name](){ name = \"Tom\"; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } name = Tom age = 18 不傳任何外部變數 語法 [] 外部變數都不能使用 1 2 3 4 5 6 7 8 9 10 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](){ //cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; //cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; }; f1(); return 0; } 傳參數 語法 (參數型態 參數1, 參數型態2 參數2, ...) (string address) 以下程式碼設定lambda的參數，呼叫函式的時候代入參數。 1 2 3 4 5 6 7 8 9 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](string address){ cout &lt;&lt; \"address = \" &lt;&lt; address &lt;&lt; endl; }; f1(\"Taiwan Taipei ....\"); return 0; } 傳回值型態 若傳回型態為void，可以省略以下語法，也可以不寫，lambda會自動推導回值型態 -&gt;型態 1 2 3 4 5 6 7 8 9 10 11 int main() { string name = \"Mary\"; int age = 18; auto f1 = [](string address) -&gt; int{ cout &lt;&lt; \"address = \" &lt;&lt; address &lt;&lt; endl; return 100; }; int val = f1(\"Taiwan Taipei ....\"); cout &lt;&lt; \"val = \" &lt;&lt; val &lt;&lt; endl; return 0; } address = Taiwan Taipei .... val = 100 函式轉成lambda 轉換前 以下程式碼有fun()的函式，參數為int型別的x與y，傳回值型別為int。 1 2 3 4 5 6 7 int fun(int x, int y) { return x + y; } int main() { cout &lt;&lt; \"x + y = \" &lt;&lt; fun(10, 100) &lt;&lt; endl; return 0; } x + y = 110 轉換後 使用auto宣告函式型態，f為函式變數名。 1 2 3 4 5 6 7 int main() { auto f = [](int x, int y) -&gt; int { return x + y; }; cout &lt;&lt; \"x + y = \" &lt;&lt; f(10, 100) &lt;&lt; endl; return 0; } x + y = 110 比對fun函式跟lambda匿名函式 1 2 3 int fun(int x, int y) { return x + y; } 1 2 3 [](int x, int y) -&gt; int { return x + y; };"
  },"/pages/c/function/using_func_pointer/": {
    "title": "using函式指標別名",
    "keywords": "",
    "url": "/pages/c/function/using_func_pointer/",
    "body": "Prerequisites: typedef類型別名 函式宣告與定義 typedef函式指標類型別名 函式參考 以上文章必須看完，才能往下看。 using替函式指標取類型別名 與typedef一樣，都是替函式指標取類型別名 定義函式指標類型別名語法 using 類型別名 = 函式指標 using Func = void(int, const string&amp;); 函式宣告 print函式與void(int, const string&amp;)是相符 注意！以下的print後面是沒有()括號 Func print; 以上程式碼等同普通函式宣告 void print(int, const string&amp;); 函式定義 所謂的函式定義就是有實作程式碼的函式 1 2 3 4 5 6 7 8 9 10 11 //Func類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server error. 函式指標 宣告函式指標，並指向函式 類型別名* 函式指標變數名 = 函式; Func* func_pointer = print; 呼叫函式 函式指標變數名(參數) func_pointer(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //Func函式類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { //宣告函式指標，指向print函式 Func* func_pointer = print; //呼叫函式 func_pointer(500, \"Server error.\"); //宣告函式參考，指向print函式 Func* func_ref = print; func_ref(400, \"Not Found.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 400 , Msg = Not Found. 函式參考 宣告函式參考，並指向函式 類型別名&amp; 函式指標變數名 = 函式; Func&amp; func_ref = print; 呼叫函式 函式參考變數名(參數) func_ref(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Func函式類型別名 using Func = void(int, const string&amp;); //函式宣告 Func print; int main() { //宣告函式參考，指向print函式 Func* func_ref = print; //呼叫函式 func_ref(400, \"Not Found.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 400 , Msg = Not Found. 類別靜態函式指標 靜態類別函式 函式指標語法 加上類別名字以及範圍運算子:: void (*func_pointer)(int, const string&amp;) = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //宣告函式指標 void (*func_pointer)(int, const string&amp;) = Student::print; func_pointer(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 使用using函式指標別名 加上類別名字以及範圍運算子:: Func *func_p = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; //Func函式類型別名 using Func = void(int, const string&amp;); int main() { //函式類型別名宣告函式指標 Func *func_p = Student::print; func_p(404, \"Page not Found.\"); return 0; } Error code = 404 , Msg = Page not Found. 物件成員函式指標 物件成員函式指標語法 必須把記憶體位址傳進去，所以有使用&amp;取位址運算子 呼叫函式時，使用物件加點(.)運算子與指標運算子(*) void(Student::* func_pointer)(int, const string&amp;) = &amp;Student::print; (student.*func_pointer)(500, \"Server error.\"); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //物件宣告 Student student; //成員函式轉成函式指標 void(Student::* func_pointer)(int, const string&amp;) = &amp;Student::print; //函式指標呼叫函式 (student.*func_pointer)(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 使用using函式指標別名 函式指標類型別名 using Func = void(Student::*)(int, const string&amp;); 建立函式指標 Func func_pointer = &amp;Student::print; 呼叫函式指標 (student.*func_pointer)(400,\"Page not found.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; //Func函式類型別名 using Func = void(Student::*)(int, const string&amp;); int main() { //建立物件 Student student; //建立函式指標 Func func_pointer = &amp;Student::print; //呼叫函式指標 (student.*func_pointer)(400,\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found."
  },"/pages/c/c11/functional/": {
    "title": "functional",
    "keywords": "",
    "url": "/pages/c/c11/functional/",
    "body": "Prerequisites: typedef類型別名 函式宣告與定義 typedef函式指標類型別名 函式參考 using函式指標別名 以上文章必須看完，才能往下看。 大陸稱包裝器，台灣目前不知稱為什麼。 功能類似函式指標 include #include &lt;functional&gt; 語法1 宣告function function&lt;函式傳回值類型(函式參數1類型 參數名1,函式參數2類型 參數名2, ...)&gt; 變數名 = 函式名; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 語法2 可以把函式類型取別名 using FuncType = void(int, const string&amp;); 宣告function時，在模板類型設成FuncType函式類型別名 function&lt;FuncType&gt; func = print; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { using FuncType = void(int, const string&amp;); //宣告function function&lt;FuncType&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } Error code = 500 , Msg = Server error. 類別靜態函式指標 語法 function&lt;void(int, const string&amp;)&gt; func = Student::print; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = Student::print; //呼叫函式 func(500, \"Server error.\"); return 0; } 物件函式 物件函式 語法 function&lt;函式傳回值類型(函式參數1類型,函式參數2類型, ...)&gt; func = 物件名; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void operator()(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //宣告function function&lt;void(int, const string&amp;)&gt; func = student; //呼叫函式 func(500, \"Server error.\"); return 0; } lambda lambda 程式碼1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; int main() { //lambda auto print = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //宣告function function&lt;void(int, const string&amp;)&gt; func = print; //呼叫函式 func(500, \"Server error.\"); return 0; } 程式碼2 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; int main() { //宣告function function&lt;void(int, const string&amp;)&gt; func = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //呼叫函式 func(500, \"Server error.\"); return 0; } 物件成員函式 宣告function function&lt;參數類型1, …&gt; 第1個參數要填入類別參考&amp; 等於號(=)指派對映的函式，必須把記憶體位址傳進去，所以使用&amp;取位址運算子+類別名+::範圍運算子+函式名 function&lt;void(Student&amp;,int, const string&amp;)&gt; func = &amp;Student::print; 呼叫function 必須把物件代入第1個參數 func(student, 500, \"Server error.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //宣告function function&lt;void(Student&amp;,int, const string&amp;)&gt; func = &amp;Student::print; //呼叫函式 func(student, 500, \"Server error.\"); return 0; }"
  },"/pages/c/function/func_def/": {
    "title": "函式宣告與定義",
    "keywords": "",
    "url": "/pages/c/function/func_def/",
    "body": "函式宣告(declaration) 沒有程式碼，最後面有冒號; 告知編譯器有一個函式名字為print，傳回值型態為void，參數類型有int與const string&amp;，之後會有程式碼實作。 void print(int code,const string&amp; msg); 函式定義(definition) 有程式碼。 1 2 3 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } 呼叫函式 print(500, \"Server Error.\"); 函式宣告與函式定義 1 2 3 4 5 6 7 8 9 10 11 //函式宣告 void print(int code,const string&amp; msg); int main() { //呼叫函式 print(500, \"Server Error.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server Error. 函式宣告與定義合在一起 在main()主程式前宣告函式，並且實作程式碼，就是函式宣告與定義結合一起，有實作程式碼一律稱之函式定義。 1 2 3 4 5 6 7 8 //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { print(500, \"Server Error.\"); return 0; } Error code = 500 , Msg = Server Error."
  },"/pages/c/function/func_ref/": {
    "title": "函式參考",
    "keywords": "",
    "url": "/pages/c/function/func_ref/",
    "body": "Prerequisites: 函式指標 函式參考與函式指標相同，不同的只是符號不同，一個用星號*，一個用&amp; 函式指標宣告 void (*func_pointer)(int, const string&amp;); 函式參考宣告 void (&amp;func_ref)(int, const string&amp;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //函式宣告 void print(int code, const string&amp; msg); int main() { //宣告函式指標，指到print函式 void (*func_pointer)(int, const string&amp;) = print; //呼叫函式 func_pointer(500, \"Server Error.\"); //宣告函式參考，指到print函式 void (&amp;func_ref)(int, const string&amp;) = print; //呼叫函式 func_ref(500, \"Server Error.\"); return 0; } //函式定義 void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } Error code = 500 , Msg = Server Error. Error code = 500 , Msg = Server Error."
  },"/pages/c/c11/bind/": {
    "title": "bind綁定",
    "keywords": "",
    "url": "/pages/c/c11/bind/",
    "body": "Prerequisites: function 語法 function&lt;函式傳回值類型(函式參數1類型 參數名1,函式參數2類型 參數名2)&gt; func2 = bind(函式名, placeholders::_1, placeholders::_2); function&lt;void(int, const string&amp;)&gt; func2 = bind(print, placeholders::_1, placeholders::_2); placeholders::_1 對映函式參數名1 placeholders::_2 對映函式參數名2 函式bind 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. 參數對調 以下語法把函式參數對調 function&lt;void(const string&amp;,int)&gt; func = bind(print, placeholders::_2,placeholders::_1); 呼叫函式時也要對調 func(\"Page not found.\", 400); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(const string&amp;,int)&gt; func = bind(print, placeholders::_2,placeholders::_1); //呼叫函式 func(\"Page not found.\", 400); return 0; } Error code = 400 , Msg = Page not found. 參數數量可自訂 使用bind，可以預設參數值，限制傳進參數的個數。 function&lt;void(const string&amp;)&gt; func = bind(print, 400, placeholders::_1); 呼叫函式只傳一個參數 func(\"Page not found.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, 400, placeholders::_1); //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. bind預設傳值 以下的程式碼，即便之後把error_code改成500，顯示仍為400 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { int error_code = 400; //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, error_code, placeholders::_1); //修改成500 error_code = 500; //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. bind傳參考 語法 function&lt;void(const string&amp;)&gt; func = bind(print, ref(error_code), placeholders::_1); 使用ref(), 可以傳參考，也就可以修改變數中的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { int error_code = 400; //設定bind與綁定的參數個數 function&lt;void(const string&amp;)&gt; func = bind(print, ref(error_code), placeholders::_1); error_code = 500; //呼叫函式 func(\"Page not found.\"); return 0; } Error code = 500 , Msg = Page not found. 參數傳的比函式參數還多 print函式只有2個參數，但有一個需求需要傳3個參數，怎麼修改？ 在function的函式參數多增加一個，呼叫函式的參數也多增加一個 function&lt;void(int, const string&amp;, int)&gt; func = bind(print, placeholders::_1, placeholders::_2); func(400, \"Page not found.\", 1000); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;, int)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\", 1000); return 0; } Error code = 400 , Msg = Page not found. 物件成員函式與bind function&lt;參數類型1, …&gt; 第1個參數要填入類別參考&amp; 等於號(=)指派對映的函式，必須把記憶體位址傳進去，所以使用&amp;取位址運算子+類別名+::範圍運算子+函式名 注意！bind的參數有三個，分別是物件參考student&amp;，整數int，字串參考string&amp; function&lt;void(Student&amp;,int, const string&amp;)&gt; func = bind(&amp;Student::print, placeholders::_1, placeholders::_2, placeholders::_3); 呼叫function 必須把物件代入第1個參數 func(student, 500, \"Server error.\"); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //設定bind與綁定的參數個數 function&lt;void(Student&amp;,int, const string&amp;)&gt; func = bind(&amp;Student::print, placeholders::_1, placeholders::_2,placeholders::_3); //呼叫函式 func(student, 400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found. 類別靜態函式 語法 只需要函式前面加上類別名:: function&lt;void(int, const string&amp;)&gt; func = bind(Student::print, placeholders::_1, placeholders::_2); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 class Student { public: static void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(Student::print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } lambda bind的第1個參數代入lambda的變數名，也可以直接把lambda函式放進bind的第一個參數。 1 2 3 4 5 6 7 8 9 10 11 int main() { //lambda auto print = [](int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }; //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(print, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } 物件函式 bind的第1個參數代入student物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student { public: void operator()(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { //建立物件 Student student; //設定bind與綁定的參數個數 function&lt;void(int, const string&amp;)&gt; func = bind(student, placeholders::_1, placeholders::_2); //呼叫函式 func(400, \"Page not found.\"); return 0; } Error code = 400 , Msg = Page not found."
  },"/pages/c/c11/move_operator/": {
    "title": "移動建構子與移動指派運算子",
    "keywords": "",
    "url": "/pages/c/c11/move_operator/",
    "body": "Prerequisites: 拷貝函式 operator=() 深淺拷貝 l-value與r-value l-value參考與r-value參考 臨時物件 關閉RVO 把RVO關閉後，才能進行以下的範例。 目的 以下的拷貝函式，針對指標(m_ptr)動態分配記憶體位址，將來源(source)物件指標內容拷貝到新分配的記憶體位址。 1 2 3 4 5 6 7 8 9 10 11 Student(const Student &amp;s) { //判斷來源(source)m_ptr是否null if(s.m_ptr) { //動態分配記憶體位址 m_ptr = new int; //拷貝來源物件m_ptr指標到新的記憶體位址 memcpy(m_ptr, src.m_ptr, sizeof(int)); } else { m_ptr = nullptr; } } 以上程式碼若拷貝的容量很大，將會花費許多時間在拷貝資料。 移動建構子(Move constructor)與移動指派運算子(Move assignment operator)主要針對右值進行指標移動，因為右值是一個臨時物件，通常使用完畢立即記憶體釋放，移動建構子與移動指派運算子是不釋放臨時物件記憶體，把指標指向臨時物件(來源物件)的記憶體位址，省略以上程式碼拷貝動作。 語法 移動建構子(Move constructor)與移動指派運算子(Move assignment operator)的參數都是右值(r-value)，因為要刪除來源物件指標(有修改的動作)，所以參數不用const，拷貝與指派運算子則是不會修改來源物件。 移動建構子(Move constructor) 類別名(類別名&amp;&amp; 來源物件) { .... } 移動指派運算子(Move assignment operator) 類別名&amp; operator=(類別名&amp;&amp; 來源物件) { ...... return *this; } 指標轉移語法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Student(Student&amp;&amp; src) { cout &lt;&lt; \"移動建構子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; } Student&amp; operator=(Student&amp;&amp; src) { cout &lt;&lt; \"移動指派運算子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; return *this; } 使用右值移動建構子 第一次右值移動建構子：return s;這個臨時對象被移動到一個中間的無名臨時對象中，觸發了第一次的右值移動建構子。 第二次右值移動建構子：接著，這個中間的無名臨時對象被移動到 s4 中，觸發了第二次的右值移動建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: int* m_ptr; public: Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; //初始化成員變數 m_ptr = nullptr; } Student(const Student &amp;src) { cout &lt;&lt; \"左值拷貝函式\" &lt;&lt; endl; //判斷來源(source)m_ptr不是null if(src.m_ptr) { //動態分配記憶體位址 m_ptr = new int; //拷貝來源物件m_ptr指標到新的記憶體位址 memcpy(m_ptr, src.m_ptr, sizeof(int)); } else { m_ptr = nullptr; } } Student&amp; operator=(const Student&amp; src) { cout &lt;&lt; \"左值指派運算子\" &lt;&lt; endl; //如果來源物件的m_ptr指標是空 if(src.m_ptr == nullptr) { //要把目的物件清空(如果目的物件不是空的話) if(m_ptr != nullptr) { delete m_ptr; m_ptr = nullptr; } } else { //如果目的物件為空 if(m_ptr == nullptr) { //動態分配記憶體 m_ptr = new int; memset(m_ptr, 0, sizeof(int)); } //記憶體的值拷貝 memcpy(m_ptr, src.m_ptr, sizeof(int)); } return *this; } Student(Student&amp;&amp; src) { cout &lt;&lt; \"右值移動建構子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; } Student&amp; operator=(Student&amp;&amp; src) { cout &lt;&lt; \"右值移動指派運算子\" &lt;&lt; endl; //把來源的指標移到m_ptr m_ptr = src.m_ptr; //把來源的指標設nullptr src.m_ptr = nullptr; return *this; } ~Student() { delete m_ptr; m_ptr = nullptr; cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { //印出記憶體位址 cout &lt;&lt; \"m_ptr address:\" &lt;&lt; &amp;m_ptr &lt;&lt; endl; cout &lt;&lt; \"m_ptr value = \" &lt;&lt; *m_ptr &lt;&lt; endl; } }; int main() { //右值指派運算子 Student s4 = [] { Student s; s.m_ptr = new int; *s.m_ptr = 200; return s; }(); cout &lt;&lt; \"s4 mptr = \" &lt;&lt; *s4.m_ptr &lt;&lt; endl; return 0; } 建構子 右值移動建構子 解構子 右值移動建構子 解構子 s4 mptr = 200 解構子"
  },"/pages/note/ip_setting/": {
    "title": "固定ip設定",
    "keywords": "",
    "url": "/pages/note/ip_setting/",
    "body": "查看dns ipconfig /all 在「其他 DNS 伺服器」欄位中輸入一個不同的備用 DNS 伺服器地址，或保留為空。例如： 如果只想使用一個 DNS 伺服器，則可以將「其他 DNS 伺服器」欄位留空。"
  },"/pages/c/c11/forward/": {
    "title": "forward",
    "keywords": "",
    "url": "/pages/c/c11/forward/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 參數為左值與右值 呼叫的函式的參數為左值與右值，相同的函式名，但參數多載(overload)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } int main() { int i = 10; //呼叫函式，參數為左值 func(i); //呼叫函式，參數為右值 func(100); return 0; } l-value r-value 保留右值參考的屬性 以下的函式，多出了middle()的函式，目的是再一次傳送參數，執行的結果會導致全被視作左值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } void middle(int x) { func(x); } int main() { int i = 10; //呼叫函式，參數為左值 middle(i); //呼叫函式，參數為右值 middle(100); return 0; } l-value l-value 為了解決以上的問題，需寫一個template，可以接收右值與左值，並把左右值屬性保留住，傳到func()的函式 T&amp;&amp; 若模板的類型為T&amp;&amp;，代表可以接收左值與右值，注意！這邊的T&amp;&amp;不是只能接收右值，也可以不接收左值，跟一般函式參數int&amp;&amp;是不一樣，函式參數類型為int&amp;&amp;就能接收右值。 forward 左右值屬性保留住，傳到其它函式。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //參數左值 void func(int&amp; x) { cout &lt;&lt; \"l-value\" &lt;&lt; endl; } //參數右值 void func(int&amp;&amp; x) { cout &lt;&lt; \"r-value\" &lt;&lt; endl; } template&lt;typename T&gt; void middle(T&amp;&amp; x) { func(forward&lt;T&gt;(x)); } int main() { int i = 10; //呼叫函式，參數為左值 middle(i); //呼叫函式，參數為右值 middle(100); return 0; } l-value r-value"
  },"/pages/c/c11/variadic/": {
    "title": "可變參數模板",
    "keywords": "",
    "url": "/pages/c/c11/variadic/",
    "body": "語法 Args代表多個不同類型與數量的參數。 以下三種…位置不同，都可以。 template&lt;typename... Args&gt; template&lt;typename ...Args&gt; template&lt;typename ... Args&gt; 參數清單 以下程式碼”Bill”,”Mary”,”Tom”,”Allen”就是參數清單。 1 2 3 4 int main() { print(\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 遞迴呼叫 以下的模板是遞迴的方式在運作 T為類型 …Args為參數清單類型 arg為每一次遞迴，就會從參數清單取出一個 args為每一次遞迴，未被取出的剩下參數清單 1 2 3 4 5 6 7 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { //每呼叫一次就從args中拿出一個參數arg cout &lt;&lt; \"參數\" &lt;&lt; arg &lt;&lt; endl; //剩下未取出的參數繼續遞迴呼叫自已 print(args...); } 遞迴結束呼叫的函式 參數為空(因為可變參數清單已經全取出來，也沒參數可傳遞) 傳回值型態void 1 2 3 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //print()傳回值void，參數為空()，待遞迴結束時會呼叫此函式 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } //print是遞回函式template //每呼叫一次就從args中拿出一個參數arg，其它的args又傳入print中遞迴呼叫 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { cout &lt;&lt; \"參數\" &lt;&lt; arg &lt;&lt; endl; print(args...); } int main() { print(\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 參數Bill 參數Mary 參數Tom 參數Allen end 其它函式呼叫遞迴模板，呼叫的函式也要變成模板 以下程式碼為了呼叫遞迴模板，所以本身函式也要變成模板，再把參數傳入遞迴模板 1 2 3 4 5 6 //定義參數的類型名稱Args template&lt;typename... Args&gt; void func(const string&amp; school, Args... args) { cout &lt;&lt; school &lt;&lt; \"的學生有:\" &lt;&lt; endl; print(args...); } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; //print()傳回值void，參數為空()，待遞迴結束時會呼叫此函式 void print() { cout &lt;&lt; \"end\" &lt;&lt; endl; } //print是遞迴函式template //每呼叫一次就從args中拿出一個參數arg，其它的args又傳入print中遞迴呼叫 template&lt;typename T, typename... Args&gt; void print(T arg, Args... args) { cout &lt;&lt; arg &lt;&lt; endl; print(args...); } template&lt;typename... Args&gt; void func(const string&amp; school, Args... args) { cout &lt;&lt; school &lt;&lt; \"的學生有:\" &lt;&lt; endl; print(args...); } int main() { //只有第1個參數傳進func印出來 //第1個參數之後都參數都是args，代入遞迴函式 func(\"青草湖國小\",\"Bill\",\"Mary\",\"Tom\",\"Allen\"); return 0; } 青草湖國小的學生有: Bill Mary Tom Allen end 可變參數模板與bind與functional functional bind l-value與r-value l-value參考與r-value參考 寫一個函式可以接收任何種類的函式與不同數量的參數，函式與參數可為左值右值。 以下程式碼不支援函式多載(overload) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; class Student { public: void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } }; void print(int code, const string&amp; msg) { cout &lt;&lt; \"Error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; } template&lt;typename Func, typename... Args&gt; auto callFunc(Func&amp;&amp; func, Args&amp;&amp;...args) { auto f = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)...); f(); return f; } int main() { callFunc(print, 400, \"Page not found.\"); //物件成員函式 Student student; callFunc(&amp;Student::print, student, 500, \"Server error.\"); //函式為右值 callFunc([](int code, const string&amp; msg) { cout &lt;&lt; \"Lambda error code = \" &lt;&lt; code &lt;&lt; \" , Msg = \" &lt;&lt; msg &lt;&lt; endl; }, 500, \"Server error.\"); return 0; } Error code = 400 , Msg = Page not found. Error code = 500 , Msg = Server error. Lambda error code = 500 , Msg = Server error."
  },"/pages/c/c11/callback/": {
    "title": "callback",
    "keywords": "",
    "url": "/pages/c/c11/callback/",
    "body": "Prerequisites: condition_variable 可變參數模板與bind與functional 增加callback 在condition_variable的程式碼中加上callback的程式碼 主要程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class SafeQueue { //成員變數為函式，函式類型為void(const string&amp; msg) function&lt;void(const string&amp; msg)&gt; m_callback; public: //成員函式模板 //參數1函式，參數2物件(可能沒有物件所以用可變參數Args...) template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { //args是物件，若呼叫的函式是物件成員函式，第二個參數就是物件 //若是函式，就不需要傳入第2個參數(因為可能沒有第2個參數，所以用可變參數Args...) m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } .... 以下程式碼略過 //若有設定回呼函式 if(m_callback) //執行回呼函式，並把回呼函式的參數傳入 m_callback(msg); .... 以下程式碼略過 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; //成員變數為函式，函式類型為void(const string&amp; msg) function&lt;void(const string&amp; msg)&gt; m_callback; public: //成員函式模板 //參數1函式，參數2物件(可能沒有物件所以用可變參數Args...) template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { //args是物件，若呼叫的函式是物件成員函式，第二個參數就是物件 //若是函式，就不需要傳入第2個參數(因為可能沒有第2個參數，所以用可變參數Args...) m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //解鎖 lock.unlock(); //若有設定回呼函式 if(m_callback) //執行回呼函式，並把回呼函式的參數傳入 m_callback(msg); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; callback是成員函式 1 2 3 Student student; //參數為物件成員函式，第二個參數是物件 safeQue.callback(&amp;Student::print, student); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void print(const string&amp; msg) { cout &lt;&lt; \" Msg = \" &lt;&lt; msg &lt;&lt; endl; } class SafeQueue { mutex m_mtx;//執行緒 condition_variable m_cond;//條件 queue&lt;string&gt; m_que; function&lt;void(const string&amp; msg)&gt; m_callback; public: template&lt;typename Func, typename... Args&gt; void callback(Func&amp;&amp; func, Args&amp;&amp;... args) { m_callback = bind(forward&lt;Func&gt;(func), forward&lt;Args&gt;(args)..., std::placeholders::_1); } void push(string&amp; msg) { //加鎖，scope的範圍為函式內 lock_guard&lt;mutex&gt; lock(m_mtx); m_que.push(msg);//放入訊息 m_cond.notify_one();//通知執行緒來接收訊息 } void pop(){ //無限迴圈等待有訊息通知 while(true) { //每個執行緒有獨立的msg變數 string msg; //加鎖 //因為m_cond.wait()參數只支援unique_lock unique_lock&lt;mutex&gt; lock(m_mtx); // queue是空的才等待 while(m_que.empty()) { //queue沒資料就等待 m_cond.wait(lock); } //被通知接收資料 //若queue有資料了，才做下面的事情 msg = m_que.front();//拿出第一個元素 m_que.pop();//移除元素 //解鎖 lock.unlock(); if(m_callback) m_callback(msg); //如果msg是end就不要再等待接收訊息 if(msg == \"END\") break; } } }; int main() { //建立物件 SafeQueue safeQue; //建立物件 Student student; //參數為物件成員函式，第二個參數是物件 safeQue.callback(&amp;Student::print, student); //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for(int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for(int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; } Msg = msg0 Msg = Msg = msg2 Msg = Msg = msg4 msg1 Msg = Msg = msg3msg6msg5 Msg = msg7 Msg = msg9 Msg = . . . 以下截掉 callback參數為函式 以下新增print()函式 callback函式設為print safeQue.callback(print); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void print(const string&amp; msg) { cout &lt;&lt; \" Msg = \" &lt;&lt; msg &lt;&lt; endl; } class SafeQueue { . . . 以下截掉(跟前一個程式碼一模一樣) } int main() { //建立物件 SafeQueue safeQue; //設定回呼函式 safeQue.callback(print); //建立3個執行緒 thread t1(&amp;SafeQueue::pop, &amp;safeQue); thread t2(&amp;SafeQueue::pop, &amp;safeQue); thread t3(&amp;SafeQueue::pop, &amp;safeQue); //產生100個訊息 for(int i = 0; i &lt; 100; i++) { string temp_msg = \"msg\" + to_string(i); safeQue.push(temp_msg); } //產生結束訊息，跳離無限迴圈，不要再等待接收訊息 for(int i = 0; i &lt; 3; i++) { string end_msg = \"END\"; safeQue.push(end_msg); } //執行緒記憶體釋放 t1.join(); t2.join(); t3.join(); return 0; }"
  },"/pages/c/stl/string/": {
    "title": "string",
    "keywords": "",
    "url": "/pages/c/stl/string/",
    "body": "Prerequisites: ArrayList實作 ArrayList記憶體擴充 string物件 動態分配記憶體位址存放一組字元 自動建立記憶體位址與釋放記憶體位址，使用時程式設計師不用做釋放記憶體的動作 自動擴展容量 底層以ArrayList實作 string記憶體擴充 string底層是ArrayList實作。 以下程式碼證明string記憶體擴充後，capacity(最大容量)會呈倍數成長。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; int main() { //建立空的字串，呼叫string()空的建構子 string s1; //印出string cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; //容量 cout &lt;&lt; \"s1.capacity() = \" &lt;&lt; s1.capacity() &lt;&lt; endl; //實際用了多少 cout &lt;&lt; \"s1.size()\" &lt;&lt; s1.size() &lt;&lt; endl; //s1的記憶體位址 cout &lt;&lt; \"s1記憶體位址 = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; cout &lt;&lt; \"----------------------------\" &lt;&lt; endl; //記憶體擴展 //25個字元(Hello 5字元*5遍) s1 = \"HelloHelloHelloHelloHello\"; //印出string cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; //容量 cout &lt;&lt; \"s1.capacity() = \" &lt;&lt; s1.capacity() &lt;&lt; endl; //實際用了多少 cout &lt;&lt; \"s1.size()\" &lt;&lt; s1.size() &lt;&lt; endl; //s1的記憶體位址 cout &lt;&lt; \"s1記憶體位址 = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; return 0; } s1 = s1.capacity() = 22 s1.size()0 s1記憶體位址 = 0x7ff7bfeff451 ---------------------------- s1 = HelloHelloHelloHelloHello s1.capacity() = 47 s1.size()25 s1記憶體位址 = 0x600000c00120 從執行結果可以看出 capacity(最大容量)呈倍數成長，從22變成47。 記憶位址不同，從0x7ff7bfeff451變成0x600000c00120 建立一個容量是47的記憶體空間，把s1的值從容量22的記憶體空間搬到容量47的記憶體空間，搬完後把容量22的記憶體空間進行記憶體釋放，所以記憶體位址才會不同。 string建構子為c字串 語法 建構子參數為c字串 string(const char *s) 呼叫建構子 方式1 string s2(\"Hello world!\"); 方式2 建構子參數只有一個，可使用指派運算子 string s3 = \"Hello World!\"; 完整程式碼 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; int main() { // 方式1 string s2(\"Hello world!\"); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; // 方式2 string s3 = \"Hello World!\"; cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl; } s2 = Hello world! s3 = Hello World! string拷貝函式 拷貝函式用於從另一個已經存在的string物件來初始化新物件。 語法 string(const string &amp;str) 方式1 1 2 3 4 5 6 7 8 #include &lt;iostream&gt; using namespace std; int main() { string s2(\"Hello world!\"); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; string s3 = s2; cout &lt;&lt; \"s3 = \" &lt;&lt; s3 &lt;&lt; endl; } s2 = Hello world! s3 = Hello world! 方式2 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hello world s2 size = 11 string assign operator=() 物件已經存在的情況下，將一個新值賦給該物件，會啟動assign operator=() 1 2 string s3; s3 = \"Hello World!\"; 字串連接 operator+= // string string&amp; operator+= (const string&amp; str); // char* string&amp; operator+= (const char* s); // character string&amp; operator+= (char c); // initializer list string&amp; operator+= (initializer_list&lt;charT&gt; il); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { string s1 = \"Hello\"; string s2 = \"hi\"; // const char* s1 += \" Mary!\"; // string s1 += s2; // character s1 += 'A'; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello Mary!hiA append // char* string &amp;append(const char *s); // string string &amp;append(const string &amp;str); 1 2 3 4 5 6 7 8 9 10 int main() { string s1 = \"Hello\"; // char* s1.append(\" world!\"); string s2 = \" Hi, Mary!\"; // string s1.append(s2); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello world! Hi, Mary! 建構子參數為c字串與n個字元 n小於c字串的長度 目的 從c字串的位址開始複製n個字元，建立字串。 語法 參數1為c字串 數數2為複製n個字元 string(const char *s,size_t n); 完整程式碼 1 2 3 4 5 6 7 int main() { //從c字串的位址開始複製5個字元，建立字串 string s(\"hello world\", 5); cout &lt;&lt; \"s = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"size = \" &lt;&lt; s.size() &lt;&lt; endl; return 0; } s = hello size = 5 n大於c字串的長度 從c字串的位址開始複製100個字元，建立字串。 從執行結果可以發現，並不會遇到\\0結尾字元而停止複製，s物件的實際大小也是20字元。 1 2 3 4 5 6 7 int main() { //從c字串的位址開始複製20個字元，建立字串 string s(\"hello world\", 20); cout &lt;&lt; \"s = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"size = \" &lt;&lt; s.size() &lt;&lt; endl; return 0; } s = hello world = siz size = 20 參數為string物件與拷貝開始與結束位置 以下是string的拷貝函式，拷貝開始位置(預設從0開始)與結束位置(預設unsigned int最大值) string(const string &amp; str, size_t pos = 0, size_t n = npos) 參數1 string物件。 參數2 拷貝開始位置(預設從0開始)，可不寫。 參數3 拷貝結束位置(預設unsigned int最大值)，可不寫。 拷貝結束位置介於字元大小間 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1,0,3); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hel s2 size = 3 拷貝結束位置超出字元大小 從執行結果可以發現遇到\\0結尾字元而停止複製，size仍是11，而不是100。 1 2 3 4 5 6 7 int main() { string s1 = \"Hello world\"; string s2(s1,0,100); cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"s2 size = \" &lt;&lt; s2.size() &lt;&lt; endl; return 0; } s2 = Hello world s2 size = 11 建立多個相同字元的string string(size_t n, char c) 參數1個數 參數2字元 1 2 3 4 5 6 int main() { string s1(100,'C'); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; \"s1 size = \" &lt;&lt; s1.size() &lt;&lt; endl; return 0; } s1 = CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC s1 size = 100 string成員函式 取得string物件記憶體大小 size_t capacity() const; 取得string物件實際使用大小 以下二者相同 size_t length() const; size_t size() const; 1 2 3 4 5 6 7 8 #include &lt;iostream&gt; using namespace std; int main() { string s1 = \"123566\"; cout &lt;&lt; \"s1 length = \" &lt;&lt; s1.length() &lt;&lt; endl; cout &lt;&lt; \"s1 size = \" &lt;&lt; s1.size() &lt;&lt; endl; return 0; } s1 length = 6 s1 size = 6 strlen() c_str() strlen()是用於c字元陣列，並非string，使用strlen，需要把string轉成字元陣列指標 size_t strlen ( const char * str ); 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { string s1 = \"123566\"; cout &lt;&lt; \"s1 length = \" &lt;&lt; s1.length() &lt;&lt; endl; cout &lt;&lt; \"s1 size = \" &lt;&lt; s1.size() &lt;&lt; endl; cout &lt;&lt; \"s1 strlen = \" &lt;&lt; strlen(s1.c_str()) &lt;&lt; endl; return 0; } s1 length = 6 s1 size = 6 s1 strlen = 6 判斷實際使用的大小為0 若為0返回true bool empty() const; 清空字串 void clear(); 讀取string位置 使用[位置]，可以取得某個位置字元 在 C++ 中，std::string 本質上是一個用於操作字元的容器，內部存儲的字元是一個連續的 char 陣列。 通過 s1[0]，你可以訪問 std::string 中存儲的第一個字元。 &amp;s1[0] 的含義: s1[0] 返回的是第一個字元，型別是 char。 &amp;s1[0] 取得的是該字元在內存中的地址，因此它的型別是 char*。 char &amp;operator[](size_t n); 取值 1 2 string s1 = \"Hello\"; cout &lt;&lt; \"s1[1] = \" &lt;&lt; s1[1] &lt;&lt; endl; s1[1] = e 取出位址 (void*)印出16進制的位址 使用以下此法，傳回的是char*，是沒有const 1 2 string s1 = \"Hello\"; cout &lt;&lt; \"s1 address = \" &lt;&lt; (void*)&amp;s1[0] &lt;&lt; endl; s1 address = 0x7ff7bfeff2d1 取得string物件存放字串的記憶體位址 (void*)印出16進制的位址 &amp;是取得物件的位址 以下是取得string物件中動態分配記憶體空間存放字串的位址，注意！傳回的是const char*，是有const const char *c_str() const; const char *data() const; 1 2 3 4 5 6 7 8 9 int main() { string s1 = \"Hello\"; //取得string物件的記憶體位址 cout &lt;&lt; \"s1 &amp; address = \" &lt;&lt; &amp;s1 &lt;&lt; endl; //取得string物件中動態分配記憶體空間存放字串的位址 cout &lt;&lt; \"s1 c_str address = \" &lt;&lt; (void*)s1.c_str() &lt;&lt; endl; cout &lt;&lt; \"s1 data address = \" &lt;&lt; (void*)s1.data() &lt;&lt; endl; return 0; } s1 &amp; address = 0x7ff7bfeff450 s1 c_str address = 0x7ff7bfeff451 s1 data address = 0x7ff7bfeff451 字串作為函式參數 參數語法 const string&amp; str 以下函式參數的寫法，不僅可以接收c字串指標，也可以接收string類別 若函式參數為const char *，參數就只能接收c字串指標，string類別要再透過c_str()函式轉成c字串指標。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; void func1(const string&amp; str) { cout &lt;&lt; str &lt;&lt; endl; } int main() { char * s1 = \"http://www.google.com\"; //可以接受c字串指標 func1(s1); string s2 = \"被討厭的勇氣\"; //可以接受字串 func1(s2); return 0; } http://www.google.com 被討厭的勇氣 字串截取 string substr(size_t pos = 0,size_t n = npos) const; 1 2 3 4 5 int main() { string s1 = \"Hello\"; cout &lt;&lt; \"s1 = \" &lt;&lt; s1.substr(1,3) &lt;&lt; endl; return 0; } s1 = ell 字串比較 bool operator==(const string &amp;str1,const string &amp;str2) const; 1 2 3 4 5 6 int main() { string s1 = \"Hello\"; string s2 = \"world\"; cout &lt;&lt; \"compare result = \" &lt;&lt; (s1 == s2) &lt;&lt; endl; return 0; } 清空 1 2 3 4 string name = \"Bill\"; cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; name.clear(); cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; endl; name: Bill name: resize() 若要對string記憶體位址操作，手動操作會使string本身的動態記憶體分配失效，要手動重新分配它的大小。 1 2 3 4 5 6 7 8 9 10 bool recv(string &amp;buffer, const size_t maxlen) { buffer.clear(); buffer.resize(maxlen); // 如果接收成功，recv()會傳回收到資料的大小，-1代表接收失敗，0代表socket斷線，大於0代表成功 int readn = ::recv(client_fd, &amp;buffer[0], buffer.size(), 0); if (readn &lt;= 0) return false; // recv()會傳回收到資料的大小，重置大小 buffer.resize(readn); return true; } string陣列 判斷數字，印出月份英文 1 2 3 4 5 6 7 8 9 10 11 12 13 //12個月 const int MAX_MONTH = 12; int main() { string mon_arr[MAX_MONTH] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"}; int month; cout &lt;&lt; \"請輸入數字月份(1~12):\"; cin &gt;&gt; month; //陣列索引介於0..11，所以要把month-1 cout &lt;&lt; mon_arr[month-1] &lt;&lt; endl; return 0; } 請輸入數字月份(1~12):1 January 其它更多成員函式"
  },"/pages/c/class/temp_obj/": {
    "title": "臨時物件temporary object",
    "keywords": "",
    "url": "/pages/c/class/temp_obj/",
    "body": "Prerequisites: 關閉RVO 拷貝函式 operator=() 匿名物件 把RVO關閉後，才能進行以下的範例。 傳回臨時物件 傳回臨時物件1 以下語法會觸發拷貝函式 Student()返回的臨時 Student 物件再次被拷貝給 s1 Student s1 = Student(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student s1 = Student(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; //離開主程式針對s1呼叫解構子 } 建構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件2 函式傳回值是臨時物件會呼叫拷貝函式。 以下程式碼會呼叫二次拷貝函式。 第一個拷貝操作：在 return Student(); 創建的臨時 Student 物件被拷貝一次，以便返回到 main 函式。這觸發了第一次拷貝建構子呼叫。 第二個拷貝操作：從 getStudent() 返回的臨時 Student 物件再次被拷貝給 s1，這會觸發第二次拷貝建構子的呼叫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; class Student { public: Student() { cout &lt;&lt; \"沒參數建構子\" &lt;&lt; endl; cout &lt;&lt; \"address = \" &lt;&lt; this &lt;&lt; endl; } Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student getStudent() { return Student(); } int main() { Student s1 = getStudent(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; } 沒參數建構子 address = 0x7ff7bfeff410 呼叫Student(const Student &amp;s)拷貝函式 解構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件3 函式傳回值是臨時物件會呼叫拷貝函式。 以下程式碼會呼叫二次拷貝函式。 第一個拷貝操作：在 return s; 創建的臨時 Student 物件被拷貝一次，以便返回到 main 函式。這觸發了第一次拷貝建構子呼叫。 第二個拷貝操作：從 func() 返回的臨時 Student 物件再次被拷貝給 s1，這會觸發第二次拷貝建構子的呼叫。 1 2 3 4 5 Student func() { Student s; return s;//呼叫拷貝函式 //離開函式，針對物件s呼叫解構子 } 以下的程式碼傳回臨時物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student func() { Student s;//呼叫建構子 cout &lt;&lt; \"函式物件記憶體位址 = \" &lt;&lt; &amp;s &lt;&lt; endl; return s;//呼叫拷貝函式 //離開函式，針對物件s呼叫解構子 } int main() { Student s1 = func(); cout &lt;&lt; \"物件記憶體位址 = \" &lt;&lt; &amp;s1 &lt;&lt; endl; return 0; //離開主程式針對s1呼叫解構子 } 建構子 函式物件記憶體位址 = 0x7ff7bfeff410 呼叫Student(const Student &amp;s)拷貝函式 解構子 呼叫Student(const Student &amp;s)拷貝函式 解構子 物件記憶體位址 = 0x7ff7bfeff468 解構子 傳回臨時物件4 因為student是已經存在的物件，因此會呼叫指派運算子=operator() Student student; 這行程式碼創建了一個 Student 類別的實例，並呼叫了預設建構子。此時 student 變數已經存在。 student = Student(); 這行程式碼產生了一個新的臨時 Student 對象，然後將它賦值給已有的 student 對象。這樣的操作會呼叫指派運算子（operator=），而不是拷貝建構子，因為 student 已經存在，不需要創建新的物件。 1 2 3 4 5 int main() { Student student; student = Student(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student student; student = Student(); return 0; } 建構子 建構子 呼叫Student operator=指派運算子 解構子 解構子 建立臨時物件 在成員函式或其它有參數的建構子呼叫參數為空建構子，只是建立臨時物件，然後很快的又被記憶體釋放。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //拷貝函式 Student(const Student &amp;s) { cout &lt;&lt; \"呼叫Student(const Student &amp;s)拷貝函式\" &lt;&lt; endl; } //指派運算子 Student&amp; operator=(const Student&amp; s) { cout &lt;&lt; \"呼叫Student operator=指派運算子\" &lt;&lt; endl; return *this; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"建立臨時物件\" &lt;&lt; endl; Student(); cout &lt;&lt; \"結束臨時物件\" &lt;&lt; endl; } }; int main() { Student s1; s1.print(); return 0; //離開主程式針對s1呼叫解構子 } 建構子 建立臨時物件 建構子 解構子 結束臨時物件 解構子"
  },"/pages/c/editor/rvo/": {
    "title": "關閉RVO",
    "keywords": "",
    "url": "/pages/c/editor/rvo/",
    "body": "什麼是RVO 「返回值優化」（Return Value Optimization, RVO）或「拷貝省略」技術。 Student student = Student(); 這行程式碼的作用是使用「臨時物件」（temporary object）初始化 student。但有以下幾個重點： 臨時物件的優化（Return Value Optimization, RVO）：在這段程式碼中，編譯器通常會應用「返回值優化」（RVO）或「拷貝省略」技術，這樣一來，它會直接在 student 的記憶體位置構建物件，而不是先創建一個臨時的 Student 物件然後再拷貝給 student。因此在實際運行中，不會產生臨時物件，而是直接將 Student() 產生的結果構建到 student 中。 不是指派記憶體位址：這段程式碼不是把臨時物件的記憶體位址「指派」給 student。它其實是構建了一個新的 Student 物件並用來初始化 student。而且，RVO 技術使得這個過程中不會額外創建臨時物件。 簡化的初始化語法：Student student = Student(); 的效果其實等同於 Student student; 或 Student student{};，因為它們都是呼叫 Student 類別的預設建構子來初始化 student。 Student student = Student(); 這段程式碼在大多數情況下不會創建額外的臨時物件。編譯器會透過優化直接將 Student() 建構的物件初始化到 student，而不是先生成臨時物件再指派給 student。 在沒有優化的情況下，Student() 會生成一個臨時 Student 對象，並在返回時拷貝或移動到主程式中的變數 student 中。 但在現代編譯器中，大多數情況下會應用「返回值優化」（Return Value Optimization, RVO）或「拷貝省略」技術。這樣一來，編譯器會直接在 student 變數所在的記憶體位置構建返回的 Student 物件，避免產生額外的臨時物件。這樣的優化讓返回的過程更加高效。 xcode關閉RVO 調降成c++11 關閉RVO 關閉RVO指令 g++ main.cpp -o main -fno-elide-constructors"
  },"/pages/c/stl/iterator/": {
    "title": "iterator疊代器",
    "keywords": "",
    "url": "/pages/c/stl/iterator/",
    "body": "Prerequisites: 記憶體間隔計算 函式模板 begin與end的位置 iterator.begin指向容器的首元素記憶體位址 iterator.end指向容器最後一個元素的下一個位址 圖中容器有10個元素，begin指向首元素，end指向最後一個元素的下一個位址 find模板 find在array寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 /** 參數1 arr陣列位址 參數2 陣列大小 參數3 要尋找的值 */ int* _find(int* arr, int n, const int&amp; val) { for(int i = 0; i &lt; n; i++) { //若找到與val相同的值，返回元素的記憶體位址 if(arr[i] == val) return &amp;arr[i]; } //找不到就返回null return nullptr; } 改寫成begin與end的參數 1 2 3 4 5 6 7 8 9 10 11 12 13 /** 參數1 開始位址 參數2 最後位址的下一個位址 參數3 要尋找的值 */ int* _find(int* begin, int* end, const int&amp; val) { for(int* iter = begin; iter != end; iter++) { //若找到與val相同的值，返回元素的記憶體位址 if(*iter == val) return iter; } //找不到就返回null return nullptr; } 支援鏈結串列的find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Node { int item; Node* next; }; /** 參數1 開始位址 參數2 最後位址的下一個位址 參數3 要尋找的值 */ Node* _find(Node* head, Node* end, const Node&amp; val) { for(Node* iter = head; iter != end; iter = iter-&gt;next) { //若找到與val相同的值，返回元素的記憶體位址 if(iter-&gt;item == val.item) return iter; } //找不到就返回null return nullptr; } find模板程式碼 C++的容器(vector,list,string…)都有iterator，iterator包含begin與end，可以把不同容器的begin與end作為模板參數傳入模板函式。 注意!!模板中，找不到元素是返回end位址，而不是nullptr。 1 2 3 4 5 6 7 8 template&lt;typename T1,typename T2&gt; T1 _find(T1 begin, T1 end, const T2 &amp;val) { for(T1 iter = begin; iter != end; iter ++) { if(*iter == val) return iter; } //注意!!如果找不到就返回end位址 return end; } vector使用find模板 vector資料結構是陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T1,typename T2&gt; T1 _find(T1 begin, T1 end, const T2 &amp;val) { for(T1 iter = begin; iter != end; iter ++) { if(*iter == val) return iter; } return end; } int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; vector&lt;int&gt;::iterator it1 = _find(v.begin(), v.end(), 4); if (it1 != v.end()) cout &lt;&lt; \"找到\" &lt;&lt; *it1 &lt;&lt; endl; else cout &lt;&lt; \"找不到\" &lt;&lt; endl; return 0; } 找到4 list使用find模板 list的資料結構是鏈結串列。 要記得include #include &lt;list&gt; 1 2 3 4 5 6 7 8 9 int main() { list&lt;int&gt; list1 = {1, 2, 3, 4, 5}; list&lt;int&gt;::iterator it1 = _find(list1.begin(), list1.end(), 4); if (it1 != list1.end()) cout &lt;&lt; \"找到\" &lt;&lt; *it1 &lt;&lt; endl; else cout &lt;&lt; \"找不到\" &lt;&lt; endl; return 0; } 找到4 疊代器支持的運算子 疊代器模擬了C++中的指標，可以有++運算，用*（取值運算子，deference）或-&gt;來訪問容器中的元素。 *iter 取值運算子 iter-&gt;member 讀取當前物件的成員變數 iter=iter1 指派給另一個疊代器 iter==iter1 疊代器相等比較 iter!=iter1 疊代器不等比較 疊代器分類 正向疊代器 只能++，不能–，只能往前遍歷，不能往後遍歷。例如資料結構為單向鏈結串列的list不能向後遍歷。 宣告疊代器語法 可修改元素的疊代器 容器&lt;元素類型&gt;::iterator 疊代器名; vector&lt;int&gt;::iterator it; 不可修改元素的疊代器 容器&lt;元素類型&gt;::const_iterator 疊代器名; vector&lt;int&gt;::const_iterator it; begin() iterator移到容器第0個元素，傳回的iterator可以修改值 1 iterator begin(); 傳回的iterator不可以修改值(有const) 1 const_iterator begin(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; using namespace std; int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; //把iterator移到容器第0個元素 vector&lt;int&gt;::iterator it = v.begin(); //將第0個元素的值改成7 *it = 7; //iterator移到下一個元素 it++; //將第1個元素的值改為8 *it = 8; for (vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } return 0; } 7, 8, 3, 4, 5, cbegin() 類型可以簡寫成auto，不可以修改值(有const) const_iterator cbegin(); 原本的程式碼 1 2 3 4 for (vector&lt;int&gt;::const_iterator it = v.cbegin(); it != v.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; 類型簡寫成auto 1 2 3 4 for (auto it = v.cbegin(); it != v.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; end() 取得最後一個元素的下一個記憶體位址 可以修改值 1 iterator end(); 不可以修改值 1 const_iterator end(); 類型可簡寫成auto，不可以修改值 1 const_iterator cend(); 雙向疊代器 疊代器可以往前遍歷，也可以向後遍歷，支援–(向後遍歷)的功能。擁有正向疊代器與反向疊代器的功能，正向疊代器上述已提過。 reverse_iterator反向疊代器 圖中容器有10個元素，rbegin指向「最後一個元素」的「起始位址」，rend指向「第 0 個元素的前一個位置」。 可修改元素的疊代器 1 2 容器&lt;元素類型&gt;::reverse_iterator 疊代器名; vector&lt;int&gt;::reverse_iterator it; 不可修改元素的疊代器 1 2 容器&lt;元素類型&gt;::const_reverse_iterator 疊代器名; vector&lt;int&gt;::const_reverse_iterator it; rbegin() 返回的是一個反向迭代器，指向容器最後一個元素的位址。這樣可以從容器的最後一個元素開始反向遍歷。 可以修改iterator指向位址的值。 1 reverse_iterator rbegin(); crbegin() 類型可以簡化成auto，不可以修改iterator指向位址的值。 1 const_reverse_iterator crbegin(); rend() 返回的則是指向容器「第 0 個元素的前一個位置」的反向迭代器，因此，它表示反向迭代器的結束位置。 可以修改iterator指向位址的值。 1 reverse_iterator rend(); crend() 返回的則是指向容器「第 0 個元素的前一個位置」的反向迭代器，因此，它表示反向迭代器的結束位置。 類型可以簡化成auto，不可以修改iterator指向位址的值。 1 const_reverse_iterator crend(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; //把iterator移到容器第0個元素 vector&lt;int&gt;::reverse_iterator it = v.rbegin(); //將最後一個元素的值改成7 *it = 7; //iterator移到倒數第2個元素 it++; //將倒數第2個元素的值改為8 *it = 8; //正向疊代器 cout &lt;&lt; \"正向 : \" &lt;&lt; endl; for (auto it = v.cbegin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; //反向疊代器 cout &lt;&lt; \"反向 : \" &lt;&lt; endl; for (auto it = v.crbegin(); it != v.crend(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 正向 : 1, 2, 3, 8, 7, 反向 : 7, 8, 3, 2, 1, 用疊代器建立容器 vector 建構子 參數為其它容器的疊代器建立vector容器 二個參數為iterator的建構子 vector(Iterator first, Iterator last) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //使用v1的cbegin()與v1的cend()，建立v2容器 vector&lt;int&gt; v2(v1.cbegin() + 2, v1.cend() - 3); //遍歷v2容器所有元素 for (auto it = v2.cbegin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 3, 4, 5, 6, 7, 指派 void assign(Iterator first, Iterator last); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;list&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //使用v1的cbegin()與v1的cend()，建立v2容器 vector&lt;int&gt; v2; v2.assign(v1.cbegin() + 2, v1.cend() - 3); //遍歷v2容器所有元素 for (auto it = v2.cbegin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; \", \"; } cout &lt;&lt; endl; return 0; } 3, 4, 5, 6, 7, 插入 返回的位址是插入元素的位址 iterator insert(iterator pos, const T&amp; value); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //在2的位址後面插入一個12 //返回插入元素的位址(指標) auto iter = v1.insert(v1.begin() + 2, 12); cout &lt;&lt; \"插入的元素是:\" &lt;&lt; *iter &lt;&lt; endl; for (auto it = v1.cbegin(); it != v1.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 插入的元素是:12 1 2 12 3 4 5 6 7 8 9 10 插入區間元素 iterator insert(iterator pos, iterator first, iterator last); 參數1:要插入的位址 參數2:其它容器的開始位址 參數3:其它容器的結束位址 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; vector&lt;int&gt; v2 = {11, 22, 33, 44, 55, 66, 77, 88, 99, 100}; //在2的位址後面插入一個v2區間 //返回第一個插入元素的位址(指標) auto iter = v1.insert(v1.begin() + 2, v2.begin() + 1, v2.end() - 3); cout &lt;&lt; \"第一個插入的元素是:\" &lt;&lt; *iter &lt;&lt; endl; for (auto it = v1.cbegin(); it != v1.cend(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 第一個插入的元素是:22 1 2 22 33 44 55 66 77 3 4 5 6 7 8 9 10 疊代器失靈 若在迴圈中有新增、插入、刪除的動作會導致疊代器無法移動到下一個位址。 resize(),reserve(),assign(),push_back(),pop_back(),insert(),erase()導致疊代器指向陣列元素或鏈結串列的節點位址移動，會導致iterator無法作用。 vector刪除元素 參數都是iterator，重點返回的是刪除元素的下一個位址。 iterator erase(iterator pos); iterator erase(iterator first, iterator last); 以下的程式碼會造成疊代器失靈 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for (vector&lt;int&gt;::const_iterator it = v1.begin(); it != v1.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; v1.erase(it); } return 0; } 1 3 5 7 9 解決疊代器失靈 把it++移除，it指向刪除元素後會返回下一個位址，疊代器就可以正常運作。 1 2 3 4 5 6 7 8 int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; for (vector&lt;int&gt;::const_iterator it = v1.begin(); it != v1.end(); ) { cout &lt;&lt; *it &lt;&lt; \" \"; it = v1.erase(it); } return 0; } 1 2 3 4 5 6 7 8 9 10"
  },"/pages/c/basic/format/": {
    "title": "程式碼格式",
    "keywords": "",
    "url": "/pages/c/basic/format/",
    "body": "以下內容參考google C++風格指南 命名 命名規則 名稱要有描述性；少用縮寫。 1 2 3 4 int price_count_reader; // 無縮寫。 int num_errors; // \"num\" 是很常見的縮寫字。 int num_dns_connections; // 大部份的人都知道 \"DNS\" 是啥。 int lstm_size; // \"LSTM\" 在機器學習領域中是個常用的縮寫字。 1 2 3 4 5 6 7 int n; // 毫無意義。 int nerr; // 模稜兩可的縮寫。 int n_comp_conns; // 模稜兩可的縮寫。 int wgc_connections; // 只有貴團隊知道是啥意思。 int pc_reader; // \"pc\" 有太多可能的解釋了。 int cstmr_id; // 有刪減若干字母。 FooBarRequestInfo fbri; // 根本不是個單字。 檔案名 檔案名稱要全部小寫，可以包含底線 () 或減號 (-)。依專案慣例來選用。如果專案沒有一致的用法，用 「」 比較好。 變數名 一般變數、函式參數 變數（包括函式的參數）以及資料成員的名稱一律小寫，單字之間用底線連接。類別的資料成員結尾處多加一個底線（但結構的資料成員不用），如：a_local_variable、a_ struct_data_member、a_class_data_member_。 1 2 string table_name; // 可 - 用底線。 string tablename; // 可 - 全小寫。 類別成員 小寫變數名，最後加底線_ 1 2 3 4 5 6 7 class TableInfo { ... private: string table_name_; // 可 - 字尾加底線。 string tablename_; // 可。 static Pool&lt;TableInfo&gt;* pool_; // 可。 }; 結構成員 不用最後加底線_ 1 2 3 4 struct UrlTableProperties { string name; int num_entries; } 命名空間 命名空間用小寫字母命名，避免使用不當的縮寫。 把檔案名稱加到名稱中，可以有效建立獨一無二的名稱（例如 在 frobber.h 中，就用 websearch::index::frobber_internal 這樣的名稱）。 函式名 一般函式使用大小寫混合。 一般來說，函式名稱的第一個字母要大寫，其後每個單字的字首字母均大寫。 1 2 3 AddTableEntry() DeleteUrl() OpenFileOrDie() 類別、結構、型別別名、列舉，以及模板型別參數 字首大寫，不能有底線，採駝峰式命名 型別名稱的每個單字首字母均大寫，不使用底線：MyExcitingClass，MyExcitingEnum。 所有型別命名（類別、結構、型別別名、列舉，以及模板型別參數）均使用相同規則。型別名稱的第一個字母要大寫，其後每個單字的字首字母均大寫，例如: 1 2 3 4 5 6 7 8 9 10 11 12 13 // 類別和結構 class UrlTable { ... class UrlTableTester { ... struct UrlTableProperties { ... // typedefs typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap; // using 別名 using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;; // 列舉 enum UrlTableErrors { ... 常數 宣告時加上 constexpr 或 const，且整個程式執行時間內都不會改變的變數，命名時需以 「k」 開頭，後面的字母以混合大小寫的方式書寫。在少數大寫字無法將單字隔開的情況下，可以使用底線當作區隔。舉例來說： 1 2 const int kDaysInAWeek = 7; const int kAndroid8_0_0 = 24; // Android 8.0.0 列舉 列舉若是常數，按照常數標準。 列舉若是型別，按照類別標準。 註解 使用 // 或 /* */，只要一致就好。 註解必須清晰易讀且平舖直述。 類別 類別前都要附帶一份註解(除非看到類別名就知道是在做什麼)，描述類別的功能和用法，了解如何使用、何時該使用這個類別。 類別運作以及實作方法的註解應該要放在類別成員函式的實作之處 函式 函式前加上用法說明的註解，除非看到函式名就知道是在做什麼，就可以不用寫。 變數名 通常變數名本身足以很好說明變數的用途。某些情況下，還是需要額外的註解說明。 全域變數 所有的全域變數都要註解說明含義、用途，以及為什麼要將它宣告為全域變數 TODO TODO 註解要使用全大寫的字串 TODO 在那些臨時的、短期的解決方案，或已經夠好但仍不完美的程式碼旁加上 TODO 註解 1 2 3 // TODO(kl@gmail.com): Use a \"*\" here for concatenation operator. // TODO(Zeke) change this to use relations. // TODO(bug 12345): remove the \"Last visitors\" feature 棄用deprecation 若已被棄用，用全大寫 DEPRECATED 註解標記。 空白 每一句程式碼內縮2個空白 以下程式碼vector前面留有2個空白 1 2 3 4 int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; return 0; } xcode把tab改為2個空白 if 注意在所有情況下，if 和左括號間都有個空格。如果有大括號的話，右括號和左大括號之間也要有個空格： 正確方式 1 if (condition) { // 可 - IF 後面和 { 前面都留有適當的空格。 錯誤方式 1 2 3 if (condition) // 差 - IF 後面沒空格。 if (condition){ // 差 - { 前面沒空格。 if (condition){ // 前面兩項錯誤犯好犯滿。 if,else if,else 正確方式 1 2 3 4 5 6 7 if (condition) { // 括號裡沒空格。 ... // 2 空格縮排。 } else if (...) { // else 與 if 的右大括號放在同一行。 ... } else { ... } 簡短的條件語句可以寫在同一行，如果這樣可讀性比較高的話。只有當句子簡單並且沒有使用 else 子句時可以使用： 1 2 if (x == kFoo) return new Foo(); if (x == kBar) return new Bar(); 如果述句中有 else 的話就禁止如此使用： 1 2 3 // 不可以這樣子 - 當 ELSE 子句存在時，IF 陳述句卻只擠在同一行 if (x) DoThis(); else DoThat(); if大括號 一般來說，單行語句不需要使用大括號，如果你喜歡用也沒問題 1 2 3 4 5 6 if (condition) DoSomething(); // 2 空格縮排。 if (condition) { DoSomething(); // 2 空格縮排。 } 但如果整個述句中某個 if-else 的區塊使用了大括號的話，其它區塊也必須使用： 1 2 3 4 5 6 7 8 9 10 11 12 // 不可以這樣子 - IF 有大括號 ELSE 卻沒有。 if (condition) { foo; } else bar; // 不可以這樣子 - ELSE 有大括號 IF 卻沒有。 if (condition) foo; else { bar; } 正確方式 1 2 3 4 5 6 // 只要其中一個區塊用了大括號，兩個區塊都要用。 if (condition) { foo; } else { bar; } for for () {….}中的內縮仍是2個空白 1 2 3 4 5 6 7 8 int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; for (auto it = v.crbegin(); it != v.crend(); it++) { //內縮2個空白 cout &lt;&lt; *it &lt;&lt; \", \"; } return 0; } for與圓括號()之間要有空白，圓括號()與左大括號{要有空白，並且左大括號{與for在同一行 1 2 for () { } 圓括號()與裡面的條件，開頭與結尾是沒空白 1 2 for (int i = 0; i &lt; 10; i++) { } 分號;後留一個空白，=等於的前後留空白，&lt;的前後留空白，++前後不用留空白 1 for (int i = 0; i &lt; 10; i++) 分號後一定要有空格。 1 2 // 迴圈中，分號後一定要有空格。 for (auto it = first; ; ) 引數 大括號{…}裡面的值，逗號(,)右側留一個空白，左側不留空白，大括號{…}中，前後不留空白。 變數名v與類型留一個空白 =等於，前後留空白 1 vector&lt;int&gt; v = {1, 2, 3, 4, 5}; 類別 public前面留一個空白 public裡面的述敘與public是一個空白 1 2 3 4 5 6 7 8 class callbackObj { public://與最邊緣留1個空白 //與public留1個空白，與最邊緣留2個空白 void print(const string&amp; msg) { //與void留2個空白，與最邊緣留4個空白 cout &lt;&lt; msg &lt;&lt; endl; } }; 模板 template與尖括號&lt;，中間有空白 1 template &lt;typename T, typename U&gt; 註解空白與對齊 2個斜線後面加一個空白 1 2 // Process \"element\" unless it was already processed. auto iter = std::find(v.begin(), v.end(), element); 行尾註解空2個空白 在行尾加兩格空隔後，加上2個斜線，再加一個空白後，開始註解 1 2 if (.....) return; // Error already logged. 註解對齊 1 2 3 4 5 6 7 8 9 10 11 DoSomething(); // 把註解放這裡才能和下一行對齊。 DoSomethingElseThatIsLonger(); // 註解和程式碼之間要有兩個空格。 { // 當開啟一個新的作用域時，可以只放一個空隔， // 這樣接下來的註解和程式碼都可以和前面那行對齊。 DoSomethingElse(); // 一般來說行註解前面都需要兩個空隔。 } std::vector&lt;string&gt; list{ // 在條列初始化中，用來說明下一個元素的註解... \"First item\", // .. 必須要妥善對齊。 \"Second item\"}; define 以井號 # 開頭的前置處理器指令一律從一行的最開頭寫起。 1 2 3 4 5 6 7 8 9 10 // 可 - 指令從行首寫起 if (lopsided_score) { #if DISASTER_PENDING // 正確 -- 從行首寫起。 DropEverything(); # if NOTIFY // 可以，但非必要 -- # 後面有空格 NotifyClient(); # endif #endif BackToNormal(); } 斷行 除非必要，不要使用斷行。尤其是：兩個函式定義之間的斷行不要超過 2 行，函式起始處不要是斷行，最後一行也不要是斷行，其餘地方也儘量少用斷行。在一個程式碼區塊中，斷行像是文章中的段落：在視覺上將兩個想法區隔開來。 函式內開頭或結尾的斷行對可讀性沒有幫助。 在多重 if-else 區塊裡加斷行對可讀性可能有些幫助。 在註解前面加空行通常可以增加可讀性，引入一段新的註解等於在介紹一個新想法的開始，此時加上空行可以清楚地表示這段註解是在說明接下來的程式碼，而非延續前面的行為。 initializer_list 若是你不得不斷行，放在下一行，加上4格的縮排 1 2 3 4 5 6 7 8 9 10 11 12 // 若是你不得不斷行。 SomeFunction( {\"assume a zero-length name before {\"}, some_other_function_parameter); SomeType variable{ \"This is too long to fit all in one line\"}; MyType m = { // 你也可以在 { 前斷行。 superlongvariablename1, superlongvariablename2, {short, interior, list}, {interiorwrappinglist, interiorwrappinglist2}}; 關係運算子放在行尾 若是你不得不斷行，放在下一行，加上4格的縮排 關係運算子斷行時一律放在行尾 1 2 3 4 5 6 7 string time_str = to_string(tmnow.tm_year + 1900) + \"/\" + to_string(tmnow.tm_mon + 1) + \"/\" + to_string(tmnow.tm_mday) + \"/\" + to_string(tmnow.tm_hour) + \":\" + to_string(tmnow.tm_min) + \":\" + to_string(tmnow.tm_sec); 1 2 3 4 5 if (this_one_thing &gt; this_other_thing &amp;&amp; a_third_thing == a_fourth_thing &amp;&amp; yet_another &amp; last_one) { ... } 建構子初始值 建構式初值列可以放在同一行，或換行後縮排 4 個空格。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 當一行可以塞得下時： MyClass::MyClass(int var) : some_var_(var) { DoSomething(); } // 如果一行塞不下建構式名稱列和初值列的話，你必須 // 在分號前換行，並且縮排 4 個空格 MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) { DoSomething(); } // 若是初值列得分成好幾行的話，每個成員各占一行， // 排列整齊： MyClass::MyClass(int var) : some_var_(var), // 4 格縮排 some_other_var_(var + 1) { // 對齊前一行 DoSomething(); } // 和其他程式碼區塊一樣，如果塞得下的話，右大括號可以 // 和左大括號放在同一行。 MyClass::MyClass(int var) : some_var_(var) {} 指標與reference 在存取成員時，句點或箭頭前後沒有空格。 指標運算子 * 或 &amp; 後面沒有空格。 1 2 3 4 x = *p; p = &amp;x; x = r.y; x = r-&gt;y; 1 2 3 4 5 6 // 沒問題，空格放在星號前。 char *c; const string &amp;str; // 沒問題，空格放在星號後。 char* c; const string&amp; str; 允許（但不常用）在同一行宣告式中宣告 1 個以上的變數，但其中不得有指標或是 reference 的宣告，因為這樣的宣告式很容易造成混淆。 1 2 // 如果對可讀性有幫助就沒問題。 int x, y; 1 2 3 int x, *y; // 禁止 - 多個變數的宣告式中不得有 &amp; 或 * char * c; // 不好 - 星號前後都有空格 const string &amp; str; // 不好 - &amp; 前後都有空格 類別 存取控制區塊的宣告依次序是 public:、protected:、private:，每次縮排 1 個空格。 關鍵詞 public:、protected: 和 private: 要縮排 1 個空格。 這些關鍵詞後不要保留空行 public 放在最前面，然後是 protected，最後是 private。 繼承關係，:冒號前後有空白，建構子初始，也是冒號前後有空白 1 class MyClass : public OtherClass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyClass : public OtherClass { public: // 注意有 1 空格縮排！ MyClass(); // 一般的 2 空格縮排。 explicit MyClass(int var); ~MyClass() {} void SomeFunction(); void SomeFunctionThatDoesNothing() { } void set_some_var(int var) { some_var_ = var; } int some_var() const { return some_var_; } private: bool SomeInternalFunction(); int some_var_; int some_other_var_; };"
  },"/pages/c/class/anonymous_obj/": {
    "title": "匿名物件",
    "keywords": "",
    "url": "/pages/c/class/anonymous_obj/",
    "body": "Prerequisites: RVO 匿名物件，也就是沒有名字(變數名)的物件，建立後馬上銷毀，沒有生命周期。 語法 類別名() 建立匿名物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { //建立匿名物件 Student(); return 0; } 建構子 解構子 返回匿名物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; Student createStudent() { return Student(); } int main() { createStudent(); return 0; } 建構子 解構子 解構子 程式碼執行流程 呼叫 createStudent() 進入 createStudent()，執行 return Student();，此時產生一個臨時對象，執行 建構子。因為你已經關閉 RVO（Return Value Optimization），這個臨時物件無法被最佳化，因此會觸發額外的拷貝函式，拷貝完之後進行銷毀臨時物件。 main() 中沒有其他 Student 物件，因此程式結束，銷毀createStudent()的返回拷貝函式產生的物件。 匿名物件指派給變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; class Student { public: //建構子 Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } //解構子 ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } }; int main() { Student s1 = Student(); return 0; } 建構子 解構子 解構子 程式碼執行流程 呼叫 createStudent() 進入 createStudent()，執行 return Student();，此時產生一個臨時對象，執行 建構子。因為你已經關閉 RVO（Return Value Optimization），這個臨時物件無法被最佳化，因此會觸發額外的拷貝函式，拷貝完之後進行銷毀臨時物件。 程式結束，銷毀s1物件。 匿名物件也是臨時物件 匿名物件是直接由程式碼直接生成。 1 2 3 4 5 int main() { //由程式碼直接建立物件 Student(); return 0; } 若函式返回的是匿名物件，編譯器自動管理其生命週期，就會變成臨時物件，所謂的臨時物件就是由編譯器生成。 通過函式傳回的物件(包含匿名物件或不是匿名物件)，全是臨時物件。 initializer_list匿名物件 initializer list 以下程式碼由initializer_list方式建立物件 {8, \"cici\"} 與 {3, \"john\"} 為匿名物件，因為他們沒有名字。 1 2 3 4 5 6 7 8 #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { map&lt;int, string&gt; m; m.insert({ {8, \"cici\"}, {3, \"john\"} }); return 0; }"
  },"/pages/c/template/findif_template/": {
    "title": "find_if模板",
    "keywords": "",
    "url": "/pages/c/template/findif_template/",
    "body": "Prerequisites: continue 物件函式 foreach模板 find_if()函式 若在容器中找到元素就返回疊代器iterator，找不到就返回容器最後一個元素的下一個位址 增加搜尋值與傳回值 將foreach模板的程式拿來修改，增加搜尋值T3的模板參數與T1的模板傳回值。 找到欲搜尋的值T3，就返回iterator 找不到就傳回容器最後一個元素的下一個位址。 1 2 3 4 5 6 7 template&lt;typename T1, typename T2, typename T3&gt; T1 findif(const T1 first, const T1 last, T2 callback, T3 search_val) { for (auto it = first; it != last; it++) { if(callback(*it, search_val) == true) return it; } return last; } 修改callback函式指標模板 增加搜尋值T的模板參數，傳回bool，判斷msg是否與要搜尋的值相同。 1 2 3 4 template&lt;typename T&gt; bool callback(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } 修改callback物件函式模板 增加搜尋值T的模板參數，傳回bool，判斷msg是否與要搜尋的值相同。 1 2 3 4 5 6 7 template&lt;typename T&gt; class Callback { public: bool operator()(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } }; 呼叫findif模板 傳回值為iterator，把iterator指標的值印出來。 1 2 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(), \"03\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; bool callback(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } template&lt;typename T&gt; class Callback { public: bool operator()(const T&amp; msg, const T&amp; search_val) { return msg == search_val; } }; template&lt;typename T1, typename T2, typename T3&gt; T1 findif(const T1 first, const T1 last, T2 callback, T3 search_val) { for (auto it = first; it != last; it++) { if(callback(*it, search_val) == true) return it; } return last; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; // 物件函式 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(), \"03\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; // 函式指標 vector&lt;string&gt;::iterator it2 = findif(v2.begin(), v2.end(), callback&lt;string&gt;, \"05\"); cout &lt;&lt; \"找到 = \" &lt;&lt; *it2 &lt;&lt; endl; return 0; } 找到 = 03 找到 = 05 物件函式，使用建構子，搜尋值作為參數 建構子初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; class Callback { public: T search_val; Callback(const T&amp; search_val):search_val(search_val) {} bool operator()(const T&amp; msg) { return msg == search_val; } }; template&lt;typename T1, typename T2&gt; T1 findif(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { if(callback(*it) == true) return it; } return last; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; // 物件函式 vector&lt;string&gt;::iterator it1 = findif(v2.begin(), v2.end(), Callback&lt;string&gt;(\"03\")); cout &lt;&lt; \"找到 = \" &lt;&lt; *it1 &lt;&lt; endl; return 0; } 技巧: 在迴圈中，若函式()返回true，就continue回到迴圈的條件判斷式，返回false就繼續執行接下來的程式碼。 之後sort模板會利用到這個技巧。"
  },"/pages/c/template/foreach_template/": {
    "title": "foreach模板",
    "keywords": "",
    "url": "/pages/c/template/foreach_template/",
    "body": "Prerequisites: iterator 傳統思維 試想一下，寫一個foreach函式，傳統思維會將容器(vector,list)位址傳入函式，如以下的寫法: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;&amp; v) { for (auto it = v.cbegin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1); return 0; } 1 2 3 4 5 6 7 8 9 10 疊代器思維 STL容器(vector,list)皆有iterator疊代器，把iterator疊代器作為參數代入函式，有以上相同效果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;::iterator first, const vector&lt;int&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 函式多載(overload) 若容器元素的類型為string，就要多寫一個支援容器元素為string的函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void foreach(const vector&lt;int&gt;::iterator first, const vector&lt;int&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } void foreach(const vector&lt;string&gt;::iterator first, const vector&lt;string&gt;::iterator last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); vector&lt;string&gt; v2 = {\"首頁\", \"客服\", \"購物車\", \"個人資訊\"}; foreach(v2.begin(), v2.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 首頁 客服 購物車 個人資訊 模板取代函式多載 類型全換成T，不管T是什麼類型，只要支持函式中的assign(=)、!=、it++、*it的功能就可以使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; void foreach(const T first, const T last) { for (auto it = first; it != last; it++) { cout &lt;&lt; *it &lt;&lt; \" \"; } cout &lt;&lt; endl; } int main() { vector&lt;int&gt; v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; foreach(v1.begin(), v1.end()); vector&lt;string&gt; v2 = {\"首頁\", \"客服\", \"購物車\", \"個人資訊\"}; foreach(v2.begin(), v2.end()); return 0; } 1 2 3 4 5 6 7 8 9 10 首頁 客服 購物車 個人資訊 callback模板函式(回調/回呼函式) 在模板函式中要做的事由callback函式去完成。 callback函式為函式指標 寫一個callback函式支援容器元素為string，並印出元素的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void callback(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; void foreach(const T first, const T last, void(*callback)(const string&amp;)) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; foreach(v2.begin(), v2.end(), callback); return 0; } 01 02 03 04 05 callback函式為物件函式 物件函式 匿名物件 呼叫函式物件，使用匿名物件方式呼叫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Callback { public: void operator()(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; template&lt;typename T&gt; void foreach(const T first, const T last, Callback callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; foreach(v2.begin(), v2.end(), Callback()); // 呼叫函式物件，使用匿名物件方式呼叫 return 0; } 01 02 03 04 05 模板取代函式指標與物件函式 從以上二個程式碼，可以發現呼叫函式指標與物件函式的方式都一樣，因此把foreach函式中的Callback參數化為模板，參數可以為函式指標或物件函式。 callback(*it); 把callback類型化為模板T2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void callback(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } class Callback { public: void operator()(const string&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; //把callback類型化為模板T2 template&lt;typename T1, typename T2&gt; void foreach(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 foreach(v2.begin(), v2.end(), Callback()); //函式指標 foreach(v2.begin(), v2.end(), callback); return 0; } callback函式參數模板化 以上函式的缺點在於函式參數固定是string&amp;的類型。 將callback函式與類別的參數模板化 函式模板 1 2 3 4 template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } 類別模板 1 2 3 4 5 6 7 template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; 呼叫函式模板、類別模板 呼叫模板函式與模板類別，記得加上&lt;型別&gt; 1 2 3 4 //物件函式 foreach(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 foreach(v2.begin(), v2.end(), callback&lt;string&gt;); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; template&lt;typename T1, typename T2&gt; void foreach(const T1 first, const T1 last, T2 callback) { for (auto it = first; it != last; it++) { callback(*it); } cout &lt;&lt; endl; } int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 foreach(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 foreach(v2.begin(), v2.end(), callback&lt;string&gt;); return 0; } 01 02 03 04 05 01 02 03 04 05 使用官方for_each 以上已實作官方for_each模板函式，以下為使用官方for_each include 1 #include &lt;algorithm&gt; for_each 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; template&lt;typename T&gt; void callback(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } template&lt;typename T&gt; class Callback { public: void operator()(const T&amp; msg) { cout &lt;&lt; msg &lt;&lt; \" \"; } }; int main() { vector&lt;string&gt; v2 = {\"01\", \"02\", \"03\", \"04\", \"05\"}; //物件函式 for_each(v2.begin(), v2.end(), Callback&lt;string&gt;()); //函式指標 for_each(v2.begin(), v2.end(), callback&lt;string&gt;); return 0; } 01 02 03 04 05 01 02 03 04 05"
  },"/pages/c/template/bsort_template/": {
    "title": "氣泡排序模板",
    "keywords": "",
    "url": "/pages/c/template/bsort_template/",
    "body": "Prerequisites: 氣泡排序 由小到大排序 傳回true的條件，左邊的值小於右邊的值 1 2 3 4 template&lt;typename T&gt; bool CompareASC(const T&amp; left, const T&amp; right) { return left &lt; right; } 由大到小排序 傳回true的條件，左邊的值大於右邊的值 1 2 3 4 template&lt;typename T&gt; bool CompareDESC(const T&amp; left, const T&amp; right) { return left &gt; right; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; bool CompareASC(const T&amp; left, const T&amp; right) { return left &lt; right; } template&lt;typename T&gt; bool CompareDESC(const T&amp; left, const T&amp; right) { return left &gt; right; } template&lt;typename T, typename Compare&gt; void BubbleSort(const T first, const T last, Compare comp) { while (true) { // 判斷容器所有容器原本就排好 bool bswap = false; // it指標移到第一個元素位址 for (auto it = first; ; ) { // 左邊的元素 auto left = it; // 移到下個位址 it++; // 右邊的元素 auto right = it; // right是最後一個元素的下一個位址 if (right == last) break; // 若二個元素已經是排好就回到for判斷條件 if (comp(*left, *right) == true) continue; // 交換 auto temp = *right; *right = *left; *left = temp; // 代表有交換 bswap = true; } // 若沒有交換代表全部元素都已經是有序的。 if (bswap == false) break; } } int main() { vector&lt;string&gt; v = {\"05\", \"04\", \"03\", \"02\", \"01\"}; BubbleSort(v.begin(), v.end(), CompareASC&lt;string&gt;); for (auto val: v) { cout &lt;&lt; val &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 01 02 03 04 05 改用物件函式 效果與函式指標是相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; template&lt;typename T&gt; class CompareASC { public: bool operator()(const T&amp; left, const T&amp; right) { return left &lt; right; } }; template&lt;typename T&gt; class CompareDESC { public: bool operator()(const T&amp; left, const T&amp; right) { return left &gt; right; } }; template&lt;typename T, typename Compare&gt; void BubbleSort(const T first, const T last, Compare comp) { while (true) { // 判斷容器所有容器原本就排好 bool bswap = false; // it指標移到第一個元素位址 for (auto it = first; ; ) { // 左邊的元素 auto left = it; // 移到下個位址 it++; // 右邊的元素 auto right = it; // right是最後一個元素的下一個位址 if (right == last) break; // 若二個元素已經是排好就回到for判斷條件 if (comp(*left, *right) == true) continue; // 交換 auto temp = *right; *right = *left; *left = temp; // 代表有交換 bswap = true; } // 若沒有交換代表全部元素都已經是有序的。 if (bswap == false) break; } } int main() { vector&lt;string&gt; v = {\"05\", \"04\", \"03\", \"02\", \"01\"}; BubbleSort(v.begin(), v.end(), CompareASC&lt;string&gt;()); for (auto val: v) { cout &lt;&lt; val &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 05 04 03 02 01"
  },"/pages/c/editor/openssh_server/": {
    "title": "安裝openssh-server",
    "keywords": "",
    "url": "/pages/c/editor/openssh_server/",
    "body": "openssh-server 以下環境 本機MAC Ubuntu 24.04 VMware Fusion 以下為Ubuntu虛擬機終端機設定 更新package list $ sudo apt update 安裝openssh-server $ sudo apt install openssh-server 按下y 啟動ssh $ sudo systemctl status ssh 離開按q $ sudo systemctl enable --now ssh 本機連ssh $ ssh localhost 按下y 重新啟動ssh $ sudo systemctl restart ssh 安裝c++ $ sudo apt install gcc $ sudo apt install g++ $ sudo apt install build-essential $ gcc --version $ g++ --version 安裝man page $ sudo apt install manpages-dev manpages-posix-dev $ man strcpy 按q退出 若跟user command有衝突的函式，請在函式名前輸入3 $ man 3 sleep 1是user command 3是Standard C library"
  },"/pages/c/template/function_class_template/": {
    "title": "類別中函式模板",
    "keywords": "",
    "url": "/pages/c/template/function_class_template/",
    "body": "建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; class MyArray{ public: template &lt;typename T&gt; // 建構子的參數為模板類型參數T MyArray(T element) { cout &lt;&lt; \"element : \" &lt;&lt; element &lt;&lt; endl; } }; int main() { // 引數為整數 MyArray myArray1(10); // 引數為字串 MyArray myArray2(\"abcdefg\"); // 引數為double MyArray myArray3(1000.555); return 0; } element : 10 element : abcdefg element : 1000.55 成員函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; using namespace std; class MyArray{ public: template &lt;typename T&gt; MyArray(T element) { cout &lt;&lt; \"element : \" &lt;&lt; element &lt;&lt; endl; } // 建立成員函式模板printMsg，傳回值為void，參數為模板類型參數T template &lt;typename T&gt; void printMsg(T msg) { cout &lt;&lt; \"msg : \" &lt;&lt; msg &lt;&lt; endl; } }; int main() { MyArray myArray1(10); // 引數為字串 myArray1.printMsg(\"Data Not Found!\"); // 引數為數字 myArray1.printMsg(404); // 引數為字元 myArray1.printMsg('$'); return 0; } element : 10 msg : Data Not Found! msg : 404 msg : $"
  },"/pages/c/template/function_template/": {
    "title": "函式模板",
    "keywords": "",
    "url": "/pages/c/template/function_template/",
    "body": "Prerequisites: 引數 函式多載 函式模板是編譯器根據引數，自動產生出對映的參數函式代碼。 模板定義 由template關鍵字定義模板，模板參數型別定義由關鍵字typename開始，可以命名任何您想要的參數型別，但依照慣例，最常使用單一大寫字母，T 是模板參數型別，若有多個模板參數型別可以T1,T2,T3…作為命名。 template &lt;typename T1, typename T2, typename T3&gt; 1 2 3 4 5 6 7 8 9 // template為模板定義 // typename為模板型別定義 // T 是模板參數 template &lt;typename T&gt; // 函式模板的名稱為FuncName // 傳回值void，T為模板參數型別，參數名為param void FuncName(T param) { cout &lt;&lt; \"param:\" &lt;&lt; param &lt;&lt; endl; } 函式多載 以下的Swap函式，只有參數的類型不同，屬於函式多載，其它程式碼都一模一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; using namespace std; void Swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; } void Swap(double &amp;a, double &amp;b) { double temp = a; a = b; b = temp; } void Swap(string &amp;a, string &amp;b) { string temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; Swap(a,b); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; double d1 = 50.5, d2 = 20.3; Swap(d1,d2); cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; \",d2=\" &lt;&lt; d2 &lt;&lt; endl; string s1 = \"test\", s2 = \"c++\"; Swap(s1,s2); cout &lt;&lt; \"s1=\" &lt;&lt; s1 &lt;&lt; \",s2=\" &lt;&lt; s2 &lt;&lt; endl; return 0; } a=20,b=10 d1=20.3,d2=50.5 s1=c++,s2=test 引數型別替換T模板參數型別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; // 函式模板會根據引數的類型自動生成Swap(int, int)對映的代碼 Swap(a,b); cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; double d1 = 50.5, d2 = 20.3; // 函式模板會根據引數的類型自動生成Swap(double, double)對映的代碼 Swap(d1,d2); cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; \",d2=\" &lt;&lt; d2 &lt;&lt; endl; string s1 = \"test\", s2 = \"c++\"; // 函式模板會根據引數的類型自動生成Swap(string, string)對映的代碼 Swap(s1,s2); cout &lt;&lt; \"s1=\" &lt;&lt; s1 &lt;&lt; \",s2=\" &lt;&lt; s2 &lt;&lt; endl; return 0; } a=20,b=10 d1=20.3,d2=50.5 s1=c++,s2=test 自訂類型 如果不想讓編譯器自動推導類型，想自訂類型，呼叫函式後面加上，就會產生此類型的函式。 1 2 3 4 5 6 7 8 9 10 11 12 template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10, b = 20; // 自訂類型 Swap&lt;int&gt;(a,b); return 0; } 傳回值為模板 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; T Add(T a, T b) { return a + b; } int main() { int a = 10; int b = 20; int result = Add(a,b); cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } 強制轉型 強制把引數轉成欲轉換的型別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; T Add(T a, T b) { return a + b; } int main() { int a = 10; // 整數類型char char c = 'A'; // 強制轉型char-&gt;int int result = Add&lt;int&gt;(a,c); cout &lt;&lt; \"result = \" &lt;&lt; result &lt;&lt; endl; return 0; } result = 75 模板多載 可以有多個相同函式模板名稱，但模板型別參數的數量不同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; template &lt;typename T1&gt; void insertLog(T1 no) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; endl; } template &lt;typename T1,typename T2&gt; void insertLog(T1 no,T2 msg) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; \",msg:\" &lt;&lt; msg &lt;&lt; endl; } template &lt;typename T1,typename T2&gt; void insertLog(T1 no,T2 msg,int seq) { cout &lt;&lt; \"no:\" &lt;&lt; no &lt;&lt; \",msg:\" &lt;&lt; msg &lt;&lt; \",seq:\" &lt;&lt; seq &lt;&lt; endl; } int main() { insertLog(10); insertLog(11, \"insert something...\"); insertLog(12, \"insert something...\", 1); return 0; } no:10 no:11,msg:insert something... no:12,msg:insert something...,seq:1 引數的類型需要一致 二個引數類型不同會產生會產生”No matching function for call to ‘Swap’“的error。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; void Swap(T &amp;a, T &amp;b) { T temp = a; a = b; b = temp; } int main() { int a = 10; double b = 20.5; Swap(a,b); return 0; } 沒有參數的模板 呼叫函式模板Swap，必須自訂類型，否則編譯器無法知道要產生什麼類型的函式模板，錯誤訊息\"No matching function for call to 'Swap'\" 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; template &lt;typename T&gt; // Swap模板函式沒有模板類型參數。 void Swap() { } int main() { Swap&lt;int&gt;(); return 0; }"
  },"/pages/c/template/special_template/": {
    "title": "模板特製化",
    "keywords": "",
    "url": "/pages/c/template/special_template/",
    "body": "模板特製化template specialization 語法 template &lt;&gt; 由template後面再加上尖括號&lt;&gt;，告知編譯器以下模板是有指定類型，參數類型都有符合才會執行。 函式模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; // 模板名為getMax，傳回類型為模板形參T，參數名為a與b template &lt;typename T&gt; T getMax(T a, T b) { if(a &gt; b) return a; // 若a比較大就把a傳回去 else return b; // 若b比較大就把b傳回去。 } int main() { int a = 10; int b = 20; int max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; return 0; } max = 20 模板特製化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include &lt;iostream&gt; using namespace std; class Student { public: void setScore(int score) { this-&gt;score = score; } int getScore() { return this-&gt;score; } private: int score; }; // 函式模板 template &lt;typename T&gt; T getMax(T a, T b) { if(a &gt; b) return a; else return b; } // 模板特製化 template &lt;&gt; Student getMax&lt;Student&gt;(Student s1, Student s2) { if(s1.getScore() &gt; s2.getScore()) return s1; else return s2; } int main() { int a = 10; int b = 20; int max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; Student s1; s1.setScore(78); cout &lt;&lt; \"s1 score = \" &lt;&lt; s1.getScore() &lt;&lt; endl; Student s2; s2.setScore(50); cout &lt;&lt; \"s2 score = \" &lt;&lt; s2.getScore() &lt;&lt; endl; // 呼叫模板特製化 Student rtn = getMax(s1, s2); cout &lt;&lt; \"score = \" &lt;&lt; rtn.getScore()&lt;&lt; endl; return 0; } max = 20 s1 score = 78 s2 score = 50 score = 78 模板函式與特製化函式傳回值與參數要一致 若模板函式是使用T，特製化模板也要使用類型。若模板函式是使用T&amp;，特製化模板則是使用類型參考&amp;。否則若不一致，例:模板函式用T，特製化模板用類型參考&amp;，將會產生錯誤error: no function template matches function template specialization。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; using namespace std; class Student { public: void setScore(int score) { this-&gt;score = score; } int getScore() { return this-&gt;score; } private: int score; }; template &lt;typename T&gt; T&amp; getMax(T&amp; a, T&amp; b) { if(a &gt; b) return a; else return b; } template &lt;&gt; Student&amp; getMax&lt;Student&gt;(Student&amp; s1, Student&amp; s2) { if(s1.getScore() &gt; s2.getScore()) return s1; else return s2; } int main() { int a = 10; int b = 20; int&amp; max = getMax(a,b); cout &lt;&lt; \"max = \" &lt;&lt; max &lt;&lt; endl; Student s1; s1.setScore(78); cout &lt;&lt; \"s1 score = \" &lt;&lt; s1.getScore() &lt;&lt; endl; Student s2; s2.setScore(50); cout &lt;&lt; \"s2 score = \" &lt;&lt; s2.getScore() &lt;&lt; endl; // 呼叫模板特製化 Student&amp; ref = getMax(s1, s2); cout &lt;&lt; \"score = \" &lt;&lt; ref.getScore()&lt;&lt; endl; return 0; } max = 20 s1 score = 78 s2 score = 50 score = 78"
  },"/pages/c/compile/core_dump/": {
    "title": "gdb core dump",
    "keywords": "",
    "url": "/pages/c/compile/core_dump/",
    "body": "產生memory leak的錯誤會存在core檔案。 linux預設不會產生core檔案，需修改系統參數。 查看core檔案大小語法 ulimit是限制使用者資源使用量 ulimit -a cici@cici-vm:~/test/app$ ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15194 max locked memory (kbytes, -l) 495132 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15194 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 由以上列表，可以發現core file size = 0 core file size (blocks, -c) 0 從以上列表，也可以看到stack大小 stack size (kbytes, -s) 8192 修改core檔案大小 -c是上述列表中有列出來的，-c代表的是core file size 將core file size設成無限unlimited $ ulimit -c unlimited $ ulimit -a real-time non-blocking time (microseconds, -R) unlimited core file size (blocks, -c) unlimited data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 15194 max locked memory (kbytes, -l) 495132 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 15194 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited core dump 建立一個cpp檔案core_test1.cpp 以下func2()中，試圖給ptr指標設值，但ptr指標是nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 *ptr = 97; // 97代表a } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下指令 $ g++ -o demo04 core_test1.cpp -g $ ./demo04 程式記憶體區段錯誤 (核心已傾印 $ ls 若是沒有產生\"core\"開頭的檔案，把core存放路徑改為目前執行程式的目錄下 echo \"core\" | sudo tee /proc/sys/kernel/core_pattern 再次執行程式 $ ./demo04 $ ls 檢查是否已經產生\"core\"開頭的檔案 debug 輸入以下指令，core是先前步驟的檔名，每個人的檔名不同，都是以core開頭 gdb ./demo04 core 黃色是要輸入的字母 Enable debuginfod for this session? (y or [n]) y Debuginfod has been enabled. To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit. Downloading separate debug info for system-supplied DSO at 0x7fffff0d2000 --Type &lt; RET &gt; for more, q to quit, c to continue without paging--c [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Core was generated by `./demo04'. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x00005a0b1c65d321 in func2 (msg=...) at core_test1.cpp:8 8 *ptr = 97; // 97代表a (gdb) 8 *ptr = 97; // 97代表a 會告知你錯誤的地方在第8行 bt 輸入bt，會列出呼叫函式的堆疊(call stack) 由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2()，最上層的是func2() (gdb) bt #0 0x00005a0b1c65d321 in func2 (msg=\"test\") at core_test1.cpp:8 #1 0x00005a0b1c65d365 in func1 (msg=\"test\") at core_test1.cpp:11 #2 0x00005a0b1c65d3d4 in main () at core_test1.cpp:14 q 輸入q就會離開gdb 顯示錯誤的行號在c++函式庫 修改程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 strcpy(ptr, msg.c_str()); } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下指令 $ g++ -o demo04 core_test1.cpp -g $ ./demo04 程式記憶體區段錯誤 (核心已傾印) $ gdb ./demo04 core 以下的錯誤無法看出來是什麼問題 #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 使用bt可以看出錯誤 (gdb) bt #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 #1 0x00005ad51c60a37f in func2 (msg=\"test\") at core_test1.cpp:8 #2 0x00005ad51c60a3c0 in func1 (msg=\"test\") at core_test1.cpp:11 #3 0x00005ad51c60a42f in main () at core_test1.cpp:14 其它方式查看core dump 安裝coredump sudo apt install systemd-coredump 執行並core dump 進入coredumpctl，使用q可離開 $ g++ -o demo03 core_test.cpp -g $ ./demo03 程式記憶體區段錯誤 (核心已傾印 $ coredumpctl TIME PID UID GID SIG COREFILE EXE &gt; Thu 2024-12-05 15:17:05 CST 25260 1000 1000 SIGSEGV present /home/cici/test/app/demo03&gt; Thu 2024-12-05 15:26:49 CST 25335 1000 1000 SIGSEGV present /home/cici/test/app/demo03&gt; $ coredumpctl debug demo03 bt 以下用黃色表示會要使用者輸入的部分與發生錯誤的行數。 bt可以列出呼叫函式的堆疊(call stack)，由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2()，最上層的是func2() 以下，使用q可離開 Enable debuginfod for this session? (y or [n]) y Debuginfod has been enabled. To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit. [Thread debugging using libthread_db enabled] --Type &lt; RET &gt; for more, q to quit, c to continue without paging--c Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Core was generated by `./demo03'. Program terminated with signal SIGSEGV, Segmentation fault. #0 0x00005893c17b7321 in func2 (msg=...) at core_test.cpp:8 8 *ptr = 97; // 97代表a (gdb) bt #0 0x00005893c17b7321 in func2 (msg=\"test\") at core_test.cpp:8 #1 0x00005893c17b7365 in func1 (msg=\"test\") at core_test.cpp:11 #2 0x00005893c17b73d4 in main () at core_test.cpp:14 若發生錯誤的是在c++的函式庫中，怎麼查找錯誤？ 將程式碼 *ptr = 97; 修改成c++函式strcpy strcpy(ptr, msg.c_str()); 修改程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { // 宣告nullptr的ptr指標 char * ptr = nullptr; // 試圖給nullptr設值 strcpy(ptr, msg.c_str()); } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 重新編譯 $ g++ -o demo03 core_test.cpp -g $ ./demo03 程式記憶體區段錯誤 (核心已傾印 $ coredumpctl $ coredumpctl debug demo03 使用bt，就可以查找出來發生錯誤的函式，main()呼叫func1，func1呼叫func2，func2呼叫strcpy #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 warning: 127 ../sysdeps/x86_64/multiarch/strcpy-avx2.S: 沒有此一檔案或目錄 (gdb) bt #0 __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:127 #1 0x000055a25facd37f in func2 (msg=\"test\") at core_test.cpp:8 #2 0x000055a25facd3c0 in func1 (msg=\"test\") at core_test.cpp:11 #3 0x000055a25facd42f in main () at core_test.cpp:14 行數請比對如下 1 #include 2 #include 3 using namespace std; 4 void func2(const string msg) { 5 // 宣告nullptr的ptr指標 6 char * ptr = nullptr; 7 // 試圖給nullptr設值 8 strcpy(ptr, msg.c_str()); 9 } 10 void func1(const string msg) { 11 func2(msg); 12 } 13 int main() { 14 func1(\"test\"); 15 return 0; 16 } &lt;/pre&gt;"
  },"/pages/c/compile/gdb/": {
    "title": "gdb",
    "keywords": "",
    "url": "/pages/c/compile/gdb/",
    "body": "何謂gdb 可以在linux系統下，debug c++程式碼，也可以debug正在運作的c++程式碼。 安裝gdb sudo apt install gdb gdb除錯 欲除錯的程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; void printParam(const char *param1, const char *param2, const char *param3) { cout &lt;&lt; \"姓名1 = \" &lt;&lt; param1 &lt;&lt; endl; cout &lt;&lt; \"姓名2 = \" &lt;&lt; param2 &lt;&lt; endl; cout &lt;&lt; \"姓名3 = \" &lt;&lt; param3 &lt;&lt; endl; } int main(int argc, char *argv[], char *envp[]) { cout &lt;&lt; \"參數有\" &lt;&lt; argc &lt;&lt; \"個\" &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) { cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; } if (argc != 4) { cout &lt;&lt; \"使用方法:./demo 參數1 參數2 參數3 \\n\"; return -1; } printParam(argv[1], argv[2], argv[3]); cout &lt;&lt; \"程式即將結束\" &lt;&lt; endl; return 0; } 編譯語法 編譯執行檔時要加上-g，產生原始檔而不是只有機器語言指令。 g++ -o demo02 print_param.cpp -g 執行gdb gdb demo02 離開gdb 按q q 設置參數 語法 set args 參數1 參數2 參數3 參數N (gdb) set args cici bill mary vi看行數 法1:移到想斷點的行數，按 ctl + g 法2: 按esc，輸入 :set number 關閉number :set nonumber 設置斷點break point b 行數 (gdb) b 11 我在以下這行加上斷點 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; 運行程式 程式運行到斷點的位置會停下來，若沒有斷點，程式會直接運行到結束。 r 執行 執行當前程式碼語句，不會進入函式內部。 n Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) n 參數0 = /home/cici/test/app/demo02 執行下一行 再按一次n，就會執行下一行，不會進入函式內部，注意！最左側11與10是目前執行的行數 Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) n 參數0 = /home/cici/test/app/demo02 10 for (int i = 0; i &lt; argc; i++) { (gdb) n Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) 印出變數 p 變數 Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) p i $1 = 1 設置變數(法1) 離開gdb，重新執行gdb，設置參數set args cici bill mary，並把斷點設成11行，按下r，移到斷點 p 變數=值 因參數有4個(demo02,cici,bill,mary) 假設把i值直接設成3，再執行一次n(移到第10行)，再執行一次n(移到13行)，就會跳離迴圈，中間直接略過i=1,i=2 (gdb) p i=3 Breakpoint 1, main (argc=1, argv=0x7fffffffe348, envp=0x7fffffffe358) at print_param.cpp:11 11 cout &lt;&lt; \"參數\" &lt;&lt; i &lt;&lt; \" = \" &lt;&lt; argv[i] &lt;&lt; endl; (gdb) p i $1 = 0 (gdb) p i=3 $2 = 3 (gdb) n 參數3 = PWD=/home/cici/test/app 10 for (int i = 0; i &lt; argc; i++) { (gdb) n 13 if (argc != 4) { 設置變數(法2) set var i=3 與 p i=3 是相同效果 直接運行到下一個斷點 輸入c會直接跳到下個斷點，若沒有下一個斷點，程式會直接運行到結束。 c 以下重新gdb，並設置斷點b 13與b 17，r是運行(會運行到第1個斷點13行)，再按c運行到下一個斷點(17行)。 cici@cici-vm:~/test/app$ g++ -o demo02 print_param.cpp -g cici@cici-vm:~/test/app$ gdb demo02 (gdb) set args cici bill mary (gdb) b 13 Breakpoint 1 at 0x1350: file print_param.cpp, line 13. (gdb) b 17 Breakpoint 2 at 0x1376: file print_param.cpp, line 17. (gdb) r 參數有4個 參數0 = /home/cici/test/app/demo02 參數1 = cici 參數2 = bill 參數3 = mary Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:13 13 if (argc != 4) { (gdb) c Continuing. Breakpoint 2, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:17 17 printParam(argv[1], argv[2], argv[3]); (gdb) 進入函式 17行剛好是呼叫函式printParam()的程式碼，按s，進入函式 s Breakpoint 1, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:13 13 if (argc != 4) { (gdb) c Continuing. Breakpoint 2, main (argc=4, argv=0x7fffffffe328, envp=0x7fffffffe350) at print_param.cpp:17 17 printParam(argv[1], argv[2], argv[3]); (gdb) s printParam (param1=0x7fffffffe5d5 \"cici\", param2=0x7fffffffe5da \"bill\", param3=0x7fffffffe5df \"mary\") at print_param.cpp:4 4 cout &lt;&lt; \"姓名1 = \" &lt;&lt; param1 &lt;&lt; endl; (gdb) p param1 $1 = 0x7fffffffe5d5 \"cici\" (gdb) p param2 $2 = 0x7fffffffe5da \"bill\" (gdb) c Continuing. 姓名1 = cici 姓名2 = bill 姓名3 = mary 程式即將結束 [Inferior 1 (process 22467) exited normally] (gdb)"
  },"/pages/c/compile/makefile/": {
    "title": "makefile",
    "keywords": "",
    "url": "/pages/c/compile/makefile/",
    "body": "編譯c++ 原理 將原始檔案變成執行檔，以下把這個過程分為二個步驟。 首先將個別原始檔(.cpp)編譯成個別目的檔(object file)，目的檔的內容是可被電腦執行的機器語言指令。 第二步便是鏈結(linking)，將上一步好幾個原始檔案編譯完後有多個目的檔，由於原始檔案中會用到c++的函式庫指令，如std::cout，將多個目的檔與函式庫機器語言指令全部鏈結一起，就形成可執行檔。 gcc與g++分別 gcc編譯c g++編譯c++ g++語法 g++ -o 執行檔名 原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 常用選項: -o 設定\"執行檔名\" -std=c++11 支援c++11 -c 只編譯，不鏈結 產生執行檔 建立檔案 $ vi hello.cpp 將以下的內容貼上 1 2 3 4 5 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; } 產生執行檔 $ g++ -o demo hello.cpp 執行 $ ./demo Hello world! 沒有-o 執行檔名 沒有-o 執行檔名，會產生a.out的檔案 $ g++ hello.cpp $ ls a.out 使用2個cpp產生執行檔 $ vi public.h 1 2 #include &lt;iostream&gt; void func(); $ vi public.cpp 1 2 3 4 5 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"call func()\" &lt;&lt; endl; } $ vi hello.cpp 1 2 3 4 5 6 7 #include &lt;iostream&gt; #include \"public.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); } $ g++ -o demo hello.cpp public.cpp $ ./demo Hello world! call func() 靜態庫 將cpp檔案整理成一個程式庫，產生執行檔可以指定庫名.a，就不用寫很多原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 多個process(行程)用到同一個靜態庫中的函式或類別，每個process(行程)拷貝一份，多個process(行程)就有多個拷貝。 靜態庫是二進位檔案(機器語言指令) 主程式在鏈結時會把靜態庫加入，產生執行檔。 若某個靜態庫更新了，所有使用它的程式都需要重新編譯。 語法 g++ -c -o lib庫名.a 原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp -c -c 只編譯，不鏈結 lib庫名.a .a代表靜態庫 lib是固定 庫名可以自由變換 檔案放置路徑 cici@cici-vm:~/test$ tree . ├── app │   └── hello.cpp └── tools ├── public.cpp └── public.h 3 directories, 3 files 將以下檔案依上方目錄結構放置。 public.h 1 2 3 4 5 6 #include &lt;iostream&gt; void func(); class Student { public: void print(); }; public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"call func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"msg....\" &lt;&lt; endl; } hello.cpp 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; #include \"../tools/public.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); } 產生靜態庫 進入tools目錄 $ cd tools 產生靜態庫 $ g++ -c -o libpublic.a public.cpp 使用靜態庫 法1 回到上層 $ cd.. 產生demo01執行檔，原始檔案有libpublic.a的靜態庫 $ g++ -o demo01 app/hello.cpp tools/libpublic.a 執行 $ ./demo01 法2 語法 g++ -o 執行檔名 原始檔案1.cpp -L 靜態庫目錄位址 -l 庫名 $ g++ -o demo01 app/hello.cpp -L tools -l public 動態庫 語法 g++ -fPIC -shared -o lib庫名.so 來源檔案1.cpp -fPIC -shared 這二句代表製作動態庫 -o 產生檔案 lib庫名.so lib與.so是固定寫法，庫名可以自已取名。 $ cd tools $ g++ -fPIC -shared -o libpublic.so public.cpp 使用動態庫 將cpp檔案整理成一個庫，產生執行檔可以指定庫名.so，就不用寫很多原始檔案1.cpp 原始檔案2.cpp 原始檔案3.cpp 原始檔案N.cpp 動態庫是二進位檔案 多個procee用到同一個動態庫中的函式或類別，在記憶體中只有一份，多個process共享相同程式碼，也稱共享庫，因為只有一份程式碼，不會占用記憶體。 主程式在執行時，才把動態庫程式碼載入到記憶體。 優點，動態庫更新，有用到動態庫的程式不用重新編譯，只需要更新動態庫。 動態庫與靜態庫同時存在，優先使用動態庫。 法1 $ g++ -o demo01 app/hello.cpp tools/libpublic.so $ ./demo01 法2 先增加LD_LIBRARY_PATH環境變數，設定放置動態庫的目錄 $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/cici/test/tools $ g++ -o demo01 app/hello.cpp -L tools -l public $ ./demo01 -L 動態庫目錄位址 -l 庫名 模擬更新動態庫 將public.cpp的程式碼更新。 增加update的字 public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"update all func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"update msg....\" &lt;&lt; endl; } 重新建立動態庫 $ cd tools $ g++ -fPIC -shared -o libpublic.so public.cpp 執行主程式 $ ./demo01 Hello world! update call func() update msg.... 總結 以上的過程，都不必重新編譯主程式。 makefile 建立makefile $ cd tools $ vi makefile 產生靜態庫,動態庫 用空格分開 all: libpublic.a libpublic.so 換行用\\ 注意！第二行是用tab，不是空格 all: libpublic.a \\ libpublic.so 動態庫或靜態庫中的cpp更新，重新編譯 編譯靜態庫libpublic.a，需要依賴public.h和public.cpp 若public.h或public.cpp更新，需要重新編譯 注意！第二行是用tab，不是空格 libpublic.a:public.h public.cpp g++ -c -o libpublic.a public.cpp 編譯動態庫libpublic.so，需要依賴public.h和public.cpp 若public.h或public.cpp更新，需要重新編譯 注意！第二行是用tab，不是空格 libpublic.so:public.h public.cpp g++ -fPIC -shared -o libpublic.so public.cpp clean刪除編譯完的檔案 clean: rm -f libpublic.a libpublic.so 使用makefile 清理 語法 make clean cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h cici@cici-vm:~/test/tools$ make clean rm -f libpublic.a libpublic.so cici@cici-vm:~/test/tools$ ls makefile public.cpp public.h 產生靜態庫,動態庫 語法 make cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp g++ -fPIC -shared -o libpublic.so public.cpp cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h 若沒有修改任何.cpp或.h，再次make不會進行動作 cici@cici-vm:~/test/tools$ make make: 對「all」無需做任何事。 修改public.cpp 將\"update\"改成\"update2\" public.cpp 1 2 3 4 5 6 7 8 #include \"public.h\" using namespace std; void func() { cout &lt;&lt; \"update2 all func()\" &lt;&lt; endl; } void Student::print() { cout &lt;&lt; \"update2 msg....\" &lt;&lt; endl; } 若有更改.cpp，make就會重新編譯 cici@cici-vm:~/test/tools$ vi public.cpp cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp g++ -fPIC -shared -o libpublic.so public.cpp 若刪除靜態檔，再make，就會重新產生靜態檔 cici@cici-vm:~/test/tools$ rm libpublic.a cici@cici-vm:~/test/tools$ make g++ -c -o libpublic.a public.cpp cici@cici-vm:~/test/tools$ ls libpublic.a libpublic.so makefile public.cpp public.h 多動態庫使用 建立myapi庫 回到最上層目錄，建立api的目錄，並在api目錄中，建立myapi.h $ mkdir api $ cd api $ vi myapi.h 路徑如下 cici@cici-vm:~/test$ tree . ├── api │   ├── makefile │   ├── myapi.cpp │   └── myapi.h ├── app │   ├── demo01 │   ├── hello │   ├── hello.cpp │   └── makefile ├── makefile └── tools ├── libpublic.a ├── libpublic.so ├── makefile ├── public.cpp └── public.h myapi.h 1 2 3 4 5 6 #include &lt;iostream&gt; void func1(); class Teacher { public: void print(); }; myapi.cpp 1 2 3 4 5 6 7 8 #include \"myapi.h\" using namespace std; void func1() { cout &lt;&lt; \"call func1()\" &lt;&lt; endl; } void Teacher::print() { cout &lt;&lt; \"teacher ... msg ...\" &lt;&lt; endl; } 進入api目錄，並建立makefile 1 2 3 4 5 6 7 all:libmyapi.a libmyapi.so libmyapi.a:myapi.h myapi.cpp g++ -c -o libmyapi.a myapi.cpp libmyapi.so:myapi.h myapi.cpp g++ -fPIC -shared -o libmyapi.so myapi.cpp clean: rm -f libmyapi.a libmyapi.so cici@cici-vm:~/test/api$ make g++ -c -o libmyapi.a myapi.cpp g++ -fPIC -shared -o libmyapi.so myapi.cpp app目錄下的hello.cpp修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include \"../tools/public.h\" #include \"../api/myapi.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); //新增修改 func1(); Teacher teacher; teacher.print(); } api目錄加到LD_LIBRARY_PATH $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/cici/test/api 回到test目錄下，執行以下語句，設定myapi動態檔放置的目錄(-L)與庫名(-l) $ g++ -o demo01 app/hello.cpp -L tools -l public -L api -l myapi $ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... -I 修改hello.cpp的include public.h與myapi.h路徑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include \"public.h\" #include \"myapi.h\" using namespace std; int main() { cout &lt;&lt; \"Hello world!\\n\"; func(); Student student; student.print(); //新增修改 func1(); Teacher teacher; teacher.print(); } 使用-I，指定.h檔案的路徑 cici@cici-vm:~/test$ g++ -o demo01 app/hello.cpp -L tools -l public -L api -l myapi -I /home/cici/test/tools -I /home/cici/test/api cici@cici-vm:~/test$ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... 為demo01寫makefile 路徑如下 cici@cici-vm:~/test$ tree . ├── api │   ├── libmyapi.a │   ├── libmyapi.so │   ├── makefile │   ├── myapi.cpp │   └── myapi.h ├── app │   ├── demo01 │   ├── hello │   ├── hello.cpp │   └── makefile ├── makefile └── tools ├── libpublic.a ├── libpublic.so ├── makefile ├── public.cpp └── public.h 在/home/cici/test目錄下撰寫的makefile: 1 2 3 4 5 all:demo01 demo01:app/hello.cpp g++ -o demo01 app/hello.cpp -L /home/cici/test/tools -l public -L /home/cici/test/api -l myapi -I /home/cici/test/tools -I /home/cici/test/api clean: rm -f demo01 在/home/cici/test/app目錄下撰寫的makefile: 1 2 3 4 5 all:demo01 demo01:hello.cpp g++ -o demo01 hello.cpp -L /home/cici/test/tools -l public -L /home/cici/test/api -l myapi -I /home/cici/test/tools -I /home/cici/test/api clean: rm -f demo01 多個檔案 在makefile定義變數 INCLUDEDIR=-I /home/cici/test/tools -I /home/cici/test/api LIBDIR=-L /home/cici/test/tools -L /home/cici/test/api 使用變數 $(變數) 多個檔案 1 2 3 4 5 6 7 8 9 10 11 INCLUDEDIR=-I /home/cici/test/tools -I /home/cici/test/api LIBDIR=-L /home/cici/test/tools -L /home/cici/test/api all:demo01 demo02 demo03 demo01:hello.cpp g++ -o demo01 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi demo02:hello.cpp g++ -o demo02 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi demo03:hello.cpp g++ -o demo03 hello.cpp $(INCLUDEDIR) $(LIBDIR) -l public -l myapi clean: rm -f demo01 demo02 demo03 $ vi makefile $ make g++ -o demo02 hello.cpp -I /home/cici/test/tools -I /home/cici/test/api -L /home/cici/test/tools -L /home/cici/test/api -l public -l myapi g++ -o demo03 hello.cpp -I /home/cici/test/tools -I /home/cici/test/api -L /home/cici/test/tools -L /home/cici/test/api -l public -l myapi $ ls demo01 demo02 demo03 hello hello.cpp makefile $ vi makefile $ ./demo01 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ ./demo02 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ ./demo03 Hello world! update2 call func() update2 msg.... call func1() teacher ... msg ... $ make clean rm -f demo01 demo02 demo03 $ ls hello hello.cpp makefile"
  },"/pages/c/c11/init_list/": {
    "title": "初始化initializer list",
    "keywords": "",
    "url": "/pages/c/c11/init_list/",
    "body": "Prerequisites: 維基介紹 初始化串列 整數 c++11用大括號{},等於號可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; int main() { int a = 10; // c++98,用圓括號() int b = (10); int c(10); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //c++11用大括號{},等於號可省略 int d = {10}; int e{10}; cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; \"e = \" &lt;&lt; e &lt;&lt; endl; return 0; } a = 10 b = 10 c = 10 d = 10 e = 10 可以用 =、() 或 {}，以下用法都對 1 2 3 4 5 6 int x = 3; int x(3); int x{3}; string name(\"Some Name\"); string name = \"Some Name\"; string name{\"Some Name\"}; 浮點數 1 2 double f{1.12}; cout &lt;&lt; \"f = \" &lt;&lt; f &lt;&lt; endl; f = 1.12 此外，{} 初始列不允許整數型別的縮小 (narrowing) 轉換，這可以用來避免一些型別上的程式撰寫錯誤。 1 2 int pi(3.14); // 可 -- pi == 3. int pi{3.14}; // 編譯器錯誤：縮小轉換 陣列 1 2 3 4 5 //陣列 int arr1[5]{1, 2, 3, 4, 5}; for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 arr1[4] = 5 new動態分配記憶體位址 1 2 3 4 int *arr_p = new int[5]{11, 12, 13, 14, 15}; for (int i = 0; i &lt; 5; i++) { cout &lt;&lt; \"arr_p[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr_p[i] &lt;&lt; endl; } arr_p[0] = 11 arr_p[1] = 12 arr_p[2] = 13 arr_p[3] = 14 arr_p[4] = 15 建立物件 c++11用大括號{},等於號可省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: Student(int number, string name) : number(number), name(name){} private: int number; // 學號 string name; }; int main() { // c98 Student s1(10122, \"Bill\"); // c11 Student s2 = {10123, \"Mary\"}; //c11 省略等於號 Student s3{10124, \"Alice\"}; return 0; } 初始化容器 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { // 把v1初始化為10個元素 vector&lt;int&gt; v1(10); // v2只有1個元素10 vector&lt;int&gt; v2{10}; // v3有3個元素，分別是11 12 13 vector&lt;int&gt; v3{11, 12, 13}; return 0; } 1 2 std::vector&lt;int&gt; v(100, 1); // vector 中有 100 個元素：每個元素都是 1 std::vector&lt;int&gt; v{100, 1}; // vector 中有 2 個元素：100 和 1 函式參數 可以把大括號{}間的值，作為參數傳給函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; int func1(initializer_list&lt;int&gt; init_list) { int total = 0; for (int val : init_list) { total += val; cout &lt;&lt; val &lt;&lt; \",\"; } cout &lt;&lt; endl; return total; } int main() { int total = func1({1, 2, 3, 4, 5}); cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl; return 0; } 1,2,3,4,5, total = 15 iterator initializer_list模板類別，跟容器一樣，提供begin()與end() 編譯 makefile 若在linux編譯時，需要加上-std=c++11 g++ -o c11_init c11_init.cpp -std=c++11"
  },"/pages/c/compile/gdb_attach_pid/": {
    "title": "gdb attach pid",
    "keywords": "",
    "url": "/pages/c/compile/gdb_attach_pid/",
    "body": "Debug正在運行的程式 建立測試檔案 以下檔案每一秒印出1個數字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; void func2(const string msg) { for (int i = 0; i &lt; 1000000; i++) { sleep(1); cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; } } void func1(const string msg) { func2(msg); } int main() { func1(\"test\"); return 0; } 執行以下程式 $ g++ -o demo03 core_test.cpp -g $ ./demo03 ssh 遠端登入另一個終端機 ssh cici@192.168.235.128 ps -ef 列出跟demo03有關的process id 黃色標註就是demo03的pid cici@cici-vm:~/test/app$ ps -ef |grep demo03 cici 27615 26646 0 10:01 pts/7 00:00:00 ./demo03 cici 27618 26755 0 10:02 pts/5 00:00:00 grep --color=auto demo03 sudo gdb -p 以user的身份執行以下指令 sudo gdb /home/cici/test/app/demo03 -p 27615 會發現正在運行的程式停住了，輸入q離開gdb，正在運行的程式繼續運作。 bt 列出呼叫函式的堆疊(call stack) 由下往上呼叫，最下面是main()呼叫func1()，func1()再呼叫func2(), func2()呼叫__sleep() (gdb) bt #0 0x0000702da76eca7a in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78 #1 0x0000702da76f9a27 in __GI___nanosleep (req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/nanosleep.c:25 #2 0x0000702da770ec63 in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55 #3 0x0000595ced2493ac in func2 (msg=\"test\") at core_test.cpp:7 #4 0x0000595ced249437 in func1 (msg=\"test\") at core_test.cpp:12 #5 0x0000595ced2494de in main () at core_test.cpp:15 set var 目前i = 282 i = 268 i = 269 i = 270 i = 271 i = 272 i = 273 i = 274 i = 275 i = 276 i = 277 i = 278 i = 279 i = 280 i = 281 i = 282 將執行時的變數修改成500，以下黃色則為要輸入的 (gdb) n 80 in ../sysdeps/unix/sysv/linux/clock_nanosleep.c (gdb) n 83 in ../sysdeps/unix/sysv/linux/clock_nanosleep.c (gdb) n __GI___nanosleep (req=req@entry=0x7ffdb28b2040, rem=rem@entry=0x7ffdb28b2040) at ../sysdeps/unix/sysv/linux/nanosleep.c:26 warning: 26 ../sysdeps/unix/sysv/linux/nanosleep.c: 沒有此一檔案或目錄 (gdb) n __sleep (seconds=0) at ../sysdeps/posix/sleep.c:62 warning: 62 ../sysdeps/posix/sleep.c: 沒有此一檔案或目錄 (gdb) n 64 in ../sysdeps/posix/sleep.c (gdb) n func2 (msg=\"test\") at core_test.cpp:8 8 cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; (gdb) set var i=500 (gdb) n 6 for (int i = 0; i &lt; 1000000; i++) { (gdb) 另一個視窗已經變成 i = 268 i = 269 i = 270 i = 271 i = 272 i = 273 i = 274 i = 275 i = 276 i = 277 i = 278 i = 279 i = 280 i = 281 i = 282 i = 500"
  },"/pages/c/stl/pair/": {
    "title": "pair",
    "keywords": "",
    "url": "/pages/c/stl/pair/",
    "body": "Prerequisites: 函式模板 initializer list pair模板與make pair模板 pair模板 1 2 3 4 5 6 7 8 9 10 template &lt;class T1, class T2&gt; struct pair { T1 first; // key T2 second; // value。 pair(); // 建構子 pair(const T1 &amp;val1,const T2 &amp;val2); // 有二個參數建構子 pair(const pair&lt;T1,T2&gt; &amp;p); // 拷貝函式 void swap(pair&lt;T1,T2&gt; &amp;p); // 交換pair }; make pair模板 匿名物件 呼叫pair的二個參數建構子，傳回pair的匿名物件 1 2 3 4 5 template &lt;class T1, class T2&gt; make_pair(const T1 &amp;first,const T2 &amp;second) { return pair&lt;T1,T2&gt;(first, second); } 使用pair 呼叫2個參數的建構子 呼叫2個參數的建構子 1 2 3 4 5 6 7 #include &lt;iostream&gt; using namespace std; int main() { pair&lt;int,string&gt; p1(1,\"cici\"); cout &lt;&lt; \"p1 first = \" &lt;&lt; p1.first &lt;&lt; \", second = \" &lt;&lt; p1.second &lt;&lt; endl; return 0; } p1 first = 1, second = cici 使用initializer list { 2, “Bill” } 為匿名物件。 1 2 pair&lt;int,string&gt; p2 = {2, \"Bill\"}; cout &lt;&lt; \"p2 first = \" &lt;&lt; p2.first &lt;&lt; \", second = \" &lt;&lt; p2.second &lt;&lt; endl; p2 first = 2, second = Bill 呼叫拷貝函式 先建立匿名物件，呼叫2個參數建構子 再用拷貝函式，把匿名物件設給p3 1 2 pair&lt;int,string&gt; p3 = pair&lt;int,string&gt;(3, \"Jeff\"); cout &lt;&lt; \"p3 first = \" &lt;&lt; p3.first &lt;&lt; \", second = \" &lt;&lt; p3.second &lt;&lt; endl; p3 first = 3, second = Jeff makepair 以下是c++14運行的結果 先建立匿名物件，呼叫2個參數建構子 再用拷貝函式，把匿名物件拷貝到傳回值 再用拷貝函式，把傳回值拷貝到p4 1 2 pair&lt;int,string&gt; p4 = make_pair&lt;int,string&gt;(4, \"Ann\"); cout &lt;&lt; \"p4 first = \" &lt;&lt; p4.first &lt;&lt; \", second = \" &lt;&lt; p4.second &lt;&lt; endl; p4 first = 4, second = Ann"
  },"/pages/c/stl/map/": {
    "title": "map",
    "keywords": "",
    "url": "/pages/c/stl/map/",
    "body": "Prerequisites: pair initializer list iterator map介紹 include #include &lt;map&gt; map的值是pair map是以紅黑樹(AVL tree)排序，所以把map的值印出來會是以排序好的方式印出。 初始化 語法 map(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 1 2 3 4 5 6 7 8 9 10 11 12 13 // 建立空的map map&lt;int, string&gt; m1; // 使用initializer初始化值 // map(initializer_list&lt;pair&lt;K,V&gt;&gt;) map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; // 省略等於號寫法 // map&lt;int,string&gt; m2 { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; // 使用括號 // map&lt;int,string&gt; m2({ {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }); for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 使用[]印出元素 1 2 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"m2[10] = \" &lt;&lt; m2[10] &lt;&lt; endl; m2[10] = Mary 若key不存在map中，則會新增空值 1 2 3 4 5 6 7 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"m2[10] = \" &lt;&lt; m2[10] &lt;&lt; endl; cout &lt;&lt; \"m2[22] = \" &lt;&lt; m2[22] &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2[10] = Mary m2[22] = 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 22, 新增修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; // 新增 m2[5] = \"Eva\"; m2[4] = \"Iric\"; // 修改 m2[10] = \"Yoyo\"; m2[9] = \"Momo\"; cout &lt;&lt; \"修改後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 修改後 4,Iric 5,Eva 6,Ken 7,Alice 8,Juli 9,Momo 10,Yoyo 插入insert 傳回值為void 語法 void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2.insert({ {1, \"Ben\"}, {2, \"Cindy\"}, {3, \"Rita\"} }); cout &lt;&lt; \"插入後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 插入後 1,Ben 2,Cindy 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 若插入的key已存在map中，則不會插入，也不會提示錯誤 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; cout &lt;&lt; \"修改前\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; m2.insert({ {10, \"Ben\"}, {9, \"Cindy\"}, {3, \"Rita\"} }); cout &lt;&lt; \"插入後\" &lt;&lt; endl; for (auto&amp; val:m2) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 修改前 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 插入後 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill 10,Mary 傳回值為pair 語法 pair&lt;iterator,bool&gt; insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 傳回值pair:first已插入的元素的iterator，second是插入的結果 1 2 3 4 5 6 7 8 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; auto ret = m2.insert({5, \"Julia\"}); if (ret.second == true) { cout &lt;&lt; \"成功\" &lt;&lt; \", first = \" &lt;&lt; ret.first-&gt;first &lt;&lt; \", second = \" &lt;&lt; ret.first -&gt; second &lt;&lt; endl; } else { cout &lt;&lt; \"失敗\" &lt;&lt; endl; } 成功, first = 5, second = Julia 使用emplace pair&lt;iterator,bool&gt; emplace(initializer_list&lt;pair&lt;K,V&gt;&gt; il); 傳回值跟先前的一樣，不同的是使用emplace可以原地建構。 使用iterator建立map 1 2 3 4 5 6 7 8 9 10 11 12 map&lt;int,string&gt; m2 = { {10, \"Mary\"}, {9, \"Bill\"}, {7, \"Alice\"}, {8, \"Juli\"}, {6, \"Ken\"} }; m2.insert({ {1, \"Ben\"}, {2, \"Cindy\"}, {3, \"Rita\"} }); // 使用iterator建立map auto first = m2.begin(); first++; auto last = m2.end(); last--; map&lt;int, string&gt; m3(first, last); for (auto &amp; val:m3) { cout &lt;&lt; val.first &lt;&lt; \",\" &lt;&lt; val.second &lt;&lt; \" \"; } cout &lt;&lt; endl; 2,Cindy 3,Rita 6,Ken 7,Alice 8,Juli 9,Bill"
  },"/pages/c/string/string_convert/": {
    "title": "string convert",
    "keywords": "",
    "url": "/pages/c/string/string_convert/",
    "body": "Prerequisites: string to_string 將整數轉成string 1 2 string str = to_string(2022 + 23); cout &lt;&lt; \"str = \" &lt;&lt; str &lt;&lt; endl; str = 2045 string to char指標 1 2 3 4 5 6 7 8 9 10 11 // char指標陣列 #include &lt;iostream&gt; using namespace std; int main() { char* arr[10]; arr[0] = (char*)\"test\"; arr[1] = (char*)\"/123\"; cout &lt;&lt; \"arr[0] = \" &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; \"arr[1] = \" &lt;&lt; arr[1] &lt;&lt; endl; return 0; } arr[0] = test arr[1] = /123 const string to char指標 strcpy c_str c_str()是取得string物件位址 1 2 3 4 const string title = \"被討厭的勇氣\"; char* s = new char[100]; strcpy(s, title.c_str()); cout &lt;&lt; \"s = \" &lt;&lt; s &lt;&lt; endl; s = 被討厭的勇氣 char* to string 字串連接 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { // 有const char* const char* c_s1 = \"Hello world!\"; // 沒const char* char* c_s2 = \" Hi! Mary!\"; // 把其中一個char*變成string，就可以套用operator+= (const char* s) string s1 = string(c_s1) + c_s2; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; return 0; } s1 = Hello world! Hi! Mary!"
  },"/pages/c/time/time/": {
    "title": "time",
    "keywords": "",
    "url": "/pages/c/time/time/",
    "body": "取得從1970/01/01至今累加的秒數，以長整數(long)存放此秒數。 取得現在時間 include語法 #include &lt;time.h&gt; 語法 time_t time(time_t *tloc); 參數代入nullptr = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;time.h&gt; using namespace std; int main() { // 方式1 // 把nullptr也就是0作為參數代入time()函式 time_t now = time(0); cout &lt;&lt; \"now = \" &lt;&lt; now &lt;&lt; endl; // 方式2 // 將now2的位址作為參數代入time()函式 time_t now2; time(&amp;now2); cout &lt;&lt; \"now2 = \" &lt;&lt; now2 &lt;&lt; endl; return 0; } now = 1733883906 now2 = 1733883906 tm結構 1 2 3 4 5 6 7 8 9 10 11 12 struct tm { int tm_year; // 年份：其值等於實際年份減去1900 int tm_mon; // 月份：取值區間為[0,11]，其中0代表一月，11代表12月 int tm_mday; // 日期：一個月中的日期，取值區間為[1,31] int tm_hour; // 時：取值區間為[0,23] int tm_min; // 分：取值區間為[0,59] int tm_sec; // 秒：取值區間為[0,59] int tm_wday; // 星期：取值區間為[0,6]，其中0代表星期日，6代表星期六 int tm_yday; // 從每年的1月1日開始算起的天數：取值區間為[0,365] int tm_isdst; // 夏令時標識符，此欄位意義不大 }; localtime string append to_string() 將time_t整數轉成tm結構 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;time.h&gt; using namespace std; int main() { time_t now = time(0); tm tmnow; localtime_r(&amp;now, &amp;tmnow); string time_str = to_string(tmnow.tm_year + 1900) + \"/\" + to_string(tmnow.tm_mon + 1) + \"/\" + to_string(tmnow.tm_mday) + \" \" + to_string(tmnow.tm_hour) + \":\" + to_string(tmnow.tm_min) + \":\" + to_string(tmnow.tm_sec); cout &lt;&lt; \"time_str = \" &lt;&lt; time_str &lt;&lt; endl; return 0; } time_str = 2024/12/11 11:48:45 計算執行時間 gettimeofday include #include &lt;sys/time.h&gt; 語法 int gettimeofday(struct timeval *tv, struct timezone *tz); 用到的參數結構 struct timeval { time_t tv_sec; // 1970-01-01開始的秒數 suseconds_t tv_usec; // 表示微秒（1秒 = 1000000微秒） }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include &lt;iostream&gt; #include &lt;sys/time.h&gt; using namespace std; int main() { timeval start, end; // 開始計時 gettimeofday(&amp;start, nullptr); for (int i = 0; i &lt; 1000000; i++); // 結束計時 gettimeofday(&amp;end, nullptr); // 儲存耗時的秒數與微秒 timeval t_val; // end微秒與start微秒相減 t_val.tv_usec = end.tv_usec - start.tv_usec; // end秒數與start秒數相減 t_val.tv_sec = end.tv_sec - start.tv_sec; // 若end微秒與start微秒相減為負數 if (t_val.tv_usec &lt; 0) { // 將負的微秒轉正 // 使用固定公式 tv_usec = 1000000 + tv_usec // 例如：若 tv_usec = -200，則變為 tv_usec = 1000000 - 200 = 999800。 t_val.tv_usec = 1000000 + t_val.tv_usec; // 同時，從秒部分（tv_sec）中減去 1，補償這多出的一秒。 t_val.tv_sec--; } cout &lt;&lt; \"耗費:\" &lt;&lt; t_val.tv_sec &lt;&lt; \"秒\" &lt;&lt; t_val.tv_usec &lt;&lt; \"微秒。\" &lt;&lt; endl; // 假設 // 開始時間為 start = {tv_sec = 10, tv_usec = 500000}， // 結束時間為 end = {tv_sec = 12, tv_usec = 300000}。 // 則： // 初始計算： // tv_usec = 300000 - 500000 = -200000 // tv_sec = 12 - 10 = 2 // 微秒補正： // tv_usec = 1000000 - 200000 = 800000 // tv_sec = 2 - 1 = 1 // 最終結果： // tv_sec = 1 // tv_usec = 800000 // 表示耗時 1秒800毫秒。 return 0; } 耗費:0秒1213微秒。"
  },"/pages/c/libc/errno/": {
    "title": "取得錯誤訊息",
    "keywords": "",
    "url": "/pages/c/libc/errno/",
    "body": "errno errno是C函式庫(libc)中的全域變數，記錄使用C函式庫過程中產生的錯誤編號 strerror strerror()用於取得errno的錯誤詳細訊息。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { // 印出errno以及錯誤詳細訊息 for (int i = 0; i &lt; 110; i++) { cout &lt;&lt; \"errno = \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; strerror(i) &lt;&lt; endl; } return 0; } errno = 0, Undefined error: 0 errno = 1, Operation not permitted errno = 2, No such file or directory errno = 3, No such process errno = 4, Interrupted system call errno = 5, Input/output error errno = 6, Device not configured errno = 7, Argument list too long errno = 8, Exec format error errno = 9, Bad file descriptor errno = 10, No child processes errno = 11, Resource deadlock avoided errno = 12, Cannot allocate memory errno = 13, Permission denied errno = 14, Bad address errno = 15, Block device required errno = 16, Resource busy errno = 17, File exists errno = 18, Cross-device link errno = 19, Operation not supported by device errno = 20, Not a directory errno = 21, Is a directory errno = 22, Invalid argument errno = 23, Too many open files in system errno = 24, Too many open files errno = 25, Inappropriate ioctl for device errno = 26, Text file busy errno = 27, File too large errno = 28, No space left on device errno = 29, Illegal seek errno = 30, Read-only file system errno = 31, Too many links errno = 32, Broken pipe errno = 33, Numerical argument out of domain errno = 34, Result too large errno = 35, Resource temporarily unavailable errno = 36, Operation now in progress errno = 37, Operation already in progress errno = 38, Socket operation on non-socket errno = 39, Destination address required errno = 40, Message too long errno = 41, Protocol wrong type for socket errno = 42, Protocol not available errno = 43, Protocol not supported errno = 44, Socket type not supported errno = 45, Operation not supported errno = 46, Protocol family not supported errno = 47, Address family not supported by protocol family errno = 48, Address already in use errno = 49, Can't assign requested address errno = 50, Network is down errno = 51, Network is unreachable errno = 52, Network dropped connection on reset errno = 53, Software caused connection abort errno = 54, Connection reset by peer errno = 55, No buffer space available errno = 56, Socket is already connected errno = 57, Socket is not connected errno = 58, Can't send after socket shutdown errno = 59, Too many references: can't splice errno = 60, Operation timed out errno = 61, Connection refused errno = 62, Too many levels of symbolic links errno = 63, File name too long errno = 64, Host is down errno = 65, No route to host errno = 66, Directory not empty errno = 67, Too many processes errno = 68, Too many users errno = 69, Disc quota exceeded errno = 70, Stale NFS file handle errno = 71, Too many levels of remote in path errno = 72, RPC struct is bad errno = 73, RPC version wrong errno = 74, RPC prog. not avail errno = 75, Program version wrong errno = 76, Bad procedure for program errno = 77, No locks available errno = 78, Function not implemented errno = 79, Inappropriate file type or format errno = 80, Authentication error errno = 81, Need authenticator errno = 82, Device power is off errno = 83, Device error errno = 84, Value too large to be stored in data type errno = 85, Bad executable (or shared library) errno = 86, Bad CPU type in executable errno = 87, Shared library version mismatch errno = 88, Malformed Mach-o file errno = 89, Operation canceled errno = 90, Identifier removed errno = 91, No message of desired type errno = 92, Illegal byte sequence errno = 93, Attribute not found errno = 94, Bad message errno = 95, EMULTIHOP (Reserved) errno = 96, No message available on STREAM errno = 97, ENOLINK (Reserved) errno = 98, No STREAM resources errno = 99, Not a STREAM errno = 100, Protocol error errno = 101, STREAM ioctl timeout errno = 102, Operation not supported on socket errno = 103, Policy not found errno = 104, State not recoverable errno = 105, Previous owner died errno = 106, Interface output queue is full errno = 107, Unknown error: 107 errno = 108, Unknown error: 108 errno = 109, Unknown error: 109 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // perror() head file #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file #include &lt;sys/stat.h&gt; // mkdir的head file using namespace std; int main() { int ret = mkdir(\"/tmp/aaa\", 0777); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } 執行第1次成功 ret = 0 0:Success 執行第2次失敗 ret = -1 17:File exists perror 傳回系統錯誤訊息，比起strerror(errno)，參數不用代入errno，代入的參數為使用者自訂的前綴字。 include #include &lt;unistd.h&gt; // perror() head file void perror ( const char * str ) 參數str 先輸出字串str，後面跟著一個冒號，然後是一個空格，然後才是錯誤訊息。 將先前的程式碼strerror改成perror 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file #include &lt;sys/stat.h&gt; // mkdir的head file using namespace std; int main() { int ret = mkdir(\"/tmp/aaa\", 0777); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; // cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; perror(\"msg\"); return 0; } ret = -1 msg: File exists"
  },"/pages/c/libc/file_io/": {
    "title": "檔案目錄操作",
    "keywords": "",
    "url": "/pages/c/libc/file_io/",
    "body": "Prerequisites: 在linux編譯c++ 以下的程式碼，請在linux下編譯執行。 取得目前目錄 getcwd取得目前目錄 include #include &lt;unistd.h&gt; 語法 char* getcwd(char *buf, size_t size); 參數 buf 路徑的儲存位置。 size 路徑的最大長度 get_current_dir_name 語法 char* get_current_dir_name(void) 沒有參數，不用帶入buf路徑儲存位置跟最大長度 注意事項: get_current_dir_name()是以malloc()建立，需要使用free()釋放記憶體 mac xcode無法編譯，需在linux下編譯。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { // 方法1 // 路徑，linux路徑最大長度為256 char path1[256]; // 參數1，路徑 // 參數2，路徑最大長度 getcwd(path1,256); cout &lt;&lt; \"path1 = \" &lt;&lt; path1 &lt;&lt; endl; //方法2 char* path2 = get_current_dir_name(); cout &lt;&lt; \"path2 = \" &lt;&lt; path2 &lt;&lt; endl; // get_current_dir_name()是以malloc()建立 // 需要使用free()釋放記憶體 free(path2); return 0; } mkdir include &lt;sys/stat.h&gt; 語法 int mkdir(const char *pathname, mode_t mode); 參數 pathname: 目錄名 mode: 目錄的權限 函數說明： mkdir()函數以mode方式建立以參數pathname命名的目錄，mode定義新建立目錄的權限。 傳回值： 若目錄建立成功，則傳回0；否則傳回-1，並將錯誤記錄到全域變數errno。 mode方式： 要4個數字，最前面要有0，如0755，0700，0644 鳥哥 改變權限, chmod 檔案權限的改變使用的是chmod這個指令，但是，權限的設定方法有兩種， 分別可以使用數字或者是符號來進行權限的變更。我們就來談一談： 數字類型改變檔案權限 Linux檔案的基本權限就有九個，分別是owner/group/others三種身份各有自己的read/write/execute權限， 先複習一下剛剛上面提到的資料：檔案的權限字元為：『-rwxrwxrwx』， 這九個權限是三個三個一組的！其中，我們可以使用數字來代表各個權限，各權限的分數對照表如下： r:4 w:2 x:1 每種身份(owner/group/others)各自的三個權限(r/w/x)分數是需要累加的，例如當權限為： [-rwxrwx---] 分數則是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= --- = 0+0+0 = 0 那如果要將權限變成『 -rwxr-xr-- 』呢？那麼權限的分數就成為 [4+2+1][4+0+1][4+0+0]=754 囉！所以你需要下達『 chmod 754 filename』。 另外，在實際的系統運作中最常發生的一個問題就是，常常我們以vim編輯一個shell的文字批次檔後，他的權限通常是 -rw-rw-r-- 也就是664， 如果要將該檔案變成可執行檔，並且不要讓其他人修改此一檔案的話， 那麼就需要-rwxr-xr-x這樣的權限，此時就得要下達：『 chmod 755 test.sh 』的指令囉！ 另外，如果有些檔案你不希望被其他人看到，那麼應該將檔案的權限設定為例如：『-rwxr-----』，那就下達『 chmod 740 filename 』吧！ 程式碼 1 2 3 4 5 6 7 8 #include &lt;iostream&gt; #include &lt;sys/stat.h&gt; // mkdir的head file using namespace std; int main() { int ret = mkdir(\"/tmp/aaa\", 0777); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; return 0; } ret = 0"
  },"/pages/c/libc/kill/": {
    "title": "kill",
    "keywords": "",
    "url": "/pages/c/libc/kill/",
    "body": "Prerequisites: 在linux編譯c++ signal fork linux提供kill指令向程序(process)發送訊號。 語法 int kill(pid_t pid, int sig); kill函式會將參數sig訊號傳給相關pid的程序(process)。 pid &gt; 0 傳給訊號給特定的pid程序。 pid = 0 傳給訊號父pid相關的程序，包含父pid程序，此父pid程序的所有子程序都會收到sig訊號 pid = -1 廣播所有process程序 以下程式碼不能用kill -9 父pid 使用以下二種方法測試 kill -15 父pid 或 ctrl+c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; using namespace std; void FatherExit(int sig) { // 怱略二次收到相同訊號 // 使用kill(0, 訊號)會發給子程序也會再次發給發送訊號的父程序自己 signal(SIGINT, SIG_IGN); // 怱略ctrl+c signal(SIGTERM, SIG_IGN); // 怱略kill -15 cout &lt;&lt; \"父程序離開， signal = \" &lt;&lt; sig &lt;&lt; endl; kill(0, SIGTERM); // 向全部的子程序發送15訊號，終止子程序 exit(0); // 父程序離開 } void ChildExit(int sig) { // 防止再次收到相同訊號 signal(SIGINT, SIG_IGN); // 怱略ctrl+c signal(SIGTERM, SIG_IGN); // 怱略kill -15 cout &lt;&lt; \"子程序 pid = \" &lt;&lt; getpid() &lt;&lt; \" 離開， signal = \" &lt;&lt; sig &lt;&lt; endl; exit(0); } int main() { // 略過全部訊號 for (int i = 0; i &lt;= 64; i++) signal(i, SIG_IGN); // 父程序要補捉的訊號 ctrl + c signal(SIGTERM, FatherExit); // 父程序要補捉kill -15 signal(SIGINT, FatherExit); while (true) { if (fork() &gt; 0) { // 建立子程序 // 父程序 sleep(5); // 睡5秒 continue; // 回到迴圈判斷式中重頭執行 } else { // 子程序 // 子程序要補捉的訊號 ctrl + c signal(SIGTERM, ChildExit); // 子程序要補捉kill -15 signal(SIGINT, ChildExit); while (true) { // 睡3秒 sleep(3); cout &lt;&lt; \"子程序 pid = \" &lt;&lt; getpid() &lt;&lt; \" 正在執行中...\" &lt;&lt; endl; } } } } 測試指令 $ps -ef | grep kill_test cici 156524 139698 0 15:32 pts/3 00:00:00 ./kill_test cici 156525 156524 0 15:32 pts/3 00:00:00 ./kill_test cici 156526 156524 0 15:32 pts/3 00:00:00 ./kill_test cici 156527 156524 0 15:32 pts/3 00:00:00 ./kill_test cici 156533 156524 0 15:32 pts/3 00:00:00 ./kill_test cici 156535 145543 0 15:32 pts/6 00:00:00 grep --color=auto kill_test $ kill -15 156524 執行結果 父程序收到15訊號後離開，下面的所有子程序全跟著離開。 子程序 pid = 156527 正在執行中... 子程序 pid = 156540 正在執行中... 子程序 pid = 156536 正在執行中... 子程序 pid = 156526 正在執行中... 子程序 pid = 156539 正在執行中... 子程序 pid = 156533 正在執行中... 子程序 pid = 156538 正在執行中... 子程序 pid = 156525 正在執行中... 父程序離開， signal = 15 子程序 pid = 156527 離開， signal = 15 子程序 pid = 156540 離開， signal = 15 子程序 pid = 156541 離開， signal = 15 子程序 pid = 156539 離開， signal = 15 子程序 pid = 156533 離開， signal = 15 子程序 pid = 156526 離開， signal = 15 子程序 pid = 156537 離開， signal = 15 子程序 pid = 156536 離開， signal = 15 子程序 pid = 156538 離開， signal = 15 以下是使用ctrl+c，測試結果，父程序收到2訊號後離開，下面的所有子程序全跟著離開。 子程序 pid = 156636 正在執行中... 子程序 pid = 156636 正在執行中... 子程序 pid = 156637 正在執行中... 子程序 pid = 156636 正在執行中... 子程序 pid = 156637 正在執行中... 子程序 pid = 156636 正在執行中... 子程序 pid = 156638 正在執行中... 子程序 pid = 156637 正在執行中... 子程序 pid = 156636 正在執行中... ^C父程序離開， signal = 2 子程序 pid = 156641 離開， signal = 2 子程序 pid = 156638 離開， signal = 15 子程序 pid = 156637 離開， signal = 15"
  },"/pages/c/libc/signal/": {
    "title": "signal訊號",
    "keywords": "",
    "url": "/pages/c/libc/signal/",
    "body": "Prerequisites: 在linux編譯c++ kill或killall給程序(process)傳送訊號(signal)，也可以使用c函式庫(libc)的kill()函式給程序(process)傳送訊號(signal)。 kill與killall kill 指令 用法：kill [選項] 功能：向特定的程序 ID (PID) 發送訊號（例如，結束程序）。 作用範圍：只能針對指定的程序 ID。 常見訊號： -9：強制終止程序（SIGKILL）。 -15：預設訊號，請求程序正常離開（SIGTERM）。。 kill -9 1234 # 終止 PID 為 1234 的程序 killall 指令 用法：killall [選項] 功能：根據程序名稱來終止所有匹配的程序。 作用範圍：針對同名的所有程序。 killall -9 nginx # 終止所有名為 \"nginx\" 的程序 常用的訊號: 訊號名 訊號值 發出訊號原因 SIGINT 2 ctrl+c停止程序 SIGKILL 9 強制終止程序 SIGSEGV 11 操作nullptr指標或超出陣列索引 SIGALRM 14 alarm()函式發出訊號 SIGTERM 15 kill後不加任何-編號，請求程序正常離開 SIGCHLD 17 子程序結束 signal函式 使用signal()函式收訊號，收到訊號後指派函式去處理。 include #include &lt;signal.h&gt; sighandler_t signal(int signum, sighandler_t handler); 參數: signum 設置要接收的訊號 handler 設置要處理訊號的函式 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func(int signum) { cout &lt;&lt; \"收到訊號 = \" &lt;&lt; signum &lt;&lt; endl; } int main() { // 收到1的訊號，執行func函式 signal(1, func); // 收到15的訊號，執行func函式 signal(15, func); for (int i = 0; ; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; sleep(1); } return 0; } 編譯並執行 $ g++ -o signal_test signal_test.cpp $ ./signal_test 打開另一個ssh連線到linux終端機，使用kill或killall傳送訊號1與訊號15 $ killall -1 signal_test $ killall -15 signal_test 查看原本編譯執行的終端機，可以看出有收到1與15的訊號 . . . i = 68 收到訊號 = 1 i = 69 i = 70 i = 71 i = 72 i = 73 i = 74 i = 75 i = 76 i = 77 i = 78 i = 79 i = 80 i = 81 收到訊號 = 15 i = 82 i = 83 i = 84 i = 85 i = 86 . . . ctrl+c終止程序 使用ctrl+c可以終止正在執行的程序，本頁範例皆為無限迴圈，需手動ctrl+c終止程序。 SIG_IGN忽略訊號 sighandler_t signal(int signum, sighandler_t handler); 參數: handler 設置要處理訊號的函式 SIG_IGN放在handler的位置。 增加一行，怱略2的訊號 // 收到2的訊號，不要執行func函式，SIG_IGN是忽略訊號 signal(2, SIG_IGN); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func(int signum) { cout &lt;&lt; \"收到訊號 = \" &lt;&lt; signum &lt;&lt; endl; } int main() { // 收到1的訊號，執行func函式 signal(1, func); // 收到15的訊號，執行func函式 signal(15, func); // 收到2的訊號，不要執行func函式，SIG_IGN是略過訊號 signal(2, SIG_IGN); for (int i = 0; ; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; sleep(1); } return 0; } 編譯執行 使用killall指令發送訊號 killall -2 signal_test SIG_DFL恢復 sighandler_t signal(int signum, sighandler_t handler); 參數: handler 設置要處理訊號的函式 若原本是有透過signal()函式處理某個訊號，也可以使用SIG_DFL恢復原本收到訊息的狀況 SIG_DFL放在handler的位置。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func(int signum) { cout &lt;&lt; \"收到訊號 = \" &lt;&lt; signum &lt;&lt; endl; // 恢復原本15訊號，程式不再接收15訊號 signal(15, SIG_DFL); } int main() { // 收到15的訊號，執行func函式 signal(15, func); for (int i = 0; ; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; sleep(1); } return 0; } 編譯執行 發送第一次15訊號 $ killall -15 signal_test 執行結果 i = 0 i = 1 i = 2 i = 3 i = 4 i = 5 i = 6 i = 7 i = 8 i = 9 i = 10 i = 11 i = 12 i = 13 i = 14 i = 15 i = 16 收到訊號 = 15 i = 17 發送第二次15訊號 $ killall -15 signal_test 執行結果 i = 13 i = 14 i = 15 i = 16 收到訊號 = 15 i = 17 i = 18 i = 19 i = 20 終止 由執行結果可以發現，第2次發送訊號是正常終止程序。 無法收到與略過的訊號 以下三種都是無法收到與略過的訊號 |訊號名|訊號值|發出訊號原因| |SIGKILL|9|強制終止程序| |SIGSEGV|11|操作nullptr指標或超出陣列索引| |SIGSTOP|19|終止程序| 以下程式碼即便設定收9的訊號，但執行killall -9 signal_test，func()函式不會被執行，直接終止程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func(int signum) { cout &lt;&lt; \"收到訊號 = \" &lt;&lt; signum &lt;&lt; endl; } int main() { signal(9, func); for (int i = 0; ; i++) { cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; sleep(1); } return 0; } alarm函式 alarm()是定時器，參數與秒數，秒數到了會自動發出14的訊號。 語法 alarm(5) 注意事項 func()函式中，不能少alarm(5)，若func()函式中少了alram()，就只會啟動一次alarm，不能無限啟動。 signal(14, func)設置在alarm()函式之後 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func(int signum) { cout &lt;&lt; \"收到訊號 = \" &lt;&lt; signum &lt;&lt; endl; // 設置定時器，參數為5，代表5秒後啟動 alarm(5); } int main() { // 設置定時器，參數為5，代表5秒後啟動 alarm(5); // signal函式一定要放置alarm()後面 // 設定收14的訊號 signal(14, func); for (int i = 0; ; i++) { cout &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } return 0; } 執行結果每5秒發出14的訊號，由func()函式接收。 0秒 1秒 2秒 3秒 4秒 收到訊號 = 14 5秒 6秒 7秒 8秒 9秒 收到訊號 = 14 10秒 11秒 12秒 13秒 14秒 收到訊號 = 14 15秒 16秒 ^C 0訊號 檢查程序是否正常運作。 對上一個例子使用./alarm_test 打開另一個終端機(使用ssh連線)，執行以下指令。 $ killall -0 signal_test signal_test：找不到任何行程 $ killall -0 alarm_test 若程序沒執行會顯示找不到任何行程"
  },"/pages/c/libc/system_execl/": {
    "title": "system與execl",
    "keywords": "",
    "url": "/pages/c/libc/system_execl/",
    "body": "system()與execl()可以執行bash指令，把bash指令作為參數傳給system()與execl()函式。 include #include &lt;unistd.h&gt; system 語法 int system(const char *command) 參數 bash指令 傳回值 0:成功 非0: 可能失敗 不管傳回值是0與非0，都不會修改全域變數errno，所以使用strerror()或perror()都會傳回Success 傳回值0程式碼 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // system() head file #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { int ret = system(\"/bin/ls -l\"); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } -rwxrwxr-x 1 cici cici 16688 12月 13 13:32 system_test -rw-rw-r-- 1 cici cici 333 12月 13 13:32 system_test.cpp ret = 0 0:Success 傳回值非0程式碼1 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // system() head file #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { int ret = system(\"/bin/laaaaa -l\"); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } sh: 1: /bin/laaaaa: not found ret = 32512 0:Success 傳回值非0程式碼2 若bash是執行其它程式碼，其它程式碼的return值非0，system()函式的傳回值也會是非0。 以下是被呼叫的程序system_call.cpp 1 2 3 4 5 6 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"被呼叫的程序: system_call\" &lt;&lt; endl; return 12; } system_test.cpp 1 2 3 4 5 6 7 int main() { // 執行system_call int ret = system(\"/home/cici/test/app/system_call\"); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } 被呼叫的程序: system_call ret = 3072 0:Success 可以看出ret傳回值為非0，errno也是0，代表Success execl 語法 int execl(const char *path, const char *arg, ..., nullptr); 使用範例1 1 int ret = execl(\"/home/cici/system_call\", \"/home/cici/system_call\", nullptr); 前2個參數都是執行檔案路徑，都是相同，最後一個參數為nullptr，代表之後沒有參數了。 使用範例2 1 2 // 呼叫/bin/ls -l /tmp int ret = execl(\"/bin/ls\", \"/bin/ls\", \"-l\", \"/tmp\", nullptr); 前2個參數都是bash指令執行檔路徑，都是相同，之後為bash指令的參數，最後一個參數為nullptr，代表之後沒有參數了。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // exec() head file #include &lt;string.h&gt; #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { // 執行execl int ret = execl(\"/home/cici/test/app/system_call\", \"/home/cici/test/app/system_call\", nullptr); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } 被呼叫的程序: system_call 從以上的執行結果可以發現，不會執行以下二行，因為程序已經被system_call程式碼取代 1 2 cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; execl 函式用於在目前的 process 中啟動一個新的程式，取代目前 process 的執行。 也就是成功執行後，原來的程式碼將不再執行，因為目前 process 已被新程式取代。 如果要繼續執行原本的程式，可以使用 fork 讓 execl 在 child process 中執行 使用ps -ef | grep execl，會發現從頭到尾只有一個pid 但若是執行的是system()，會發現有2個pid 以下二個程式碼增加getpid() execl_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // exec() head file #include &lt;string.h&gt; #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { cout &lt;&lt; \"execl_test pid = \" &lt;&lt; getpid() &lt;&lt; endl; // 執行execl int ret = execl(\"/home/cici/test/app/system_call\", \"/home/cici/test/app/system_call\", nullptr); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; return 0; } system_call.cpp 1 2 3 4 5 6 7 8 #include &lt;iostream&gt; #include &lt;unistd.h&gt; // getpid() head file using namespace std; int main() { cout &lt;&lt; \"system_call pid = \" &lt;&lt; getpid() &lt;&lt; endl; cout &lt;&lt; \"被呼叫的程序: system_call\" &lt;&lt; endl; return 12; } 編譯二個檔案，並執行execl_test 由執行結果可以發現，二個執行檔的pid都一模一樣。 execl_test pid = 131087 system_call pid = 131087 被呼叫的程序: system_call fork與execl fork 為了解決execl會取代主程序，使用fork()建立子程序，由子程序被execl取代，就不會取代主程序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;cstring&gt; // strerror() 需要head file #include &lt;cerrno&gt; // errno全域變數的head file using namespace std; int main() { // fork傳回值pid pid_t pid = fork(); if (pid &gt; 0) { // 父程序 for (int i = 0; i &lt; 15; i++) { sleep(1); cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; } } else { int ret = execl(\"/home/cici/test/app/system_call\", \"/home/cici/test/app/system_call\", nullptr); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; errno &lt;&lt; \":\" &lt;&lt; strerror(errno) &lt;&lt; endl; } cout &lt;&lt; \"結束\" &lt;&lt; endl; } system_call pid = 146493 被呼叫的程序: system_call 第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 第11秒 第12秒 第13秒 第14秒 結束"
  },"/pages/c/libc/exit/": {
    "title": "exit終止程序",
    "keywords": "",
    "url": "/pages/c/libc/exit/",
    "body": "程序正常中止的方式如下 exit(0) return 0 在thread中，最後一個thread呼叫return() 在thread中，最後一個thread呼叫pthread_exit() exit 在任意子函式呼叫exit()，就會直接終止程序，不會再返回到main()函式。 以下程式碼 main()呼叫func1()，func1()呼叫func2()，func2()呼叫exit(0)離開程序。程式執行到func2，不會返回main() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; // system() head file using namespace std; void func2() { cout &lt;&lt; \"func2()\" &lt;&lt; endl; exit(0); } void func1() { cout &lt;&lt; \"func1()\" &lt;&lt; endl; // call func2 func2(); cout &lt;&lt; \"返回func1()\" &lt;&lt; endl; } int main() { cout &lt;&lt; \"main()\" &lt;&lt; endl; // call fun1 func1(); cout &lt;&lt; \"返回main()\" &lt;&lt; endl; return 0; } main() func1() func2() 若把以上程式碼exit(0)移掉，執行結果如下 main() func1() func2() 返回func1() 返回main() exit(0)與return 0，0為預設終止程序傳回值，若不寫，也會傳回0，以下指令印出上一個程序執行傳回的值。 echo $? 終止程序與解構子 return與解構子 return會呼叫全域與區域變數的解構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: Student(const string &amp;name) : name(name) {} ~Student() { cout &lt;&lt; \"解構子 : \" &lt;&lt; name &lt;&lt; endl; } private: string name; }; // 全域變數 Student s1(\"Mary\"); int main() { // 區域變數 Student s2(\"Bill\"); return 0; } 解構子 : Bill 解構子 : Mary exit與解構子 exit只會呼叫全域的解構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; using namespace std; class Student { public: Student(const string &amp;name) : name(name) {} ~Student() { cout &lt;&lt; \"解構子 : \" &lt;&lt; name &lt;&lt; endl; } private: string name; }; // 全域變數 Student s1(\"Mary\"); int main() { // 區域變數 Student s2(\"Bill\"); exit(0); } 解構子 : Mary _exit()與_Exit()與解構子 _exit()與_Exit()不會呼叫任何解構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; class Student { public: Student(const string &amp;name) : name(name) {} ~Student() { cout &lt;&lt; \"解構子 : \" &lt;&lt; name &lt;&lt; endl; } private: string name; }; // 全域變數 Student s1(\"Mary\"); int main() { // 區域變數 Student s2(\"Bill\"); _exit(0); } atexit() 可使用atexit()函式，註冊終止程序時要呼叫的函式。 語法 int atexit(void (*function)(void)); 參數為函式指標(要符合函式指標格式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; void destroy1() { cout &lt;&lt; \"呼叫destroy1\" &lt;&lt; endl; } void destroy2() { cout &lt;&lt; \"呼叫destroy2\" &lt;&lt; endl; } int main() { atexit(destroy1); atexit(destroy2); exit(0); } 呼叫destroy2 呼叫destroy1"
  },"/pages/c/libc/fork/": {
    "title": "fork 複製程序",
    "keywords": "",
    "url": "/pages/c/libc/fork/",
    "body": "fork 現在的程序中，使用fork()複製出子程序，子程序的程式碼執行的位置由fork()開始的程式碼，父程序fork()函式的傳回值是子程序的pid，子程序fork()傳回值為0。 fork_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { cout &lt;&lt; \"父程序開始\" &lt;&lt; endl; // 建立子程序，子程序開始的程式碼 pid_t pid = fork(); cout &lt;&lt; \"fork() return pid = \" &lt;&lt; pid &lt;&lt; endl; // 停止30秒，方便以ps -ef | grep 查看父程序與子程序 sleep(30); cout &lt;&lt; \"結束\" &lt;&lt; endl; } 父程序開始 fork() return pid = 145656 fork() return pid = 0 結束 結束 由執行結果可以知道，父程序開始的字只執行一次。 執行上面的程式，打開另一個終端機視窗 ps -ef | grep fork -e：顯示所有程序，等同於 -A 選項。 -f：顯示完整的格式，包括父程序和其他資訊。 可以發現子程序pid是145773，父程序是145772，有二個程序都跑起來了。 cici 145772 139698 0 14:43 pts/3 00:00:00 ./fork_test cici 145773 145772 0 14:43 pts/3 00:00:00 ./fork_test 使用pstree查看子父關係 語法 pstree -p 父pid $ pstree -p 145772 fork_test(145772)───fork_test(145773) 由以上結果可以知，145772下面有一個子程序145773 透過fork傳回值執行不同程式碼 父程序fork()函式的傳回值是子程序的pid，子程序fork()傳回值為0，根據傳回值判斷是父程序或子程序。 父get fork pid = 146095 子get fork pid = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { pid_t pid = fork(); if (pid &gt; 0) { cout &lt;&lt; \"父get fork pid = \" &lt;&lt; pid &lt;&lt; endl; } else { cout &lt;&lt; \"子get fork pid = \" &lt;&lt; pid &lt;&lt; endl; } sleep(20); cout &lt;&lt; \"結束\" &lt;&lt; endl; } 父get fork pid = 146095 子get fork pid = 0 結束 結束 fork()與變數 fork()函式，會把變數複製一份給子程序，雖然子程序與父程序的變數位址是相同，但實際上是存放不同位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { // 學號 int id = 888; // 姓名 string name = \"May\"; // fork傳回值pid pid_t pid = fork(); if (pid &gt; 0) { // 父程序 cout &lt;&lt; \"父get fork pid = \" &lt;&lt; pid &lt;&lt; endl; cout &lt;&lt; \"id = \" &lt;&lt; id &lt;&lt; \", address = \" &lt;&lt; &amp;id &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; \", address = \" &lt;&lt; &amp;name &lt;&lt; endl; } else { // 子程序 cout &lt;&lt; \"子get fork pid = \" &lt;&lt; pid &lt;&lt; endl; cout &lt;&lt; \"id = \" &lt;&lt; id &lt;&lt; \", address = \" &lt;&lt; &amp;id &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; \", address = \" &lt;&lt; &amp;name &lt;&lt; endl; } sleep(20); cout &lt;&lt; \"結束\" &lt;&lt; endl; } 父get fork pid = 146276 id = 888, address = 0x7ffef9691170 name = May, address = 0x7ffef9691180 子get fork pid = 0 id = 888, address = 0x7ffef9691170 name = May, address = 0x7ffef9691180 結束 結束 證明不是讀取相同記憶體位址 以下程式碼先讓子程序先執行(子程序有修改變數的值)，5秒後，再執行父程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { // 學號 int id = 888; // 姓名 string name = \"May\"; // fork傳回值pid pid_t pid = fork(); if (pid &gt; 0) { // 先讓父程序先睡5秒，讓子程序先執行 sleep(5); // 父程序 cout &lt;&lt; \"父get fork pid = \" &lt;&lt; pid &lt;&lt; endl; cout &lt;&lt; \"id = \" &lt;&lt; id &lt;&lt; \", address = \" &lt;&lt; &amp;id &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; \", address = \" &lt;&lt; &amp;name &lt;&lt; endl; } else { // 修改變數值 id = 777; name = \"Bill\"; // 子程序 cout &lt;&lt; \"子get fork pid = \" &lt;&lt; pid &lt;&lt; endl; cout &lt;&lt; \"id = \" &lt;&lt; id &lt;&lt; \", address = \" &lt;&lt; &amp;id &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; \", address = \" &lt;&lt; &amp;name &lt;&lt; endl; } sleep(20); cout &lt;&lt; \"結束\" &lt;&lt; endl; } 子get fork pid = 0 id = 777, address = 0x7ffeb7027c90 name = Bill, address = 0x7ffeb7027ca0 父get fork pid = 146339 id = 888, address = 0x7ffeb7027c90 name = May, address = 0x7ffeb7027ca0 結束 結束 由執行結果可以看出，即便子程序修改了變數值，但父程序仍顯示原來的值(888與Mary)。 子程序在背景執行 子程序在背景執行時，不會被ctrl+c強制終止。 法1 語法 ./執行檔名 &amp; 法2 在程式碼第一行加上 if (fork() &gt; 0) return 0; 編譯並執行，執行後面不用加&amp; ./執行檔名 如果 fork() 的返回值大於 0，表示這是 父程序，執行 return 0 直接結束父程序。 如果 fork() 的返回值等於 0，表示這是 子程序，繼續執行後面的程式碼。 父程序結束後，只有子程序執行程式的剩餘部分。 子程序會進入無限迴圈，並每秒輸出 第X秒。 fork_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main() { // 父程序離開，只剩下fork的子程序在執行 if (fork() &gt; 0) return 0; // 無限迴圈 for (int i = 0; ; i++) { cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } } 孤兒程序orphan process 父程序結束，子程序沒有父親，子程序變成孤兒，由init系統程序(1號程序)接管 使用ps查看父程序的pid已經變成1號程序 $ ps -ef | grep fork_test cici 154291 1 0 09:46 pts/3 00:00:00 ./fork_test 刪除背景程序 開另一個終端機，輸入killall -9 程序名或kill 程序pid PID 0 1 2 號 PID 0 號 名稱：Idle 程序（也稱為 swapper 或 scheduler） 特性： 核心中的第一個程序，在系統啟動階段由核心創建。 PID 1 號 名稱：systemd 由 0 號程序創建 作用： 負責系統初始化，如加載其他守護程序、掛載檔案系統、設置網路等。 PID 2 號 名稱：kthreadd（核心多工管理器） 特性： 負責執行例如磁碟 I/O、網絡處理等系統級操作。 PID（程序 ID）為 2，因此被稱為 2 號程序。 程序之間的關係 啟動順序： 系統啟動時，最初由核心創建 0 號程序。 0 號程序創建 1 號程序 0 號程序也會創建 2 號程序 查看0號程序樹 語法 pstree -p 0 zombie process 父程序沒有處理子程序的離開(如:資源釋放)，造成僵屍程序，子程序的pid就會一直存在，系統的pid數量是有限的，若存在太多子程序pid，就不會再產生新的程序。 使用以下程式碼會產生僵屍程序 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; using namespace std; int main() { // 離開子程序 if (fork() == 0) return 0; // 無限迴圈 for (int i = 0; ; i++) { cout &lt;&lt; \"父程序運行第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } } 執行時，再用ps查詢程序，可以發現明明子程序154631已經離開，但仍占著pid，後面跟著&lt; defunct &gt;，這就是僵屍程序 $ ps -ef | grep fork_test cici 154630 139698 0 10:19 pts/3 00:00:00 ./fork_test cici 154631 154630 0 10:19 pts/3 00:00:00 [fork_test] &lt;defunct&gt; 避免僵屍程序的方法 怱略SIGCHLD 子程序離開前，kernel會向父程序發出SIGCHLD訊號，把它怱略，kernel收到會釋放子程序資源。 語法 signal(SIGCHLD, SIG_IGN); SIG_IGN代表怱略 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; using namespace std; int main() { // 呼叫fork()之前，怱略子程序離開的訊號 signal(SIGCHLD, SIG_IGN); // 離開子程序 if (fork() == 0) return 0; // 無限迴圈 for (int i = 0; ; i++) { cout &lt;&lt; \"父程序運行第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } } 執行程序時，使用ps查看，發現pid只剩下父程序154674 $ ps -ef | grep fork_test cici 154674 139698 0 10:22 pts/3 00:00:00 ./fork_test 使用wait include #include &lt;sys/wait.h&gt; 語法 pid_t wait(int *stat_loc); pid_t:傳回子程序pid stat_loc指標:用於存放子程序離開的結果 正常離開為以下的狀況，不管x值是什麼，都是正常離開。 return x; exit(x); _exit(x)或_Exit(x) 異常離開 收到訊號kill 程序pid abort()函式終止 正常離開程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; using namespace std; int main() { if (fork() &gt; 0) { // 父程序 int status; // 用於儲存子程序離開的結果 pid_t pid = wait(&amp;status); // 等待子程序離開 cout &lt;&lt; \"已終止的子程序pid是:\" &lt;&lt; pid &lt;&lt; endl; // 把離開結果傳給WIFEXITED()前置指令，若傳回true，代表正常離開來 if (WIFEXITED(status)) { cout &lt;&lt; \"正常離開，狀態 : \" &lt;&lt; WEXITSTATUS(status) &lt;&lt; endl; } else { cout &lt;&lt; \"異常離開，狀態 : \" &lt;&lt; WTERMSIG(status) &lt;&lt; endl; } } else { // 子程序執行15秒 0 .. 14 for (int i = 0; i &lt; 15 ; i++) { cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } exit(5); } } 第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 第11秒 第12秒 第13秒 第14秒 已終止的子程序pid是:154866 正常離開，狀態 : 5 使用kill不正常離開1 執行程式 打開另一個終端機視窗 $ ps -ef | grep fork_test cici 154938 139698 0 10:50 pts/3 00:00:00 ./fork_test cici 154939 154938 0 10:50 pts/3 00:00:00 ./fork_test cici 154942 145543 0 10:50 pts/6 00:00:00 grep --color=auto fork_test $ kill 154939 回到原本執行程式的終端機視窗 第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 第11秒 第12秒 已終止的子程序pid是:154939 異常離開，狀態 : 15 使用kill不正常離開2 執行程式 打開另一個終端機視窗 $ ps -ef | grep fork_test cici 155000 139698 0 10:55 pts/3 00:00:00 ./fork_test cici 155001 155000 0 10:55 pts/3 00:00:00 ./fork_test cici 155003 145543 0 10:55 pts/6 00:00:00 grep --color=auto fork_test $ kill -9 155001 回到原本執行程式的終端機視窗 第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 第11秒 第12秒 已終止的子程序pid是:155001 異常離開，狀態 : 9 操作nullptr不正常離開 在子程序的部分，增加操作nullptr的程式碼 int* ptr = nullptr; *ptr = 10; 訊號名 訊號值 發出訊號原因 SIGSEGV 11 操作nullptr指標或超出陣列索引 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; using namespace std; int main() { if (fork() &gt; 0) { // 父程序 int status; // 用於儲存子程序離開的結果 pid_t pid = wait(&amp;status); // 等待子程序離開 cout &lt;&lt; \"已終止的子程序pid是:\" &lt;&lt; pid &lt;&lt; endl; // 把離開結果傳給WIFEXITED()前置指令，若傳回true，代表正常離開來 if (WIFEXITED(status)) { cout &lt;&lt; \"正常離開，狀態 : \" &lt;&lt; WEXITSTATUS(status) &lt;&lt; endl; } else { cout &lt;&lt; \"異常離開，狀態 : \" &lt;&lt; WTERMSIG(status) &lt;&lt; endl; } } else { // 子程序執行15秒 0 .. 14 for (int i = 0; i &lt; 15 ; i++) { cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } int* ptr = nullptr; *ptr = 10; exit(5); } } 第0秒 第1秒 第2秒 第3秒 第4秒 第5秒 第6秒 第7秒 第8秒 第9秒 第10秒 第11秒 第12秒 第13秒 第14秒 已終止的子程序pid是:155059 異常離開，狀態 : 11 補捉SIGCHLD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; using namespace std; /** 補捉SIGCHLD子程序離開訊號 */ void func(int signal) { int status; // 用於儲存子程序離開的結果 pid_t pid = wait(&amp;status); // 等待子程序離開 cout &lt;&lt; \"已終止的子程序pid是:\" &lt;&lt; pid &lt;&lt; endl; // 把離開結果傳給WIFEXITED()前置指令，若傳回true，代表正常離開來 if (WIFEXITED(status)) { cout &lt;&lt; \"正常離開，狀態 : \" &lt;&lt; WEXITSTATUS(status) &lt;&lt; endl; } else { cout &lt;&lt; \"異常離開，狀態 : \" &lt;&lt; WTERMSIG(status) &lt;&lt; endl; } } int main() { // 補捉子程序離開的訊號 signal(SIGCHLD, func); if (fork() &gt; 0) { // 父程序執行30秒 0 .. 29 for (int i = 0; i &lt; 30 ; i++) { cout &lt;&lt; \"父 : 第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } } else { // 子程序執行15秒 0 .. 14 for (int i = 0; i &lt; 15 ; i++) { cout &lt;&lt; \"子 : 第\" &lt;&lt; i &lt;&lt; \"秒\" &lt;&lt; endl; sleep(1); } // 子程序執行15秒結束 exit(5); } } 父 : 第0秒 子 : 第0秒 父 : 第1秒 子 : 第1秒 父 : 第2秒 子 : 第2秒 父 : 第3秒 子 : 第3秒 父 : 第4秒 子 : 第4秒 父 : 第5秒 子 : 第5秒 父 : 第6秒 子 : 第6秒 父 : 第7秒 子 : 第7秒 父 : 第8秒 子 : 第8秒 父 : 第9秒 子 : 第9秒 父 : 第10秒 子 : 第10秒 父 : 第11秒 子 : 第11秒 父 : 第12秒 子 : 第12秒 父 : 第13秒 子 : 第13秒 父 : 第14秒 子 : 第14秒 父 : 第15秒 已終止的子程序pid是:155462 正常離開，狀態 : 5 父 : 第16秒 父 : 第17秒 父 : 第18秒 父 : 第19秒 父 : 第20秒 父 : 第21秒 父 : 第22秒 父 : 第23秒 父 : 第24秒 父 : 第25秒 父 : 第26秒 父 : 第27秒 父 : 第28秒 父 : 第29秒 取得父程序的id pid_t getpid(void); // 取得目前程序pid pid_t getppid(void); //取得父程序pid"
  },"/pages/c/libc/shared_memory/": {
    "title": "Shared Memory共用記憶體",
    "keywords": "",
    "url": "/pages/c/libc/shared_memory/",
    "body": "多個程序(process)共用同一塊記憶體。 共用記憶體 若共用記憶體沒被建立過，則會重新建立，若已建立過，則會傳回shmid。 include #include &lt;sys/shm.h&gt; shmget取得共用記憶體 建立共用記憶體，沒被建立過，則會重新建立，若已建立過，則會傳回shmid int shmget (key_t key, size_t size, int shmflg); 參數 key鍵值 : 使用16進位，0x開頭，後面4個數字，例:0x0001 size容量 : 結構的大小(資料物件，使用 struct；其他狀況一律使用 class) shmflg權限 : 參考linux權限，前面要加上0，例:0640 shmflg權限 : IPC_CREAT代表若共用記憶體沒被建立過，則會重新建立，若已建立過，則會傳回shmid。 傳回值shmid : -1失敗，其它數字代表成功。 shmat使用共用記憶體 使用共用記憶體，程序連接共用記憶體，會傳回共用記憶體位址，要把void*轉成結構*。 void* shmat(int shmid, const void *shmaddr, int shmflg); 參數 shmid shmaddr，通常用nullptr，由系統自已設定記憶體位址 shmflg,通常設0 shmdt程序不再使用共用記憶體，不是刪除 int shmdt (const void *shmaddr); 參數傳入shmat()函式傳回的指標。 呼叫成功時返回一個指向共用記憶體第一個位元組的指標，如果呼叫失敗返回-1，-1要用void*轉型。 程式碼 記得將以下二句轉型 SharedData *ptr = (SharedData*)shmat(shmid, nullptr, 0); if (ptr == (void*)-1) { 結構的成員不能是string/vector/list/map(STL容器相關)，只能使用char,int,long…原生的資料型別。 struct SharedData { char data[100]; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;signal.h&gt; #include &lt;sys/shm.h&gt; #include &lt;cstring&gt; using namespace std; struct SharedData { char data[100]; }; int main() { int shmid = shmget(0x0001, sizeof(SharedData), 0640|IPC_CREAT); if (shmid == -1) { cout &lt;&lt; \"記憶體不足或權限不足，無法建立空間。\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"shmid = \" &lt;&lt; shmid &lt;&lt; endl; SharedData *ptr = (SharedData*)shmat(shmid, nullptr, 0); if (ptr == (void*)-1) { cout &lt;&lt; \"shmat() failed\" &lt;&lt; endl; return -1; } strcpy(ptr-&gt;data, \"abcdfrere\"); cout &lt;&lt; \"share memory data = \" &lt;&lt; ptr-&gt;data &lt;&lt; endl; shmdt(ptr); } shmid = 3 share memory data = abcdfrere 共用記憶體bash指令 查看共用記憶體 $ipcs -m ------ 共用記憶體資料段 -------- 鍵值 shmid 擁有者 perms 位元組 使用數 狀 刪除共用記憶體 $ipcrm -m 值 值 = shmid 結合circular queue Prerequisites: circular queue 檔名cir_queue.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; /** 類別模板 元素型別T與陣列大小maxLen是使用者設定 */ template &lt;class T, int maxLen&gt; class CircularQueue{ public: // 建構子 CircularQueue() { Init(); // 呼叫初始化 } // 初始化函式 void Init() { // 只能初始化1次，沒初始化就初始化 if (is_init_ != true) { front_ = 0; // 初始化front指向0的索引(第一個元素) tail_ = maxLen - 1; // 尾指標指向陣列最後一個元素索引 len_ = 0; // 初始化佇列實際大小為0 memset(data_, 0, sizeof(data_)); // 清空陣列記憶體 is_init_ = true; // 設成已初始化 } } bool IsFull() { return len_ == maxLen; } int size() { return len_; } bool empty() { return len_ == 0; } bool push(const T &amp;element) { // 判斷queue是否已經滿了 if (IsFull()) { cout &lt;&lt; \"Queue is full.\" &lt;&lt; endl; return false; } tail_ = (tail_ + 1) % maxLen; // 把值塞入 data_[tail_] = element; len_++; return true; } bool pop() { if (empty()) return false; front_ = (front_ + 1) % maxLen; len_--; return true; } void print() { for (int i = 0; i &lt; size(); i++) { cout &lt;&lt; data_[(front_ + i) % maxLen] &lt;&lt; \",\"; } cout &lt;&lt; endl; } T&amp; front() { return data_[front_]; } private: bool is_init_; // 是否已經初始化 T data_[maxLen]; // 建立陣列，元素型別與陣列大小是使用者設定 int front_; // 前端指標，指向queue排隊最前面的元素 int tail_; // 尾指標，指向queue排隊最後面的元素 int len_; // queue實際占用大小 // 禁止拷貝 CircularQueue(const CircularQueue &amp;) = delete; // 禁止使用等於=指派assign CircularQueue &amp;operator=(const CircularQueue &amp;) = delete; }; 以下檔案中要注意的是轉型與呼叫init()，因為cir_que是指標，不是物件，所以要用-&gt;方式呼叫成員函式，而不是使用點. 以下程式碼是向共用記憶體insert 11,12,13，每次都只pop一個，連續執行4次，查看共用記憶體中的狀況 檔名shm_cir_que.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &lt;iostream&gt; #include \"cir_queue.h\" #include &lt;sys/shm.h&gt; #include &lt;cstring&gt; using namespace std; struct SharedData { char data[100]; }; int main() { using ElemType = int; // 注意轉型 int shmid = shmget(0x0001, sizeof(CircularQueue&lt;int, 6&gt;), 0640|IPC_CREAT); if (shmid == -1) { cout &lt;&lt; \"記憶體不足或權限不足，無法建立空間。\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"shmid = \" &lt;&lt; shmid &lt;&lt; endl; // 注意轉型 CircularQueue&lt;int, 6&gt;* cir_que = (CircularQueue&lt;int, 6&gt;*)shmat(shmid, nullptr, 0); if (cir_que == (void*)-1) { cout &lt;&lt; \"shmat() failed\" &lt;&lt; endl; return -1; } // 使用共用記憶體，不會呼叫CircularQueue的建構子，所以要手動呼叫Init() cir_que-&gt;Init(); // push的流程 ElemType tmp_val; tmp_val = 11; cir_que-&gt;push(tmp_val); tmp_val = 12; cir_que-&gt;push(tmp_val); tmp_val = 13; cir_que-&gt;push(tmp_val); cout &lt;&lt; \"queue size = \" &lt;&lt; cir_que-&gt;size() &lt;&lt; endl; cir_que-&gt;print(); // pop tmp_val = cir_que-&gt;front(); cir_que-&gt;pop(); cout &lt;&lt; \"pop = \" &lt;&lt; tmp_val &lt;&lt; endl; shmdt(cir_que); } $ g++ -o shm_cir_que shm_cir_que.cpp $ ./shm_cir_que 執行結果 $ ./shm_cir_que shmid = 3 queue size = 3 11,12,13, pop = 11 $ ./shm_cir_que shmid = 3 queue size = 5 12,13,11,12,13, pop = 12 $ ./shm_cir_que shmid = 3 Queue is full. queue size = 6 13,11,12,13,11,12, pop = 13 $ ./shm_cir_que shmid = 3 Queue is full. Queue is full. queue size = 6 11,12,13,11,12,11, pop = 11"
  },"/pages/c/dataStruct/circular_queue/": {
    "title": "circular queue環狀佇列",
    "keywords": "",
    "url": "/pages/c/dataStruct/circular_queue/",
    "body": "環狀佇列就是固定大小空間的陣列，循環利用。 初始化 front指向第一筆資料 front = 0 tail指向最後一筆資料 tail = 5 push push語法 1 2 3 tail_ = (tail_ + 1) % maxLen; // 把值塞入 data_[tail_] = element; 第1次新增 將以下的值代入上方push語法中 最大容量為maxLen = 6 原本tail = 5 (指向最後一筆資料) 經過以下公式，tail指向索引0 tail = (5 + 1) % 6 tail = 0 (指向索引0) 非第1次新增 假設最大容量為maxLen = 6 原tail = 2 tail = (2 + 1) % 6 經過以上公式，tail往後移動一位 tail = 3 把值塞入tail tail由最後移向第0筆 假設最大容量為maxLen = 6 若前面的資料都已被pop出去，索引0,1,2仍有空位。 tail指向最後面 原tail = 5 tail = (5 + 1) % 6 經過以上公式，tail移到最前面索引0 tail指向陣列索引0，新增一個資料55在陣列索引0 pop pop語法 pop語法跟push語法一模一樣 1 front_ = (front_ + 1) % maxLen; 把第0筆pop之前 把第0筆pop之後 front往後移動 print 假設環狀佇列的狀況如下 要把以上的值印出來 print語法 print語法跟push與pop語法也是一模一樣，把front代入就行。 i為0 .. size實際已占用大小 1 (front_ + i) % maxLen 以上圖來說 i = 0，front = 3，最大容量為maxLen = 6 (3 + 0) % 6 = 3 i = 1，front = 3，最大容量為maxLen = 6 (3 + 1) % 6 = 4 i = 2，front = 3，最大容量為maxLen = 6 (3 + 2) % 6 = 5 i = 3，front = 3，最大容量為maxLen = 6 (3 + 3) % 6 = 0 完整print語法 1 2 3 4 5 6 void print() { for (int i = 0; i &lt; size(); i++) { cout &lt;&lt; data_[(front_ + i) % maxLen] &lt;&lt; \",\"; } cout &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include &lt;iostream&gt; using namespace std; /** 類別模板 元素型別T與陣列大小maxLen是使用者設定 */ template &lt;class T, int maxLen&gt; class CircularQueue{ public: // 建構子 CircularQueue() { Init(); // 呼叫初始化 } // 初始化函式 void Init() { // 只能初始化1次，沒初始化就初始化 if (is_init_ != true) { front_ = 0; // 初始化front指向0的索引(第一個元素) tail_ = maxLen - 1; // 尾指標指向陣列最後一個元素索引 len_ = 0; // 初始化佇列實際大小為0 memset(data_, 0, sizeof(data_)); // 清空陣列記憶體 is_init_ = true; // 設成已初始化 } } bool IsFull() { return len_ == maxLen; } int size() { return len_; } bool empty() { return len_ == 0; } bool push(const T &amp;element) { // 判斷queue是否已經滿了 if (IsFull()) { cout &lt;&lt; \"Queue is full.\" &lt;&lt; endl; return false; } tail_ = (tail_ + 1) % maxLen; // 把值塞入 data_[tail_] = element; len_++; return true; } bool pop() { if (empty()) return false; front_ = (front_ + 1) % maxLen; len_--; return true; } void print() { for (int i = 0; i &lt; size(); i++) { cout &lt;&lt; data_[(front_ + i) % maxLen] &lt;&lt; \",\"; } cout &lt;&lt; endl; } T&amp; front() { return data_[front_]; } private: bool is_init_; // 是否已經初始化 T data_[maxLen]; // 建立陣列，元素型別與陣列大小是使用者設定 int front_; // 前端指標，指向queue排隊最前面的元素 int tail_; // 尾指標，指向queue排隊最後面的元素 int len_; // queue實際占用大小 // 禁止拷貝 CircularQueue(const CircularQueue &amp;) = delete; // 禁止使用等於=指派assign CircularQueue &amp;operator=(const CircularQueue &amp;) = delete; }; int main() { // 資料型別為int，最大容量為6 CircularQueue&lt;int, 6&gt; cir_queue; int tmp_val; // push 10,11,12 tmp_val = 10; cir_queue.push(tmp_val); tmp_val = 11; cir_queue.push(tmp_val); tmp_val = 12; cir_queue.push(tmp_val); cout &lt;&lt; \"size = \" &lt;&lt; cir_queue.size() &lt;&lt; endl; // 印出大小 cir_queue.print(); // pop流程 // 取出queue中索引0 tmp_val = cir_queue.front(); // 移除10 cir_queue.pop(); cout &lt;&lt; \"pop value = \" &lt;&lt; tmp_val &lt;&lt; endl; // 移除11 tmp_val = cir_queue.front(); cir_queue.pop(); cout &lt;&lt; \"pop value = \" &lt;&lt; tmp_val &lt;&lt; endl; // 移除12 tmp_val = cir_queue.front(); cir_queue.pop(); cout &lt;&lt; \"pop value = \" &lt;&lt; tmp_val &lt;&lt; endl; return 0; }"
  },"/pages/c/libc/semaph_que/": {
    "title": "semaphore作為condition",
    "keywords": "",
    "url": "/pages/c/libc/semaph_que/",
    "body": "Prerequisites: mutex condition semaphore circular_queue 結合circular queue 延續先前semaphore與mutex的範例，這頁是semaphore作為condition的範例，使用circular queue作為範例 檔名:push_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include &lt;iostream&gt; #include \"semaph.h\" #include \"cir_queue.h\" #include &lt;sys/shm.h&gt; #include &lt;cstring&gt; using namespace std; struct SharedData { char data[100]; }; int main() { using ElemType = int; // 注意轉型 int shmid = shmget(0x0001, sizeof(CircularQueue&lt;int, 6&gt;), 0640|IPC_CREAT); if (shmid == -1) { cout &lt;&lt; \"記憶體不足或權限不足，無法建立空間。\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"shmid = \" &lt;&lt; shmid &lt;&lt; endl; // 注意轉型 CircularQueue&lt;int, 6&gt;* cir_que = (CircularQueue&lt;int, 6&gt;*)shmat(shmid, nullptr, 0); if (cir_que == (void*)-1) { cout &lt;&lt; \"shmat() failed\" &lt;&lt; endl; return -1; } // 使用共用記憶體，不會呼叫CircularQueue的建構子，所以要手動呼叫Init() cir_que-&gt;Init(); // 建立mutex Semaph mutex; mutex.init(0x0001); // 建立condition Semaph condition; condition.init(0x0002, 0, 0); // lock加鎖 mutex.wait(); // push的流程 ElemType tmp_val; tmp_val = 11; cir_que-&gt;push(tmp_val); tmp_val = 12; cir_que-&gt;push(tmp_val); tmp_val = 13; cir_que-&gt;push(tmp_val); // unlock解鎖 mutex.post(); // 計數功能 condition.post(3); // 參數3代表生產3個資料 cir_que-&gt;print(); shmdt(cir_que); } 檔名:pop_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include &lt;iostream&gt; #include \"semaph.h\" #include \"cir_queue.h\" #include &lt;sys/shm.h&gt; #include &lt;cstring&gt; using namespace std; struct SharedData { char data[100]; }; int main() { using ElemType = int; // 注意轉型 int shmid = shmget(0x0001, sizeof(CircularQueue&lt;int, 6&gt;), 0640|IPC_CREAT); if (shmid == -1) { cout &lt;&lt; \"記憶體不足或權限不足，無法建立空間。\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"shmid = \" &lt;&lt; shmid &lt;&lt; endl; // 注意轉型 CircularQueue&lt;int, 6&gt;* cir_que = (CircularQueue&lt;int, 6&gt;*)shmat(shmid, nullptr, 0); if (cir_que == (void*)-1) { cout &lt;&lt; \"shmat() failed\" &lt;&lt; endl; return -1; } // 使用共用記憶體，不會呼叫CircularQueue的建構子，所以要手動呼叫Init() cir_que-&gt;Init(); // 建立mutex Semaph mutex; mutex.init(0x0001); // 建立condition Semaph condition; condition.init(0x0002, 0, 0); // 存放pop出來的資料 ElemType tmp_val; while (true) { // lock加鎖 mutex.wait(); while (cir_que-&gt;empty()) { // 若佇列為空，無限迴圈 mutex.post(); // unlock解鎖 condition.wait(); // 等待有資料，沒資料就一直卡在這 // 若有資料就會執行以下這行，並離開cir_que-&gt;empty的迴圈 mutex.wait(); // lock加鎖 } // pop資料 tmp_val = cir_que-&gt;front(); cout &lt;&lt; \"tmp_val = \" &lt;&lt; tmp_val &lt;&lt; endl; cir_que-&gt;pop(); // unlock解鎖 mutex.post(); cout &lt;&lt; \"val = \" &lt;&lt; tmp_val &lt;&lt; endl; // 假設處理資料要花10秒鐘 sleep(10); } shmdt(cir_que); } 編譯指令 g++ -o push_test push_test.cpp semaph.cpp g++ -o pop_test pop_test.cpp semaph.cpp 打開二個終端機視窗 一個執行push ./push_test 一個執行pop ./pop_test 執行結果 push $ ./push_test shmid = 5 Queue is full. Queue is full. Queue is full. 11,12,13,11,12,13, $ ./push_test shmid = 5 11,12,13, pop $ ./pop_test shmid = 5 tmp_val = 11 val = 11 tmp_val = 12 val = 12 tmp_val = 13 val = 13 tmp_val = 11 val = 11 tmp_val = 12 val = 12 tmp_val = 13 val = 13 tmp_val = 11 val = 11 tmp_val = 12 val = 12 tmp_val = 13 val = 13 ^C"
  },"/pages/c/libc/semaphore/": {
    "title": "semaphore",
    "keywords": "",
    "url": "/pages/c/libc/semaphore/",
    "body": "Prerequisites: mutex condition 共用記憶體沒有mutex，所以使用semaphore來實現加鎖lock/解鎖unlock/等待wait/通知notify，以達到讀取相同記憶體時，搶到鎖的程序process就可以使用這個記憶體，而其它程序process就在門外排隊等待門的鎖打開，當鎖打開，就輪下一個程序process使用記憶體。 semaphore中文翻譯有太多種，訊號量(大陸)，號誌(台灣)，所以用英文代替。 linux semaphore指令 列出semaphore $ ipcs -s —— 號誌陣列 ——– 鍵值 semid 擁有者 perms nsems 0x00000001 0 cici 666 1 刪除semaphore 在進行本頁範例前，請先手工刪除semaphore，還有刪除共用記憶體，避免產生錯誤。 $ ipcrm sem 0 資源已刪除 0為semid 初始化 init() 1 bool init(key_t key, unsigned short value = 1, short sem_flg = SEM_UNDO); key: 使用16進位，0x開頭，後面4個數字，例:0x0001，可跟共用記憶體的key一樣 value: value有以下二種功能 mutex: 1 condition_variable: 0 sem_flg: value有以下二種功能 mutex: SEM_UNDO為數字1 condition_variable: 0 wait() 1 bool wait(short value = -1); 預設參數value = -1代表把semid減1，不是設成負1，是減1的意思。 value小於0，程式就卡在wait()這行不動，直到value大於0，執行wait()以後的程式碼 mutex: 加鎖lock condition_variable: 等待wait post() 1 bool post(short value = 1); 預設參數value = 1代表把semid加1，不是設成1，是加1的意思。 mutex: 解鎖unlock condition_variable: 通知notify 檔名:semaph.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/sem.h&gt; using namespace std; class Semaph { public: // 初始化建構子，預設semid為-1，-1代表沒被初始化 // 若已經初始化semid將大於等於0 Semaph() : semid_(-1) {} // 初始化 // key: 使用16進位，0x開頭，後面4個數字，例:0x0001，可跟共用記憶體的key一樣 // value: 若semaphore沒被建立過，就建立，並把value設為1 // value有二種功能，一種是mutex，一種是condition_variable bool init(key_t key, unsigned short value = 1, short sem_flg = SEM_UNDO); bool wait(short value = -1); bool post(short value = 1); // 取得semid int getvalue(); bool destroy(); ~Semaph(); private: // union固定寫法 union semun_ { int val_; struct semid_ds *buf_; unsigned short *arry_; }; int semid_; // sem_flg是0為mutex // sem_flg是SEM_UNDO為condition_variable short sem_flg_; Semaph(const Semaph &amp;) = delete; // 禁用拷貝 Semaph&amp; operator=(const Semaph &amp;) = delete; // 禁用assign }; 檔名:semaph.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \"semaph.h\" bool Semaph::init(key_t key, unsigned short value, short sem_flg) { if (semid_ != -1) return false; sem_flg_ = sem_flg; if ((semid_ = semget(key, 1, 0666)) == -1) { if(errno == ENOENT) { if((semid_ = semget(key, 1, 0666 | IPC_CREAT | IPC_EXCL)) == -1) { if (errno == EEXIST) { if ((semid_ = semget(key, 1, 0666)) == -1) { perror(\"init 1 semget()\"); return false; } return true; } else { perror(\"init 2 semget()\"); return false; } } union semun_ sem_union; sem_union.val_ = value; if (semctl(semid_, 0, SETVAL, sem_union) &lt; 0) { perror(\"init semctl()\"); return false; } } else { perror(\" init 3 semget()\"); return false; } } return true; } bool Semaph::wait(short value) { if (semid_ == -1) return false; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = value; sem_b.sem_flg = sem_flg_; if (semop(semid_, &amp;sem_b, 1) == -1) { perror(\"p semop()\"); return false; } return true; } bool Semaph::post(short value) { if (semid_==-1) return false; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = value; sem_b.sem_flg = sem_flg_; if (semop(semid_, &amp;sem_b, 1) == -1) { perror(\"V semop()\"); return false; } return true; } int Semaph::getvalue() { return semctl(semid_,0,GETVAL); } bool Semaph::destroy() { if (semid_==-1) return false; if (semctl(semid_, 0, IPC_RMID) == -1) { perror(\"destroy semctl()\"); return false; } return true; } Semaph::~Semaph(){} 檔名:semaph_test.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \"cir_queue.h\" #include \"semaph.h\" #include &lt;sys/shm.h&gt; #include &lt;cstring&gt; using namespace std; struct SharedData { char data[100]; }; int main() { int shmid = shmget(0x0001, sizeof(SharedData), 0640|IPC_CREAT); if (shmid == -1) { cout &lt;&lt; \"記憶體不足或權限不足，無法建立空間。\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"shmid = \" &lt;&lt; shmid &lt;&lt; endl; SharedData *ptr = (SharedData*)shmat(shmid, nullptr, 0); if (ptr == (void*)-1) { cout &lt;&lt; \"shmat() failed\" &lt;&lt; endl; return -1; } Semaph mutex; if (mutex.init(0x0001) == false) { cout &lt;&lt; \"mutex fail\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"申請鎖\" &lt;&lt; endl; mutex.wait(); cout &lt;&lt; \"申請鎖成功\" &lt;&lt; endl; strcpy(ptr-&gt;data, \"abcdfrere\"); cout &lt;&lt; \"share memory data = \" &lt;&lt; ptr-&gt;data &lt;&lt; endl; sleep(10); mutex.post(); cout &lt;&lt; \"解鎖\" &lt;&lt; endl; shmdt(ptr); } 編譯指令 g++ -o semaph_test semaph_test.cpp semaph.cpp 開二個終端機同時測試 一個終端機已經申請到鎖 $ ./semaph_test shmid = 4 申請鎖 申請鎖成功 share memory data = abcdfrere 一個終端機在等待解鎖 $ ./semaph_test shmid = 4 申請鎖"
  },"/pages/c/file/file_io/": {
    "title": "File IO",
    "keywords": "",
    "url": "/pages/c/file/file_io/",
    "body": "o是output簡寫，輸出 i是input簡寫，輸入 f是file文字檔 上圖是各個輸入串流與輸出串流繼承狀況，本頁著重在fstream(讀取與寫入文字檔)與ifstream(讀取文字檔)與ofstream(寫入文字檔)。 寫入文字檔 步驟有4步 include #include &lt;fstream&gt; 建立寫入文字檔的物件 寫入文字檔用ofstream(output file stream)。 1 ofstream fout; 打開文字檔 1 fout.open(file_name, ios::trunc); 參數1是檔名 參數2是開啟文字檔的模式 不填，使用預設ios::out ios::trunc ios:out ios::app ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本文字檔內容 ios::app是append附加在文字檔內容後面 用ofstreamt物件打開文字檔 ofstream物件本身也可以打開文字檔，使用以下語法，就不需要使用fout.open()打開，可以取代fout.open() 1 ofstream fout(file_name, ios::app); 參數1是檔名 參數2是開啟文字檔的模式 不填，使用預設ios::out ios::trunc ios:out ios::app 判斷是否打開成功 使用is_open()函式判斷是否有下列問題，若有以下問題會傳回true。 目錄不存在 硬碟容量不足 權限不夠 1 2 3 4 if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } 寫入文字檔 寫入(用法與cout一樣，cout«是輸出到螢幕，fout«是輸出到文字檔) 1 fout &lt;&lt; \"file 1 test test \\n\"; 關閉文字檔 1 fout.close(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::trunc); if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } // 3.寫入(用法與cout一樣，cout&lt;&lt;是輸出到螢幕，fout&lt;&lt;是輸出到檔案) fout &lt;&lt; \"file 1 test test\\n\"; fout &lt;&lt; \"file 2 test test\\n\"; fout &lt;&lt; \"file 3 test test\\n\"; // 4.關閉檔案 fout.close(); return 0; } 讀取文字檔 include #include &lt;fstream&gt; 建立讀取文字檔的物件 讀取文字檔用ifstream(input file stream)。 1 ifstream fin; 打開文字檔 1 fin.open(file_name, ios::in); 參數1是檔名 參數2是開啟文字檔的模式 不填，使用預設ios::in ios::in 用ifstream物件打開文字檔 ifstream物件本身也可以打開文字檔，使用以下語法，就不需要使用fin.open()打開，可以取代fin.open() 1 ofstream fin(file_name, ios::in); 參數1是檔名 參數2是開啟文字檔的模式 不填，使用預設ios::in ios::in 判斷是否打開成功 使用is_open()函式判斷是否有下列問題，若有以下問題會傳回true。 文字檔不存在 硬碟容量不足 權限不夠 1 2 3 4 if (fin.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } 讀取一列文字檔 1 2 3 4 // 用於存放讀取的內容 string buffer; // 讀取一列字串，存放到buffer中 getline(fin, buffer); while讀取整個文字檔 前一個例子只能讀取一列，使用while()讀取整個文字檔，若讀不到文字，就會傳回nullptr 1 2 3 4 5 6 // 用於存放讀取的內容 string buffer; // 讀取一列字串，存放到buffer中 while (getline(fin, buffer)) { cout &lt;&lt; buffer &lt;&lt; endl; } file 1 test test file 2 test test file 3 test test file 1 test test file 2 test test file 3 test test 關閉文字檔 1 fin.close(); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; // getline()函式需要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test.txt\"; ifstream fin(file_name, ios::in); if (fin.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } // 用於存放讀取的內容 string buffer; // 讀取一列字串，存放到buffer中 while (getline(fin, buffer)) { cout &lt;&lt; buffer &lt;&lt; endl; } // 關閉檔案 fin.close(); return 0; } 寫入Binary file Binary file中文翻譯可為二進位檔案，它跟文字檔不同 文字檔 string str = “123”; 大小3byte 字元 '1' '2' '3' ascii 49 50 51 記憶體實際存放的是二進位資料如下: 二進位 00110001 00110010 00110011 文字檔以字串一列一列組成，讀取也以一列一列的方式讀取。 Binary file int i = 12345678; int大小4byte，記憶體實際存放的是二進位資料如下: 二進位 00000000 10111100 01100001 01001110 二進位檔案可以存放陣列、結構、類別…什麼類型都可以，圖片檔、mp3檔、mp4這些都是Binary file。 打開Binary file 1 ofstream fout(file_name, ios::binary); 參數1是檔名 參數2是ios::binary打開Binary file 1 ofstream fout(file_name, ios::app | ios::binary); ios::app | ios::binary意思是，寫入檔案從檔案最後開始寫。 1 ofstream fout(file_name, ios::trunc | ios::binary); ios::trunc | ios::binary意思是，寫入檔案用覆蓋原本檔案的方式寫入。 建立內容格式 假設要寫入類別，注意，不能用string，string 類型的資料無法直接用 write 和 read 操作進行正確的二進位序列化和反序列化。 1 2 3 4 5 6 7 8 class Student{ public: char name[100]; int age; }; Student s1; strcpy(s1.name, \"Mary\"); s1.age = 15; 寫入write 1 2 3 4 // 使用write(位址, size)寫入 // 參數1:物件位址，需手動轉型成const char* // 參數2:物件大小 fout.write((const char*)&amp;s1, sizeof(s1)); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstring&gt; // strcpy()要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.exe\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout(file_name, ios::trunc | ios::binary); if (fout.is_open() == false) { cout &lt;&lt; \"開啟檔案失敗\" &lt;&lt; endl; return 0; } class Student{ public: char name[100]; int age; }; Student s1; strcpy(s1.name, \"Mary\"); s1.age = 15; // 使用write(位址, size)寫入 // 參數1:物件位址，需手動轉型成const char* // 參數2:物件大小 fout.write((const char*)&amp;s1, sizeof(s1)); // 4.關閉檔案 fout.close(); return 0; } 讀取Binary file 打開Binary file 1 2 string file_name = \"/home/cici/test/app/test1.exe\"; ifstream fin(file_name, ios::in | ios::binary); 使用ios::in | ios::binary打開Binary file 讀取read fin.read((char*)位址, 大小); 將物件位址手動轉型成(char*) 1 2 3 4 5 6 7 8 9 // 怎麼寫入怎麼讀出來 class Student{ public: char name[100]; int age; }; Student s1; fin.read((char*)&amp;s1, sizeof(s1)); cout &lt;&lt; \"name = \" &lt;&lt; s1.name &lt;&lt; \", age = \" &lt;&lt; s1.age &lt;&lt; endl; 以上範例是只有寫入一個Student物件，若寫N個Student物件，可用while讀出來。 1 2 3 while (fin.read((char*)&amp;s1, sizeof(s1))) { cout &lt;&lt; \"name = \" &lt;&lt; s1.name &lt;&lt; \", age = \" &lt;&lt; s1.age &lt;&lt; endl; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.exe\"; ifstream fin(file_name, ios::in | ios::binary); if (fin.is_open() == false) { cout &lt;&lt; \"開啟檔案失敗\" &lt;&lt; endl; return 0; } // 怎麼寫入怎麼讀出來 class Student{ public: char name[100]; int age; }; Student s1; fin.read((char*)&amp;s1, sizeof(s1)); cout &lt;&lt; \"name = \" &lt;&lt; s1.name &lt;&lt; \", age = \" &lt;&lt; s1.age &lt;&lt; endl; // 關閉檔案 fin.close(); return 0; } 檔案的游標位置 用記事本或sublime文件編輯軟體打開文字檔，一開始閃爍的游標會停在第0格的位置，將滑鼠游標移動到其它文字或其它列，在這邊所說的”游標”就是會回應使用者輸入的位置，而這個”位置”“就是這小節的重點。 語法 取得游標位置函式，以下功能都相同 ofstream.tellp() ifstream.tellg() fstream.tellp() fstream.tellg() 文字檔寫入與取得游標位置 將先前寫入文字檔的範例，增加取得游標位置函式，每換行一次就印出目前的游標位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::trunc); if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } // 3.寫入(用法與cout一樣，cout&lt;&lt;是輸出到螢幕，fout&lt;&lt;是輸出到檔案) cout &lt;&lt; \"游標位置 = \" &lt;&lt; fout.tellp() &lt;&lt; endl; fout &lt;&lt; \"file 1 test test \\n\"; cout &lt;&lt; \"游標位置 = \" &lt;&lt; fout.tellp() &lt;&lt; endl; fout &lt;&lt; \"file 2 test test \\n\"; cout &lt;&lt; \"游標位置 = \" &lt;&lt; fout.tellp() &lt;&lt; endl; fout &lt;&lt; \"file 3 test test \\n\"; cout &lt;&lt; \"游標位置 = \" &lt;&lt; fout.tellp() &lt;&lt; endl; // 4.關閉檔案 fout.close(); return 0; } 游標位置 = 0 游標位置 = 18 游標位置 = 36 游標位置 = 54 二進位檔案讀取與游標位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;fstream&gt; using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.exe\"; ifstream fin(file_name, ios::in | ios::binary); if (fin.is_open() == false) { cout &lt;&lt; \"開啟檔案失敗\" &lt;&lt; endl; return 0; } // 怎麼寫入怎麼讀出來 class Student{ public: char name[100]; int age; }; Student s1; cout &lt;&lt; \"游標位置 = \" &lt;&lt; fin.tellg() &lt;&lt; endl; fin.read((char*)&amp;s1, sizeof(s1)); cout &lt;&lt; \"游標位置 = \" &lt;&lt; fin.tellg() &lt;&lt; endl; cout &lt;&lt; \"name = \" &lt;&lt; s1.name &lt;&lt; \", age = \" &lt;&lt; s1.age &lt;&lt; endl; // 關閉檔案 fin.close(); return 0; } 游標位置 = 0 游標位置 = 104 name = Mary, age = 15 隨機讀取與隨機寫入 移動游標位置 移動游標位置函式，以下功能都相同 std::istream &amp; seekg(std::streampos _Pos); 參數_Pos為游標位置 傳回游標位置指標 以下都是移動游標位置的語法: ofstream.seekp(_Pos) ifstream.seekg(_Pos) fstream.seekp(_Pos) fstream.seekg(_Pos) 位置參數 ios::beg，代表移動到檔案開始的位置 ios::end，代表移動到檔案最末尾的位置 ios::cur，代表目前游標在檔案中的位置 以上的值，都可作為上述_Pos的參數 1 2 3 4 // 移動到檔案最末尾的位置 fout.seekp(ios::end); // 移動到100 fout.seekp(100); 移動游標位置2 1 2 3 4 5 6 7 8 9 std::istream &amp; seekg(std::streamoff _Off,std::ios::seekdir _Way); // 移動到檔案開始的位置，再往右邊移動6個字元 fin.seekg(6, ios::beg); // 移動到游標位置，再往左移動5字元 fin.seekg(-5, ios::cur); // 移動到游標位置，再往右移動8字元 fin.seekg( 8, ios::cur); // 移動到檔案最末尾的位置，再往左移動10字元 fin.seekg(-10, ios::end); 移動游標程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; // getline()函式需要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test.txt\"; ifstream fin(file_name, ios::in); if (fin.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } // 用於存放讀取的內容 string buffer; // 移動到檔案開始的位置，再往右邊移動6個字元 fin.seekg(6, ios::beg); // 讀取一列字串，存放到buffer中 while (getline(fin, buffer)) { cout &lt;&lt; buffer &lt;&lt; endl; } // 關閉檔案 fin.close(); return 0; } 原本文字檔如下: file 1 test test file 2 test test file 3 test test 執行後結果，確實”file 1”共6個字元都沒有被顯示出來。 test test file 2 test test file 3 test test 緩衝區 暫時置放輸出或輸入資料的記憶體區域，也就是說寫入文件沒有即時寫入檔案，而是先放在記憶體區域，等待記憶體區域滿了，才會寫入檔案。 以下程式碼可能可以證明緩衝區的存在。 開二個linux終端機，一個編譯並執行以下程式碼，另一個終端機輸入tail -f test1.txt 注意！fout « 結尾不能是endl因為endl本身自帶flush的功能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; // usleep()要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::out); if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } for (int i = 0; i &lt; 1000; i++) { // 寫入 fout &lt;&lt; \"第 i = \" &lt;&lt; i &lt;&lt; \"次,abcdefghijklm.kljoppo kllkkjlkjjljjkldfjfdladfaklffadjkfladfjadklfalfakdfadlfjadkljfdakldfajfkfjkal \\n\"; // usleep(微秒) 暫時使程式停止執行 // 1秒 = 1,000,000 微秒 // 0.1秒 = 100,000 usleep(100000); } // 關閉檔案 fout.close(); return 0; } 若執行到999次之間有停頓住，代表緩衝區還沒滿。 flush fout.flush()將緩衝區的資料立即寫入檔案，終端機使用tail -f test1.txt可以追蹤查看檔案是一列列顯示，而不會停頓一下又冒出一批資料出來。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; // usleep()要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::out); if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } for (int i = 0; i &lt; 1000; i++) { // 寫入 fout &lt;&lt; \"第 i = \" &lt;&lt; i &lt;&lt; \"次,abcdefghijklm.kljoppo kllkkjlkjjljjkldfjfdladfaklffadjkfladfjadklfalfakdfadlfjadkljfdakldfajfkfjkal \\n\"; fout.flush(); // usleep(微秒) 暫時使程式停止執行 // 1秒 = 1,000,000 微秒 // 0.1秒 = 100,000 usleep(100000); } // 關閉檔案 fout.close(); return 0; } endl 除了斷行之外，還會將緩衝區的資料立即寫入檔案。 1 fout &lt;&lt; \"第 i = \" &lt;&lt; i &lt;&lt; \"次,abcdefghi\" &lt;&lt; endl; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; // usleep()要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::out); if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } for (int i = 0; i &lt; 1000; i++) { // 寫入 fout &lt;&lt; \"第 i = \" &lt;&lt; i &lt;&lt; \"次,abcdefghi\" &lt;&lt; endl; // usleep(微秒) 暫時使程式停止執行 // 1秒 = 1,000,000 微秒 // 0.1秒 = 100,000 usleep(100000); } // 關閉檔案 fout.close(); return 0; } unibuf 將緩衝區設置為有資料立即寫入檔案。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; // usleep()要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test1.txt\"; // 1.建立寫入檔案的物件(輸出串流) ofstream fout; // 2.打開檔案，若無檔案會建立新 // ios::trunc與ios:out與預設不代入第2個參數，覆蓋(清除)原本檔案內容 // ios::app是append附加在檔案內容後面 fout.open(file_name, ios::out); fout &lt;&lt; unitbuf; if (fout.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } for (int i = 0; i &lt; 1000; i++) { // 寫入 fout &lt;&lt; \"第 i = \" &lt;&lt; i &lt;&lt; \"次 \\n\"; // usleep(微秒) 暫時使程式停止執行 // 1秒 = 1,000,000 微秒 // 0.1秒 = 100,000 usleep(100000); } // 關閉檔案 fout.close(); return 0; } 判斷輸入串流錯誤 eof() 只有輸入串流有eofbit，輸出串流沒有。 當inputstream讀到檔案末尾會設定eofbit變數，eof()函式會檢查是否設定eofbit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; // getline()函式需要用到 using namespace std; int main() { // linux檔案位置 string file_name = \"/home/cici/test/app/test.txt\"; ifstream fin(file_name, ios::in); if (fin.is_open() == false) { cout &lt;&lt; \"開啟文字檔失敗\" &lt;&lt; endl; return 0; } // 用於存放讀取的內容 string buffer; while (true) { fin &gt;&gt; buffer; cout &lt;&lt; buffer &lt;&lt; endl; if (fin.eof() == true) break; } // 關閉檔案 fin.close(); return 0; } 以上的程式碼可被取代為 1 2 3 while (fin &gt;&gt; buffer) { cout &lt;&lt; buffer &lt;&lt; endl; } bad() bad()函式會檢查badbit是否設定，當硬碟空間不足，或系統有錯誤，就會被設定。 fail() fail()函式會檢查failbit是否設定，當檔案到了末尾，或程式有bug，就會被設定。 good() eofbit,badbit,failbit都是0的時候good()函式就會傳回true"
  },"/pages/c/file/file_desc/": {
    "title": "File description",
    "keywords": "",
    "url": "/pages/c/file/file_desc/",
    "body": "寫入文字檔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; // open()要用到 #include &lt;cstring&gt; // strcpy()要用到 using namespace std; int main() { int fd; // File descriptor // open file // O_CREAT 建立文字檔，如果檔案不存在就建立 // O_RDWR 有讀與寫的權限 // O_TRUNC 每一次寫入都直接把原檔內容清空覆蓋 fd = open(\"/home/cici/test/app/test.txt\", O_CREAT | O_RDWR | O_TRUNC); // 檔案操作失敗都會傳回-1，網路相關操作也是傳回-1 if (fd == -1) { perror(\"open fail\"); return -1; } cout &lt;&lt; \"fd = \" &lt;&lt; fd &lt;&lt; endl; // 寫入文字 char buffer[1024]; strcpy(buffer, \"input data test1 ...\"); // write()函式參數用到fd(File descriptor) if (write(fd, buffer, strlen(buffer)) == -1) { perror(\"write fail\"); return -1; } // close()函式參數用到fd(File descriptor) close(fd); // 暫停100秒，方便查看proc中的fd目錄 sleep(100); return 0; } fd = 3 讀取文字檔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; // open()要用到 #include &lt;cstring&gt; // strcpy()要用到 using namespace std; int main() { int fd; // File descriptor // open file // O_RDONLY 只有讀權限 fd = open(\"/home/cici/test/app/test.txt\", O_RDONLY); // 檔案操作失敗都會傳回-1，網路相關操作也是傳回-1 if (fd == -1) { perror(\"open fail\"); return -1; } cout &lt;&lt; \"fd = \" &lt;&lt; fd &lt;&lt; endl; // 讀取文件 // 存放文件內容的字元陣列 char buffer[1024]; memset(buffer, 0, sizeof(buffer)); // read()函式參數用到fd(File descriptor) if (read(fd, buffer, sizeof(buffer)) == -1) { perror(\"read fail\"); return -1; } cout &lt;&lt; \"檔案內容 = \" &lt;&lt; buffer &lt;&lt; endl; // close()函式參數用到fd(File descriptor) close(fd); // 暫停100秒，方便查看proc中的fd目錄 sleep(100); return 0; } $ ./fd_r_test fd = 3 檔案內容 = input data test1 ... fd 在linux編譯執行以上程式碼 進入/proc/進程id/fd目錄，裡面存放所有進程的File description cd /proc/進程id/fd $ cd /proc/13786 $ cd fd $ ls 0 1 2 fd預設有 0 cin鍵盤輸入 1 cout輸出到瑩幕 2 cerr錯誤訊息輸出到瑩幕 關掉fd 使用close，可以關掉fd close(fd); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; // open()要用到 #include &lt;cstring&gt; // strcpy()要用到 using namespace std; int main() { // 關閉cin close(0); // 關閉cout //close(1); // 關閉cerr //close(2); char input[100]; cin &gt;&gt; input; cout &lt;&lt; \"input = \" &lt;&lt; input &lt;&lt; endl; cerr &lt;&lt; \"error!\" &lt;&lt; endl; // 暫時休眠200秒，方便使用proc查看fd sleep(200); return 0; } 編譯後執行 $ ./input_test input = (??6? error! 開另一個終端機，進入fd的目錄查看，發現少一個0 /proc/13900/fd$ ls 1 2 若把0,1,2都關掉，fd的編號就會從0開始。"
  },"/pages/c/socket/fork_socket/": {
    "title": "多工的socket",
    "keywords": "",
    "url": "/pages/c/socket/fork_socket/",
    "body": "之前的socket是一對一連線，也就是一個socket對一個client。 此篇是一個Server，可以讓多個Client連線。 每次接受Client連線後，就fork一個子程序去做傳送資料與接收資料的事。 父程序流程 監聽listen socket()函式 -&gt; 轉換port變成big-endian -&gt; bind()綁定ip與port -&gt; listen()開始監聽 -&gt; accept()接受client連線，傳回client socket 對於父程序來說，只要管理listen socket，關閉listen socket。 子程序流程 send()傳送資料 -&gt; recv()接收資料 對於子程序而言，只要管理client socket，關閉client socket。 多工Server Socket程式碼 TCPServer tcpServer;設為全域變數 include signal.h 複製kill的FatherExit()與ChildExit()函式 加上while fork複製出子程序 fork複製出子程序後，父程序就不需要管理client socket，關掉client socket 子程序不用管理監聽的socket，所以關掉它 子程序執行完，要關閉子程序，return 0;在無限迴圈內關閉子程序，while(true){… return 0;} class TCPServer { public: // 建構子 // 監聽listen_fd，-1代表未初始化 // client_fd，-1代表未連線 TCPServer() : listen_fd_(-1), client_fd_(-1) {} // 初始化監聽的socket bool initListen(const unsigned short port) { listen_fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listen_fd_ == -1) return false; port_ = port; // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server port server_addr.sin_port = htons(port_); // server有多個ip，所有ip都會監聽port server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // socket綁定ip與port if (::bind(listen_fd_, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) == -1) { // 關閉監聽器 close(listen_fd_); listen_fd_ = -1; return false; } // 把socket設為監聽的狀態 // 最多只讓3個client同時連server if (listen(listen_fd_, 3)) { close(listen_fd_); listen_fd_ = -1; return false; } return true; } bool accept() { // client的ip結構 struct sockaddr_in client_addr; socklen_t addr_len = sizeof(client_addr); // 接受client的連線 // 若要得到client的ip，第二個參數填sockaddr_in結構，第3個參數填結構大小 // 若不想得到client ip，第2與第3參數填0就好 client_fd_ = ::accept(listen_fd_, (struct sockaddr*)&amp;client_addr, &amp;addr_len); if (client_fd_ == -1) return false; // 取得client的ip // 透過inet_ntoa把big-endian轉成little-endian client_ip_ = inet_ntoa(client_addr.sin_addr); return true; } const string&amp; getClientIp() const { return client_ip_; } bool send(const string &amp;buffer) { // 如果client fd是-1就沒必要繼續後面的動作，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer.data(), buffer.size(), 0)) &lt;= 0) return false; return true; } // 第一個參數要修改buffer的內容，所以不加const bool recv(string &amp;buffer, const size_t maxlen) { // 清空string buffer.clear(); // 分配記憶體大小 buffer.resize(maxlen); // 收到的資料放在buffer的記憶體空間 // 操作到string的記憶體位址，有對string物件進行讀取與寫入 // 第2個參數填不是const的記憶體位址，第3個參數填大小 // &amp;buffer[0]取得位址，傳回值不是const // buffer.data()傳回值是const，所以不用 // recv()傳回值是收到的資料大小 int iret = ::recv(client_fd_, &amp;buffer[0], buffer.size(), 0); // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if (iret &lt;= 0) { cout &lt;&lt; \"iret = \" &lt;&lt; iret &lt;&lt; endl; // 失敗時把buffer清空，否則buffer大小一直維持1024 buffer.clear(); return false; } // 如果有操作到string的記憶體位址，string的自動擴展空間會失效 // 需要自己重設string大小 // 從1024大小，設為真正收到資料的大小 buffer.resize(iret); return true; } // 關閉監聽socket bool closeListen() { // 若未初始化，直接返回 if (listen_fd_ == -1) return false; ::close(listen_fd_); // 設為未初始化-1 listen_fd_ = -1; return true; } // 關閉client socket bool closeClient() { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; ::close(client_fd_); // 設成未連線-1 client_fd_ = -1; return true; } ~TCPServer() { // 解構子把二個socket都關掉 closeListen(); closeClient(); } private: int listen_fd_; int client_fd_; string client_ip_; unsigned short port_; }; // 設成全域變數 // 建立監聽fd listen_fd TCPServer tcpServer; // 父程序離開 void FatherExit(int sig) { // 怱略二次收到相同訊號 // 使用kill(0, 訊號)會發給子程序也會再次發給發送訊號的父程序自己 signal(SIGINT, SIG_IGN); // 怱略ctrl+c signal(SIGTERM, SIG_IGN); // 怱略kill -15 cout &lt;&lt; \"父程序退出， signal = \" &lt;&lt; sig &lt;&lt; endl; kill(0, SIGTERM); // 向全部的子程序發送15訊號，終止子程序 // 父程序管理listen socket，父程序要離開要釋放記憶體 // 關閉listen socket tcpServer.closeListen(); exit(0); // 父程序離開 } // 子程序離開 void ChildExit(int sig) { // 防止再次收到相同訊號 signal(SIGINT, SIG_IGN); // 怱略ctrl+c signal(SIGTERM, SIG_IGN); // 怱略kill -15 cout &lt;&lt; \"子程序 pid = \" &lt;&lt; getpid() &lt;&lt; \" 退出， signal = \" &lt;&lt; sig &lt;&lt; endl; // 子程序管理client socket，子程序要離開要釋放記憶體 // 關閉client socket tcpServer.closeClient(); exit(0); // 子程序離開 } int main(int argc, char *argv[]) { if (argc != 2) { cout &lt;&lt; \"請輸入 ./server_test port\" &lt;&lt; endl; return -1; } // 略過全部訊號 for (int i = 0; i &lt;= 64; i++) signal(i, SIG_IGN); // 父程序要補捉的訊號 ctrl + c signal(SIGTERM, FatherExit); // 父程序要補捉kill -15 signal(SIGINT, FatherExit); // 初始化監聽 if (tcpServer.initListen(atoi(argv[1])) == false) { perror(\"initListen\"); return -1; } // 無限循環，一直為Client提供服務 while (true) { // 接受client連接 if (tcpServer.accept() == false) { perror(\"accept\"); return -1; } // fork後，會把client socket與listen socket複製一份給子程序 int pid = fork(); if (pid == -1) { perror(\"fork()\"); return -1; } // 大於0是父程序，直接跳到while()條件句，等待Client來連線 if (pid &gt; 0) { // fork複製出子程序後，父程序就不需要管理client socket，這個是子程序管理 // 關掉client socket tcpServer.closeClient(); continue; } // 以下是子程序要跑的程式碼 // 子程序不用管理監聽的socket，所以關掉它 tcpServer.closeListen(); // 子程序要補捉的訊號 ctrl + c signal(SIGTERM, ChildExit); // 子程序要補捉kill -15 signal(SIGINT, ChildExit); cout &lt;&lt; \"client已連上 = \" &lt;&lt; tcpServer.getClientIp() &lt;&lt; endl; string buffer; while (true) { // 如果client沒有send data，recv()會等待 // 收到0，代表斷線 if (tcpServer.recv(buffer, 1024) == false) { perror(\"recv()\"); break; } cout &lt;&lt; \"收到client data = \" &lt;&lt; buffer &lt;&lt; endl; // 建立回應的資料給client buffer = \"ok\"; // 傳送回應的資料 if (tcpServer.send(buffer) == false) { perror(\"send\"); break; } cout &lt;&lt; \"send = \" &lt;&lt; buffer &lt;&lt; endl; } // 子程序處理用戶端傳輸，傳輸接收完畢後，要用return 0關閉子程序 // 若不關閉又會回到accept()函式 return 0; } }"
  },"/pages/c/socket/socket/": {
    "title": "socket",
    "keywords": "",
    "url": "/pages/c/socket/socket/",
    "body": "Prerequisites: File description errno main linux下編譯c++ socket()函式 1 int socket(int domain, int type, int protocol); 失敗傳回-1，錯誤訊息已放至errno 成功傳回fd 參數domain 固定用AF_INET AF_INET支援TCP與UDP通訊傳輸協定。 參數type SOCK_STREAM 使用在TCP可靠傳輸協議，封包不會丟失 SOCK_DGRAM 使用在UDP不可靠傳輸協議，封包會丟失 參數protocol IPPROTO_TCP 建立TCP socket語法 1 socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); IPPROTO_UDP 建立UDP socket語法 1 socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); big-endian 網路傳輸以big-endian方式傳輸。 電腦是以little-endian方式進行記憶體儲存，但在網路傳輸，一律轉成big-Endian。 host，主機，伺服器提供網站服務，此時這個伺服器是主機。 port轉成big-endian 透過以下語法把port互轉為big-Endian與little-endian 1 2 3 4 5 6 // port轉成big-endian uint16_t h to n s(uint16_t hostshort); // uint16_t 2byte unsigned short uint32_t htonl(uint32_t hostlong); // uint32_t 4byte unsigned int // big-endian的port轉成little-endian uint16_t n to h s(uint16_t netshort); uint32_t ntohl(uint32_t netlong); h = host(主機) to = 轉 n = network(網路) s = short(2byte=16bit) l = long(4byte=32bit) sockaddr結構 1 2 3 4 struct sockaddr { unsigned short sa_family; // 固定填AF_INET unsigned char sa_data[14]; // 14byte的ip與port }; sockaddr_in結構 大小與sockaddr結構一模一樣，但sockaddr結構的sa_data[14]範圍太大，此sockaddr_in結構補足sockaddr的不足。 1 2 3 4 5 6 7 8 9 10 struct sockaddr_in { unsigned short sin_family; // 固定填AF_INET unsigned short sin_port; // 16bit,2byte port number,用htons()函式轉成big-endian struct in_addr sin_addr; // ip結構32bit,4byte unsigned char sin_zero[8]; // 未使用，主要補足14byte - (ip 4byte) - (port 2byte) = 8 byte }; // ip結構 struct in_addr { unsigned int s_addr; // 32bit,4byte ip 透過gethostbyname()函式轉成big-endian }; 在呼叫connect()函式時，再把sockaddr_in結構轉成sockaddr結構，二者記憶體大小都一樣，可以轉換。 1 (struct sockaddr* )&amp;server_addr ip轉成big-endian gethostbyname()函式將ip轉成big-endian 1 struct hostent* gethostbyname(const char* name); define hostent結構 1 2 3 4 5 6 7 8 struct hostent { char* h_name; // 主機名 char** h_aliases; // 主機別名 short h_addrtype; // ip類型，固定填AF_INET short h_length; // ip長度, ipv4 是4 byte char** h_addr_list; //ip address以big-endian存放 }; #define h_addr h_addr_list[0] // h_addr是h_addr_list[0]的別名 透過以下語法將轉成big-endian的ip拷貝到sockaddr_in結構 1 memcpy(&amp;sockaddr_in.sin_addr,h-&gt;h_addr,h-&gt;h_length); client建立socket 建立socket流程如下: socket()函式 -&gt; 轉換ip與port變成big-endian -&gt; connect() 傳輸流程如下: send()傳送資料 -&gt; recv()接收資料 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; using namespace std; int main(int argc, char *argv[]) { if (argc != 3) { cout &lt;&lt; \"請輸入 ./client_test ip port\" &lt;&lt; endl; return -1; } // 建立socket，失敗傳回-1 int socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (socket_fd == -1) { perror(\"socket\"); return -1; } // server ip轉big-endian struct hostent* h; if ((h = gethostbyname(argv[1])) == nullptr) { cout &lt;&lt; \"gethostbyname() fail.\" &lt;&lt; endl; // 關閉socket close(socket_fd); return -1; } // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server ip memcpy(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length); // server port server_addr.sin_port = htons(atoi(argv[2])); // connect伺服器，傳回值為0代表連線成功，不是0代表連線失敗 if (connect(socket_fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) != 0) { perror(\"connect\"); // 關閉socket close(socket_fd); return -1; } // send data給伺服器 char buffer[1024]; for (int i = 0; i &lt; 3; i++) { // 宣告send()與recv()的傳回值 int iret; // 清空buffer memset(buffer, 0, sizeof(buffer)); // sprintf 格式化輸出到 buffer 裡。 sprintf(buffer, \"data %d\", i + 1); // send buffer to server if ((iret = send(socket_fd, buffer, strlen(buffer), 0)) &lt;= 0) { perror(\"send\"); break; } cout &lt;&lt; \"傳送給伺服器 = \" &lt;&lt; buffer &lt;&lt; endl; // 清空buffer memset(buffer, 0, sizeof(buffer)); // 收伺服器的回應 if ((iret = recv(socket_fd, buffer, sizeof(buffer), 0)) &lt;= 0) { cout &lt;&lt; \"iret = \" &lt;&lt; iret &lt;&lt; endl; break; } cout &lt;&lt; \"伺服器的回應 = \" &lt;&lt; buffer &lt;&lt; endl; //暫停1秒 sleep(1); } close(socket_fd); return 0; } server systemctl 以下bash指令都是在ubuntu下進行 systemctl指令是對服務進行管理 語法 $ sudo systemctl 操作 服務名 以下為開啟服務，停止服務，重啟服務，查看服務狀態，檢查是否啟動 $ sudo systemctl start 服務名 $ sudo systemctl stop 服務名 $ sudo systemctl restart 服務名 $ sudo systemctl status 服務名 $ sudo systemctl is-active 服務名 Linux重新開機後會自動啟動服務 $ sudo systemctl enable 服務名 Linux重新開機後會關閉自動啟動服務 $ sudo systemctl disable 服務名 查看是否為開始自動啟動服務 $ sudo systemctl is-enabled 服務名 防火牆 以下步驟是更新 -&gt; 安裝防火牆 -&gt; 啟動防火牆 -&gt; 查看防火牆狀態為active(啟動) $ sudo apt-get update $ sudo apt-get install ufw $ sudo systemctl start ufw $ sudo systemctl status ufw ● ufw.service Loaded: not-found (Reason: Unit ufw.service not found.) Active: active (exited) since Wed 2025-01-15 09:24:41 CST; 8min ago Main PID: 31048 (code=exited, status=0/SUCCESS) CPU: 501ms open listen port 增加對外開放的port $ sudo ufw allow 1234 $ sudo ufw status 狀態： 啓用 至 動作 來自 - -- -- 1234 ALLOW Anywhere 1234 (v6) ALLOW Anywhere (v6) 增加iptable $ sudo iptables -I INPUT -p tcp -m tcp --dport 1234 -j ACCEP $ sudo iptables -L -n Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT 6 -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:1234 Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 編譯執行程式 編譯執行此頁最下面server程式碼 $ vi server_test.cpp $ g++ -o server_test server_test.cpp $ ./server_test 1234 打開另一個ssh終端機，要確認有0 0.0.0.0:1234 $ sudo netstat -tunlp (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.54:53 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:1234 0.0.0.0:* LISTEN 33757/./server_test 打開另一個ssh終端機，檢查是否能連上1234 port 有出現’^]’這個符號，代表可以連上。 $ telnet 192.168.235.128 1234 Trying 192.168.235.128... Connected to 192.168.235.128. Escape character is '^]'. 打開另一個ssh終端機，把上面client建立socket程式碼編譯執行 $ vi client_test.cpp $ g++ -o client_test client_test.cpp $ ./client_test 192.168.235.128 1234 執行結果 sever_test $ ./server_test 1234 client已連上 收到client data = data 1 send = ok 收到client data = data 2 send = ok 收到client data = data 3 send = ok iret = 0 client_test $ ./client_test 192.168.235.128 1234 傳送給伺服器 = data 1 伺服器的回應 = ok 傳送給伺服器 = data 2 伺服器的回應 = ok 傳送給伺服器 = data 3 伺服器的回應 = ok server程式碼 建立監聽socket與接受clinet連線的流程: 建立監聽listen socket()函式 -&gt; 轉換port變成big-endian -&gt; bind()綁定ip與port -&gt; listen()開始監聽 -&gt; accept()接受client連線，傳回client socket 傳輸流程如下: send()傳送資料 -&gt; recv()接收資料 監聽socket與client socket的區別: 監聽listen socket只能建立連線 client的socket可以與用戶端傳送與接收資料 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; using namespace std; int main(int argc, char *argv[]) { if (argc != 2) { cout &lt;&lt; \"請輸入 ./server_test port\" &lt;&lt; endl; return -1; } // 建立監聽fd listen_fd，失敗傳回-1 int listen_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listen_fd == -1) { perror(\"socket\"); return -1; } // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server port server_addr.sin_port = htons(atoi(argv[1])); // server有多個ip，所有ip都會監聽port server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 綁定監聽器，失敗傳回-1 if (bind(listen_fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) == -1) { perror(\"bind error\"); // 關閉監聽器 close(listen_fd); return -1; } // 最多只讓3個client同時連server if (listen(listen_fd, 3)) { perror(\"listen\"); close(listen_fd); return -1; } // 接受client連接 int client_fd = accept(listen_fd, 0, 0); if (client_fd == -1) { perror(\"accept\"); close(listen_fd); return -1; } cout &lt;&lt; \"client已連上\" &lt;&lt; endl; char buffer[1024]; // 一定要用無限循環，等待client連上來 while (true) { int iret; memset(buffer, 0, sizeof(buffer)); // 如果client沒有send data，recv()會等待 // 如果client斷線，recv()傳回0 // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if ((iret = recv(client_fd, buffer, sizeof(buffer), 0)) &lt;= 0) { cout &lt;&lt; \"iret = \" &lt;&lt; iret &lt;&lt; endl; // 斷線 = 0就跳出無限循環 break; } cout &lt;&lt; \"收到client data = \" &lt;&lt; buffer &lt;&lt; endl; // 建立回應的資料給client strcpy(buffer, \"ok\"); // 傳送回應的資料 if ((iret = send(client_fd, buffer,strlen(buffer), 0)) &lt;= 0) { perror(\"send\"); break; } cout &lt;&lt; \"send = \" &lt;&lt; buffer &lt;&lt; endl; } close(listen_fd); close(client_fd); return 0; } 封裝Socket Prerequisites: 使用陣列索引取得記憶體位址 data()取得記憶體位址 cstring與string連結 resize() string size string參數 封裝，物件導向中用來實作資訊隱藏的機制，確保物件的安全。其作法為：隱藏不想讓外界碰觸的成員，只公開接受外界存取的成員。 使用::connect()，::二個冒號是使用Standard Library中的全域函式connect()，並不是自己建立的成員函式connect()。 send(const string &amp;buffer)，參數使用const string是因為既可支援string，也可支援const char* client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; using namespace std; class TCPClient { public: // 建構子，初始化client_fd，-1代表沒有連線 TCPClient() : client_fd_(-1) {} bool connect(const string &amp;ip, const unsigned short port) { // client_fd若已連線，就不用再連，直接返回 if (client_fd_ != -1) return false; ip_ = ip; port_ = port; client_fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // socket失敗傳回-1 if (client_fd_ == -1) return false; // server ip轉big-endian struct hostent* h; // gethostbyname需要cstring，所以要把string轉成cstring if ((h = gethostbyname(ip_.c_str())) == nullptr) { cout &lt;&lt; \"gethostbyname() fail.\" &lt;&lt; endl; // 關閉socket ::close(client_fd_); // 失敗把client_fd還原成初始化-1 client_fd_ = -1; return false; } // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server ip memcpy(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length); // server port server_addr.sin_port = htons(port_); // connect伺服器，傳回值為0代表連線成功，不是0代表連線失敗 if (::connect(client_fd_, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) != 0) { // 關閉socket ::close(client_fd_); // 失敗把client_fd還原成初始化-1 client_fd_ = -1; return false; } return true; } // 參數使用const string是因為既可支援string，也可支援const char* bool send(const string &amp;buffer) { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer.data(), buffer.size(), 0)) &lt;= 0) return false; return true; } // 第一個參數要修改buffer的內容，所以不加const bool recv(string &amp;buffer, const size_t maxlen) { // 清空string buffer.clear(); // 分配記憶體大小 buffer.resize(maxlen); // 收到的資料放在buffer的記憶體空間 // 操作到string的記憶體位址，有對string物件進行讀取與寫入 // 第2個參數填不是const的記憶體位址，第3個參數填大小 // &amp;buffer[0]取得位址，傳回值不是const // buffer.data()傳回值是const，所以不用 // recv()傳回值是收到的資料大小 int iret = ::recv(client_fd_, &amp;buffer[0], buffer.size(), 0); // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if (iret &lt;= 0) { // 失敗時把buffer清空，否則buffer大小一直維持1024 buffer.clear(); return false; } // 如果有操作到string的記憶體位址，string的自動擴展空間會失效 // 需要自己重設string大小 // 從1024大小，設為真正收到資料的大小 buffer.resize(iret); return true; } bool close() { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; ::close(client_fd_); client_fd_ = -1; return true; } ~TCPClient() { close(); } private: int client_fd_; string ip_; unsigned short port_; }; int main(int argc, char *argv[]) { if (argc != 3) { cout &lt;&lt; \"請輸入 ./client_test ip port\" &lt;&lt; endl; return -1; } // 建立socket TCPClient tcp_client; if (tcp_client.connect(argv[1], atoi(argv[2])) == false) { perror(\"socket\"); return -1; } // send data給伺服器 string buffer; for (int i = 0; i &lt; 3; i++) { buffer = \"data \" + to_string(i); // send buffer to server if (tcp_client.send(buffer) == false) { perror(\"send\"); break; } cout &lt;&lt; \"傳送給伺服器 = \" &lt;&lt; buffer &lt;&lt; endl; // 收伺服器的回應，若伺服器沒回應，就會一直停在這裡等待回應，不會往下執行 if (tcp_client.recv(buffer, 1024) == false) { perror(\"rev\"); break; } cout &lt;&lt; \"伺服器的回應 = \" &lt;&lt; buffer &lt;&lt; endl; //暫停1秒 sleep(1); } return 0; } server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; using namespace std; class TCPServer { public: // 建構子 // 監聽listen_fd，-1代表未初始化 // client_fd，-1代表未連線 TCPServer() : listen_fd_(-1), client_fd_(-1) {} // 初始化監聽的socket bool initListen(const unsigned short port) { listen_fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listen_fd_ == -1) return false; port_ = port; // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server port server_addr.sin_port = htons(port_); // server有多個ip，所有ip都會監聽port server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // socket綁定ip與port if (::bind(listen_fd_, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) == -1) { // 關閉監聽器 close(listen_fd_); listen_fd_ = -1; return false; } // 把socket設為監聽的狀態 // 最多只讓3個client同時連server if (listen(listen_fd_, 3)) { close(listen_fd_); listen_fd_ = -1; return false; } return true; } bool accept() { // client的ip結構 struct sockaddr_in client_addr; socklen_t addr_len = sizeof(client_addr); // 接受client的連線 // 若要得到client的ip，第二個參數填sockaddr_in結構，第3個參數填結構大小 // 若不想得到client ip，第2與第3參數填0就好 client_fd_ = ::accept(listen_fd_, (struct sockaddr*)&amp;client_addr, &amp;addr_len); if (client_fd_ == -1) return false; // 取得client的ip // 透過inet_ntoa把big-endian轉成little-endian client_ip_ = inet_ntoa(client_addr.sin_addr); return true; } const string&amp; getClientIp() const { return client_ip_; } bool send(const string &amp;buffer) { // 如果client fd是-1就沒必要繼續後面的動作，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer.data(), buffer.size(), 0)) &lt;= 0) return false; return true; } // 第一個參數要修改buffer的內容，所以不加const bool recv(string &amp;buffer, const size_t maxlen) { // 清空string buffer.clear(); // 分配記憶體大小 buffer.resize(maxlen); // 收到的資料放在buffer的記憶體空間 // 操作到string的記憶體位址，有對string物件進行讀取與寫入 // 第2個參數填不是const的記憶體位址，第3個參數填大小 // &amp;buffer[0]取得位址，傳回值不是const // buffer.data()傳回值是const，所以不用 // recv()傳回值是收到的資料大小 int iret = ::recv(client_fd_, &amp;buffer[0], buffer.size(), 0); // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if (iret &lt;= 0) { cout &lt;&lt; \"iret = \" &lt;&lt; iret &lt;&lt; endl; // 失敗時把buffer清空，否則buffer大小一直維持1024 buffer.clear(); return false; } // 如果有操作到string的記憶體位址，string的自動擴展空間會失效 // 需要自己重設string大小 // 從1024大小，設為真正收到資料的大小 buffer.resize(iret); return true; } // 關閉監聽socket bool closeListen() { // 若未初始化，直接返回 if (listen_fd_ == -1) return false; ::close(listen_fd_); // 設為未初始化-1 listen_fd_ = -1; return true; } // 關閉client socket bool closeClient() { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; ::close(client_fd_); // 設成未連線-1 client_fd_ = -1; return true; } ~TCPServer() { // 解構子把二個socket都關掉 closeListen(); closeClient(); } private: int listen_fd_; int client_fd_; string client_ip_; unsigned short port_; }; int main(int argc, char *argv[]) { if (argc != 2) { cout &lt;&lt; \"請輸入 ./server_test port\" &lt;&lt; endl; return -1; } // 建立監聽fd listen_fd TCPServer tcpServer; // 初始化監聽 if (tcpServer.initListen(atoi(argv[1])) == false) { perror(\"initListen\"); return -1; } // 接受client連接 if (tcpServer.accept() == false) { perror(\"accept\"); return -1; } cout &lt;&lt; \"client已連上 = \" &lt;&lt; tcpServer.getClientIp() &lt;&lt; endl; string buffer; while (true) { // 如果client沒有send data，recv()會等待 // 收到0，代表斷線 if (tcpServer.recv(buffer, 1024) == false) { perror(\"recv()\"); break; } cout &lt;&lt; \"收到client data = \" &lt;&lt; buffer &lt;&lt; endl; // 建立回應的資料給client buffer = \"ok\"; // 傳送回應的資料 if (tcpServer.send(buffer) == false) { perror(\"send\"); break; } cout &lt;&lt; \"send = \" &lt;&lt; buffer &lt;&lt; endl; } return 0; }"
  },"/pages/c/basic/include/": {
    "title": "include與define",
    "keywords": "",
    "url": "/pages/c/basic/include/",
    "body": "head file 檔名以.h為結尾，定義使用的標頭檔，定義(definition)函式，定義類別，定義結構…等等。 include head file 從編譯器中的Library找尋標頭檔: 1 #include &lt;標頭檔&gt; 檔案所在目錄下，尋找副檔名.h標頭檔，找不到就去編譯器中的Library找尋。 1 #include \"標頭檔.h\" include也可以用.cpp檔，不是只限於.h include是把檔案內容複製下來，貼上呼叫include的位置，跟內嵌函式是一樣的。 pragma once 重覆include的標頭檔，只要include一次，放在檔案最上面。 1 #pragma once C Standard Library c98的Standard Library，舊版本會加上.h，新版本前面會加上c去掉.h 不加上std的namespace也可以使用C Standard Library 舊版本 1 #include &lt;stdio.h&gt; 新版本前面會加上c去掉.h 1 #include &lt;cstdio&gt; C++ Standard Library 要加上std的namespace才可以使用C++ Standard Library 1 using namespace std; 舊版本會加上.h，新版本會去掉.h，已棄用。 1 #include &lt;iostream.h&gt; 新版本會去掉.h 1 #include &lt;iostream&gt; define前置指令 編譯的時候，編譯器把以下的內容取代變數，跟內嵌函式是一樣的。 define只是把內容取代變數，沒有變數型別。 1 #define 變數 內容 以下將”ABCDEFaaaaaa”取代MSG 1 2 3 4 5 #define MSG \"ABCDEFaaaaaa\" int main() { cout &lt;&lt; MSG &lt;&lt; endl; return 0; } ABCDEFaaaaaa 把MSG變數的內容改成endl;斷行與分號，以下程式碼編譯不會出錯。 1 2 3 4 5 6 #define MSG endl; int main() { // 注意，以下結尾沒有分號 cout &lt;&lt; MSG return 0; } 結果只會出現一個斷行 C++提供的前置指令 __cplusplus ，可以辯別是c++還c 檔名 : __FILE__ 函式名 : __Function__ 程式碼行號 : __LINE__ 編譯日期: __DATE__ 編譯時間: __TIME__ 1 2 3 4 5 6 7 8 9 10 int main() { cout &lt;&lt; \"__cplusplus = \" &lt;&lt; __cplusplus &lt;&lt; endl; cout &lt;&lt; \"__FILE__ = \" &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; \"__FUNCTION__ = \" &lt;&lt; __FUNCTION__ &lt;&lt; endl; cout &lt;&lt; \"__LINE__ = \" &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; \"__DATE__ = \" &lt;&lt; __DATE__ &lt;&lt; endl; cout &lt;&lt; \"__TIME__ = \" &lt;&lt; __TIME__ &lt;&lt; endl; cout &lt;&lt; \"__TIMESTAMP__ = \" &lt;&lt; __TIMESTAMP__ &lt;&lt; endl; return 0; } __cplusplus = 201402 __FILE__ = /Users/cici/projects/lsn11/lsn11/main.cpp __FUNCTION__ = main __LINE__ = 20 __DATE__ = Jan 13 2025 __TIME__ = 13:41:38 __TIMESTAMP__ = Mon Jan 13 13:41:36 2025 define 只有變數沒有內容 定義前置變數，並不是一定要有內容 1 #define 變數 例: 1 #define DEBUG ifdef 判斷是否有定義前置變數 1 2 3 4 5 6 7 8 9 #define DEBUG int main() { #ifdef DEBUG // 若有定義DEBUG printf(\"測試測試\\n\"); #else // 若沒有定義DEBUG printf(\"不是測試\\n\"); #endif return 0; } 測試測試 ifndef 判斷若沒定義 以下的程式碼功能跟pragma once一樣，只會被include一次 1 2 3 4 5 6 7 8 9 using namespace std; #ifndef __CICI__H // 若沒有定義CICI__H #define __CICI__H // 定義它 #include \"cici.h\" // 匯入cici.h的內容 #endif int main() { hi(); return 0; } Hello! Cici! cici.h的內容如下: 1 2 3 4 5 #include &lt;iostream&gt; using namespace std; void hi() { cout &lt;&lt; \"Hello! Cici!\" &lt;&lt; endl; } 判斷作業系統 Linux : __linux__ Windows : _WIN32 1 2 3 4 5 6 7 8 int main() { #ifdef _WIN32 // 判斷是不是windows cout &lt;&lt; \"這是windows\" &lt;&lt; endl; #else cout &lt;&lt; \"這不是windows\" &lt;&lt; endl; #endif return 0; } 這不是windows 不同作業系統，定義型別 在windows中，long是4byte(32bit)，long long是8byte(64bit) 在linux中，long是8byte(64bit)，二者的long的bit不同。 以下範例自行定義64bit的整數型別，int64，根據判斷作業系統，採用不同的long，但型別的儲存大小都是8byte(64bit)。 1 2 3 4 5 6 7 8 9 10 11 int main() { #ifdef _WIN32 //判斷是不是windows cout &lt;&lt; \"這是windows\" &lt;&lt; endl; typedef long long int64; #else cout &lt;&lt; \"這不是windows\" &lt;&lt; endl; typedef long int64; #endif int64 val = 100; cout &lt;&lt; \"val = \" &lt;&lt; val &lt;&lt; endl; return 0; 這不是windows val = 100"
  },"/pages/c/basic/main/": {
    "title": "main",
    "keywords": "",
    "url": "/pages/c/basic/main/",
    "body": "Prerequisites: linux下編譯c++ main函式 main()函式為程式進入點，若沒有要抓參數，可以不寫main的參數，預設參數為空，函式傳回值預設傳0。 main函式的參數 1 int main(int argc, char* argv[]) argc 參數個數 argv[] 參數的值 程式碼 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; int main(int argc, char* argv[]) { cout &lt;&lt; \"參數個數 = \" &lt;&lt; argc &lt;&lt; endl; // 全部參數 for (int i = 0; i &lt; argc; i++) { cout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"個參數 = \" &lt;&lt; argv[i] &lt;&lt; endl; } return 0; } 編譯執行 $ vi main_test.cpp $ g++ -o main_test main_test.cpp $ ./main_test 參數個數 = 1 第0個參數 = ./main_test 由以上結果可知，./main_test，也是一個參數 $ /home/cici/test/app/main_test 參數個數 = 1 第0個參數 = /home/cici/test/app/main_test 由以上結果可知，輸入執行檔的全部路徑，全部路徑也是一個參數 $ ./main_test aa bb cc dd ee ff 參數個數 = 7 第0個參數 = ./main_test 第1個參數 = aa 第2個參數 = bb 第3個參數 = cc 第4個參數 = dd 第5個參數 = ee 第6個參數 = ff"
  },"/pages/c/socket/file_socket/": {
    "title": "Socket傳送檔案",
    "keywords": "",
    "url": "/pages/c/socket/file_socket/",
    "body": "Prerequisites: File IO client 傳送流程 傳送檔名與大小 -&gt; 取得server回應(確認server已收到檔名與大小) -&gt; 傳送檔案 -&gt; 取得server回應(確認server已收到檔案) 傳送檔名與檔案大小 1 2 3 4 5 6 7 8 9 // 傳送檔名與大小 bool send(void *buffer, const size_t size) { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer, size, 0)) &lt;= 0) return false; return true; } 傳送檔案 使用while無限迴圈，待檔案傳送完，就會離開無限迴圈。 把每個byte都視為1個磚頭，有1000個磚頭，每次只搬7個磚頭，直至1000個磚頭搬送完畢。 檔案每次只傳7byte，除非剩下要傳的byte小於7byte，才用小於7byte的數字傳送。 了解原理後，可以把7byte改成1024byte，每次只傳1024byte，直到全部的byte都傳送完畢。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 傳送檔案 bool sendFile(const string &amp;file_name, const size_t file_size) { // 參數2指定binaryfile ifstream fin(file_name, ios::binary); if (fin.is_open() == false) { cout &lt;&lt; \"open file (\" &lt;&lt; file_name &lt;&lt; \") fail\" &lt;&lt; endl; return false; } // 每次要讀資料的個數(byte) int read = 0; // 記錄已傳送資料的個數，若total_byte == file_size代表傳送完 int total_bytes = 0; // 每次只傳送7byte char buffer[7]; while (true) { // 清空 memset(buffer, 0, sizeof(buffer)); // 如果剩下的byte數量，大於7個，就傳送7個 if (file_size - total_bytes &gt; 7) read = 7; else //小於7，就傳小於7的數量 read = file_size - total_bytes; fin.read(buffer, read); // 把讀到的資料送給server if (send(buffer, read) == false) return false; // 加上已傳送的數量 total_bytes += read; if (total_bytes == file_size) break; } return true; } main參數 改為傳送5個參數，./client_test ip port 檔名 檔案大小 1 2 3 4 if (argc != 5) { cout &lt;&lt; \"請輸入 ./client_test ip port 檔名 檔案大小\" &lt;&lt; endl; return -1; } 檔案結構 包含檔名與檔案大小 1 2 3 4 5 6 7 8 9 // 檔案結構 struct FileInfo { char filename[256]; // 檔名 int filesize; // 檔案大小 } file_info; // 變數名 // 清空 memset(&amp;file_info, 0, sizeof(file_info)); strcpy(file_info.filename, argv[3]); // 檔名 file_info.filesize = atoi(argv[4]); // 檔案大小 傳送檔名與檔案大小 1 2 3 4 5 // 傳送檔名與檔案大小 if (tcp_client.send(&amp;file_info, sizeof(file_info)) == false) { perror(\"send\"); return -1; } 傳送完檔名與檔案後，取得server回應 傳送完檔名與檔案大小，要等待server回應”ok”，代表server收到檔名與大小。 1 2 3 4 5 6 7 8 9 10 11 // 收到server回應 string buffer; // 參數2，\"ok\"是2byte if (tcp_client.recv(buffer, 2) == false) { perror(\"recv\"); return -1; } if (buffer != \"ok\") { cout &lt;&lt; \"server沒回應ok\" &lt;&lt; endl; return -1; } 呼叫傳送檔案 1 2 3 4 5 // 傳送檔案 if (tcp_client.sendFile(file_info.filename, file_info.filesize) == false) { perror(\"sendFile\"); return -1; } 傳送檔案後，取得server回應 1 2 3 4 5 6 7 8 9 10 // 參數2，\"ok\"是2byte if (tcp_client.recv(buffer, 2) == false) { perror(\"recv\"); return -1; } if (buffer != \"ok\") { cout &lt;&lt; \"傳送檔案失敗\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"client 傳送檔案成功\" &lt;&lt; endl; server 接收檔案流程 收到檔名與大小 -&gt; 回應client收到檔名與大小 -&gt; 收到檔案 -&gt; 回應client收到檔案 接收檔名與大小 1 2 3 4 5 6 // 收到client傳來的檔案結構 bool recv(void* buffer, const size_t size) { if (::recv(client_fd_, buffer, size, 0) &lt;= 0) return false; return true; } 接收檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool recvFile(const string &amp;file_name, const size_t file_size) { ofstream fout; fout.open(file_name, ios::binary); if (fout.is_open() == false) { cout &lt;&lt; \"open file \" &lt;&lt; file_name &lt;&lt; \"fail\" &lt;&lt; endl; return false; } int total_bytes = 0; int read = 0; char buffer[7]; while (true) { if (file_size - total_bytes &gt; 7) { read = 7; } else { read = file_size - total_bytes; } if (recv(buffer, read) == false) return false; fout.write(buffer, read); total_bytes += read; if (total_bytes == file_size) break; } return true; } main參數 改為傳送3個參數，./server_test port 存放目錄 1 2 3 4 5 if (argc != 3) { cout &lt;&lt; \"請輸入 ./server_test port 存放目錄\" &lt;&lt; endl; return -1; } 檔案結構 1 2 3 4 5 6 7 8 // 檔案結構 struct FileInfo { char filename[256]; // 檔名 int filesize; // 檔案大小 } file_info; // 變數名 // 清空 memset(&amp;file_info, 0, sizeof(file_info)); 接收檔名與大小 1 2 3 4 5 6 7 if (tcpServer.recv(&amp;file_info, sizeof(file_info)) == false) { perror(\"recv()\"); return -1; } cout &lt;&lt; \"server 收到檔名 = \" &lt;&lt; file_info.filename &lt;&lt; \", 檔案大小 = \" &lt;&lt; file_info.filesize &lt;&lt; endl; 回應client已收到檔名與大小 1 2 3 4 5 if (tcpServer.send(\"ok\") == false) { perror(\"send\"); return -1; } 接收檔案 1 2 3 4 5 if (tcpServer.recvFile(string(argv[2]) + \"/\" + file_info.filename, file_info.filesize) == false) { cout &lt;&lt; \"檔案傳送失敗\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"檔案傳送成功\" &lt;&lt; endl; 回應client已收到檔案 1 tcpServer.send(\"ok\"); 完整程式碼 client程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;fstream&gt; using namespace std; class TCPClient { public: // 建構子，初始化client_fd，-1代表沒有連線 TCPClient() : client_fd_(-1) {} bool connect(const string &amp;ip, const unsigned short port) { // client_fd若已連線，就不用再連，直接返回 if (client_fd_ != -1) return false; ip_ = ip; port_ = port; client_fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // socket失敗傳回-1 if (client_fd_ == -1) return false; // server ip轉big-endian struct hostent* h; // gethostbyname需要cstring，所以要把string轉成cstring if ((h = gethostbyname(ip_.c_str())) == nullptr) { cout &lt;&lt; \"gethostbyname() fail.\" &lt;&lt; endl; // 關閉socket ::close(client_fd_); // 失敗把client_fd還原成初始化-1 client_fd_ = -1; return false; } // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server ip memcpy(&amp;server_addr.sin_addr, h-&gt;h_addr, h-&gt;h_length); // server port server_addr.sin_port = htons(port_); // connect伺服器，傳回值為0代表連線成功，不是0代表連線失敗 if (::connect(client_fd_, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) != 0) { // 關閉socket ::close(client_fd_); // 失敗把client_fd還原成初始化-1 client_fd_ = -1; return false; } return true; } // 參數使用const string是因為既可支援string，也可支援const char* bool send(const string &amp;buffer) { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer.data(), buffer.size(), 0)) &lt;= 0) return false; return true; } // 傳送檔名與大小 bool send(void *buffer, const size_t size) { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if (::send(client_fd_, buffer, size, 0) &lt;= 0) { return false; } return true; } // 傳送檔案 bool sendFile(const string &amp;file_name, const size_t file_size) { // 參數2指定binaryfile ifstream fin(file_name, ios::binary); if (fin.is_open() == false) { cout &lt;&lt; \"open file (\" &lt;&lt; file_name &lt;&lt; \") fail\" &lt;&lt; endl; return false; } // 每次要讀資料的個數(byte) int read = 0; // 記錄已傳送資料的個數，若total_byte == file_size代表傳送完 int total_bytes = 0; // 每次只傳送7byte char buffer[7]; while (true) { // 清空 memset(buffer, 0, sizeof(buffer)); // 如果剩下的byte數量，大於7個，就傳送7個 if (file_size - total_bytes &gt; 7) read = 7; else //小於7，就傳小於7的數量 read = file_size - total_bytes; fin.read(buffer, read); // 把讀到的資料送給server if (send(buffer, read) == false) return false; // 加上已傳送的數量 total_bytes += read; if (total_bytes == file_size) break; } return true; } // 第一個參數要修改buffer的內容，所以不加const bool recv(string &amp;buffer, const size_t maxlen) { // 清空string buffer.clear(); // 分配記憶體大小 buffer.resize(maxlen); // 收到的資料放在buffer的記憶體空間 // 操作到string的記憶體位址，有對string物件進行讀取與寫入 // 第2個參數填不是const的記憶體位址，第3個參數填大小 // &amp;buffer[0]取得位址，傳回值不是const // buffer.data()傳回值是const，所以不用 // recv()傳回值是收到的資料大小 int iret = ::recv(client_fd_, &amp;buffer[0], buffer.size(), 0); // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if (iret &lt;= 0) { // 失敗時把buffer清空，否則buffer大小一直維持1024 buffer.clear(); return false; } // 如果有操作到string的記憶體位址，string的自動擴展空間會失效 // 需要自己重設string大小 // 從1024大小，設為真正收到資料的大小 buffer.resize(iret); return true; } bool close() { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; ::close(client_fd_); client_fd_ = -1; return true; } ~TCPClient() { close(); } private: int client_fd_; string ip_; unsigned short port_; }; int main(int argc, char *argv[]) { if (argc != 5) { cout &lt;&lt; \"請輸入 ./client_test ip port 檔名 檔案大小\" &lt;&lt; endl; return -1; } // 建立socket TCPClient tcp_client; if (tcp_client.connect(argv[1], atoi(argv[2])) == false) { perror(\"socket\"); return -1; } // 檔案結構 struct FileInfo { char filename[256]; // 檔名 int filesize; // 檔案大小 } file_info; // 變數名 // 清空 memset(&amp;file_info, 0, sizeof(file_info)); strcpy(file_info.filename, argv[3]); // 檔名 file_info.filesize = atoi(argv[4]); // 檔案大小 // 傳送結構(檔名與檔案大小) if (tcp_client.send(&amp;file_info, sizeof(file_info)) == false) { perror(\"send\"); return -1; } cout &lt;&lt; \"傳送檔名 = \" &lt;&lt; file_info.filename &lt;&lt; \", 檔案大小 = \" &lt;&lt; file_info.filesize &lt;&lt; endl; // 收到server回應 string buffer; // 參數2，\"ok\"是2byte if (tcp_client.recv(buffer, 2) == false) { perror(\"recv\"); return -1; } if (buffer != \"ok\") { cout &lt;&lt; \"server沒回應ok\" &lt;&lt; endl; return -1; } // 傳送檔案 if (tcp_client.sendFile(file_info.filename, file_info.filesize) == false) { perror(\"sendFile\"); return -1; } // 參數2，\"ok\"是2byte if (tcp_client.recv(buffer, 2) == false) { perror(\"recv\"); return -1; } if (buffer != \"ok\") { cout &lt;&lt; \"傳送檔案失敗\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"client 傳送檔案成功\" &lt;&lt; endl; return 0; } server程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;unistd.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;fstream&gt; using namespace std; class TCPServer { public: // 建構子 // 監聽listen_fd，-1代表未初始化 // client_fd，-1代表未連線 TCPServer() : listen_fd_(-1), client_fd_(-1) {} // 初始化監聽的socket bool initListen(const unsigned short port) { listen_fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listen_fd_ == -1) return false; port_ = port; // sockaddr_in結構 struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; // server port server_addr.sin_port = htons(port_); // server有多個ip，所有ip都會監聽port server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // socket綁定ip與port if (::bind(listen_fd_, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)) == -1) { // 關閉監聽器 close(listen_fd_); listen_fd_ = -1; return false; } // 把socket設為監聽的狀態 // 最多只讓3個client同時連server if (listen(listen_fd_, 3)) { close(listen_fd_); listen_fd_ = -1; return false; } return true; } bool accept() { // client的ip結構 struct sockaddr_in client_addr; socklen_t addr_len = sizeof(client_addr); // 接受client的連線 // 若要得到client的ip，第二個參數填sockaddr_in結構，第3個參數填結構大小 // 若不想得到client ip，第2與第3參數填0就好 client_fd_ = ::accept(listen_fd_, (struct sockaddr*)&amp;client_addr, &amp;addr_len); if (client_fd_ == -1) return false; // 取得client的ip // 透過inet_ntoa把big-endian轉成little-endian client_ip_ = inet_ntoa(client_addr.sin_addr); return true; } const string&amp; getClientIp() const { return client_ip_; } bool send(const string &amp;buffer) { // 如果client fd是-1就沒必要繼續後面的動作，直接返回 if (client_fd_ == -1) return false; // send()第2個參數填記憶體位址，第3個參數填大小 if ((::send(client_fd_, buffer.data(), buffer.size(), 0)) &lt;= 0) return false; return true; } // 第一個參數要修改buffer的內容，所以不加const bool recv(string &amp;buffer, const size_t maxlen) { // 清空string buffer.clear(); // 分配記憶體大小 buffer.resize(maxlen); // 收到的資料放在buffer的記憶體空間 // 操作到string的記憶體位址，有對string物件進行讀取與寫入 // 第2個參數填不是const的記憶體位址，第3個參數填大小 // &amp;buffer[0]取得位址，傳回值不是const // buffer.data()傳回值是const，所以不用 // recv()傳回值是收到的資料大小 int iret = ::recv(client_fd_, &amp;buffer[0], buffer.size(), 0); // iret = -1 失敗 // iret = 0 socket斷線 // iret &gt; 0 收到資料 if (iret &lt;= 0) { cout &lt;&lt; \"iret = \" &lt;&lt; iret &lt;&lt; endl; // 失敗時把buffer清空，否則buffer大小一直維持1024 buffer.clear(); return false; } // 如果有操作到string的記憶體位址，string的自動擴展空間會失效 // 需要自己重設string大小 // 從1024大小，設為真正收到資料的大小 buffer.resize(iret); return true; } // 收到client傳來的檔案結構 bool recv(void* buffer, const size_t size) { if (::recv(client_fd_, buffer, size, 0) &lt;= 0) return false; return true; } bool recvFile(const string &amp;file_name, const size_t file_size) { ofstream fout; fout.open(file_name, ios::binary); if (fout.is_open() == false) { cout &lt;&lt; \"open file \" &lt;&lt; file_name &lt;&lt; \"fail\" &lt;&lt; endl; return false; } int total_bytes = 0; int read = 0; char buffer[7]; while (true) { if (file_size - total_bytes &gt; 7) { read = 7; } else { read = file_size - total_bytes; } if (recv(buffer, read) == false) return false; fout.write(buffer, read); total_bytes += read; if (total_bytes == file_size) break; } return true; } // 關閉監聽socket bool closeListen() { // 若未初始化，直接返回 if (listen_fd_ == -1) return false; ::close(listen_fd_); // 設為未初始化-1 listen_fd_ = -1; return true; } // 關閉client socket bool closeClient() { // client_fd若已斷線，直接返回 if (client_fd_ == -1) return false; ::close(client_fd_); // 設成未連線-1 client_fd_ = -1; return true; } ~TCPServer() { // 解構子把二個socket都關掉 closeListen(); closeClient(); } private: int listen_fd_; int client_fd_; string client_ip_; unsigned short port_; }; int main(int argc, char *argv[]) { if (argc != 3) { cout &lt;&lt; \"請輸入 ./server_test port 存放目錄\" &lt;&lt; endl; return -1; } // 建立監聽fd listen_fd TCPServer tcpServer; // 初始化監聽 if (tcpServer.initListen(atoi(argv[1])) == false) { perror(\"initListen\"); return -1; } // 接受client連接 if (tcpServer.accept() == false) { perror(\"accept\"); return -1; } cout &lt;&lt; \"client已連上 = \" &lt;&lt; tcpServer.getClientIp() &lt;&lt; endl; // 檔案結構 struct FileInfo { char filename[256]; // 檔名 int filesize; // 檔案大小 } file_info; // 變數名 // 清空 memset(&amp;file_info, 0, sizeof(file_info)); if (tcpServer.recv(&amp;file_info, sizeof(file_info)) == false) { perror(\"recv()\"); return -1; } cout &lt;&lt; \"server 收到檔名 = \" &lt;&lt; file_info.filename &lt;&lt; \", 檔案大小 = \" &lt;&lt; file_info.filesize &lt;&lt; endl; if (tcpServer.send(\"ok\") == false) { perror(\"send\"); return -1; } if (tcpServer.recvFile(string(argv[2]) + \"/\" + file_info.filename, file_info.filesize) == false) { cout &lt;&lt; \"檔案傳送失敗\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"檔案傳送成功\" &lt;&lt; endl; tcpServer.send(\"ok\"); return 0; } 測試方式 server $ ./server_test 1234 /tmp client已連上 = 192.168.235.128 server 收到檔名 = test1.txt, 檔案大小 = 15890 檔案傳送成功 $ cd /tmp $ ls test1.txt VMwareDnD vmware-root_727-4290690966 $ ll test1.txt -rw-rw-r-- 1 cici cici 15890 1月 17 13:03 test1.txt client $ ll test1.txt -rw-rw-r-- 1 cici cici 15890 12月 31 13:33 test1.txt $ ./client_test 192.168.235.128 1234 test1.txt 15890 傳送檔名 = test1.txt, 檔案大小 = 15890 client 傳送檔案成功"
  },"/pages/ffmpeg/install_ffmpeg_mac/": {
    "title": "FFmpeg in Mac",
    "keywords": "",
    "url": "/pages/ffmpeg/install_ffmpeg_mac/",
    "body": "安裝步驟 下載ffmpeg source code Download source code 下載完後解壓，進入解壓後的目錄 安裝 Xcode Command Line Tools 在 macOS 下，你需要 Xcode Command Line Tools 提供的編譯工具（如 gcc 和 make）。執行以下命令來確認是否已安裝： xcode-select --install 安裝gcc brew install gcc 安裝yasm brew install yasm 安裝ffmpeg ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --enable-shared --disable-static 安裝至/usr/local/ffmpeg 預設產生靜態檔，使用--disable-static把產生靜態檔關閉 --enable-shared，產生動態檔 編譯ffmpeg make -j 4 安裝ffmpeg sudo make install 目錄 切換目錄至/usr/local/ffmpeg，會有以下四個目錄 $ls bin include lib share lib 進入lib目錄，檢查是否產生動態檔，動態檔副檔名為.dylib，副檔名.a為靜態檔，是我之前產生的，可以先略過。 % ls libavcodec.61.19.100.dylib libavformat.dylib libavcodec.61.dylib libavutil.59.39.100.dylib libavcodec.a libavutil.59.dylib libavcodec.dylib libavutil.a libavdevice.61.3.100.dylib libavutil.dylib libavdevice.61.dylib libswresample.5.3.100.dylib libavdevice.a libswresample.5.dylib libavdevice.dylib libswresample.a libavfilter.10.4.100.dylib libswresample.dylib libavfilter.10.dylib libswscale.8.3.100.dylib libavfilter.a libswscale.8.dylib libavfilter.dylib libswscale.a libavformat.61.7.100.dylib libswscale.dylib libavformat.61.dylib pkgconfig libavformat.a include 放head file的目錄，進行ffmpeg開發時，需要include head file cici@liyutingdeMacBook-Pro include % ls libavcodec libavfilter libavutil libswscale libavdevice libavformat libswresample bin 放ffmpeg執行檔 cici@liyutingdeMacBook-Pro bin % ls ffmpeg ffprobe share 使用範例與手冊 xcode匯入ffmpeg 建立Xcode Project 建立目錄 進入先前建立的project目錄後，再進入myapp2，指令如下 % cd myapp2 % ls myapp2 myapp2.xcodeproj % cd myapp2 % pwd /Users/cici/projects/myapp2/myapp2 建立include與libs目錄 % mkdir include % mkdir libs % ls Assets.xcassets Preview Content libs ContentView.swift include myapp2App.swift 拷貝先前安裝的ffmpeg的include跟lib目錄 % cp -r /usr/local/ffmpeg/include/* ./include/ % cp -r /usr/local/ffmpeg/lib/* ./libs/ 匯入目錄 建立c檔案 手動建立Bridging Header xcode Version 14.2，每一個版本有不同的方式。 若先前沒有按下Create Bridging Header的按鈕，補救方法如下: 在 Xcode，選擇 File → New → File… 選擇 Header File (.h)，然後按 Next 命名為 專案名稱-Bridging-Header.h（例如：MyProject-Bridging-Header.h） 確保它位於你的專案內，並按 Create 在 Build Settings 設定 Bridging Header include ffmpeg header file 增加以下句子在testc.h #include \"libavutil/avutil.h\" testc.h 1 2 3 4 5 6 7 #ifndef testc_h #define testc_h #include &lt;stdio.h&gt; #include \"libavutil/avutil.h\" void printLog(); #endif /* testc_h */ testc.c 1 2 3 4 5 6 #include \"testc.h\" void printLog() { av_log_set_level(AV_LOG_DEBUG); av_log(NULL, AV_LOG_DEBUG, \"Hello world!\"); return; } swift呼叫c ViewController 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import Cocoa class ViewController: NSViewController { override func viewDidLoad() { super.viewDidLoad() self.view.setFrameSize(NSSize(width: 320, height: 240)) let btn = NSButton.init(title: \"button\", target: nil, action: nil) btn.frame = NSRect(x: 320/2-40, y: 240/2-15, width:80, height:30) btn.bezelStyle = .rounded btn.setButtonType(.pushOnPushOff) btn.target = self btn.action = #selector(myfunc) self.view.addSubview(btn) // Do any additional setup after loading the view. } @objc func myfunc() { printLog(); } override var representedObject: Any? { didSet { // Update the view, if already loaded. } } }"
  },"/pages/swift/swift_doc/": {
    "title": "swift 文件",
    "keywords": "",
    "url": "/pages/swift/swift_doc/",
    "body": "swift ui"
  },"/pages/ffmpeg/first_jni/": {
    "title": "First jni",
    "keywords": "",
    "url": "/pages/ffmpeg/first_jni/",
    "body": "JNI JNI是指程式運行時Java程式碼可以使用C或C++的lib，也可以在C或C++的lib使用Java程式碼。 建立JNI 檢查SDK NDK與CMake要有勾選 build project 若出現以下error，直接按”File”&gt;”Sync Project with Gradle Files” java.lang.NullPointerException: Cannot invoke “String.length()” because “\" is null appcompat-1.7.0-runtime-jar constraintlayout-2.2.0-runtime.jar constraintlayout-core-1.1.0.jar profileinstaller-1.4.0-runtime.jar cmake 自己建立lib 匯入(find)其它lib,自己建立的lib與其它lib綁定，並產生鏈結檔 activity 增加jni方法 滑鼠對著函式名(如下圖是滑鼠對著stringFromJNI2函式名)，按alt + enter，也可以產生jni方法"
  },"/pages/ffmpeg/jni/": {
    "title": "JNI",
    "keywords": "",
    "url": "/pages/ffmpeg/jni/",
    "body": "JNI JNI是指程式運行時Java程式碼可以使用C或C++的lib，也可以在C或C++的lib使用Java程式碼。 NDK 是一個工具，包含Android的交叉編譯器，Android可以用的靜態庫與動態庫。 建立Java可以呼叫的C++ java sdk 我是MAC電腦，在終端機執行以下指令，就會顯示java sdk的路徑 $ /usr/libexec/java_home /Users/cici/Library/Java/JavaVirtualMachines/openjdk-20.0.1/Contents/Home native 在函式前面加上native，表示這個是呼叫c++函式。 MainActivity.java 1 public native String stringFromJNI(); c++函式與java函式相互跳躍 jni.h 先include jni.h的head file native-lib.cpp 1 #include &lt;jni.h&gt; extern c 若是c++寫的程式，前面都要加上extern c，Java才可以辦識這是C++程式 native-lib.cpp 1 extern \"C\" JNIEXPORT jstring JNICALL 傳回值 c++函式傳回值的型態是jstring MainActivity.java 1 public native String stringFromJNI(); java函式傳回值是String native-lib.cpp 1 extern \"C\" JNIEXPORT jstring JNICALL Java的型態與c++型態 Java類別 jni類別 void void boolean jboolean byte jbyte char jchar short jshort int jint long jlor float jfloat double jdouble Object jobject Class jclass String jstring Object[] jobjectArray boolean[] jbooleanArray byte[] jbyteArray char[] jcharArray short[] jshortArray int[] jintArray long[] jlongArray float[] jfloatArray double[] jdoubleArray jni函式參數 以下是c++中的jni函式 1 2 3 4 Java_com_example_ndkproj_MainActivity_stringFromJNI( JNIEnv* env, jobject thiz) { } JNIEnv 代表Java虛擬機，透過Java虛擬機可以取得Java類別物件。 jobject instance 呼叫c++函式的類別，以本頁的例子是MainActivity.java 動態庫so檔 project編譯完成會打包成.so檔，系統啟動的時候會去把專案ndkproj.so Load進來 1 2 3 4 5 6 public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"ndkproj\"); } ... } jni取得字串 MainActivity.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"ndkproj\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI() + stringFromJNI2(\"abcdefg\")); } public native String stringFromJNI(); public native String stringFromJNI2(String str); } native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;jni.h&gt; #include &lt;string&gt; #include &lt;android/log.h&gt; extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_ndkproj_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { // 使用 __android_log_print() 輸出到 Logcat __android_log_print(ANDROID_LOG_DEBUG, \"NDK_TEST\", \"test() 返回值: %d\", result); std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str()); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_ndkproj_MainActivity_stringFromJNI2(JNIEnv *env, jobject thiz, jstring _str) { const char* str = env-&gt;GetStringUTFChars(_str, 0); env-&gt;ReleaseStringUTFChars(_str, str); return env-&gt;NewStringUTF(\"test\"); } jni陣列類型轉型 MainActivity.java 1 2 3 4 5 6 7 8 9 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ... int intArr[] = {11, 22, 33, 44}; String strArr[] = {\"test1\", \"test2\", \"test3\"}; test2(1, \"Hello World\", intArr, strArr); Log.e(\"Java\", Arrays.toString(intArr)); } native-lib.cpp要include Android寫Log的head file #include &lt;android/log.h&gt; // ...代表__VA_ARGS__，可變參數 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"JNI\",__VA_ARGS__); native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 extern \"C\" JNIEXPORT void JNICALL Java_com_example_ndkproj_MainActivity_test2(JNIEnv *env, jobject thiz, jint num, jstring str, jintArray int_arr, jobjectArray str_arr) { // 取得陣列指標 jint *int_arr_p = env-&gt;GetIntArrayElements(int_arr, NULL); // 取得長度 int32_t len = env-&gt;GetArrayLength(int_arr); for (int i = 0; i &lt; len; i++) { // 參數1:Log級別 // 參數2:TAG // 參數3:印出的值 // 參數4:把值傳給參數3 //__android_log_print(ANDROID_LOG_ERROR, \"JNI\", \"取得值%d\", *(int_arr_p + i)); LOGE(\"取得值%d\", *(int_arr_p + i)); // 修改值 *(int_arr_p + i) = *(int_arr_p + i) + 100; } // 使用GetIntArrayElements，就要釋放記憶體空間 // 釋放記憶體空間 // 參數1: java傳來的int_arr // 參數2: 由GetIntArrayElements得到的指標 // 參數3: 模式 // 0 : 更新java傳來的int_arr，並且釋放指標int_arr記憶體空間 // 1 : 只更新java傳來的int_arr // 2 : 只釋放指標int_arr記憶體空間 env-&gt;ReleaseIntArrayElements(int_arr, int_arr_p, 0); jint strlen = env-&gt;GetArrayLength(str_arr); for (int i = 0; i &lt; strlen; i++) { jstring str = static_cast&lt;jstring&gt;(env-&gt;GetObjectArrayElement(str_arr, i)); // 將jstring轉成c++ const char* s = env-&gt;GetStringUTFChars(str, 0); LOGE(\"取得值%s\", s); // release memory env-&gt;ReleaseStringUTFChars(str, s); } } Android Studio Log jni簽名 Java類別 簽名 boolean Z short S float F byte B int I double D char C long J void V String Ljava/lang/String; Array [+類別簽名 jni取得物件，執行成員函式，修改成員變數 Bean1.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.ndkproj; import android.util.Log; public class Bean { private static final String TAG = \"Bean\"; private int data; public int getData() { return data; } public void setData(int data) { Log.e(TAG, \"somebody setdata\"); this.data = data; } public static void printInfo(String msg) { Log.e(TAG, msg); } public static void printInfo(Bean2 bean2) { Log.e(TAG, \"param is object:\" + bean2.i); } } Bean2.java 1 2 3 4 5 6 7 8 9 package com.example.ndkproj; public class Bean2 { int i = 12345; public Bean2() { } public Bean2(int i) { this.i = i; } } MainActivity.java 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method Bean bean = new Bean(); bean.setData(5000); passObject(bean); } native void passObject(Bean bean); native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 extern \"C\" JNIEXPORT void JNICALL Java_com_example_ndkproj_MainActivity_passObject(JNIEnv *env, jobject thiz, jobject bean) { // 1. 取得class jclass beanCls = env-&gt;GetObjectClass(bean); // 2. 取得get方法 // 參數1:class // 參數2:函式名 // 參數3:簽名()I代表無法參數，傳回int jmethodID getI = env-&gt;GetMethodID(beanCls, \"getData\", \"()I\"); // 3. 呼叫方法 jint i = env-&gt;CallIntMethod(bean, getI); LOGE(\"getI():%d\", i); // set方法 // (I)V參數是Int，傳回值是Void jmethodID setI = env-&gt;GetMethodID(beanCls, \"setData\", \"(I)V\"); env-&gt;CallVoidMethod(bean, setI, 1000); // static方法 jmethodID printInfo = env-&gt;GetStaticMethodID(beanCls, \"printInfo\", \"(Ljava/lang/String;)V\"); // 建立java 字串 jstring param1 = env-&gt;NewStringUTF(\"call static method\"); env-&gt;CallStaticVoidMethod(beanCls,printInfo,param1); // 參數是自訂類別 // static方法 jmethodID printInfo2 = env-&gt;GetStaticMethodID(beanCls, \"printInfo\", \"(Lcom/example/ndkproj/Bean2;)V\"); // 建立物件jclass jclass bean2Cls = env-&gt;FindClass(\"com/example/ndkproj/Bean2\"); // 呼叫空建構子()V // 呼叫有int建構子(I)V jmethodID constructor = env-&gt;GetMethodID(bean2Cls, \"&lt;init&gt;\", \"(I)V\"); // 呼叫建構子取得物件 jobject bean2 = env-&gt;NewObject(bean2Cls, constructor, 1111); env-&gt;CallStaticVoidMethod(beanCls,printInfo2, bean2); // 釋放區域變數 // new出來的都要釋放記憶體 // delete方法針對jobject(FindClass,NewObject) env-&gt;DeleteLocalRef(bean2Cls); env-&gt;DeleteLocalRef(bean2); // 自已建立的物件，包含自己建立的jstring用delete env-&gt;DeleteLocalRef(param1); // release用在GetStringUTFChars //env-&gt;ReleaseStringUTFChars(str, s); // 取得成員變數 jfieldID jfieldId = env-&gt;GetFieldID(beanCls, \"data\", \"I\"); // 修改成員變數 env-&gt;SetIntField(bean, jfieldId, 666); } 2025-03-18 12:41:58.614 16753-16753 JNI com.example.ndkproj E getI():5000 2025-03-18 12:41:58.610 16753-16753 Bean com.example.ndkproj E somebody setdata 2025-03-18 12:41:58.616 16753-16753 Bean com.example.ndkproj E somebody setdata 2025-03-18 12:41:58.620 16753-16753 Bean com.example.ndkproj E call static method 2025-03-18 12:41:58.622 16753-16753 Bean com.example.ndkproj E param is object:1111 記憶體釋放 以下的寫法是在建立指標(請見下一個程式碼jni.h)，使用typedef把指標取成去掉*的別名，但實際上是指標。 1 2 3 jobject bean2 = env-&gt;NewObject(bean2Cls, constructor, 1111); jstring param1 = env-&gt;NewStringUTF(\"call static method\"); jclass bean2Cls = env-&gt;FindClass(\"com/example/ndkproj/Bean2\"); jni.h 1 2 3 typedef _jobject* jobject; typedef _jclass* jclass; typedef _jstring* jstring; jni已經做到在函式中建立指標，離開函式這些指標會自動被JVM釋放記憶體，就算沒寫以下的程式碼，也會被記憶體釋放。 1 2 3 4 5 // delete方法針對jobject(FindClass,NewObject) env-&gt;DeleteLocalRef(bean2Cls); env-&gt;DeleteLocalRef(bean2); // 自已建立的物件，包含自己建立的jstring用delete env-&gt;DeleteLocalRef(param1); 全域參考與區域指標 NewGlobalRef 區域參考離開函式就會被記憶體回收，使用全域參考則不會被JVM釋放記憶體。 Delete GlobalRef 刪除全域參考 env-&gt;DeleteGlobalRef(global_bean_cls); 1 2 3 4 5 6 7 8 9 10 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); invokeBean2Method(); invokeBean2Method(); } native void invokeBean2Method(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 全域變數 jclass global_bean_cls; // jclass weak_bean_cls; extern \"C\" JNIEXPORT void JNICALL Java_com_example_ndkproj_MainActivity_invokeBean2Method(JNIEnv *env, jobject thiz) { if (global_bean_cls == NULL) { // 區域變數 jclass cls = env-&gt;FindClass(\"com/example/ndkproj/Bean2\"); // 建立全域參考 global_bean_cls = static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(cls)); // 釋放區域變數 env-&gt;DeleteLocalRef(cls); // 釋放全域變數 //env-&gt;DeleteGlobalRef(global_bean_cls); } jmethodID contructor = env-&gt;GetMethodID(global_bean_cls, \"&lt;init&gt;\", \"(I)V\"); jobject bean2 = env-&gt;NewObject(global_bean_cls, contructor, 666); // 弱參考會被記憶體回收 // 判斷弱參考是否存在 jboolean isExist = env-&gt;IsSameObject(weak_bean_cls, NULL); if (isExist) { // 區域變數 jclass cls = env-&gt;FindClass(\"com/example/ndkproj/Bean2\"); // 弱參考 weak_bean_cls = static_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(cls)); env-&gt;DeleteLocalRef(cls); // delete weak //env-&gt;DeleteWeakGlobalRef(weak_bean_cls); } } 動態註冊jni 之前的都是靜態註冊，缺點是函式名很長，接下來要說明的是動態註冊。 JNI_OnLoad project編譯完成會打包成.so檔，系統啟動的時候會去把專案ndkproj.so Load進來 1 2 3 4 5 6 public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"ndkproj\"); } ... } Load進來的時候會呼叫JNI_OnLoad()函式 1 2 3 jint JNI_OnLoad(JavaVM *vm, void *reserved) { return JNI_VERSION_1_6; } 第一個參數*vm是虛擬機，第二個參數可以不用管它。 最後一定要傳回JNI_VERSION_1_6 g_method[] 是一個陣列，陣列裡包含java的函式(第1個參數)與函式簽名(第2個參數)，c++的函式名(第3個參數)，記得c++函式名前面一定要加上(void*) 1 2 3 static JNINativeMethod g_methods[] = { {\"_test\",\"()Ljava/lang/String;\",(void*)my_test_register}, }; 以下是java的native函式名_test()，函式簽名是()Ljava/lang/String;傳回值是String物件，沒參數。 MainActivity.java 1 2 3 4 5 public class MainActivity extends AppCompatActivity { ... public native String _test(); ... } 以下是C++函式要與java函式對映。 參數1是java虛擬機要寫 參數2是呼叫c++函式的類別，以本頁的例子是MainActivity.java native-lib.cpp 1 2 3 4 5 6 extern \"C\" JNIEXPORT jstring JNICALL my_test_register(JNIEnv *env, jobject instance) { return env-&gt;NewStringUTF(\"this is a test of register!\"); } 取得env 第一個參數&amp;env指標參考為要轉為(void**)，第二個參數一定要是JNI_VERSION_1_6 1 2 3 4 5 6 7 8 jint JNI_OnLoad(JavaVM *vm, void *reserved) { // 空的env指標 JNIEnv *env = NULL; // 取得env，第一個參數env指標的位址 vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6); ... return JNI_VERSION_1_6; } 若要檢查是否有取得到java虛擬機，可用以下程式碼。 1 2 3 4 5 6 7 // ret = 0 JNI_OK 成功 // ret &lt; 0 JNI_ERR 失敗 int ret = vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6); if (ret != JNI_OK) { // crush return -1; } 取得g_method[]長度 以下語法取得g_method長度 sizeof(g_methods)/sizeof(g_methods[0]) clazz 1 #define JNI_CLASS_PATH \"com/example/ndkproj/MainActivity\" 或者寫成以下方式也可以 1 static const char* clazz_path = \"com/example/ndkproj/MainActivity\"; 1 2 // java函式的所在的類別 jclass clazz = env-&gt;FindClass(JNI_CLASS_PATH); 註冊 參數1是java函式的類別 參數2是g_methods 參數3是g_methods的長度 1 env-&gt;RegisterNatives(clazz, g_methods, sizeof(g_methods)/sizeof(g_methods[0])); 完整程式碼 MainActivity.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class MainActivity extends AppCompatActivity { // Used to load the 'ndkproj' library on application startup. static { System.loadLibrary(\"ndkproj\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(_test()); } public native String _test(); } native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;jni.h&gt; #include &lt;string&gt; #define JNI_CLASS_PATH \"com/example/ndkproj/MainActivity\" #include &lt;android/log.h&gt; extern \"C\" JNIEXPORT jstring JNICALL my_test_register(JNIEnv *env, jobject instance) { return env-&gt;NewStringUTF(\"this is a test of register!\"); } static JNINativeMethod g_methods[] = { { \"_test\", \"()Ljava/lang/String;\", (void*)my_test_register }, }; jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6); jclass clazz = env-&gt;FindClass(JNI_CLASS_PATH); env-&gt;RegisterNatives(clazz, g_methods, sizeof(g_methods)/sizeof(g_methods[0])); return JNI_VERSION_1_6; } JNI執行緒 MainActivity.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MainActivity extends AppCompatActivity { // Used to load the 'ndkproj' library on application startup. static { System.loadLibrary(\"ndkproj\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); testThread(); } public void updateUI() { // 主執行緒 main thread if (Looper.myLooper() == Looper.getMainLooper()) { Toast.makeText(this, \"update UI\", Toast.LENGTH_SHORT).show(); } else { // 非主執行緒 runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, \"update ui2\", Toast.LENGTH_SHORT).show(); } }); } } native void testThread(); } native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include &lt;jni.h&gt; #include &lt;string&gt; #include &lt;android/log.h&gt; #include &lt;pthread.h&gt; // ...代表__VA_ARGS__，可變參數 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, \"JNI\",__VA_ARGS__); // 全域變數 JavaVM* _vm = nullptr; jint JNI_OnLoad(JavaVM *vm, void *reserved) { // 透過JNI_OnLoad取得jvm _vm = vm; return JNI_VERSION_1_6; } // 建立結構體 struct Context { // instance為mainActivity放置java函式的類別 jobject instance; }; void* threadTask(void* args) { JNIEnv *env; // env本來就不是多執行緒，要變成可被多執行緒使用，要用jvm中的AttachCurrentThread jint rtn = _vm-&gt;AttachCurrentThread(&amp;env, 0); // 判斷有沒有把env加進執行緒中 if (rtn != JNI_OK) { return 0; } // 參數是傳進執行緒中的context，將void*轉成Context Context *context = static_cast&lt;Context*&gt;(args); jclass cls = env-&gt;GetObjectClass(context-&gt;instance); // 取得mainActivity放置java函類的類別 jmethodID updateUI = env-&gt;GetMethodID(cls, \"updateUI\", \"()V\"); // 呼叫java函式 env-&gt;CallVoidMethod(context-&gt;instance, updateUI); // 釋放context記憶體 delete(context); context = nullptr; // 把env從多執行緒分離 _vm-&gt;DetachCurrentThread(); return 0; } extern \"C\" JNIEXPORT void JNICALL Java_com_example_ndkproj_MainActivity_testThread(JNIEnv *env, jobject thiz) { // pthread_t是long，以下可作為long pid pthread_t pid; // 建立自訂context物件 Context *context = new Context; // thiz是mainActivity放置java函式的類別 // 建立全域參考 context-&gt;instance = env-&gt;NewGlobalRef(thiz); // 啟動執行緒 // 參數1: pid // 參數2: 0 // 參數3: 執行緒呼叫的函式 // 參數4: 給函式傳參數，參數是context pthread_create(&amp;pid, 0 ,threadTask, context); } lsn7_jni資料 jni+Specification.CHM"
  },"/pages/c/basic/linux_shell/": {
    "title": "Linux shell指令",
    "keywords": "",
    "url": "/pages/c/basic/linux_shell/",
    "body": "查看檔案 less分頁 less 檔名.副檔名 q:離開 空格: 下一頁 b: 上一頁 Enter與j: 往下移動一行 k: 往上移動一行 g：跳到文件的開頭。 G：跳到文件的結尾 more分頁 more 檔名.副檔名 q:離開 空格: 下一頁 b: 上一頁 Enter與j: 往下移動一行 k: 往上移動一行 g：跳到文件的開頭。 G：跳到文件的結尾 wc統計行數 wc 檔名.副檔名 % wc config.h 784 2369 22076 config.h 784 行數 2369 字數 22076byte 檔案大小(單位是byte) 統計目前目錄所有檔案的行數,字數,檔案大小 wc * 統計多個檔案 wc 檔案1 檔案2 檔案3 grep 以下指令為，在ffmpeg.txt中搜尋”input” grep \"input\" ffmpeg.txt 在所有的head檔中，搜尋那個檔案中有包含”stdio.h” grep \"stdio.h\" *.h 執行結果 common.h:#include &lt;stdio.h&gt; file_open.h:#include &lt;stdio.h&gt; internal.h:#include &lt;stdio.h&gt; vulkan_loader.h:#include &lt;stdio.h&gt; 顯示的意思為 檔名.副檔名: 有出現 stdio.h 的那一行 head 顯示檔案的前10筆 head 檔名.副檔名 顯示檔案的前15筆 head -n 15 檔名.副檔名 tail 顯示檔案的後10筆 tail 檔名.副檔名 顯示檔案的後15筆 tail -n 15 檔名.副檔名 若檔案有新增筆數(例如0.1秒新增一筆)，使用以下指令在檔案有變更時會立即更新顯示結果 tail -f 檔名.副檔名 ctrl+c放棄追蹤更新 ls 以下指令，最新的檔案排在最前面 ls -lt piple 若目錄下檔案很多，使用分頁功能查看。以下指令把ls的結果作為輸出給less指令去分頁 ls -lt | less 查看log，使用以下指令會列出檔案中2025-01-01的log，並以分頁方式顯示 grep \"2025-01-01\" 檔案.log | less 查看行數、字數、大小 grep \"2025-01-01\" 檔案.log | wc top查看系統效能 每3秒更新cpu系統效能畫面，ctrl+c離開 top Load Avg: 3.93, 4.09, 3.47 Load Avg:在一段時間內，cpu正在處理或等待處理的程序總合平均值，分別以最近1分鐘、5分鐘、15分鐘顯示 Processes: 543 total, 2 running, 541 sleeping, 2150 threads 共有543程序，2個正在執行，541個在休眠，2150個執行緒 env環境變數 顯示所有環境變數 env 使用grep搜尋要看的環境變數 env | grep PATH 環境變數分頁 env | less 使用echo顯示環境變數的值，注意！環境變數前要加錢字號$ echo $PATH 常用環境變數 LANG系統語言 預設中文是UTF-8 % echo $LANG en_US.UTF-8 PATH PATH的值是多個目錄，包含linux bash指令存放位置，或user的應用程式的執行檔案存放位置，以:分號分隔目錄。 注意！環境變數前要加錢字號$ echo $PATH /usr/local/Cellar/ruby/3.3.0/bin:/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin:/bin:/usr/bin:/usr/local/bin:/sbin: 例如ls指令是放在/usr/bin目錄下，如果PATH少了/usr/bin，就不能使用ls、wc、less…等等bash指令。 LD_LIBRARY_PATH c++動態庫的目錄 export 注意！export的效果只有在目前的shell中適用，重新登入就清掉了，需要設置系統環境變數才能永久有效。 方式一 變數=\\'值\\' export 變數 TEST='TEST1 TEST2 TEST3' export TEST env | grep TEST 方式二 export 變數=\\'值\\' 如果值不是空格或特殊符號，可以不用'' 設定PATH 如果要增加/Users/cici/test目錄在PATH，可以用以下指令設定，$PATH代表原來PATH變數的值，再加上:冒號，後面加上要增加的目錄 export PATH=$PATH:/Users/cici/NDK Linux bash_profile 僅對Linux有效 在user目錄下會有.bash_profile的檔案 cd ~ ls -l .bash* -rw-r--r--@ 1 cici staff 536 Aug 30 12:15 .bash_profile 使用cat指令查看檔案 cat .bash_profile # Setting PATH for Python 3.7 # The original version is saved in .bash_profile.pysave PATH=\"/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}\" export PATH alias python='python3.7' alias pip='pip3.7' export ANDROID_HOME=/Users/cici/Library/Android/sdk export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:/Users/cici/.rbenv/versions/3.2.2/bin # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" 離開終端機或重新登入，環境變數已被修改。 echo PATH MAC Zsh 我的MAC的Shell指令是Zsh，所以修改bash_profile對MAC的環境變數是沒有新增或修改。 使用以下指令在終端機，查看你的MAC電腦是什麼指令。 % echo $SHELL /bin/zsh Zsh 不會讀取 .bash_profile，它有自己的設定檔： ~/.zshrc（互動式 Shell 配置，每次開啟終端機載入） ~/.zprofile（登入 Shell 配置，類似 .bash_profile） 修改環境變數: vi ~/.zshrc 增加環境變數，後面的:$PATH是固定的，儲存並退出。 export PATH=\"/your/custom/path:$PATH\" 使環境變數生效。 source ~/.zshrc 執行檔案 我增加/Users/cici/testc的目錄，在目錄中，增加testc.cpp的檔案，並且編譯產生執行檔testc vi testc.cpp g++ -o testc testc.cpp 1 2 3 4 5 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; } 使用./來執行檔案，.圓點代表目前的目錄下，’./testc’代表目前目錄下的testc檔案，如果只寫testc是找不到目前目錄下的testc檔案 ./testc 如果想在任何目錄都可以執行目錄目錄的執行檔案，可以在PATH增加.圓點，就可以執行testc export PATH=$PATH:. testc 以相對/絕對路徑執行指令，例如”/bin/ls”或”./ls”"
  },"/pages/ffmpeg/cmake/": {
    "title": "cmake",
    "keywords": "",
    "url": "/pages/ffmpeg/cmake/",
    "body": "cpu不同 在linux下可以使用以下語句產生執行檔 g++ -o hello hello.cpp 但hello執行檔可以在Linux下執行，無法在Android手機執行，原因是Linux與Android的操作系統os不同，Android手機的os是ARM架構。 因此編譯Android os的執行檔需要使用ARM的編譯器編譯出.so(動態庫)或.a(靜態庫)，才能在Android的os上執行。 查詢模擬器CPU架構 MAC的Android Studio是根據MAC的晶片預設模擬器CPU架構 x86 或 x86_64 → 適合 Intel/AMD CPU，模擬效能較佳（支援 Hypervisor）。 arm64-v8a 或 armeabi-v7a → 適合 M1/M2 Mac 或某些 ARM 虛擬機，但效能較低。 如果你在 Apple Silicon（M1/M2/M3）Mac 上運行模擬器，預設會使用 ARM 版的模擬器（arm64-v8a）。 查詢CPU架構 確保模擬器是運行 進入platform-tools 執行以下語句 $ cd ~/Library/Android/sdk/platform-tools $ ./adb shell uname -m x86_64 顯示結果，我的模擬器是x86_64 clang 是一個c,c++,Object-c的輕量編譯器，基於LLVM(LLVM是以c++編寫而成的編譯器) cmake使用方法 camke的目的是將c++檔案變成Android下可以執行的so檔，so檔是動態庫 cmake的使用方法，當作函式呼叫，參數以空格分開 函式(參數1 參數2 參數3) 也可以用斷行分開 函式(參數1 參數2 參數3) cmake目錄路徑 放置cmake文件的目錄 ${CMAKE_SOURCE_DIR} 顯示變數 CMakeLists.txt message(\"Android_ABI: ${ANDROID_ABI}\") 設定版本 CMakeLists.txt cmake_minimum_required(VERSION 3.22.1) 原始檔案變so檔 ndkproj是so檔的名字，會產生ndkproj.so的檔案 SHARED是動態庫 native-lib.cpp是原始檔案 CMakeLists.txt add_library( # Sets the name of the library. ndkproj # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). native-lib.cpp) 尋找log 如果沒有設定ndkVersion 預設會在local.properties下尋找sdk的安裝目錄 sdk.dir=/Users/cici/Library/Android/sdk中的ndk目錄下尋找log庫，找到的path，設給log-lib這個變數 CMakeLists.txt find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log) 自行編譯動態庫與靜態庫 ndk路徑 我的ndk路徑如下 /Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android33-clang CMakeLists.txt路徑 我的CMakeLists.txt路徑如下 /Users/cici/AndroidStudioProjects/ndkProj/app/src/main/cpp 建立jniLibs目錄 在以下的路徑下建立jniLibs目錄 /Users/cici/AndroidStudioProjects/ndkProj/app/src/main c檔案 檔名testc.c 1 2 3 int test() { return 1; } build.gradle(app)設定 專案的ABI 設置自己寫的ndk產生各種cpu的so檔，可多個，目前範例只有’x86_64’ 1 2 3 4 5 6 7 8 9 10 11 12 13 android { ... defaultConfig { ... externalNativeBuild { ndkBuild { abiFilters 'x86_64' } } ... } ... } 第三方的Lib的ABI 所謂第三方的Lib是指(dependencies)依賴的Lib 1 2 3 dependencies { implementation '....' } 設置第三方的Lib產生各種cpu的so檔，可多個，目前範例只有’x86_64’ 1 2 3 4 5 6 7 8 9 10 android { ... defaultConfig { ... ndk { abiFilters 'x86_64' } } ... } cmake文件路徑 cmake文件放置路徑跟build.gradle(app)同目錄下的src/main/cpp 1 2 3 4 5 6 7 8 9 10 android { ... externalNativeBuild { cmake { path file('src/main/cpp/CMakeLists.txt') version '3.22.1' } } ... } jniLibs設定 so檔放置路徑 1 2 3 4 5 6 7 8 9 android { ... sourceSets { main { jniLibs.srcDirs = ['src/main/jniLibs'] } } ... } 編譯so 終端機執行以下指令，產生出libTest.so /Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android33-clang --sysroot=/Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot -fPIC -shared testc.c -o libTest.so 匯入動態態庫 CmakeList.txt #動態庫 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}\") 解釋 ..代表回上一層目錄 ${CMAKE_CXX_FLAGS}CMakeLists.txt放置的目錄 ${ANDROID_ABI}代表abiFilters，目前是x86_64 檢查so檔的ABI $ file libTest.so libTest.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, not stripped 編譯靜態庫 先產生.o的檔案 /Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android33-clang --sysroot=/Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot -fPIC -c testc.c -o testc.o 產生.a靜態庫 /Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin/llvm-ar -r libTest.a testc.o 產生出libTest.a 匯入靜態庫 libTest.a放在跟cmake.md同一個目錄下 CMakeLists.txt add_library(Test STATIC IMPORTED) set_target_properties(Test PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/libTest.a) 導入到專案中 MainActivity.java增加 1 2 3 4 static { System.loadLibrary(\"ndkproj\"); System.loadLibrary(\"Test\"); } 鏈結 注意！ndkproj是要產生的project的so，所以一定要放在第一個，不能把Test放在最上面 需要編譯ndkproj.so需要依賴log-lib，需要Test的library 靜態檔:Test與add_library()中的Test是要一模一樣 動態檔:會自動尋找libTest.so，根據Test，前面加上lib，以及副檔名.so CMakeLists.txt target_link_libraries( # Specifies the target library. ndkproj # Links the target library to the log library # included in the NDK. ${log-lib} Test ) jni使用外部的.so檔 extern c 呼叫c檔案的function，要用extern \"C\"{}包起來。 1 2 3 extern \"C\" { int test(); } android log head file 使用Logcat可以看到錯誤訊息 1 #include &lt;android/log.h&gt; 使用android log 1 2 3 4 int result = test(); // 使用 __android_log_print() 輸出到 Logcat __android_log_print(ANDROID_LOG_DEBUG, \"NDK_TEST\", \"test() 返回值: %d\", result); 完整檔案 MainActivity.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class MainActivity extends AppCompatActivity { // Used to load the 'ndkproj' library on application startup. static { System.loadLibrary(\"ndkproj\"); System.loadLibrary(\"Test\"); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI() + stringFromJNI2(\"abcdefg\") + _test()); } public native String stringFromJNI(); } native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;jni.h&gt; #include &lt;string&gt; #define JNI_CLASS_PATH \"com/example/ndkproj/MainActivity\" #include &lt;android/log.h&gt; // 告知編譯器 test() 是一個 C 語言函式，避免名稱修飾 extern \"C\" { int test(); } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_ndkproj_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { int result = test(); // 使用 __android_log_print() 輸出到 Logcat __android_log_print(ANDROID_LOG_DEBUG, \"NDK_TEST\", \"test() 返回值: %d\", result); std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str()); } CMakeLists.txt 1 2 3 4 5 6 7 8 9 10 11 cmake_minimum_required(VERSION 3.22.1) project(\"ndkproj\") add_library(ndkproj SHARED native-lib.cpp) #靜態庫 add_library(Test STATIC IMPORTED) set_target_properties(Test PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/libTest.a) #動態庫 #set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}\") find_library(log-lib log) link_directories(${CMAKE_SOURCE_DIR}) target_link_libraries(ndkproj ${log-lib} Test)"
  },"/pages/c/conversion/conversion_function/": {
    "title": "建構子轉型",
    "keywords": "",
    "url": "/pages/c/conversion/conversion_function/",
    "body": "Prerequisites: RVO 建構子參數只有一個，可使用指派運算子 conversion function又稱作轉型函式，主要用來將一個類別轉型成另一個類別的函式，以下例子有從char轉型成Student類別，有從double轉型成Student類別，有從int轉型成Student類別。 explicit強制轉型 語法 (類型)表達式 類型(表達式) 強制轉型就是告訴編譯器要轉型的型別，例如下方程式碼，等號右邊明確定義Student型別。 1 2 Student student2 = Student(\"student2\"); Student student3 = (Student)\"student2\"; implicit自動轉型 等號右邊是const char* 型別，由編譯器去尋找能接受const char* 的建構子來建立物件。 1 Student student3 = \"student3\"; 多個單一參數，但型別不同建構子 以下分別有const char*建構子與double建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數只有一個建構子 Student(const char* name) { this-&gt;name = name; } // 參數是double Student(double weight) { this-&gt;weight = weight; } }; int main() { // 呼叫建構子參數為const char* name Student student4 = \"student4\"; // 呼叫建構子參數為double Student student5 = 58.5; return 0; } 多個參數，但第2個參數以後皆有預設值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數第2個以後都有預設參數 Student(int age, double weight = 50) { this-&gt;age = age; this-&gt;weight = weight; } }; int main() { // 呼叫建構子第1個參數為int，第2個參數是預設 Student student6 = 18; return 0; } 先建立物件，再自動轉型的方式建立物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數第2個以後都有預設參數 Student(int age, double weight = 50) { this-&gt;age = age; this-&gt;weight = weight; } }; int main() { // 呼叫沒有參數的建構子 Student student4; // 等號右邊建立匿名物件(呼叫1個參數的建構子)，再把匿名物件指派給student4(等號左邊) student4 = \"student4\"; return 0; } 函式的參數是字串，再自動轉型的方式建立物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數只有一個建構子 Student(const char* name) { this-&gt;name = name; } // 參數是double Student(double weight) { this-&gt;weight = weight; } // 參數第2個以後都有預設參數 Student(int age, double weight = 50) { this-&gt;age = age; this-&gt;weight = weight; } }; void printStudent(Student s) { cout &lt;&lt; \"s的名字:\" &lt;&lt; s.name &lt;&lt; endl; } int main() { printStudent(\"Bill\"); return 0; } s的名字:Bill 函式傳回值為自動轉型 1 2 3 4 5 6 7 8 Student createStudent() { return \"Alice\"; } int main() { Student student7 = createStudent(); cout &lt;&lt; \"student7 name = \" &lt;&lt; student7.name &lt;&lt; endl; return 0; } student7 name = Alice 若自動轉型的型態與參數型態不同，但可以透過自動轉型，建立物件 以下例子是由char轉成int，會呼叫int的建構子參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} Student(int age) { this-&gt;age = age; this-&gt;weight = weight; } }; Student createStudent2() { char a = 97; return a; } int main() { Student student8 = createStudent2(); cout &lt;&lt; \"student8 age = \" &lt;&lt; student8.age &lt;&lt; endl; return 0; } student8 age = 97 建構子前加上explicit，就不能使用自動轉型函式 但可以使用強制轉型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數是double explicit Student(double weight) { this-&gt;weight = weight; } }; int main() { // 強制轉型 Student student5 = Student(58.5); // 無法使用以下自動轉型 //Student student5 = 58.5; return 0; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &lt;iostream&gt; using namespace std; class Student { public: string name; double weight; int age; Student(){}; // 解構子 ~Student() {} // 參數只有一個建構子 Student(const char* name) { this-&gt;name = name; } // 參數是double explicit Student(double weight) { this-&gt;weight = weight; } // 參數第2個以後都有預設參數 Student(int age, double weight = 50) { this-&gt;age = age; this-&gt;weight = weight; } }; void printStudent(Student s) { cout &lt;&lt; \"s的名字:\" &lt;&lt; s.name &lt;&lt; endl; } Student createStudent() { return \"Alice\"; } Student createStudent2() { char a = 97; return a; } int main() { // 呼叫一個參數的建構子 Student student1(\"student1\"); cout &lt;&lt; \"student1 name = \" &lt;&lt; student1.name &lt;&lt; endl; // 強制轉型 // 手動指定轉型過程（例如 Student student2 = Student(\"student2\");，這就是強制轉型 Student student2 = Student(\"student2\"); cout &lt;&lt; \"student2 name = \" &lt;&lt; student2.name &lt;&lt; endl; // 使用等於(=)指派運算子呼叫只有一個參數的建構子 // 自動轉型：\"student3\" 會被轉型為 Student(\"student3\")。 // \"student3\" 原本是 const char* 型別，不是 Student。 // C++編譯器發現 Student 類別有一個能接受 const char* 的建構子，所以它自動執行型別轉型，並呼叫這個建構子來建立 Student 物件 // 這種自動進行的轉型稱為自動轉型 Student student3 = \"student3\"; cout &lt;&lt; \"student3 name = \" &lt;&lt; student3.name &lt;&lt; endl; // 建立student4物件 // 呼叫沒有參數的建構子 Student student4; // 等號右邊建立匿名物件(呼叫1個參數的建構子)，再把匿名物件指派給student4(等號左邊) student4 = \"student4\"; cout &lt;&lt; \"student4 name = \" &lt;&lt; student4.name &lt;&lt; endl; // 呼叫建構子參數為double Student student5 = Student(58.5); cout &lt;&lt; \"student5 weight = \" &lt;&lt; student5.weight &lt;&lt; endl; // 呼叫建構子第1個參數為int，第2個參數是預設 Student student6 = 18; cout &lt;&lt; \"student6 age = \" &lt;&lt; student6.age &lt;&lt; \",student6 weight = \" &lt;&lt; student6.weight &lt;&lt; endl; printStudent(\"Bill\"); Student student7 = createStudent(); cout &lt;&lt; \"student7 name = \" &lt;&lt; student7.name &lt;&lt; endl; Student student8 = createStudent2(); cout &lt;&lt; \"student8 age = \" &lt;&lt; student8.age &lt;&lt; endl; Student student9 = (Student)\"student9\"; cout &lt;&lt; \"student9 name = \" &lt;&lt; student9.name &lt;&lt; endl; return 0; } student1 name = student1 student2 name = student2 student3 name = student3 student4 name = student4 student5 weight = 58.5 student6 age = 18,student6 weight = 50 s的名字:Bill student7 name = Alice student8 age = 97 student9 name = student9"
  },"/pages/c/class/inheritance/": {
    "title": "繼承",
    "keywords": "",
    "url": "/pages/c/class/inheritance/",
    "body": "子類別繼承父類別 子類別繼承父類別，子類別可以使用父類別的成員變數與成員函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &lt;iostream&gt; using namespace std; class Parent { public: string name_; string tel_; void setName(const string&amp; name) { name_ = name; } void setTel(const string&amp; tel) { tel_ = tel; } }; class Child:public Parent { public: int id_; void setId(const int id) { id_ = id; } void print() { cout &lt;&lt; \"id = \" &lt;&lt; id_ &lt;&lt; \", name = \" &lt;&lt; name_ &lt;&lt; \", tel = \" &lt;&lt; tel_ &lt;&lt; endl; } }; int main() { // 建立child物件 Child child; // 使用父類別的setName成員函式 child.setName(\"Cici\"); // 使用父類別的setTel成員函式 child.setTel(\"08xxxxxx\"); child.setId(100); child.print(); return 0; } 繼承方式 1 2 class Child1:public Parent { }; 以上的:public，public就是繼承方式 繼承方式有三種，public、protected、private。 若繼承方式是protected，父類別的public成員函式與成員變數會降級成protected，影嚮到孫子類別存取祖父類別的成員函式與變數。 若繼承方式是private，父類別的public成員函式與成員變數會降級成private，影嚮到孫子類別無法存取祖父類別的成員函式與變數。 繼承方式 在 main()存取父類別public成員函式 在子類別存取父類別public成員函式 在孫子類別存取祖父類別public成員函式 public 可存取 可存取 可存取 protected 無法存取 可存取 可存取 private 無法存取 可存取 無法存取 以下程式碼透過public的printId()與setId()就可以由外部main()函式去寫入私有成員變數與讀取私有成員變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; class Parent { public: string name_; Parent(){} void setId(const string&amp; id) { id_ = id; } void printId() { cout &lt;&lt; \"id = \" &lt;&lt; id_ &lt;&lt; endl; } private: string id_; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include &lt;iostream&gt; using namespace std; class Parent { public: string name_; Parent(){} void setName(const string&amp; name) { name_ = name; } void setTel(const string&amp; tel) { tel_ = tel; } void setId(const string&amp; id) { id_ = id; } void printId() { cout &lt;&lt; \"id = \" &lt;&lt; id_ &lt;&lt; endl; } protected: string tel_; private: string id_; }; class Child1:public Parent { public: void print() { // 父類別id_成員變數是private無法使用 cout &lt;&lt; \"name = \" &lt;&lt; name_ &lt;&lt; \",tel_ = \" &lt;&lt; tel_ &lt;&lt; endl; } }; //繼承方式為protected，父類別的public成員變數與函式全變成protected class Child2:protected Parent { public: void print(const string&amp; name, const string&amp; tel, const string&amp; id) { // 父類別id_成員變數是private無法使用 // 父類別的成員函式降級protected，但仍能在子類別成員函式使用 // 無法在main()外部使用父類public的setName(),setTel(),printId() setName(name); setTel(tel); setId(id); printId(); // 父類別的成員變數的仍可給child成員函式使用 cout &lt;&lt; \"name = \" &lt;&lt; name_ &lt;&lt; \",tel_ = \" &lt;&lt; tel_ &lt;&lt; endl; } }; class GrandChild2:protected Child2 { public: void print(const string&amp; name, const string&amp; tel, const string&amp; id) { // 祖父id_成員變數是private無法使用 // 祖父的成員函式setName(),setTel(),printId()降級protected，但仍能在孫子類別成員函式使用 // 無法在main()外部使用祖父類public的setName(),setTel(),printId() setName(name); setTel(tel); setId(id); printId(); // 祖父類別的成員變數的仍可給child成員函式使用 cout &lt;&lt; \"name = \" &lt;&lt; name_ &lt;&lt; \",tel_ = \" &lt;&lt; tel_ &lt;&lt; endl; } }; class Child3:private Parent { public: void print(const string&amp; name, const string&amp; tel, const string&amp; id) { // 父類別id_成員變數是private無法使用 // 父類別的成員函式setName(),setTel(),printId()降級private, 但仍能在子類別成員函式使用，孫子類別無法使用 // 無法在main()外部使用父類public的setName(),setTel(),printId() setName(name); setTel(tel); setId(id); printId(); // 父類別的成員變數的仍可給child成員函式使用 cout &lt;&lt; \"name = \" &lt;&lt; name_ &lt;&lt; \",tel_ = \" &lt;&lt; tel_ &lt;&lt; endl; } }; class GrandChild3:private Child3 { public: void print(const string&amp; name, const string&amp; tel, const string&amp; id) { // 祖父類別id_成員變數是private無法使用 // 祖父類別的成員函式setName(),setTel(),setId(),printId()降級private無法使用 // 祖父類別的public方法setName(),setTel(),setId(),printId()全部降級成private無法使用 //setName(name); //setTel(tel); //setId(id); //printId(); // 祖父類別的成員變數降級private無法使用 // cout &lt;&lt; \"name = \" &lt;&lt; name_ &lt;&lt; \",tel_ = \" &lt;&lt; tel_ &lt;&lt; endl; } }; int main() { // 建立child1物件 // 因為繼承方式是public，所以父類別的public成員函式可以使用 Child1 child1; child1.setName(\"Cici\"); child1.setTel(\"080xxxx\"); child1.print(); Child2 child2; // 因為繼承方式是protected，所以父類別的public成員函式全降級變為protected成員函式 // protected就不能在main()外部使用父類別的public成員函式setName()與setTel() //child2.setName(\"Cici2\"); //child2.setTel(\"080xxxx2\"); child2.print(\"Bill\",\"09xxxx\",\"0001\"); GrandChild2 gchild2; gchild2.print(\"gBill\",\"g09xxxx\",\"g0001\"); Child3 child3; child3.print(\"Jerry\",\"08xxxx\",\"0002\"); GrandChild3 gchild3; gchild3.print(\"gJerry\",\"g08xxxx\",\"g0002\"); return 0; } name = Cici,tel_ = 080xxxx id = 0001 name = Bill,tel_ = 09xxxx id = g0001 name = gBill,tel_ = g09xxxx id = 0002 name = Jerry,tel_ = 08xxxx 改變父類別存取權限 使用using 子類別可以改變父類別成員變數的權限，但無法修改父類別權限為private成員變數。 以下的例子public權限改為private，protected改為public 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Parent { public: string name_; protected: string tel_; private: string id_; }; class Child:public Parent { public: // 父類別別protected成員變數改成public using Parent::tel_; private: // 父類別別public成員變數改成private using Parent::name_; }; int main() { Child child; child.tel_ = \"087000\"; return 0; } 繼承的建構子與解構子 建立子類別物件，呼叫父類別建構子-&gt;呼叫子類別建構子 銷毀子類別物件，呼叫子類別解構子-&gt;呼叫父類別解構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; class Parent { public: Parent() {cout &lt;&lt; \"Parent建構子\" &lt;&lt; endl;} ~Parent() {cout &lt;&lt; \"Parent解構子\" &lt;&lt; endl;} }; class Child:public Parent { public: Child() {cout &lt;&lt; \"Child建構子\" &lt;&lt; endl;} ~Child() {cout &lt;&lt; \"Child解構子\" &lt;&lt; endl;} }; int main() { Child child; return 0; } Parent建構子 Child建構子 Child解構子 Parent解構子 繼承的範圍運算子 以下的範例，父類別與子類別與孫類別都有print()成員函式，也都有name的成員變數，使用範圍運算子，可以明確指示出要使用祖父類別或父類別的成員函式或成員變數。 呼叫父類別成員變數語法 子類物件.父類別::成員變數 呼叫父類別成員函式語法 子類物件.父類別::成員函式() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &lt;iostream&gt; using namespace std; class Parent { public: string name_ = \"Parent\"; void print() { cout &lt;&lt; \"Parent name:\" &lt;&lt; name_ &lt;&lt; endl; } }; class Child:public Parent { public: string name_ = \"Child\"; void print() { cout &lt;&lt; \"Child name:\" &lt;&lt; name_ &lt;&lt; endl; } }; class GrandChild:public Child { public: string name_ = \"GrandChild\"; void print() { cout &lt;&lt; \"GrandChild name:\" &lt;&lt; name_ &lt;&lt; endl; } }; int main() { GrandChild grandChild; cout &lt;&lt; \"Parent name = \" &lt;&lt; grandChild.Parent::name_ &lt;&lt; endl; cout &lt;&lt; \"Child name = \" &lt;&lt; grandChild.Child::name_ &lt;&lt; endl; cout &lt;&lt; \"GrandChild name = \" &lt;&lt; grandChild.GrandChild::name_ &lt;&lt; endl; cout &lt;&lt; \"------------------------\" &lt;&lt; endl; grandChild.Parent::print(); grandChild.Child::print(); grandChild.GrandChild::print(); return 0; } Parent name = Parent Child name = Child GrandChild name = GrandChild ------------------------ Parent name:Parent Child name:Child GrandChild name:GrandChild 也可以使用一層層呼叫方式，呼叫成員變數。呼叫方式子類別::父類別::父類別的成員變數 1 cout &lt;&lt; \"Parent name = \" &lt;&lt; grandChild.Child::Parent::name_ &lt;&lt; endl; 父類別子類別大小 sizeof Prerequisites: operator new delete 以下的程式範例可以看出父類別有3個int變數(m1,m2,m3)，int大小為4byte，所以父類別總共為12byte 子類別只有1個int變數(m4)，4byte，但子類別會繼承父類別的變數，所以12byte + 4byte = 16byte，因此子類別建立的記憶體大小為16byte。 透過自建operator new()函式，可以看到建立Child的大小為16byte。 使用以下語法可以看出父類別的大小 sizeof(父類別) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; using namespace std; void* operator new(size_t size) { cout &lt;&lt; \"全域new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"全域 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"全域 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } class Parent { public: int m1_ = 10; int m2_ = 20; int m3_ = 30; }; class Child:public Parent { public: int m4_ = 40; }; int main() { cout &lt;&lt; \"size of Parent = \" &lt;&lt; sizeof(Parent) &lt;&lt; endl; cout &lt;&lt; \"size of Child = \" &lt;&lt; sizeof(Child) &lt;&lt; endl; Child* ptr = new Child; return 0; } size of Parent = 12 size of Child = 16 全域new size = 16 全域 address = 0x600000008030 記憶體布局 Memory layout windows使用以下語法 cl 原始檔案 /d1 reportSingleClassLayout類別名 cl test.cpp /d1 reportSingleClassLayoutTestA mac使用以下語法 -A 10 代表只印出10筆 clang++ -Xclang -fdump-record-layouts -c 原始檔案.cpp | grep -A 10 \"class 類別名\" clang++ -Xclang -fdump-record-layouts -c test1.cpp | grep -A 10 \"class Parent\" Parent 拿上一個範例的程式碼，顯示出來的記憶體布局如下: 0 | class Parent 0 | int m1_ 4 | int m2_ 8 | int m3_ | [sizeof=12, dsize=12, align=4, | nvsize=12, nvalign=4] m1_從0byte開始 m2_從4byte開始 m3_從8byte開始 int整數大小是4byte，所以Parent類別的大小為12 Child clang++ -Xclang -fdump-record-layouts -c test1.cpp | grep -A 10 \"class Child\" 0 | class Child 0 | class Parent (base) 0 | int m1_ 4 | int m2_ 8 | int m3_ 12 | int m4_ | [sizeof=16, dsize=16, align=4, | nvsize=16, nvalign=4] Parent m1_從0byte開始 Parent m2_從4byte開始 Parent m3_從8byte開始 Child m4_從12byte開始 子類別本身包含了父類別的成員變數，所以Child的大小為16byte。"
  },"/pages/c/conversion/type_conversion/": {
    "title": "c++轉型",
    "keywords": "",
    "url": "/pages/c/conversion/type_conversion/",
    "body": "Prerequisites: 建構子轉型 強制轉型 以下C語言的強制轉型 語法 (類型)表達式 類型(表達式) 1 2 3 4 int a = (int)8.3; int a = int(8.3); Student student2 = Student(\"student2\"); Student student3 = (Student)\"student2\"; 接下來要說C++的強制轉型 static_cast 語法 static_cast&lt;類型&gt;(表達式) 基本型態 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { // int是4byte int i = 10; // long在win是4byte，在linux8byte // 低精準度int轉成高精準度long，不會有小數點被截掉，精準度不足的問題 long long1 = i; double d = 5.55; // 自動轉型，double是8byte高精準度轉到long4byte低精準度 // 會有小數點被截掉，精準度不足的問題 long long2 = d; // c語言的強制轉型 long long3 = (long)d; // c++的強制轉型 long long4 = static_cast&lt;long&gt;(d); return 0; } 指標轉型 以下C語言的指標強制轉型 語法 (指標類型*)位址 以下C++的指標強制轉型，但static cast只支援同類型轉型 語法 static_cast&lt;指標類型*&gt;(位址) 不同類型要先轉成void指標(任何類型指標都能轉成void指標) 1 2 void* point_v1 = 變數位址; double* 指標變數 = static_cast&lt;類型*&gt;(point_v1); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { int i = 10; // c的強制轉型 double* point_d1 = (double*)&amp;i; // c++的強制轉型 // static cast不能轉型二種不同類型的指標 // 以下語法編譯不過，因為&amp;i是整數類型的指標 //double* point_d2 = static_cast&lt;double&gt;(&amp;i); // 需要先把整數類型的指標轉成void類型的指標 //任何類型的指標都可以自動轉型成void指標 void* point_v1 = &amp;i; double* point_d3 = static_cast&lt;double*&gt;(point_v1); return 0; } 函式轉型指標類型 在函式中要轉型不同類型指標，函式參數要用void* 1 2 3 4 5 6 7 8 void func(void* ptr) { double* point = static_cast&lt;double*&gt;(ptr); } int main() { int i = 10; func(&amp;i); return 0; } reinterpret_cast 以下三種語法例子，一定要有一方是指標，要嘛指標轉指標，要嘛指標轉成數值，要嘛數值轉成指標 轉型不同類型指標 語法1:不同類型指標轉型 reinterpret_cast&lt;指標類型&gt;(位址或指標) 轉型指標可以不用透過void指標，就直接把指標轉型。 1 2 3 4 5 int main() { int i = 10; double* point_double = reinterpret_cast&lt;double*&gt;(&amp;i); return 0; } 基本類型與指標互相轉型 所謂的基本類型是指一定要跟指標一樣是8byte才能互轉，不能用int(4byte)轉指標(8byte)，會編譯不過。 語法2:long long(8byte)轉成指標(8byte) reinterpret_cast&lt;指標類型&gt;(基本類型) 語法3:指標轉成long long reinterpret_cast&lt;基本類型&gt;(指標類型) 1 2 3 4 5 6 7 8 9 10 11 void func(void* ptr) { // 指標轉成long long long long ll = reinterpret_cast&lt;long long&gt;(ptr); cout &lt;&lt; \"ll = \" &lt;&lt; ll &lt;&lt; endl; } int main() { long long ll = 10; // long long(8byte)轉成void指標(8byte) func(reinterpret_cast&lt;void*&gt;(ll)); return 0; } const_cast static_cast與reinterpret_cast不能去掉const類型，但const_cast可以去掉const類型 基本資料型態去掉const 對於基本類型const轉成不是const類型，可以編譯成功 1 2 3 4 5 6 int main() { // 對於基本類型沒有const轉成不是const類型的問題 const int i1 = 10; int i2 = i1; return 0; } const指標轉成不是const指標會編譯不過 若把const指標轉成不是const指標，以下程式碼會編譯不過，不能把const類型指標指派給不是const類型指標。 1 2 3 4 5 int main() { const int* ptr_i1 = nullptr; int* ptr_i2 = ptr_i1; return 0; } const_cast語法 以下C語言的指標去掉const 語法 (指標類型*)位址 以下C++的指標去掉const 語法 const_cast&lt;指標類型*&gt;(位址或指標) 使用const_cast強制轉型 1 2 3 4 5 6 7 8 int main() { const int* ptr_i1 = nullptr; // c語言去掉const，強制轉型成不是const int* ptr_i2 = (int*)ptr_i1; // c++強制轉型不是const int* ptr_i3 = const_cast&lt;int*&gt;(ptr_i1); return 0; } 非const類型轉成const 1 2 3 4 5 int main() { char *p1 = \"321\"; const char *c = const_cast&lt;const char*&gt;(p1); return 0; }"
  },"/pages/c/conversion/cast_operator/": {
    "title": "cast operator轉型運算子",
    "keywords": "",
    "url": "/pages/c/conversion/cast_operator/",
    "body": "Prerequisites: 建構子轉型 在建構子轉型的文章中，是把string轉成類別、int轉成類別、double轉成類別 cast operator，把類別轉型成某種類型，比如類別轉成int、類別轉成string、類別轉成float 語法，必須放在類別中，沒有傳回值類型，不能有參數。 operator 類型() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int main() { Student student; student.name_ = \"Bill\"; student.age_ = 20; student.weight_ = 50; // 自動轉型 string name = student; int age = student; double weight = student; cout &lt;&lt; \"name = \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"age = \" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; \"weight = \" &lt;&lt; weight &lt;&lt; endl; // 強制轉型 string name2 = (string)student; int age2 = (int)student; double weight2 = (double)student; cout &lt;&lt; \"name2 = \" &lt;&lt; name2 &lt;&lt; endl; cout &lt;&lt; \"age2 = \" &lt;&lt; age2 &lt;&lt; endl; cout &lt;&lt; \"weight2 = \" &lt;&lt; weight2 &lt;&lt; endl; string name3 = string(student); int age3 = int(student); double weight3 = double(student); cout &lt;&lt; \"name3 = \" &lt;&lt; name3 &lt;&lt; endl; cout &lt;&lt; \"age3 = \" &lt;&lt; age3 &lt;&lt; endl; cout &lt;&lt; \"weight3 = \" &lt;&lt; weight3 &lt;&lt; endl; return 0; } name = Bill age = 20 weight = 50 name2 = Bill age2 = 20 weight2 = 50 name3 = Bill age3 = 20 weight3 = 50"
  },"/pages/c/class/inherit_init/": {
    "title": "繼承初始化",
    "keywords": "",
    "url": "/pages/c/class/inherit_init/",
    "body": "Prerequisites: 建構子初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include &lt;iostream&gt; using namespace std; class Parent { public: int public_member_; private: int private_member_; public: Parent() : public_member_(0), private_member_(0) { cout &lt;&lt; \"父類別建構子\" &lt;&lt; endl; } Parent(int param1, int param2) : public_member_(param1), private_member_(param2) { cout &lt;&lt; \"父類別建構子\" &lt;&lt; endl; } // 父類別拷貝函式，將傳來的物件中的值assign給二個成員變數 Parent(const Parent &amp;p) : public_member_(p.public_member_), private_member_(p.private_member_) { cout &lt;&lt; \"父類別拷貝建構子\" &lt;&lt; endl; } void showParent() { cout &lt;&lt; \"父類別 public_member_ = \" &lt;&lt; public_member_ &lt;&lt; \",private_member_ = \" &lt;&lt; private_member_ &lt;&lt; endl; } }; class Child : public Parent { public: int child_member_; // 子類別預設會呼叫父類別的空建構子，就算省略不寫:Parent()，編譯器也會自動產生 // 並初始化child_member_值為100 Child() : Parent(), child_member_(100) {} Child(int param1, int param2, int param3) : Parent(param1, param2), child_member_(param3) { cout &lt;&lt; \"子類別3個參數建構子\" &lt;&lt; endl; } // 呼叫父類別的拷貝建構子 Child(const Parent&amp; parent, int param3) : Parent(parent), child_member_(param3) { cout &lt;&lt; \"子類別2個參數建構子\" &lt;&lt; endl; } void showChild() { cout &lt;&lt; \"child_member = \" &lt;&lt; child_member_ &lt;&lt; endl; } }; int main() { // 呼叫子類別空建構子 Child child1; child1.showChild(); // 呼叫子類別3個參數建構子 Child child2(5, 10, 15); child2.showChild(); // 呼叫父類別2個參數建構子 Parent p1(22, 33); //子類別2個參數的建構子，並且呼叫父類別拷貝函式 Child child3(p1, 44); // 呼叫父類別的函式 child3.showParent(); child3.showChild(); return 0; } 父類別建構子 child_member = 100 父類別建構子 子類別3個參數建構子 child_member = 15 父類別建構子 父類別拷貝建構子 子類別2個參數建構子 父類別 public_member_ = 22,private_member_ = 33 child_member = 44"
  },"/pages/c/dynamicMemory/malloc/": {
    "title": "malloc",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/malloc/",
    "body": "語法 1 void* malloc(size_t __size) 傳回值型態 由於malloc傳回的類型是void*指標地址，void*可以強轉成任何型態。 所以可以強制轉型 1 2 char* name = (char* )malloc(10); // 10byte int* num = (int* )malloc(1 * 1024 * 1024); // 1byte * 1024 = 1kb -&gt;1kb * 1024=1mb 參數size_t 參數size_t __size代表設定空間大小 也可以這樣定義 1 2 3 // int 4byte * 10 = 40 byte // 申請40byte的記憶體空間 int* num = (int* )malloc(sizeof(int) * 10); 變數申請動態空間 1 char* name = (char* )malloc(100); 初始化memset -memset 把指標所指向的記憶體內容，初始化要定義的值 以下是把jj指標所指向的記憶體空間，全變成NULL，0等於NULL 1 2 3 void* jj = malloc(1 * 1024 * 1024); size_t jj_size = 1 * 1024 * 1024; memset(jj, 0, jj_size); // 初始化jj指標所指向的內存為0 釋放記憶體空間 使用完要手動釋放空間，不然會造成記憶體洩露 1 2 3 name = 0; // 相當於 name = NULL free(name); name = nullptr; 完整程式碼 1 2 3 4 5 6 // jj指標指向1mb的動態內存空間1byte*1024 = 1kb -&gt;1kb*1024=1mb void* jj = malloc(1 * 1024 * 1024); size_t jj_size = 1 * 1024 * 1024; memset(jj, 0, jj_size); // 初始化jj指標所指向的記憶體位址的值為0 free(jj); // 把jj指標的空間釋放，若使用malloc要用free來釋放空間 jj = 0; // jj指標設為0也就是null"
  },"/pages/c/dynamicMemory/operator_new_delete/": {
    "title": "operator new delete",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/operator_new_delete/",
    "body": "Prerequisites: malloc memset 自己實作new與delete 呼叫順序 new 先呼叫operator new() 呼叫建構子 delete 呼叫解構子 呼叫operator delete() 語法 new的寫法 operator new 傳回值固定void* 參數型態固定size_t return 指標 使用malloc(大小) new語法 1 2 3 4 5 6 void* operator new(size_t size) { cout &lt;&lt; \"全域new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"全域 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } delete的寫法 operator delete 傳回值固定void 參數型態固定void* 使用free(指標) delete語法 1 2 3 4 5 void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"全域 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } 在全域的位置添加上述new與delete的語法，建立物件就會使用自建的new與delete語法。 new基本型態 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void* operator new(size_t size) { cout &lt;&lt; \"全域new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"全域 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"全域 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } int main() { int* ptr1 = new int(10); cout &lt;&lt; \"int address = \" &lt;&lt; (void*)ptr1 &lt;&lt; \" , value = \" &lt;&lt; *ptr1 &lt;&lt; endl; delete ptr1; return 0; } 全域new size = 4 全域 address = 0x600000004050 int address = 0x600000004050 , value = 10 全域 delete address = 0x600000004050 new類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void* operator new(size_t size) { cout &lt;&lt; \"全域new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"全域 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"全域 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } // 建立Student物件 class Student { string name; }; int main() { Student* s1 = new Student(); cout &lt;&lt; \"student address = \" &lt;&lt; (void*)s1 &lt;&lt; endl; delete s1; return 0; } 全域new size = 24 全域 address = 0x600000203140 student address = 0x600000203140 全域 delete address = 0x600000203140 類別自建operator new與delete 靜態類別變數與函式 如果類別自己有operator new與delete，就不會使用全域的new與delete 靜態成員函式的new與delete 類別中的operator new與delete是static靜態成員函式 因為是靜態成員函式，所以只能使用靜態成員變數與靜態成員函式，不能使用非靜態成員變數與函式。 靜態成員變數需要初始化 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void* operator new(size_t size) { cout &lt;&lt; \"全域new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"全域 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"全域 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } // 建立Student物件 class Student { public: string name; void* operator new(size_t size) { cout &lt;&lt; \"類別中 new size = \" &lt;&lt; size &lt;&lt; endl; void* ptr = malloc(size); cout &lt;&lt; \"類別中 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; cout &lt;&lt; \"類別中 delete address = \" &lt;&lt; ptr &lt;&lt; endl; free(ptr); } }; int main() { int* ptr1 = new int(10); cout &lt;&lt; \"int address = \" &lt;&lt; (void*)ptr1 &lt;&lt; \" , value = \" &lt;&lt; *ptr1 &lt;&lt; endl; delete ptr1; Student* s1 = new Student(); cout &lt;&lt; \"student address = \" &lt;&lt; (void*)s1 &lt;&lt; endl; delete s1; return 0; } 全域new size = 4 全域 address = 0x600000004050 int address = 0x600000004050 , value = 10 全域 delete address = 0x600000004050 類別中 new size = 24 類別中 address = 0x600000203140 student address = 0x600000203140 類別中 delete address = 0x600000203140 自建pool Student只包含二個成員變數，分別是int id_與 int age_，大小共8byte。 自建的pool為18byte，把pool分為二個區塊來儲存物件，可以存二個物件，超過pool的大小，就用系統的空間來儲存記憶體位址。 第1個byte作為標誌位，1代表使用，0代表沒使用，第2個byte為第一區塊的資料存放的記憶體位址。 第9個byte作為標誌位，1代表使用，0代表沒使用，第10個byte為第二區塊的資料存放的記憶體位址。 使用char*來儲存記憶體位址，因為是char是1byte，一次只會遞增或遞減1byte。 initPool()與freepool()都為靜態函式，使用方式類別::靜態函式() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // 建立Student物件 class Student { public: int id_; int age_; // char是1byte，一次只會遞增或遞減1byte。 static char* pool_; // pool的記憶體開始位址 static bool initPool() { pool_ = (char*)malloc(18); // 建立18byte大小的記憶體空間 if (pool_ == nullptr) return false; // 申請記憶體位址失敗返回 memset(pool_, 0, 18); // 把記憶體的值全初始化為0 cout &lt;&lt; \"開始位址 = \" &lt;&lt; (void*)pool_ &lt;&lt; endl; return true; } static void freepool() { if (pool_ == nullptr) return; // 記憶體位址是空就return返回 free(pool_); // 記憶體釋放 cout &lt;&lt; \"記憶體釋放\" &lt;&lt; endl; } Student() { cout &lt;&lt; \"建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"解構子\" &lt;&lt; endl; } void* operator new(size_t size) { if (pool_[0] == 0) { cout &lt;&lt; \"第一區塊位址 = \" &lt;&lt; (void*)(pool_ + 1) &lt;&lt; endl; pool_[0] = 1; // 註記為已使用 return pool_ + 1; // 傳回記憶體位址 } if (pool_[9] == 0) { cout &lt;&lt; \"第二區塊位址 = \" &lt;&lt; (void*)(pool_ + 10) &lt;&lt; endl; pool_[9] = 1; // 註記為已使用 return pool_ + 10; // 傳回記憶體位址 } // 以上位址都使用，就用系統內部的記憶體 void* ptr = malloc(size); cout &lt;&lt; \"系統 address = \" &lt;&lt; ptr &lt;&lt; endl; return ptr; } void operator delete(void* ptr) { if (ptr == nullptr) return; // 如果參數的位址是第一個區間的位址 if (ptr == pool_ + 1) { cout &lt;&lt; \"free 第一個區間\" &lt;&lt; endl; pool_[0] = 0; // 註記為沒在使用 return; } // 如果參數的位址是第二個區間的位址 if (ptr == pool_ + 10) { cout &lt;&lt; \"free 第二個區間\" &lt;&lt; endl; pool_[9] = 0; // 註記為沒在使用 return; } // 如果傳進來的位址不是pool_中的位址，代表是系統的位址，使用free free(ptr); } }; // 靜態成員變數要初始化 char* Student::pool_ = nullptr; int main() { if (Student::initPool() == false) { cout &lt;&lt; \"init fail\" &lt;&lt; endl; return -1; } cout &lt;&lt; \"========= create s1 ============\" &lt;&lt; endl; Student* s1 = new Student(); cout &lt;&lt; \"s1 address = \" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; \"========= create s2 ============\" &lt;&lt; endl; Student* s2 = new Student(); cout &lt;&lt; \"s2 address = \" &lt;&lt; s2 &lt;&lt; endl; cout &lt;&lt; \"========= create s3 ============\" &lt;&lt; endl; Student* s3 = new Student(); cout &lt;&lt; \"s3 address = \" &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; \"========= del s1 ============\" &lt;&lt; endl; delete s1; cout &lt;&lt; \"========= create s4 ============\" &lt;&lt; endl; Student* s4 = new Student(); cout &lt;&lt; \"s4 address = \" &lt;&lt; s4 &lt;&lt; endl; cout &lt;&lt; \"========= del s2 ============\" &lt;&lt; endl; delete s2; cout &lt;&lt; \"========= del s3 ============\" &lt;&lt; endl; delete s3; cout &lt;&lt; \"========= del s4 ============\" &lt;&lt; endl; delete s4; Student::freepool(); return 0; } 開始位址 = 0x600000209300 ========= create s1 ============ 第一區塊位址 = 0x600000209301 建構子 s1 address = 0x600000209301 ========= create s2 ============ 第二區塊位址 = 0x60000020930a 建構子 s2 address = 0x60000020930a ========= create s3 ============ 系統 address = 0x600000008030 建構子 s3 address = 0x600000008030 ========= del s1 ============ 解構子 free 第一個區間 ========= create s4 ============ 第一區塊位址 = 0x600000209301 建構子 s4 address = 0x600000209301 ========= del s2 ============ 解構子 free 第二個區間 ========= del s3 ============ 解構子 ========= del s4 ============ 解構子 free 第一個區間 記憶體釋放"
  },"/pages/c/class/polymorphism/": {
    "title": "多型",
    "keywords": "",
    "url": "/pages/c/class/polymorphism/",
    "body": "多型概念 所謂的多型就是父類別的指標指向子類別，並且可以使用子類別覆寫父類別的函式。 父類別的指標指向子類別時，子類別不用強制轉型成父類別。 以下程式碼，父類別Parent指標指向子類別Child，子類別也同時有func()函式，但使用父類別指標呼叫func()函式則會呼叫父類別的func()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Parent { public: void func() { cout &lt;&lt; \"Parent func()\" &lt;&lt; endl; } }; class Child:public Parent { public: // 子類別覆寫func()函式 void func() { cout &lt;&lt; \"Child func()\" &lt;&lt; endl; } }; int main() { // 父類別Parent指標指向子類別Child // 子類別不用強制轉型成父類別 Parent* ptr = new Child; // 呼叫父類別的func() ptr-&gt;func(); return 0; } Parent func() virtual 為了解決這個問題，C++發明了virtual關鍵字。 在宣告函式的時候，在函式前面加上virtual關鍵字，告訴編譯器，若父類別指標指向子類別時，子類別有覆寫父類別virtual函式，則使用子類別的函式，若子類別沒覆寫則使用父類別的函式。 以下程式碼父類別有二個virtual函式func1與func2，子類別只覆寫func1。 當父類別指標指向子類別，父類別指標呼叫func1()，實際上是會去看子類別有沒有覆寫func1()，若有覆寫則使用子類別func1()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Parent { public: virtual void func1() { cout &lt;&lt; \"Parent func1()\" &lt;&lt; endl; } virtual void func2() { cout &lt;&lt; \"Parent func2()\" &lt;&lt; endl; } }; class Child:public Parent { public: void func1() { cout &lt;&lt; \"Child func1()\" &lt;&lt; endl; } }; int main() { Parent* ptr = new Child; ptr-&gt;func1(); ptr-&gt;func2(); return 0; } Child func1() Parent func2() 使用父類別的函式 父類別指標指向子類別，子類別有覆寫父類別virtual函式，但仍要使用父類別的函式，則使用父類別::函式()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; class Parent { public: virtual void func1() { cout &lt;&lt; \"Parent func1()\" &lt;&lt; endl; } virtual void func2() { cout &lt;&lt; \"Parent func2()\" &lt;&lt; endl; } }; class Child:public Parent { public: void func1() { cout &lt;&lt; \"Child func1()\" &lt;&lt; endl; } }; int main() { Parent* ptr = new Child; // 父類別::函式() ptr-&gt;Parent::func1(); return 0; } Parent func1() 應用 想像一下，我們要做出一個功能，印出狼、魚、貓、狗、人如何吃東西。 “狼、魚、貓、狗、人”，他們都是生物，他們都會吃，只是每個生物吃的方法不一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { // wolf Wolf* wolf = new Wolf(); wolf-&gt;eat(); // fish Fish* fish = new Fish(); fish-&gt;eat(); // bird Bird* bird = new Bird(); bird-&gt;eat(); // human Human* human = new Human(); human-&gt;eat(); // cat Cat* cat = new Cat(); cat-&gt;eat(); return 0; } 多型步驟: 先抓出他們的共同動作，eat()，建立父類別Animal中有一個eat()函式。 父類別eat()函式前面加上virtual。 動物們繼承父類別Animal，然後子類別覆寫eat()函式。 父類別的指標指向子類別，父類別指標呼叫子類別eat()函式。 於是寫下以下的程式碼，有父類別(Animal)，子類別(Wolf、Fish、Cat…)，所有子類別覆寫eat()的函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include &lt;iostream&gt; using namespace std; class Animal{ public: virtual void eat(){} }; class Wolf: public Animal{ public: void eat(){ cout &lt;&lt; \"Wolf eat!\" &lt;&lt; endl; } }; class Fish: public Animal{ public: void eat(){ cout &lt;&lt; \"Fish eat!\" &lt;&lt; endl; } }; class Bird: public Animal{ public: void eat(){ cout &lt;&lt; \"Bird eat!\" &lt;&lt; endl; } }; class Human: public Animal{ public: void eat(){ cout &lt;&lt; \"Human eat!\" &lt;&lt; endl; } }; class Cat: public Animal{ public: void eat(){ cout &lt;&lt; \"Cat eat!\" &lt;&lt; endl; } }; int main() { // wolf Animal* wolf = new Wolf(); wolf-&gt;eat(); // fish Animal* fish = new Fish(); fish-&gt;eat(); // bird Animal* bird = new Bird(); bird-&gt;eat(); // human Animal* human = new Human(); human-&gt;eat(); // cat Animal* cat = new Cat(); cat-&gt;eat(); return 0; } Wolf eat! Fish eat! Bird eat! Human eat! Cat eat! 相同父類別的子類別全放進vector iterator 我們把這些動物丟進一個籃子中，然後再一個個抓出來，印出”吃”這個動作。 代表Animal可以有多種類型，可以是Wolf、Fish、Cat… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Animal{ public: virtual void eat(){} }; class Wolf: public Animal{ public: void eat(){ cout &lt;&lt; \"Wolf eat!\" &lt;&lt; endl; } }; class Fish: public Animal{ public: void eat(){ cout &lt;&lt; \"Fish eat!\" &lt;&lt; endl; } }; class Bird: public Animal{ public: void eat(){ cout &lt;&lt; \"Bird eat!\" &lt;&lt; endl; } }; class Human: public Animal{ public: void eat(){ cout &lt;&lt; \"Human eat!\" &lt;&lt; endl; } }; class Cat: public Animal{ public: void eat(){ cout &lt;&lt; \"Cat eat!\" &lt;&lt; endl; } }; int main() { vector&lt;Animal*&gt; animals; animals.push_back(new Wolf()); animals.push_back(new Fish()); animals.push_back(new Bird()); animals.push_back(new Human()); animals.push_back(new Cat()); //使用iterator vector&lt;Animal*&gt;::iterator it = animals.begin(); //animals.end()指向最後一個元素的下一個元素 for(;it != animals.end(); it++) { (*it)-&gt;eat() ; } return 0; } Wolf eat! Fish eat! Bird eat! Human eat! Cat eat! 多型解構子 所謂的多型就是父類別的指標指向子類別，那如果使用父類別的指標進行解構子，會呼叫子類別的解構子嗎？ 以下的執行結果可以發現，不會執行子類別的解構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; class Parent { public: ~Parent() { cout &lt;&lt; \"Parent 解構子\" &lt;&lt; endl; } }; class Child:public Parent { public: ~Child() { cout &lt;&lt; \"Child 解構子\" &lt;&lt; endl; } }; int main() { Parent* ptr = new Child; delete ptr; return 0; } Parent 解構子 為了處理上述問題，若子類別的解構子中有處理記憶體釋放的程式碼，父類別的解構子前面就一定要加上virtual，這樣使用父類別的指標，delete時就會呼叫子類別的解構子然後再呼叫父類別的解構子。 銷毀子類別物件，呼叫子類別解構子-&gt;呼叫父類別解構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; class Parent { public: virtual ~Parent() { cout &lt;&lt; \"Parent 解構子\" &lt;&lt; endl; } }; class Child:public Parent { public: ~Child() { cout &lt;&lt; \"Child 解構子\" &lt;&lt; endl; } }; int main() { Parent* ptr = new Child; delete ptr; return 0; } Child 解構子 Parent 解構子 純虛擬函式pure virtual function 在Java中pure virtual function就是抽象方法，c++中文稱為純虛擬函式。 意思是父類別不實作這個函式，但繼承這個父類別的子類別一定要實作(implementation)此函式。 virtual function虛擬函式，通常是撰寫基本的功能，而繼承的子類別則實作(implementation)虛擬函式成為更適用於子類別的。 pure virtual function純虛擬函式，完全沒有任何基本程式碼的函式，但繼承的子類別一定要實作(implementation)純虛擬函式。 父類別中有pure virtual function純虛擬函式，代表這個類別為抽象類別，不能用new建立物件。 父類別中有pure virtual function純虛擬函式，為抽象類別，但可作為父類別指標，實際上指向子類別。(多型) 純虛擬函式pure virtual function語法 virtual 傳回值類型 函式(參數) = 0; virtual void func() = 0; 父類別中有pure virtual function純虛擬函式，代表這個類別為抽象類別，不能用new建立物件。 以下程式碼會編譯錯誤。 1 2 3 4 5 6 7 8 9 class Parent { public: virtual void func() = 0; }; int main() { Parent* ptr = new Parent; delete ptr; return 0; } 如果子類別沒有實作(implementation)父類別的純虛擬函式，也不能用new建立物件。 以下程式碼會編譯錯誤。 1 2 3 4 5 6 7 8 9 10 11 class Parent { public: virtual void func() = 0; }; class Child:public Parent { }; int main() { Child* ptr = new Child; delete ptr; return 0; } 子類別實作(implementation)父類別的純虛擬函式，會編譯成功。 父類別參考與父類別指標都是相同的意思，參考的本質是指標。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Parent { public: virtual void func() = 0; }; class Child:public Parent { public: void func() { cout &lt;&lt; \"實作父類別func()\" &lt;&lt; endl; } }; int main() { Child child; // 父類別指標指向子類別 Parent* ptr = &amp;child; ptr-&gt;func(); // 父類別參考指向子類別 Parent &amp;ref1 = child; ref1.func(); return 0; } 實作父類別func() 實作父類別func() 純虛擬函式解構子 原理跟多型解構子一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; using namespace std; class Parent { public: virtual void func() = 0; virtual ~Parent() { cout &lt;&lt; \"父類別解構子\" &lt;&lt; endl; } }; class Child:public Parent { public: void func() { cout &lt;&lt; \"實作父類別func()\" &lt;&lt; endl; } ~Child() { cout &lt;&lt; \"子類別解構子\" &lt;&lt; endl; } }; int main() { Parent* ptr = new Child; ptr-&gt;func(); delete ptr; return 0; } 實作父類別func() 子類別解構子 父類別解構子 typeid判斷類型 使用typeid的==與!=，可以判斷類型。 語法 typeid(類型) typeid(指標) typeid(參考) typeid(變數) 普通類別判斷類型 以下範例建立Student物件s1。 建立Student指標，建立Student參考。 註解中有解釋各種比較。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; class Student { public: string name; }; int main() { Student s1; Student* ptr = &amp;s1; Student&amp; ref = s1; // 判斷s1變數是不是Student類別 if (typeid(s1) == typeid(Student)) cout &lt;&lt; \"s1 == Student\" &lt;&lt; endl; // ptr指標，使用*取值運算子，取出指標存放的物件，判斷這個物件是不是Student if (typeid(*ptr) == typeid(Student)) cout &lt;&lt; \"*ptr == Student\" &lt;&lt; endl; // 指標與Student類別，就不是相等，一個是指標，一個是類別，怎麼會是相同東西。 if (typeid(ptr) == typeid(Student)) cout &lt;&lt; \"ptr指標 == Student\" &lt;&lt; endl; // 指標與Student指標相比，二者都是指標 if (typeid(ptr) == typeid(Student*)) cout &lt;&lt; \"ptr指標 == Student指標\" &lt;&lt; endl; // ref參考是不是Student類別 if (typeid(ref) == typeid(Student)) cout &lt;&lt; \"ref == Student\" &lt;&lt; endl; return 0; } s1 == Student *ptr == Student ptr指標 == Student指標 ref == Student 多型判斷類型 由於多型的過程，父類別指標指向各種不同的子類別，如先前的例子，Animal可以有多種類型，可以是Wolf、Fish、Cat… 那麼要如何知道父類別指標是那個子類型呢？透過typeid可以知道。 注意！不能把父類別指標與子類別指標進行比較，因為二者是不同的。 使用*取值運算子，將父類別指標指向的記憶體位址的值(物件)取出來，比較類別。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Animal{ public: virtual void eat(){} virtual ~Animal() { cout &lt;&lt; \"父類別解構子\" &lt;&lt; endl; } }; class Fish: public Animal{ public: void eat(){ cout &lt;&lt; \"Fish eat!\" &lt;&lt; endl; } }; class Cat: public Animal{ public: void eat(){ cout &lt;&lt; \"Cat eat!\" &lt;&lt; endl; } }; int main() { Animal* animal = new Fish; // animal指標是Animal，Fish指標是Fish，二者不是相同的指標 // 不能用父類別指標與子類別指標相互比較，即便父類別指標指向的記憶體位址的值是子類別 if (typeid(animal) == typeid(Fish*)) { cout &lt;&lt; \"1.這是魚\" &lt;&lt; endl; } else { cout &lt;&lt; \"1.這不是魚\" &lt;&lt; endl; } // 在多型中，不能用指標來判斷類型 // 要使用指標指向的物件，物件與物件進行比較，才能判斷出類型 // 使用*取值運算子，父類別指標指向的記憶體位址的值取出來，也就是把子類別物件取出來 // 判斷物件是不是相同類別 if (typeid(*animal) == typeid(Fish)) { cout &lt;&lt; \"2.這是魚\" &lt;&lt; endl; } else { cout &lt;&lt; \"2.這不是魚\" &lt;&lt; endl; } delete animal; return 0; } 1.這不是魚 2.這是魚 dynamic_cast dynamic_cast主要用於多型，所謂的多型，也就是父類別指標指向子類別記憶體位址。 當要把父類別指標(實際上指向子類別)轉型成子類別指標，除了原本c語言的強制轉型的方法之外，C++提供了dynamic_cast，把父類別指標轉回原本的子類別指標。 dynamic_cast轉型失敗會傳回nullptr。 c++轉型語法 子類別指標* 指標變數名 = dynamic_cast&lt;子類別指標*&gt;(父類別指標); Fish* fish_ptr = dynamic_cast&lt;Fish*&gt;(parent_ptr); c語言強制轉型語法 功能與dynamic_cast相同，但轉型失敗不會傳回nullptr。 子類別指標* 指標變數名 = (子類別指標*)父類別指標; Fish* fish_ptr = (Fish*)parent_ptr; 以下的範例是判斷是Fish類別，就呼叫游泳的功能swim()，父類別Animal是沒有swim()函式，必須將父類別指標轉成子類別指標，才能呼叫swim()函式。 步驟如下: 使用*取值運算子取出父類別指標指向的記憶體位址存放的物件。 判斷父類別指標指向的物件是否為Fish類別 使用dynamic_cast把父類別指標轉成子類別指標，因為父類別Animal是沒有swim()函式。 子類別指標呼叫swim()函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Animal{ public: virtual void eat(){} virtual ~Animal() { cout &lt;&lt; \"父類別解構子\" &lt;&lt; endl; } }; class Wolf: public Animal{ public: void eat(){ cout &lt;&lt; \"Wolf eat!\" &lt;&lt; endl; } }; class Fish: public Animal{ public: void eat(){ cout &lt;&lt; \"Fish eat!\" &lt;&lt; endl; } void swim() { cout &lt;&lt; \"Fish swim!\" &lt;&lt; endl; } }; class Bird: public Animal{ public: void eat(){ cout &lt;&lt; \"Bird eat!\" &lt;&lt; endl; } }; class Human: public Animal{ public: void eat(){ cout &lt;&lt; \"Human eat!\" &lt;&lt; endl; } }; class Cat: public Animal{ public: void eat(){ cout &lt;&lt; \"Cat eat!\" &lt;&lt; endl; } }; int main() { vector&lt;Animal*&gt; animals; animals.push_back(new Wolf()); animals.push_back(new Fish()); animals.push_back(new Bird()); animals.push_back(new Human()); animals.push_back(new Cat()); //使用iterator vector&lt;Animal*&gt;::iterator it = animals.begin(); //animals.end()指向最後一個元素的下一個元素 for(;it != animals.end(); it++) { Animal* parent_ptr = *it; parent_ptr-&gt;eat() ; if(typeid(*parent_ptr) == typeid(Fish)) { //Fish* fish_ptr = dynamic_cast&lt;Fish*&gt;(parent_ptr); Fish* fish_ptr = (Fish*)parent_ptr; // 若轉型成功才執行以下程式碼，轉型失敗會傳回nullptr if (fish_ptr != nullptr) fish_ptr-&gt;swim(); } delete parent_ptr; } return 0; } Wolf eat! Fish eat! Fish swim! Bird eat! Human eat! Cat eat!"
  },"/pages/c/class/this/": {
    "title": "this",
    "keywords": "",
    "url": "/pages/c/class/this/",
    "body": "this是記憶體位址 在類別的每一個成員函式，都有一個隱藏參數為this指標，this指標為「呼叫物件」的記憶體位址。 什麼是「呼叫物件」，以下例的程式範例來說，建立s1物件Student s1;，s1物件呼叫getAddressByPoint()成員函式，那麼函式中的隱藏參數this指標就是s1的記憶體位址，s1就是「呼叫物件」，也就是誰呼叫了成員函式getAddressByPoint()，this指標就是誰。 this記憶體位址存放的值就是呼叫函式的物件，也就是s1。 指標就是記憶體位址，所以函式傳回值為指標，就可以直接傳回this。 若函式傳回值為參考，就要把this指標，透過*取值運算子，取出物件，並將物件傳回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Student{ public: // 傳回值為指標 Student* getAddressByPoint(){ return this; } // 傳回值為參考 Student&amp; getAddressByRef(){ // 透過取值運算子，取出物件 return *this; } void func() { cout &lt;&lt; \"call func()\" &lt;&lt; endl; } }; int main() { Student s1; Student* ptr = s1.getAddressByPoint(); cout &lt;&lt; \"address = \" &lt;&lt; ptr &lt;&lt; endl; ptr-&gt;func(); Student&amp; ref = s1.getAddressByRef(); ref.func(); return 0; } address = 0x7ff7bfeff2e8 call func() call func() this指標取得物件成員變數 使用this指標取得物件成員變數要用-&gt;(箭頭)取得，因為this是指標，指向物件存放的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Student{ public: string name; Student* getAddressByPoint(){ return this; } Student&amp; getAddressByRef(){ return *this; } void func() { cout &lt;&lt; \"call func() name = \" &lt;&lt; this-&gt;name &lt;&lt; endl; } }; int main() { Student s1; s1.name = \"Cici\"; Student* ptr = s1.getAddressByPoint(); cout &lt;&lt; \"address = \" &lt;&lt; ptr &lt;&lt; endl; ptr-&gt;func(); Student&amp; ref = s1.getAddressByRef(); ref.func(); return 0; } address = 0x7ff7bfeff2d0 call func() name = Cici call func() name = Cici this比較 程式碼中的this是指呼叫函式的物件。 s1.compare(s2)這段程式碼而言，this就是s1。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Student{ public: Student(); ~Student(); Student* getAddress(){ return this; } int getWeight() { return this-&gt;weight; } void setWeight(int weight) { this-&gt;weight = weight; } int compare(Student&amp; s) { return this-&gt;weight &gt; s.weight; } private: int weight; }; int main() { Student s1; s1.setWeight(50); Student s2; s2.setWeight(45); if(s1.compare(s2)) { cout &lt;&lt; \"s1比較重 \" &lt;&lt; endl; } else { cout &lt;&lt; \"s2比較重 \" &lt;&lt; endl; } return; }"
  },"/pages/c/pointer/unique_ptr/": {
    "title": "unique_ptr",
    "keywords": "",
    "url": "/pages/c/pointer/unique_ptr/",
    "body": "unique_ptr儲存在stack中記憶體，當unique_ptr離開有效的範圍(例如:離開main函式)，就會啟動unique_ptr的解構子，解構子會去刪除unique_ptr指向的指標，就可以防止new出來的物件，但沒delete它，記憶體沒被釋放的問題。 unique_ptr只指向一個指標，沒有辦法指向多個指標。 建立 要include memory #include &lt;memory&gt; 以下建立方式有註解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class Student { public: string name_; Student() { cout &lt;&lt; \"Student 建構子\" &lt;&lt; endl; } Student(const string&amp; name) : name_(name){ cout &lt;&lt; \"Student一個參數 建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"Student 解構子\" &lt;&lt; endl; } }; int main() { // 方式一:使用指標作為unique_ptr建構子參數 Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 方式二:使用匿名物件作為unique_ptr建構子參數 unique_ptr&lt;Student&gt; ptr2(new Student); // 方式二:使用make_unique c++14含以上才能用 unique_ptr&lt;Student&gt; ptr3 = make_unique&lt;Student&gt;(); // 方式二:使用make_unique一個參數的使用方法 unique_ptr&lt;Student&gt; ptr4 = make_unique&lt;Student&gt;(\"Alice\"); return 0; } Student一個參數 建構子 Student 建構子 Student 建構子 Student一個參數 建構子 Student 解構子 Student 解構子 Student 解構子 Student 解構子 不支援assign=運算子與拷貝函式 以下會編譯失敗 1 2 3 4 5 6 7 8 9 10 11 int main() { Student* s = new Student(\"Mary\"); // 以下會編譯失敗，unique_ptr不支援拷貝函式 unique_ptr&lt;Student&gt; ptr3 = s; unique_ptr&lt;Student&gt; ptr4 = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr5 = ptr3; // 以下會編譯失敗，unique_ptr不支援assign運算子= unique_ptr&lt;Student&gt; ptr6; ptr6 = ptr3; return 0; } 取值運算子 1 2 3 4 5 6 7 8 int main() { Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 使用*取值運算子 cout &lt;&lt; \"*s.name = \" &lt;&lt; (*s).name_ &lt;&lt; endl; cout &lt;&lt; \"*ptr1.name = \" &lt;&lt; (*ptr1).name_ &lt;&lt; endl; return 0; } Student一個參數 建構子 *s.name = Mary *ptr1.name = Mary Student 解構子 箭頭運算子 1 2 3 4 5 6 7 8 int main() { Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 使用-&gt;箭頭 cout &lt;&lt; \"s-&gt;name = \" &lt;&lt; s-&gt;name_ &lt;&lt; endl; cout &lt;&lt; \"ptr1-&gt;name = \" &lt;&lt; ptr1-&gt;name_ &lt;&lt; endl; return 0; } Student一個參數 建構子 s-&gt;name = Mary ptr1-&gt;name = Mary Student 解構子 記憶體位址 get()函式可以取得物件記憶體位址。 1 2 3 4 5 6 7 8 9 10 int main() { Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 記憶體位址 cout &lt;&lt; \"s的位址 = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"ptr1 = \" &lt;&lt; ptr1 &lt;&lt; endl; cout &lt;&lt; \"get() = \" &lt;&lt; ptr1.get() &lt;&lt; endl; cout &lt;&lt; \"ptr1的位址 = \" &lt;&lt; &amp;ptr1 &lt;&lt; endl; return 0; } Student一個參數 建構子 s的位址 = 0x60000020c720 ptr1 = 0x60000020c720 get() = 0x60000020c720 ptr1的位址 = 0x7ff7bfeff2b0 Student 解構子 函式 函式參數只能參考，不能值(因為unique_ptr不支援assign=與拷貝函式) 1 2 3 4 5 6 7 8 9 10 void func(unique_ptr&lt;Student&gt; &amp;ptr) { cout &lt;&lt; \"func name = \" &lt;&lt; ptr-&gt;name_ &lt;&lt; endl; } int main() { Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 函式參數，只能傳參考，不能傳值(因為unique_ptr不支援assign=與拷貝函式) func(ptr1); return 0; } Student一個參數 建構子 func name = Mary Student 解構子 一個unique_ptr指向一個指標 1 2 3 4 5 6 7 8 int main() { Student* s = new Student(\"Mary\"); // 不能使用多個unique_ptr指向同一個物件，因為多個unique_ptr對同一個記憶體位址釋放多次 // unique_ptr&lt;Student&gt; ptr5(s); // unique_ptr&lt;Student&gt; ptr6(s); // unique_ptr&lt;Student&gt; ptr7(s); return 0; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class Student { public: string name_; Student() { cout &lt;&lt; \"Student 建構子\" &lt;&lt; endl; } Student(const string&amp; name) : name_(name){ cout &lt;&lt; \"Student一個參數 建構子\" &lt;&lt; endl; } ~Student() { cout &lt;&lt; \"Student 解構子\" &lt;&lt; endl; } }; void func(unique_ptr&lt;Student&gt; &amp;ptr) { cout &lt;&lt; \"func name = \" &lt;&lt; ptr-&gt;name_ &lt;&lt; endl; } int main() { // 方式一:使用指標作為unique_ptr建構子參數 Student* s = new Student(\"Mary\"); unique_ptr&lt;Student&gt; ptr1(s); // 使用*取值運算子 cout &lt;&lt; \"*s.name = \" &lt;&lt; (*s).name_ &lt;&lt; endl; cout &lt;&lt; \"*ptr1.name = \" &lt;&lt; (*ptr1).name_ &lt;&lt; endl; // 使用-&gt;箭頭 cout &lt;&lt; \"s-&gt;name = \" &lt;&lt; s-&gt;name_ &lt;&lt; endl; cout &lt;&lt; \"ptr1-&gt;name = \" &lt;&lt; ptr1-&gt;name_ &lt;&lt; endl; // 記憶體位址 cout &lt;&lt; \"s的位址 = \" &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; \"ptr1 = \" &lt;&lt; ptr1 &lt;&lt; endl; cout &lt;&lt; \"get() = \" &lt;&lt; ptr1.get() &lt;&lt; endl; cout &lt;&lt; \"ptr1的位址 = \" &lt;&lt; &amp;ptr1 &lt;&lt; endl; // 函式參數，只能傳參考，不能傳值(因為unique_ptr不支援assign=與拷貝函式) func(ptr1); // 方式二:使用匿名物件作為unique_ptr建構子參數 unique_ptr&lt;Student&gt; ptr2(new Student); // 方式二:使用make_unique c++14含以上才能用 unique_ptr&lt;Student&gt; ptr3 = make_unique&lt;Student&gt;(); // 方式二:使用make_unique一個參數的使用方法 unique_ptr&lt;Student&gt; ptr4 = make_unique&lt;Student&gt;(\"Alice\"); // 以下會編譯失敗，unique_ptr不支援拷貝函式 // unique_ptr&lt;Student&gt; ptr4 = s; // unique_ptr&lt;Student&gt; ptr4 = new Student(\"Mary\"); // unique_ptr&lt;Student&gt; ptr4 = ptr3; // 以下會編譯失敗，unique_ptr不支援assign運算子= // unique_ptr&lt;Student&gt; ptr4; // ptr4 = ptr3; // 不能使用多個unique_ptr指向同一個物件，因為多個unique_ptr對同一個記憶體位址釋放多次 // unique_ptr&lt;Student&gt; ptr5(s); // unique_ptr&lt;Student&gt; ptr6(s); // unique_ptr&lt;Student&gt; ptr7(s); return 0; }"
  },"/pages/android/android_studio/": {
    "title": "Android studio",
    "keywords": "",
    "url": "/pages/android/android_studio/",
    "body": "縮排2 space 自動格式排版 cmd + alt + L 使用cmd+滑鼠滾輪 適用MAC，windows是ctrl+滑鼠滾輪 程式碼文字大小 操作介面文字大小"
  },"/pages/note/english/": {
    "title": "English",
    "keywords": "",
    "url": "/pages/note/english/",
    "body": "2025-03-19 原本 Recently, I have been thinking about the meaning of travaling. “Is the greatest building more importance?” or “Is Less Payment of travaling and envirment of travling much more importance?” After I come back from Janpen, I found Japen is very suitable for traveler. The payment in Japen is not very high, also the transport fee is cheap, not stealing money, not rober, food is very delicious, even the convenience store also sell delicious food and open 24 hours. 修正後 Recently, I have been thinking about the meaning of traveling. “Is the greatest building more important?” or “Are lower travel costs and a good travel environment much more important?” After I came back from Japan, I found that Japan is very suitable for travelers. The cost of living in Japan is not very high, and the transportation fees are cheap. There is no theft or robbery, the food is very delicious, and even the convenience stores sell tasty food and are open 24 hours. 原本 Today I’m watching TV, and the news reported a boby was abused by nanny, I feel so angry, Why nanny so evil, Why people come to earth for what? The earth is a prison, so evil person come to earth to torture other people. A baby is so small, Why did she do that! I feel so depression. The nanny doesn’t have humanity. The law is not fair to the evil people like this nanny, The punishment of this nanny is low. This nanny won’t be regretful. 修正後 Today, I was watching TV, and the news reported that a baby was abused by a nanny. I felt so angry. Why is the nanny so evil? Why do people come to Earth, and for what purpose? The Earth feels like a prison, where evil people come to torture others. A baby is so small and innocent—why would she do that? I feel so depressed. The nanny has no humanity. The law is not fair to evil people like this nanny. The punishment for this nanny is too light. I doubt this nanny will ever feel remorseful. 2025-03-20 I had bad sleep yesterday. Because I searched many information of renting a car about traveling in Egypt. Becasue a deposit of 150 us dollar on renting car is so much. I have to prepare a lot of us dollar in Egypt. The thief or robber will steal money from me. It’s very dangerous. The highly deposit of renting car is problem. 修正後 I had a bad sleep last night because I spent a lot of time searching for information about renting a car for traveling in Egypt. A deposit of 150 US dollars for renting a car is too high. I have to carry a lot of US dollars in Egypt, which makes me worried about thieves or robbers targeting me. It feels very dangerous. The high deposit for renting a car is a real problem. Many people went to the outside of the court to protest the punishment of abusing child is too light. They demand to modify the low that the person who abuse or tourture child causing die must be die. Many people can’t standar the low which can’t threat evil people do really bad things to others. 修正後 Many people gathered outside the court to protest that the punishment for child abuse is too lenient. They are demanding to amend the law so that anyone who abuses or tortures a child, resulting in death, must be sentenced to death. Many people cannot tolerate a law that fails to deter evil individuals from committing such horrific acts against others. 2025-03-28 Child do something is not meaning and purpose, when they feel happy and than they draw a picture, when they want to make a story and then they write a novel. They do those things just for fun. Making a comic book is for hobby. The inital purpose is not for business. But child grow up become a adult, they do anyting will concern the benifit and how much time will be cost. Because they grow up, they have a family , they have to earn more money to raise their children, they need food and a place to live which is not free, they have to consider what kind of job can earn more money. The job career is important for the whole life. 修正後的版本： When children do something, it is without specific meaning or purpose. They draw pictures when they feel happy, and they write stories when they want to create something. They do these things purely for fun. Making a comic book is just a hobby, and the initial purpose is not for business. However, when children grow up and become adults, they start considering the benefits and the time cost of everything they do. As adults, they have families to support and need to earn money to raise their children. Food and shelter are not free, so they must think about which jobs can provide a stable income. Career choices become crucial because they impact their entire lives."
  },"/pages/ffmpeg/compile_ffmpeg_android/": {
    "title": "FFmpeg on Android",
    "keywords": "",
    "url": "/pages/ffmpeg/compile_ffmpeg_android/",
    "body": "Prerequisites: 查詢模擬器CPU架構 編譯ffmpeg 下載ffmpeg source code Download source code 下載完後解壓，進入解壓後的目錄 下載ndk 歷經千辛萬苦，終於ndk build ffmpeg成功， 以下為編譯後的重要記事作為記錄。 MAC下載ndk後，請選xxxxxxxx.app，然後滑鼠”右鍵” &gt; “顯示套件內容” &gt; “Contents” &gt; “NDK” 把NDK目錄複製到家目錄下(或任何你能記住的地方) 建立build_android.sh檔案並修改權限 建立build_android.sh在ffmpeg目錄下 修改權限，增加執行功能 chmod 777 build_android.sh 或 chmod +x build_android.sh 交叉編譯過程 在ffmpeg目錄下執行以下指令 終端機執行./build_android.sh 會自動去執行./configure，後面有設置許多編譯時需要用到的參數。 會自動產生makefile檔案 build_android.sh自動執行make install指令 至OUTPUT參數的路徑查看是否有產生動態庫.so或靜態庫.a make V=1 V=1查看詳細的編譯過程 make -j4 V=1 make clean 清理 make install 執行makefile，並把產生出來的動態庫與靜態庫放在設置OUTPUT參數的目錄下 編譯參數介紹 LLVM 出現一些編譯問題，首先cross-prefix要使用llvm，因為NDK r28已經移除aarch64-linux-android-strip 統一使用 LLVM 提供的 llvm-strip，所以cross-prefix一律由llvm來處理bin相關執行檔。 1 --cross-prefix=$TOOLCHAIN/bin/llvm- \\ SYSROOT 表頭檔(include目錄)與lib目錄的放置路徑 1 --sysroot=$SYSROOT \\ cflags 轉給gcc編譯器的參數，參數--sysroot=，告訴編譯器去那個路徑尋找head file與lib extra-cflags一律簡化成只有sysroot參數 1 --extra-cflags=\"--sysroot=$SYSROOT\" \\ build.ninja build.ninja是AndroidStudio交叉編譯工具 若不知道cflag(給c++編譯器的參數)怎麼寫，可以打開Android studio，參考下圖的路徑，找到你要編譯出來的andorid作業系統，找到build.ninja，參考flags參數 -D 意思為Android Stuido交叉編譯器，所設置的前置指令，c++的前置指令是define arch與cpu arch arm (32 位) arm64 x86 (32 位) x86_64 (64 位) cpu armv7-a armv8-a i686 x86-64 位数 32 位 64 位 32 位 64 位 性能 较低 较高 中等 高 功耗 低 较低 较高 高 兼容性 仅支持 32 位应用 兼容 32 位应用 仅支持 32 位应用 兼容 32 位应用 常见设备 旧 Android 设备 现代 Android 设备 部分平板/模拟器 高性能平板/模拟器 ABI armeabi-v7a arm64-v8a x86 x86_64 FFmpeg TARGET armv7a-linux-androideabi aarch64-linux-android i686-linux-android x86_64-linux-android arm ARCH=arm CPU=armv7-a TARGET=armv7a-linux-androideabi arm64 ARCH=arm64 CPU=armv8-a TARGET=aarch64-linux-android x86 ARCH=x86 CPU=i686 TARGET=i686-linux-android x86_64 ARCH=x86_64 CPU=x86-64 TARGET=x86_64-linux-android nm nm由LLVM處理，因為NDK r28已經移除aarch64-linux-android-nm 1 --nm=$TOOLCHAIN/bin/llvm-nm \\ config.log 檢查ffmpeg目錄下的ffbuild/config.log文件，使用error或failed等關鍵字搜尋錯誤訊息 grep \"error\" ffbuild/config.log BIN_PREFIX BIN_PREFIX最後面沒有任何- BIN_PREFIX=$TOOLCHAIN/bin/$TARGET$API_LEVEL 增加PATH,CC,CXX export PATH=$PATH:/Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/bin export CC=aarch64-linux-android24-clang export CXX=aarch64-linux-android24-clang++ ./configure configure產生makefile的shell檔案 什麼是makefile？指導gnu make如何編譯的shell檔案 執行make 會產生.so檔或.a檔 若執行./configure沒權限，替./configure增加可執行權限 chmod +x configure configure help文件 ./configure --help 幫助的文件 prefix 產生出來的.so檔或.a檔，放置的資料夾 pwd為放置.configure檔案的所在目錄 ./configure --prefix=`pwd`/android/armeabi-v72 \\ 傳遞--prefix參數給configure \\為換行字元，若沒這個字元，所有參數必須全在同一行，不能換行 可以一行傳多個參數，注意!最後一行沒有\\ ./configure --prefix=`pwd`/android/armeabi-v72 \\ --xxx=abc \\ --xxx=abcd -xxx=abcde \\ --xxx=abcd -xxx=abcde --xx=abcdef 進到已解壓的ffmpeg目錄，執行以下句子 ./configure --help 會發現bindir,datadir,docdi,libdir…，目錄前面都有PREFIX，如:[PREFIX/lib] Standard options: --logfile=FILE log tests and output to FILE [ffbuild/config.log] --disable-logging do not log configure debug information --fatal-warnings fail if any configure warning is generated --prefix=PREFIX install in PREFIX [/usr/local] --bindir=DIR install binaries in DIR [PREFIX/bin] --datadir=DIR install data files in DIR [PREFIX/share/ffmpeg] --docdir=DIR install documentation in DIR [PREFIX/share/doc/ffmpeg] --libdir=DIR install libs in DIR [PREFIX/lib] --shlibdir=DIR install shared libs in DIR [LIBDIR] --incdir=DIR install includes in DIR [PREFIX/include] --mandir=DIR install man page in DIR [PREFIX/share/man] --pkgconfigdir=DIR install pkg-config files in DIR [LIBDIR/pkgconfig] --enable-rpath use rpath to allow installing libraries in paths not part of the dynamic linker search path use rpath when linking programs (USE WITH CARE) --install-name-dir=DIR Darwin directory name for installed targets Configuration options Configuration options: --disable-static do not build static libraries [no] --enable-shared build shared libraries [no] --enable-small optimize for size instead of speed --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary) --enable-gray enable full grayscale support (slower color) --disable-swscale-alpha disable alpha channel support in swscale --disable-all disable building components, libraries and programs --disable-autodetect disable automatically detected external libraries [no] --disable-static 不要產生靜態庫.a，預設是[no]，預設會產生靜態庫.a --enable-shared 產生動態庫.so，預設是[no]，預設不會產生動態庫.so --enable-small 優化lib的大小，使lib容量更小 Program options Program options: --disable-programs do not build command line programs --disable-ffmpeg disable ffmpeg build --disable-ffplay disable ffplay build --disable-ffprobe disable ffprobe build --disable-programs 不要產生ffmpeg,ffplay,ffprobe執行檔 --disable-programs 就相當於執行以下三個 --disable-ffmpeg disable ffmpeg build --disable-ffplay disable ffplay build --disable-ffprobe disable ffprobe build Component options ffmpeg的組成 Component options: --disable-avdevice disable libavdevice build --disable-avcodec disable libavcodec build --disable-avformat disable libavformat build --disable-swresample disable libswresample build --disable-swscale disable libswscale build --disable-postproc disable libpostproc build --disable-avfilter disable libavfilter build --disable-pthreads disable pthreads [autodetect] --disable-w32threads disable Win32 threads [autodetect] --disable-os2threads disable OS/2 threads [autodetect] --disable-network disable network support [no] --disable-dwt disable DWT code --disable-error-resilience disable error resilience code --disable-lsp disable LSP code --disable-faan disable floating point AAN (I)DCT code --disable-iamf disable support for Immersive Audio Model --disable-pixelutils disable pixel utils in libavutil ffmpeg主要由下面的元件所組成: libavformat：用於各種音視頻封裝格式的生成和「解析」，包括獲取解碼所需資訊以產生解碼上下文結構 和讀取音視頻幀等功能； libavcodec ：用於各種類型「聲音/影像」編「解碼」； libavutil ：包含一些公共的「工具函式」； libswscale ：用於視訊場景比例「縮放」、色彩映射轉換； libpostproc ：用於後製效果(浮水印，字幕)處理； ffmpeg ：此專案提供的工具，可用於格式轉換、解碼或電視卡即時編碼等； ffsever ：一個HTTP 多媒體即時廣播串流伺服器； ffplay ：是一個簡單的播放器，使用ffmpeg 函式庫解析和解碼，透過SDL顯示； swresample 聲音重新採樣，音檔可能有雙聲道，若想把雙聲道變單聲道，需要用這個元件。 要disable的有下列元件 (disable就不會產生靜態庫，不會讓apk肥大) avdevice : 操作相機鏡頭(不支持android相機) 可以關閉disable-avdevice postproc : 用於後製效果處理 不能disable的有下列元件 avcodec 影像聲音解碼 avformat 影像聲音封裝格式解碼 avfilter : 影像加上字幕加上浮水印 swscale : 放大縮小 Individual component options: Individual component options: --disable-encoders 關閉編碼，影片播放時不需要編碼 --enable-decoder=NAME 打開解碼，影片播放時需要解碼(預設會打開，不用設定) --disable-muxers 關閉混合封裝 (把圖片與聲音混合在一起)，但是播放時，不需要產生影片，所以關閉。 --disable-filters 需要禁用過濾器，但仍需要產生libavfilter cross-compile cross-compile就是交叉編譯的意思，使用各種不同作業系統的交叉編譯來編譯ffmpeg --enable-cross-compile 打開交叉編譯 --cross-prefix=$TOOLCHAIN/bin/llvm- 設定交叉編譯的工具 所有編譯過程使用的工具gcc或link工具，前綴都是$TOOLCHAIN/bin/llvm- build_android.sh完整檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #!/bin/bash # 設置變數 NDK=/Users/cici/NDK API_LEVEL=30 ARCH=x86_64 # 可選：arm, arm64, x86, x86_64 OUTPUT=`pwd`/android-build/$ARCH/ # 根據架構設置目標三元組和目錄名 case \"$ARCH\" in arm) TARGET=armv7a-linux-androideabi CPU=armv7-a ;; arm64) TARGET=aarch64-linux-android CPU=armv8-a ;; x86) TARGET=i686-linux-android CPU=i686 ;; x86_64) TARGET=x86_64-linux-android CPU=x86-64 ;; *) echo \"錯誤：不支持的架構 '$ARCH'\" exit 1 ;; esac # 工具鏈路徑 TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64 SYSROOT=$TOOLCHAIN/sysroot BIN_PREFIX=$TOOLCHAIN/bin/$TARGET$API_LEVEL # 檢查工具鏈是否存在 if [ ! -d \"$TOOLCHAIN\" ]; then echo \"錯誤：工具鏈路徑 '$TOOLCHAIN' 不存在\" exit 1 fi # 檢查編譯器是否存在 if [ ! -f \"$BIN_PREFIX-clang\" ]; then echo \"錯誤：編譯器 '$BIN_PREFIX-clang' 不存在\" exit 1 fi # 檢查輸出目錄是否存在，如果不存在則創建 if [ ! -d \"$OUTPUT\" ]; then echo \"創建輸出目錄：$OUTPUT\" mkdir -p \"$OUTPUT\" fi # 測試編譯器 echo \"測試編譯器是否能生成可執行文件...\" echo 'int main() { return 0; }' &gt; test.c $BIN_PREFIX-clang test.c -o test if [ $? -ne 0 ]; then echo \"錯誤：編譯器測試失敗\" echo \"請檢查以下內容：\" echo \"1. 編譯器路徑：$BIN_PREFIX-clang\" echo \"2. sysroot 路徑：$SYSROOT\" echo \"3. 環境變數：CC=$CC, CXX=$CXX, PATH=$PATH\" exit 1 else echo \"編譯器測試成功\" rm test.c test fi echo $OUTPUT # 配置 FFmpeg echo \"開始配置 FFmpeg...\" ./configure \\ --nm=$TOOLCHAIN/bin/llvm-nm \\ --libdir=${OUTPUT}/libs/$ARCH \\ --incdir=${OUTPUT}/includes/$ARCH \\ --pkgconfigdir=${OUTPUT}/pkgconfig/$ARCH \\ --target-os=android \\ --arch=$ARCH \\ --cpu=$CPU \\ --sysroot=$SYSROOT \\ --cross-prefix=$TOOLCHAIN/bin/llvm- \\ --cc=$BIN_PREFIX-clang \\ --cxx=$BIN_PREFIX-clang++ \\ --extra-cflags=\"--sysroot=$SYSROOT\" \\ --extra-ldexeflags=\"--sysroot=$SYSROOT\" \\ --disable-doc \\ --disable-programs \\ --disable-avdevice \\ --disable-postproc \\ --disable-encoders \\ --disable-muxers \\ --disable-filters \\ --enable-cross-compile \\ --enable-small \\ --disable-static \\ --enable-shared \\ --prefix=$OUTPUT # 檢查配置是否成功 if [ $? -ne 0 ]; then echo \"錯誤：FFmpeg 配置失敗\" exit 1 fi # 編譯並安裝 echo \"開始編譯 FFmpeg...\" make clean make -j4 V=1 # 檢查編譯是否成功 if [ $? -ne 0 ]; then echo \"錯誤：FFmpeg 編譯失敗\" exit 1 fi echo \"開始安裝 FFmpeg...\" sudo make install # 檢查安裝是否成功 if [ $? -ne 0 ]; then echo \"錯誤：FFmpeg 安裝失敗\" exit 1 fi echo \"FFmpeg 編譯和安裝完成！\""
  },"/pages/jekyll/old/change_ruby_path/": {
    "title": "如何更改舊ruby路徑",
    "keywords": "",
    "url": "/pages/jekyll/old/change_ruby_path/",
    "body": "參考此篇 https://stackoverflow.com/questions/51126403/you-dont-have-write-permissions-for-the-library-ruby-gems-2-3-0-directory-ma echo 'eval \"$(rbenv init -)\"' &gt;&gt; ~/.zshrc source ~/.zshrc 這一步最重要官網沒提到 檢查一下ruby在那 以下是錯誤的位置 以下是正確的位置"
  },"/pages/jekyll/old/install_jekyll/": {
    "title": "安裝Gem jekyll",
    "keywords": "",
    "url": "/pages/jekyll/old/install_jekyll/",
    "body": "gem install jekyll 不能出現 ERROR: While executing gem … (Gem::FilePermissionError) You don’t have write permissions 千萬不能輸入sudo sudo gem install jekyll 錯誤畫面 若出現以上畫面，代表ruby是舊的 可以輸入which ruby跟ruby -v來檢查 舊的ruby如下 請參考如何更改舊ruby路徑的文章 確認ruby的版本都正確 確認版本的指令如下(參考下圖) ruby -v which ruby 然後執行gem install jekyll 回到user目錄 輸入 jekyll new myblog cd myblog 若按照官網的作法輸入 jekyll serve 會產生以下的錯誤 /Users/cici/.rbenv/versions/3.2.2/lib/ruby/3.2.0/bundler/resolver.rb:290:in `raise_not_found!': Could not find gem 'minima (~&gt; 2.5)' in locally installed gems. (Bundler::GemNotFound) 參考此篇 https://stackoverflow.com/questions/39384024/jekyll-cannot-find-gem-after-bundle-install 進入myblog 輸入bundle install 再輸入bundle exec jekyll serve 再瀏覽器輸入 http://localhost:4000/"
  },"/pages/jekyll/old/install_ruby/": {
    "title": "安裝Ruby",
    "keywords": "",
    "url": "/pages/jekyll/old/install_ruby/",
    "body": "使用rbenv https://github.com/rbenv/rbenv 建議安裝rbenv 因為參考Jekyll官網的安裝方法會出現許多問題 ERROR: Error installing jekyll: ERROR: Failed to build gem native extension. 或 ERROR: While executing gem … (Gem::CommandLineError) Unknown command jekyll 或 ERROR: While executing gem … (Gem::FilePermissionError) You don’t have write permissions for the /Library/Ruby/Gems/2.6.0 directory. 參考以下文章 https://www.rubyonmac.dev/error-installing-jekyll-failed-to-build-gem-native-extension 安裝方法，參考 https://github.com/rbenv/rbenv 輸入 brew install rbenv ruby-build sudo apt install rbenv rbenv init 選擇要安裝的版本 rbenv install -l 安裝3.2.2 rbenv install 3.2.2 rbenv global 3.2.2 rbenv local 3.2.2 gem install bundler gem env home echo ‘eval “$(rbenv init -)”’ » ~/.zshrc source ~/.zshrc 這一步最重要官網沒提到 參考如何更改舊ruby路徑"
  },"/pages/note/mac/apfs/": {
    "title": "APFS",
    "keywords": "",
    "url": "/pages/note/mac/apfs/",
    "body": "到磁碟管理工具，先選清除 再到卷宗按”-“移掉 然後再回到磁碟管理工具，再選清除，換成其它格式 在「清除」對話框中，按一下「架構」彈出式選單，然後選擇分割區架構。 按一下「格式」彈出式選單，然後選擇下列其中一項操作： ExFAT：如果磁碟大小超過 32 GB，請選擇此格式。 當你在 Mac上的「磁碟工具程式」中清除和格式化儲存裝置時，系統會要求你選擇要使用的架構。「磁碟工具程式」支援以下架構： GUID 分割區配置表：為所有 Intel 架構式和 Apple 晶片的 Mac 電腦選擇此選項。部分較新型的 Microsoft Windows 電腦也可使用此架構。 參考文章 https://support.apple.com/zh-tw/guide/disk-utility/dskutl1010/mac https://support.apple.com/zh-tw/guide/disk-utility/dsku1c614201/22.0/mac/13.0"
  },"/pages/note/mac/mac_monitor/": {
    "title": "外接螢幕配置主副",
    "keywords": "",
    "url": "/pages/note/mac/mac_monitor/",
    "body": "白色框框的部分，就是配置誰是主(桌面在主)，誰是副 滑鼠移動到其它方位。若外接營幕在右邊，就把外接的放在右邊，若外接在左邊，就把外接的放在左邊。"
  },"/pages/note/mac/mac_time/": {
    "title": "mac時光機",
    "keywords": "",
    "url": "/pages/note/mac/mac_time/",
    "body": "蘋果&gt;系統偏好設定 選擇時光機"
  },"/pages/note/mac/mac_usage/": {
    "title": "mac使用方式",
    "keywords": "",
    "url": "/pages/note/mac/mac_usage/",
    "body": "使用标签页功能 打开新标签页：在Finder窗口中，按下 Command + T 或点击菜单栏的“文件” &gt; “新建标签页”。 拖放窗口合并：如果你已经打开了多个Finder窗口，可以将一个窗口的标签页拖到另一个窗口的标签栏上，这样它们就会合并为一个窗口中的多个标签页。 设置Finder默认以标签页打开 打开Finder设置：点击菜单栏的“Finder” &gt; “设置”。 选择“在标签页中打开文件夹”：在“通用”标签中，将“首选以标签页方式打开文件夹”选项勾选。这样，新打开的文件夹会以标签页形式显示在当前窗口中，而不是新窗口。 使用快捷键 合并窗口：如果你有多个Finder窗口，可以按下 Command + Option + W 关闭所有窗口，然后重新打开一个Finder窗口并使用标签页功能。"
  },"/pages/ffmpeg/import_ffmpeg_android/": {
    "title": "import ffmpeg in Android",
    "keywords": "",
    "url": "/pages/ffmpeg/import_ffmpeg_android/",
    "body": "我的模擬器是x86_64，所以以下我都用x86_64的ABI作為示範。 編譯完應該有以下目錄，includes包含以下目錄，裡面都是head files。 . ├── includes │   └── x86_64 │   ├── libavcodec │   ├── libavfilter │   ├── libavformat │   ├── libavutil │   ├── libswresample │   └── libswscale ├── libs │   └── x86_64 ├── pkgconfig │   └── x86_64 └── share └── ffmpeg └── examples libs目錄包含以下靜態庫。 . └── x86_64 ├── libavcodec.a ├── libavfilter.a ├── libavformat.a ├── libavutil.a ├── libswresample.a └── libswscale.a 建立一個新的native c的project，目錄結構如下圖 新建include目錄，把ffmpeg編譯好的include/x86_64下的目錄全拷貝過來 你的android專案位置/app/src/main/cpp/include 新建libs目錄，把ffmpeg編譯好的libs目錄下，把x86_64拷貝到以下路徑。 你的android專案位置/app/src/main/cpp/libs app下的build.gradle 增加你要編譯的ABI，本範例為x86_64 android { ... defaultConfig { ... ndk{ abiFilters 'x86_64' } ... } ... } CMakeLists.txt cmake_minimum_required(VERSION 3.22.1) project(\"myapplication\") add_library(${CMAKE_PROJECT_NAME} SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp) #匯入head file目錄 include_directories(${CMAKE_SOURCE_DIR}/include) #給c++編譯器設定libs的目錄 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/libs/${ANDROID_ABI}\" ) target_link_libraries(${CMAKE_PROJECT_NAME} android # 要用到的lib，libavcodec去掉lib後面的avcodec就是要用lib avcodec avfilter avformat avutil swresample swscale log) 測試lib是否能include，可以用av_version_info()函式 native-lib.cpp 1 2 3 4 5 6 7 8 9 10 11 //因為ffmpeg是由c開發，所以要包在extern c{}之間 extern \"C\"{ #include &lt;libavcodec/avcodec.h&gt; } extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(av_version_info()); }"
  },"/pages/ffmpeg/vlc/": {
    "title": "vlc",
    "keywords": "",
    "url": "/pages/ffmpeg/vlc/",
    "body": "killall VLC # 删除 VLC 配置和缓存 rm -rf ~/Library/Preferences/org.videolan.vlc rm -rf ~/Library/Application\\ Support/org.videolan.vlc 啟動vlc /Applications/VLC.app/Contents/MacOS/VLC -vvv \"/Users/cici/Downloads/test_video.mp4\" \\ --sout '#rtp{sdp=rtsp://:8555/test.sdp,mux=ts}' \\ --no-sout-audio --input-repeat=999999 \\ 試圖增加這串指令，但會讓ffplay無法連上 在vlc的playlist中要播放，以下才有效 測試vlc ffplay rtsp://localhost:8555/test.sdp 192.168.8.103 port8554跟android虛擬機有關，因為會發現vlc日誌一直讀取android studio的內容，建議換其它的port 日誌一直讀取'/Users/cici/./AndroidStudioProjects/MyApplication2/app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar' [00007fc01200bf80] main stream debug: using stream_filter module \"record\" [00007fc0117265d0] main input source debug: creating demux: access='file' demux='any' location='/Users/cici/./AndroidStudioProjects/MyApplication2/app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar' file='/Users/cici/./AndroidStudioProjects/MyApplication2/app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar' [00007fc01200c140] main demux debug: looking for demux module matching \"any\": 55 candidates [00007fc01210c540] main xml reader debug: looking for xml reader module matching \"any\": 1 candidates [00007fc01210c540] main xml reader debug: using xml reader module \"xml\" 192.168.8.114:5004/test"
  },"/pages/android/android_note/": {
    "title": "Android note",
    "keywords": "",
    "url": "/pages/android/android_note/",
    "body": "取得TAG MainActivity.class.getSimpleName() alt+F7 Find usage shit二次尋找 網路測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private class NetworkTestTask extends AsyncTask&lt;Void, Void, Boolean&gt; { @Override protected Boolean doInBackground(Void... voids) { try (Socket socket = new Socket(\"localhost\", 8555)) { Log.d(\"NETWORK\", \"模拟器网络正常\"); return true; } catch (IOException e) { Log.e(\"NETWORK\", \"模拟器无法访问RTSP端口: \" + e.getMessage()); return false; } } @Override protected void onPostExecute(Boolean success) { if (success) { Toast.makeText(MainActivity.this, \"网络测试通过\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(MainActivity.this, \"网络测试失败\", Toast.LENGTH_SHORT).show(); } } } // 在 onCreate() 中调用 new NetworkTestTask().execute(); 1 2 3 4 5 6 7 8 9 new Thread(() -&gt; { try (Socket socket = new Socket(\"localhost\", 8555)) { Log.d(\"NETWORK\", \"模拟器网络正常\"); runOnUiThread(() -&gt; Toast.makeText(MainActivity.this, \"网络正常\", Toast.LENGTH_SHORT).show()); } catch (IOException e) { Log.e(\"NETWORK\", \"模拟器无法访问RTSP端口: \" + e.getMessage()); runOnUiThread(() -&gt; Toast.makeText(MainActivity.this, \"网络失败: \" + e.getMessage(), Toast.LENGTH_SHORT).show()); } }).start(); // 1. 添加依赖（build.gradle） implementation “org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4” // 2. 在 Activity 中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 lifecycleScope.launch(Dispatchers.IO) { try { Socket(\"localhost\", 8555).use { socket -&gt; withContext(Dispatchers.Main) { Toast.makeText(this@MainActivity, \"网络正常\", Toast.LENGTH_SHORT).show() } } } catch (e: IOException) { withContext(Dispatchers.Main) { Toast.makeText(this@MainActivity, \"网络失败: ${e.message}\", Toast.LENGTH_SHORT).show() } } } 與 Native (C/C++) 互動時 在 NDK 開發中，當 C/C++ 需要通知 Java 層更新 UI，通常會透過 JNI 呼叫 Java 方法，而 Handler 可以幫助你在 UI Thread 上執行更新。 Looper 和 MessageQueue 的運作機制 如果你的應用程式中有 長時間運行的 Thread，例如 自訂的背景執行緒，你可能需要讓該執行緒擁有自己的 Looper 來處理訊息，這時候 Handler 就很有用。 HandlerThread 如果你想要在單獨的背景執行緒處理特定的工作，但不想要每次都創建新執行緒，HandlerThread 是很好的選擇。這在影像處理、音訊處理或某些與 NDK 相關的計算 時可能會派上用場。 不過，如果你的目標是寫現代化的 Android 應用程式，而不是處理 NDK 或特殊場景，那麼建議你 優先學習 Kotlin Coroutines，因為它的可讀性更高，而且能更簡潔地處理異步操作。 runOnUiThread() 與 new Handler().post() 的區別 這兩種方法都是在 Android 中將代碼切換到主線程(UI 線程)執行的方法，但它們有一些重要區別： 主要區別 所屬類別不同 runOnUiThread() 是 Activity 類的方法 new Handler().post() 是 Handler 類的方法 當前線程檢查 runOnUiThread() 會先檢查當前是否已在 UI 線程，如果是則直接執行，否則通過 Handler 發送到 UI 線程 new Handler().post() 總是將 Runnable 發送到消息隊列，即使當前已在 UI 線程 使用場景 runOnUiThread() 通常在 Activity 或 Fragment 中使用更方便 new Handler().post() 可以在任何有 Context 的地方使用 性能考量 如果已經在 UI 線程，runOnUiThread() 會直接執行而不通過消息隊列，效率更高 new Handler().post() 總是通過消息隊列，即使已在 UI 線程 示例代碼 java 复制 // runOnUiThread() 用法 runOnUiThread(new Runnable() { @Override public void run() { // 更新 UI } }); // Handler.post() 用法 new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { // 更新 UI } }); 選擇建議 在 Activity 或 Fragment 中優先使用 runOnUiThread()，因為更簡潔且可能更高效 在非 Activity 類中或需要更精確控制時使用 Handler.post() 如果代碼可能在 UI 線程或非 UI 線程運行，runOnUiThread() 是更好的選擇"
  },"/pages/android/kapt_err/": {
    "title": "kaptGenerateStubsDebugKotlin task (current target is 17) jvm target",
    "keywords": "",
    "url": "/pages/android/kapt_err/",
    "body": "kaptGenerateStubsDebugKotlin task (current target is 17) jvm target 'compileDebugJavaWithJavac' task (current target is 1.8) and 'kaptGenerateStubsDebugKotlin' task (current target is 17) jvm target 參考網址 https://stackoverflow.com/questions/75650195/build-error-kspdebugkotlin-task-current-target-is-17/75916224#75916224 要填上以下的紅色字在 plugins { id 'com.android.application' id 'org.jetbrains.kotlin.android' id 'kotlin-android' id 'kotlin-kapt' } dependencies { //dagger var dagger_version = \"2.46.1\" implementation \"com.google.dagger:dagger:$dagger_version\" kapt \"com.google.dagger:dagger-compiler:$dagger_version\" } 把以下這堆全放置在build.gradle(Project:My_Application) allprojects { tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach { kotlinOptions { jvmTarget = \"1.8\" } } }"
  },"/pages/compose/text/": {
    "title": "Compose Text",
    "keywords": "",
    "url": "/pages/compose/text/",
    "body": "先建立package叫Components. 再建立Kotlin File名字TextSample 建立Text 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.example.myapplication.components import androidx.compose.material3.Text import androidx.compose.runtime.Composable import androidx.compose.ui.graphics.Color import androidx.compose.ui.res.stringResource import androidx.compose.ui.text.TextStyle import androidx.compose.ui.text.font.FontFamily import androidx.compose.ui.text.font.FontStyle import androidx.compose.ui.text.font.FontWeight import androidx.compose.ui.text.style.TextAlign import androidx.compose.ui.text.style.TextDecoration import androidx.compose.ui.text.style.TextOverflow import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.ExperimentalUnitApi import androidx.compose.ui.unit.TextUnit import androidx.compose.ui.unit.TextUnitType import androidx.compose.ui.unit.sp import com.example.myapplication.R @OptIn(ExperimentalUnitApi::class) @Composable fun TextSample() { Text( text = stringResource(id = R.string.testData), color = Color(255, 255, 255), //fontSize = TextUnit(16f, TextUnitType.Sp) fontSize = 16.sp, fontStyle = FontStyle.Italic,//斜體 fontWeight = FontWeight.Bold,//粗體 fontFamily = FontFamily.SansSerif,//字型 letterSpacing = 10.sp,//字之間的距離 //底線跟中線 textDecoration = TextDecoration.combine( listOf( TextDecoration.LineThrough, TextDecoration.Underline ) ), //文字居右 textAlign = TextAlign.Center, //行高 lineHeight = 30.sp, maxLines = 1,//最大行數 //超出就... overflow = TextOverflow.Ellipsis, style = TextStyle() ) } @Preview(widthDp = 100) @Composable fun TextSamplePreview() { TextSample() } 建立click以及sytle跟push annotation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.example.myapplication.components import android.util.Log import androidx.compose.foundation.text.ClickableText import androidx.compose.runtime.Composable import androidx.compose.ui.graphics.Color import androidx.compose.ui.text.SpanStyle import androidx.compose.ui.text.TextStyle import androidx.compose.ui.text.buildAnnotatedString import androidx.compose.ui.text.style.TextDecoration import androidx.compose.ui.text.withStyle import androidx.compose.ui.tooling.preview.Preview import androidx.compose.ui.unit.ExperimentalUnitApi import androidx.compose.ui.unit.sp @OptIn(ExperimentalUnitApi::class) @Composable fun TextSample2() { val annotationStr = buildAnnotatedString { append(\"text text\") pushStringAnnotation(\"tag1\", \"http://xxxx.xxxx/xx\") withStyle( style = SpanStyle( color = Color.Red, textDecoration = TextDecoration.Underline, fontSize = 16.sp ) ) { append(\"tag1\") } pop() append(\"ggg\") pushStringAnnotation(\"tag2\", \"http://123.xxxx/123\") withStyle( style = SpanStyle( color = Color.Red, textDecoration = TextDecoration.Underline, fontSize = 16.sp ) ) { append(\"tag2\") } pop() } ClickableText(text = annotationStr, onClick = { offset -&gt; annotationStr.getStringAnnotations(\"tag1\", start = offset, end = offset).firstOrNull() ?.let { annotation -&gt; Log.d(\"///aaaa\", \"test${annotation.item}\") } annotationStr.getStringAnnotations(\"tag2\", start = offset, end = offset).firstOrNull() ?.let { annotation -&gt; Log.d(\"///aaaa\", \"test${annotation.item}\") } }) } @Preview @Composable fun TextSample2Preview() { TextSample2() }"
  },"/pages/android/android_thread/": {
    "title": "Main Thread",
    "keywords": "",
    "url": "/pages/android/android_thread/",
    "body": "Prerequisites: thread Main Thread, UI Thread 在Android中，關於使用者介面UI的操作都要放在主要執行緒(UI thread或Main thread)，其它耗時的操作(耗時的運算,IO,網路連線,資料庫存取…等等)則放在背景執行緒(Background Thread)，所謂的背景執行緒(Background Thread)也就是主流程(UI thread)之外的其它流程，一個程序只有一個主要執行緒(UI thread或Main thread)，但有很多個背景執行緒(Background Thread)。 舉例來說，在主要執行緒(UI thread)發出網路連線請求，應用程式的UI就會被凍結，凍結超過5秒，就會顯示應用程式無回應 (ANR) 對話方塊，所以要把網路連線請求放在背景執行緒(background Thread)，由背景執行緒(background Thread)處理長時間執行的網路連線流程，主要執行緒(UI thread)繼續處理UI更新。 Main Thread有那些? Android生命周期 onCreate(),onStart,onResume()…等等。 事件 onClick(),onItemClick()…等等，on開頭的方法都是Main Thread。 UI 例:TextView.setText()，跟UI有關的都是Main Thread。 UI的同步與非同步 同步 等待上一個動作完成，才可以處理下一個動作。 需要等待傳回結果，例如金流處理，付款等相關流程，需要有一個進度bar讓ui暫時凍結。 非同步 不用等待上一個動作完成，可以同時做多個動作。 不需要等待傳回結果，例如批次下載圖片，可以先用暫時的圖片取代還未下載完成的圖片，不需要把ui凍結。使用者仍可進行其它ui操作。 lance"
  },"/pages/java/thread/": {
    "title": "Thread",
    "keywords": "",
    "url": "/pages/java/thread/",
    "body": "Prerequisites: 匿名內部類別 介面 名詞介紹 程式(Program)透過javac編譯後，產生了.class檔，.class檔又稱為位元碼。 javac 類別.java 把.class位元碼載入到記憶體，程式執行的過程，稱之為程序(Process)。 java 類別 可以執行多次java 類別指令，產生很多程序。 操作系統(OS)可以管理多個程序(Process)，可以讓多個程序(Process)輪流使用CPU資源。 Jvm視為虛擬的操作系統，管理多個程序中的多個執行緒。 每一個執行緒(Thread)都是一個流程。 每個程序(Process)都有一個主要執行緒(Main Thread)，也稱作主要流程，是程式的入口。 想「同時執行」很多流程，每一個流程都是一個執行緒，下圖中，main主要執行緒啟動了2個執行緒，其中一個執行緒，又再啟動2個執行緒，大家來「同時」執行。 Concurrent併發 一個CPU執行多個執行緒，Jvm有一個排程管理系統，會十分快速的將一個流程(執行緒)切換到另一個流程(執行緒)，快速的切換讓使用者以為是同時執行這些流程(執行緒)，實際上是十分快速的輪流執行(執行緒)。 Parallel 多個CPU執行多個執行緒，平行執行任務。 但執行緒若有100個，不可能有100個CPU彼此對映，大部分的時候都是Concurrent + Parallel互相搭配，1核心就是1個CPU，8核心就是8個CPU，可能8個CPU分配處理100個執行緒，每一個CPU快速切換在各個不同執行序之間。 Runnable 介面 要實作Runnable，並且覆寫run方法，類別才能變成執行緒。 1 2 3 public interface Runnable { void run(); } Thread原始碼 Thread實作Runnable介面，並且覆寫run()方法。 實作Runnable介面的類別，才可以放進Thread(Runnable task)建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Thread implements Runnable { // 無參數建構子 public Thread() { this(null, null, 0, null, 0, null); } // 參數是有實作Runnable的類別 public Thread(Runnable task) { this(null, null, 0, task, 0, null); } // 覆寫run方法 public void run() { Runnable task = holder.task; if (task != null) { Object bindings = scopedValueBindings(); runWith(bindings, task); } } // 啟動執行緒 public void start() { synchronized (this) { // zero status corresponds to state \"NEW\". if (holder.threadStatus != 0) throw new IllegalThreadStateException(); // 呼叫Native C++的執行緒方法 start0(); } } // Native C++的執行緒方法，start0會呼叫run()方法 private native void start0(); } Thread.start() 啟動執行緒。 Thread.run() 不是啟動執行緒，run()是給native c++的start0()呼叫。 使用run()方法，就等同於main呼叫方法，並不是啟動執行緒。 Thread.sleep() 讓執行緒暫時休息。 參數是毫秒，1秒是1000毫秒，0.5秒是500毫秒，0.1秒是100毫秒，0.01秒是10毫秒，0.001秒是1毫秒，請自行換算。 使用時會有Exception，要強制處理Exception。 1 2 3 4 5 try { Thread.sleep(1000); // 休息1秒 } catch (InterruptedException e) { // 要處理異常 } 阻斷與同步 阻斷的英文是Blocked 同步的英文是synchronous 下面的程式碼，在main()方法中呼叫func1()，func1()執行完，再回到main()方法，執行呼叫func1()的下一行。 main()在呼叫func1()的時候，是被卡住(Block)，必須等到func1()執行完，才能繼續執行，這個卡住的過程，稱為阻斷。 同步(synchronous)就是等待上一個動作完成，才可以處理下一個動作，在這裡的例子是main()必須等待func1()執行完，才能執行呼叫func1()的下一行。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test2 { public static void main(String[] args) { // 呼叫func1() func1(); System.out.println(\"回到main方法\"); System.out.println(\"執行func1()之後的程式碼\"); } public static void func1 () { System.out.println(\"執行func1()\"); } } 執行func1() 回到main方法 執行func1()之後的程式碼 執行緒與主程式同時執行 執行緒與main執行緒是同時執行，main不等待。 下圖中，程序呼叫主要執行緒(Main Thread)，main啟動執行緒1，但main執行結束，執行緒1仍在執行，直到程序中所有執行緒都結束了，程序才結束。 建立Thread 建立Thread有二個方式，一個是繼承thread類別，一個是實作Runnable介面。 繼承thread類別 Java不支援多繼承，繼承Thread後就沒辦法繼承其它類別，建議使用Runnable，比較不會有限制。 類別繼承Thread，並覆寫run()方法。 1 2 3 4 5 6 public class 類別名 extends Thread { @Override public void run() { // 要執行的流程 } } 啟動執行緒 1 new 類別名().start(); 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Thread1 extends Thread { @Override public void run() { // 每1秒印1句話，執行10秒 for (int i = 0; i &lt; 10; i++) { System.out.println(\"Thread1 i = \" + i); try { // 休息1秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Thread1 執行緒結束\"); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) throws InterruptedException { // 建立執行緒 Thread1 t1 = new Thread1(); // 啟動執行緒 t1.start(); // 每1秒印1句話，執行5秒 for (int i = 0; i &lt; 5; i++) { System.out.println(\"main i = \" + i); // 休息1秒 Thread.sleep(1000); } System.out.println(\"main 主要執行緒結束\"); } } main i = 0 Thread1 i = 0 Thread1 i = 1 main i = 1 Thread1 i = 2 main i = 2 Thread1 i = 3 main i = 3 Thread1 i = 4 main i = 4 main 主要執行緒結束 Thread1 i = 5 Thread1 i = 6 Thread1 i = 7 Thread1 i = 8 Thread1 i = 9 Thread1 執行緒結束 Process finished with exit code 0 由執行結果可以發現main與Thread1同時執行，而且main比Thread1提早結束。 Thread1執行結束，程序才結束。 實作Runnable介面 類別實作Runnable介面，並覆寫run()方法。 1 2 3 4 5 6 public class 類別名 implements Runnable { @Override public void run() { // 要執行的流程 } } 先前Thread原始碼有提到，Thread類別才有start()方法，要透過start()方法啟動執行緒。 所以要把實作Runnable物件放入Thread有參數的建構子。 1 2 3 4 5 6 public class Thread implements Runnable { // 參數是有實作Runnable的類別 public Thread(Runnable task) { this(null, null, 0, task, 0, null); } } 把Runable物件放進Thread的有參數的建構子，然後使用Thread類別start()方法啟動執行緒。 1 new Thread(new Runnable物件()).start(); 程式碼，把上一個程式碼修改成實作Runnable。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class R1 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"R1 i = \" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"R1 執行緒結束\"); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Test { public static void main(String[] args) throws InterruptedException { // 建立Runnable物件 R1 r1 = new R1(); // 把Runnable物件放入Thread的建構子 Thread t1 = new Thread(r1); // 啟動執行緒 t1.start(); for (int i = 0; i &lt; 5; i++) { System.out.println(\"main i = \" + i); Thread.sleep(1000); } System.out.println(\"main 主要執行緒結束\"); } } 匿名類別 Runnable匿名類別 要把實作Runnable匿名物件放入Thread有參數的建構子。 1 2 3 4 new Thread(new Runnable() { @Override public void run() { ... } }).start(); thread匿名類別 使用無參數的建構子。 1 2 3 4 5 6 new Thread() { @Override public void run() { // 要執行的流程 } }.start(); 結束執行緒 return 使用return，就會結束執行緒。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Thread1 implements Runnable { private int count = 0; @Override public void run() { for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 3; j++) { System.out.println(\"Thread1 count = \" + (++count)); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 若count等於5，就結束執行緒 if( count == 5) return; } } System.out.println(\"Thread1 執行緒結束\"); } } Thread1 count = 1 main i = 0 main i = 1 Thread1 count = 2 main i = 2 Thread1 count = 3 main i = 3 Thread1 count = 4 main i = 4 Thread1 count = 5 main 主要執行緒結束 由執行結果發現，執行到count = 5，Thread1就結束了。 break 離開迴圈也是結束執行緒的方法，如果只有1層迴圈，可以離開執行緒，2層迴圈使用break，是只跳出目前的迴圈，並非離開函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Thread1 implements Runnable { private int count = 0; @Override public void run() { for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 若count等於5，就結束執行緒 if( count == 5) break; } System.out.println(\"Thread1 執行緒結束\"); } } 使用flag 提供set方法，設定私有屬性flag。 由其它類別控制何時結束。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class R2 implements Runnable { // 控制結束的flag private boolean flag = true; // 由其它類別來設定flag public void setFlag(boolean flag) { this.flag = flag; } @Override public void run() { while (flag) { System.out.println(Thread.currentThread().getName() + \"執行中\"); // 每秒印1次 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) throws InterruptedException { R2 r2 = new R2(); // 啟動執行緒 new Thread(r2).start(); for (int i = 0; i &lt; 10; i++) { // i為5就把執行緒關掉 if(i == 5) { r2.setFlag(false); } // 每秒印1次 System.out.println(\"i = \" + i); Thread.sleep(1000); } } } Thread-0執行中 i = 0 Thread-0執行中 i = 1 Thread-0執行中 i = 2 Thread-0執行中 i = 3 Thread-0執行中 i = 4 Thread-0執行中 i = 5 i = 6 i = 7 i = 8 i = 9 Thread類別常用方法 setName() 設定緒行緒的名字。 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) throws InterruptedException { // 建立執行緒物件 Thread1 t1 = new Thread1(); //設定執行緒的名字 t1.setName(\"執行緒1\"); // 啟動執行緒 t1.start(); } } currentThread().getName() 取得目前執行緒的名字。 1 2 3 4 5 6 7 8 9 class R1 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { // 取得目前執行緒的名字。 System.out.println(Thread.currentThread().getName() + \" i = \" + i); } } } 在main中取得執行緒的名字。 1 2 3 4 5 public class Test { public static void main(String[] args) { System.out.println(Thread.currentThread().getName()); } } main 執行緒共享 所謂的共享是不同的執行緒(Thread)，存取相同的記憶體位址。 Runnable共享 只要建立一個Runnable物件，多個執行緒可以共享同一個Runnable物件的變數。 同一個物件建立的執行緒，多個執行緒可使用相同的成員屬性。 R1是實作Runnable的物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 class R1 implements Runnable { // 執行緒使用相同屬性money private int money = 10000; @Override public void run() { // 無窮迴圈 while (true) { if (money &lt;= 0) break; money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } } } 同時啟動2個執行緒。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test { public static void main(String[] args) { // 建立Runnable物件 R1 r1 = new R1(); // 使用r1 Runnable物件為參數 Thread t1 = new Thread(r1); // 設定名字 t1.setName(\"執行緒1\"); // 使用r1 Runnable物件為參數 Thread t2 = new Thread(r1); // 設定名字 t2.setName(\"執行緒2\"); // 啟動執行緒 t1.start(); t2.start(); } } 執行緒2 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒2 提領 1000 元，剩下 6000 元 執行緒2 提領 1000 元，剩下 5000 元 執行緒2 提領 1000 元，剩下 4000 元 執行緒1 提領 1000 元，剩下 9000 元 執行緒1 提領 1000 元，剩下 2000 元 執行緒1 提領 1000 元，剩下 1000 元 執行緒1 提領 1000 元，剩下 0 元 執行緒2 提領 1000 元，剩下 3000 元 因為沒有使用synchronized，所以執行結果不如預期，但二個執行緒都使用相同money屬性。 繼承Thread共享資源 繼承Thread沒辦法共用相同物件屬性，因為每一次都是用new Thread()，每一次new都是不同物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 建立執行緒 Thread1 t1 = new Thread1(); // 啟動執行緒 t1.start(); // 建立執行緒 Thread1 t2 = new Thread1(); // 啟動執行緒 t2.start(); // 建立執行緒 Thread1 t3 = new Thread1(); // 啟動執行緒 t3.start(); 只能使用以下二種方法，存取相同的記憶體位址。 Static靜態變數 提供一個public方法或建構子，傳入相同物件，才能存取相同的記憶體位址。 使用Static變數 1 2 3 4 5 6 7 8 9 10 11 class TestThread extends Thread { private static int money = 10000; @Override public void run() { while (true) { if (money &lt;= 0) break; money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { TestThread t1 = new TestThread(); t1.setName(\"執行緒1\"); TestThread t2 = new TestThread(); t2.setName(\"執行緒2\"); //啟動執行緒 t1.start(); t2.start(); } } 執行緒2 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒2 提領 1000 元，剩下 6000 元 執行緒2 提領 1000 元，剩下 5000 元 執行緒2 提領 1000 元，剩下 4000 元 執行緒2 提領 1000 元，剩下 3000 元 執行緒2 提領 1000 元，剩下 2000 元 執行緒2 提領 1000 元，剩下 1000 元 執行緒2 提領 1000 元，剩下 0 元 執行緒1 提領 1000 元，剩下 9000 元 使用物件 建立提款卡類別，裡面有10000元。 1 2 3 4 5 6 7 8 9 10 11 class BankCard { private int money = 10000; public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } } 執行緒提供參數為提款卡的建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class TestThread extends Thread { private BankCard card; public TestThread(BankCard card) { this.card = card; } @Override public void run() { while (true) { if (card.getMoney() &lt;= 0) break; card.setMoney(card.getMoney() - 1000); System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + card.getMoney() + \" 元\"); } } } 啟動執行緒。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { BankCard bankCard = new BankCard(); // 放入相同的bankCard物件 TestThread t1 = new TestThread(bankCard); t1.setName(\"執行緒1\"); // 放入相同的bankCard物件 TestThread t2 = new TestThread(bankCard); t2.setName(\"執行緒2\"); // 啟動 t1.start(); t2.start(); } } 執行緒2 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒1 提領 1000 元，剩下 9000 元 執行緒1 提領 1000 元，剩下 5000 元 執行緒2 提領 1000 元，剩下 6000 元 執行緒1 提領 1000 元，剩下 4000 元 執行緒2 提領 1000 元，剩下 3000 元 執行緒1 提領 1000 元，剩下 2000 元 執行緒2 提領 1000 元，剩下 1000 元 執行緒1 提領 1000 元，剩下 0 元 因為沒有使用synchronized，所以執行結果不如預期，但二個執行緒都使用相同bankCard物件。 呼叫run() 先前已經提過，呼叫run()，等同於呼叫方法，不是啟動執行緒。 呼叫方法，會有阻斷Block，也就是前面的方法執行完，才能執行接下來的方法，按照順序執行。 1 2 3 4 5 6 7 8 class TestThread2 extends Thread { @Override public void run() { for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \" i = \" + i); } } } 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { TestThread2 t1 = new TestThread2(); t1.setName(\"執行緒1\"); TestThread2 t2 = new TestThread2(); t2.setName(\"執行緒2\"); t1.run(); t2.run(); } } main i = 0 main i = 1 main i = 2 main i = 3 main i = 4 main i = 0 main i = 1 main i = 2 main i = 3 main i = 4 由執行結果可以發現，雖然有設定執行緒的名字，但印出來的執行緒名字都是main，代表run()都是在main執行緒中執行。 而且印出的i是0至4，共印出2次，也就是呼叫2次run()。"
  },"/pages/note/git/github/": {
    "title": "github note",
    "keywords": "",
    "url": "/pages/note/git/github/",
    "body": "離開其它的repository 進入自己的”Settings”-&gt;”Repository”&gt;”Leave repository”"
  },"/pages/note/sublime/": {
    "title": "sublime note",
    "keywords": "",
    "url": "/pages/note/sublime/",
    "body": "Snippets 儲存位置 /Users/cici/Library/Application Support/Sublime Text 3/Packages/User/java_highlight.sublime-snippet 副檔名要為.sublime-snippet 字體大小 取代\\n"
  },"/pages/note/git/other_note/": {
    "title": "other note",
    "keywords": "",
    "url": "/pages/note/git/other_note/",
    "body": ".env安裝"
  },"/pages/jekyll/install/install_jekyll/": {
    "title": "安裝 Jekyll",
    "keywords": "",
    "url": "/pages/jekyll/install/install_jekyll/",
    "body": "參考的教學 https://www.youtube.com/watch?v=D9CLhQdLp8w 建立Repository 如果想在自己的根目錄可以看到網站，以下的方框輸入你的帳號.github.io 如果只想要在原本的github網址後面多個目錄，例:https://你的帳號.github.io/你建立的目錄名/，以下的方框輸入目錄名 記得要public 使用git desktop clone下來 建立Gemfile clone下來後，在clone的目錄下建立Gemfile Gemfile source 'https://rubygems.org' gem 'webrick' gem 'nokogiri' gem 'rack', '~&gt; 2.2.4' gem 'rspec' gem \"jekyll\", \"~&gt; 3.9.5\" gem \"github-pages\", group: :jekyll_plugins gem \"jekyll-include-cache\", group: :jekyll_plugins 建立_config.yml 在clone的目錄下建立_config.yml title: Jekyll Gitbook remote_theme: sighingnow/jekyll-gitbook plugins: - jekyll-paginate - jekyll-sitemap - jekyll-gist - jekyll-feed - jekyll-include-cache 建立README.md README.md 內容隨便寫 指令 打開終端機，輸入以下指令 % bundle update % gem install % bundle install % git add Gemfile.lock % bundle % bundle exec jekyll serve 將產生以下畫面 % % bundle exec jekyll serve /usr/local/lib/ruby/gems/3.3.0/gems/jekyll-3.9.5/lib/jekyll.rb:28: warning: csv was loaded from the standard library, but will no longer be part of the default gems since Ruby 3.4.0. Add csv to your Gemfile or gemspec. Also contact author of jekyll-3.9.5 to add csv into its gemspec. Configuration file: /Users/cici/GitHub/old/_config.yml To use retry middleware with Faraday v2.0+, install `faraday-retry` gem Source: /Users/cici/GitHub/old Destination: /Users/cici/GitHub/old/_site Incremental build: disabled. Enable with --incremental Generating... Remote Theme: Using theme sighingnow/jekyll-gitbook Jekyll Feed: Generating feed for posts GitHub Metadata: No GitHub API authentication could be found. Some fields may be missing or have incorrect data. done in 2.77 seconds. Auto-regeneration: enabled for '/Users/cici/GitHub/old' Server address: http://127.0.0.1:4000 Server running... press ctrl-c to stop. Regenerating: 1 file(s) changed at 2025-04-10 12:41:32 README.md Remote Theme: Using theme sighingnow/jekyll-gitbook Jekyll Feed: Generating feed for posts ...done in 0.096139 seconds. 打開瀏覽器輸入網址 http://127.0.0.1:4000 上傳到你的github commit &gt; push Github pages 進入Github pages 設置branch，並save 到Action查看佈屬狀況，黃色代表正在佈屬 綠色代表佈屬成功 查看網站 二種方式: https://你的帳號.github.io/ https://你的帳號.github.io/你建立的目錄名/"
  },"/pages/android/opensles/": {
    "title": "OpenSLES音訊",
    "keywords": "",
    "url": "/pages/android/opensles/",
    "body": "官網 https://developer.android.com/ndk/guides/audio/opensl/getting-started?hl=zh-tw libOpenSLES放置位置 /Users/cici/NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib/aarch64-linux-android/32/libOpenSLES.so ndk的範例 https://github.com/android/ndk-samples OpenSLES的ndk範例 https://github.com/android/ndk-samples/blob/main/native-audio/app/src/main/cpp/native-audio-jni.c 混音器 // create the engine and output mix objects JNIEXPORT void JNICALL Java_com_example_nativeaudio_NativeAudio_createEngine"
  },"/pages/c/template/pointer_template/": {
    "title": "指標模板",
    "keywords": "",
    "url": "/pages/c/template/pointer_template/",
    "body": "函式的參數是指標: 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 可以改成以下方式: 1 2 3 4 5 6 7 8 9 10 template &lt;typename T&gt; void func1(T param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1&lt;int*&gt;(p); return 0; } 也可以改成以下方式: 明確定義參數是指標類型，但呼叫函式宣告的型別不能為&lt;int*&gt;，要為&lt;int&gt;，告訴編譯器T是int型別，若函式宣告的型別為int指標型別&lt;int*&gt;，編譯器會把T*再加上一個*，最後就會變成T**，變成指標的指標，但實際上傳入的參數是指標。 1 2 3 4 5 6 7 8 9 10 template &lt;typename T&gt; void func1(T* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1&lt;int&gt;(p); return 0; } 以下的Queue中的T，可以是基本型別或指標或類別，沒有限定型別。 1 2 3 4 5 6 7 8 9 template&lt;typename T&gt; class MyQueue { private: std::queue&lt;T&gt; q; public: void push(const T new_value) { q.push(new_value); } }; 指標放入queue 1 2 3 4 5 6 7 int main() { MyQueue&lt;int*&gt; my_q; int var1 = 10; int* p = &amp;var1; my_q.push(p); return 0; } 基本型別放入queue 1 2 3 4 5 6 int main() { MyQueue&lt;int&gt; my_q; int var1 = 10; my_q.push(var1); return 0; }"
  },"/pages/android/handler/": {
    "title": "Handler訊息溝通",
    "keywords": "",
    "url": "/pages/android/handler/",
    "body": "Prerequisites: Thread Android Main Thread Handler 當背景執行緒(background Thread)處理完耗時操作，要通知UI執行緒(主要執行緒Main Thread)處理畫面更新，就需要使用到handler來通知UI執行緒來更新畫面。 建立handler 1 Handler handler = new Handler(); Handler主要做二件事:通知、接收訊息 建立背景執行緒(background Thread) 建立背景執行緒(background Thread)可以透過new thread或建立runnable物件，二種方式建立背景執行緒(background Thread) 1 2 3 4 5 6 new Thread() { @Override public void run() { ... } }.start(); 1 2 3 4 5 6 new Thread(new Runnable() { @Override public void run() { ... } }).start(); 訊息Message 建立訊息語法 Message message = new Message(); message.what = 1; handler.sendMessage(message); 所謂的what，可視為訊息的id編號，代表我這個訊息是1號 Handler通知 背景執行緒background thread可使用handler.sendMessage()通知ui thread要更新ui畫面。 1 2 3 4 5 6 7 8 9 10 11 new Thread() { @Override public void run() { // 建立訊息 Message message = new Message(); // 建立訊息編號id message.what = 1; // 通知ui thread，要更新ui，sendMessage()參數為先前建立的訊息 handler.sendMessage(message); } }.start(); Handler收到通知 onCreate()是屬於UI Thread，UI Thread中handler收到message通知。 取出message，再取出what，根據不同的訊息id，處理相對映的更新畫面動作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { handler = new Handler() { @Override public void handleMessage(@NonNull Message msg) { switch (msg.what) { case 1: Toast.makeText(MainActivity.this, \"test\", Toast.LENGTH_SHORT).show(); Log.e(TAG,\"handler test\"); break; } } }; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { // 建立訊息接收者 handler = new Handler() { // 收到訊息 @Override public void handleMessage(@NonNull Message msg) { // 根據訊息編號判斷要做什麼畫面更新的流程 switch (msg.what) { case 1: //訊息編號為1 Toast.makeText(MainActivity.this, \"test\", Toast.LENGTH_SHORT).show(); Log.e(TAG,\"handler test\"); break; } } }; // 建立背景執行緒 new Thread() { @Override public void run() { // 建立訊息 Message message = new Message(); // 訊息編號 message.what = 1; // 傳送訊息，通知ui thread更新畫面 handler.sendMessage(message); } }.start();// 啟動背景執行緒 } message.obj 可以在message加上訊息。 語法如下: 1 2 3 4 String data = \"12345\"; Message message = new Message(); message.what = 1; message.obj = data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public void testHandler() { new Thread() { @Override public void run() { String data = \"12345\"; // 建立訊息 Message message = new Message(); // 建立訊息編號id message.what = 1; // 建立物件 message.obj = data; // 通知ui thread，要更新ui，sendMessage()參數為先前建立的訊息 handler.sendMessage(message); } }.start(); } public void btnClick(View view) { testHandler(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 handler = new Handler() { // 收到訊息 @Override public void handleMessage(@NonNull Message msg) { // 根據訊息編號判斷要做什麼畫面更新的流程 switch (msg.what) { case 1: //訊息編號為1 String data = (String) msg.obj; Toast.makeText(MainActivity.this, \"test\" + data, Toast.LENGTH_SHORT).show(); Log.e(TAG, \"handler test data = \" + data); break; case 2: break; } } }; sendEmptyMessage() 語法 handler.sendEmptyMessage(整數的編號); handler.sendEmptyMessage(1); 參數為訊息的編號 可以省略new Message()…等等相關流程，一樣有同樣的效果。 1 2 3 4 5 6 7 new Thread() { @Override public void run() { // 傳送訊息，通知ui thread更新畫面 handler.sendEmptyMessage(1); } }.start();// 啟動背景執行緒 sendEmptyMessageDelayed() 幾秒後像handler發送訊息 語法 handler.sendEmptyMessageDelayed(整數的編號, 幾秒後發送); handler.sendEmptyMessage(2, 2*1000); 參數1:訊息編號 參數2:單位是毫秒，1秒是1000毫秒，此範例使用2秒也就是2000毫秒 ProgressBar xml 1 2 3 4 5 6 7 8 9 10 &lt;ProgressBar android:id=\"@+id/progressBar1\" style=\"?android:attr/progressBarStyleHorizontal\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:max=\"100\" android:visibility=\"gone\" app:layout_constraintBottom_toTopOf=\"@+id/button\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" /&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 private ProgressBar progressBar1; // 進度條變數 private int progress = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); progressBar1 = (ProgressBar) findViewById(R.id.progressBar1); handler = new Handler() { // 收到訊息 @Override public void handleMessage(@NonNull Message msg) { // 根據訊息編號判斷要做什麼畫面更新的流程 switch (msg.what) { case 1: //訊息編號為1 Toast.makeText(MainActivity.this, \"test\", Toast.LENGTH_SHORT).show(); Log.e(TAG,\"handler test\"); break; case 2: // 每收到訊息一次，progress小於100 progress就+10 if (progress &lt; 100) { // 進度條變數+10 progress+=10; // 將進度條變數放入progressBar中 progressBar1.setProgress(progress); // 這個是重點！循環向handler傳送訊息，每隔2秒 // progress滿了100就不再發訊息 handler.sendEmptyMessageDelayed(2, 2*1000); } break; } } }; // 發送訊息 public void testTimer() { progressBar1.setVisibility(View.VISIBLE); // 2*1000毫秒 = 2 秒 2秒以後傳送handler訊息 handler.sendEmptyMessageDelayed(2, 2*1000); } // 按了按鈕才開始 public void btnClick(View view) { testTimer(); } post(Runnable) 變更畫面的流程，寫進參數Runnable中的run()方法，post()方法會把Runnable物件丟給主要執行緒UI thread，由主要執行緒(UI Thread)去執行Runnable物件中的run()方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void postTest() { new Thread() { @Override public void run() { handler.post(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, \"post clicked!\", Toast.LENGTH_LONG).show(); Log.d(\"test:\", \"post here\"); } }); } }.start();// 啟動背景執行緒 } public void btnClick(View view) { postTest(); } view.post(Runnable) ui元件都繼承view，所以用ui元件.post(new Runnable())，畫面處理的流程寫在Runnable介面中的run()方法，通知UI thread，並根據run()方法中的流程，更新ui畫面。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private Button btn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn = (Button) findViewById(R.id.button); } public void viewpostTest() { new Thread() { @Override public void run() { // btn是view的子類別，使用post()的方法可以通知ui thread btn.post(new Runnable() { @Override public void run() { Toast.makeText(MainActivity.this, \"view.post clicked!\", Toast.LENGTH_LONG).show(); Log.d(\"test:\", \"view.post here\"); } }); } }.start();// 啟動背景執行緒 } public void btnClick(View view) { viewpostTest(); } runOnUiThread 更新畫面 除了handler外，runOnUiThread也可以進行畫面的更新。 在執行緒中添加以下程式碼，並把畫面處理的流程寫在Runnable介面中的run()方法，通知ui thread，並根據run()方法中的流程，更新ui畫面。 1 2 3 4 5 6 7 8 9 10 // 通知ui thread更新畫面 runOnUiThread( new Runnable() { @Override public void run() { // 畫面更新的流程 Toast.makeText(MainActivity.this, \"ui Test\", Toast.LENGTH_SHORT).show(); Log.e(TAG,\"ui Thread Test\"); } }); 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 建立背景執行緒 new Thread(new Runnable() { @Override public void run() { // 通知ui thread更新畫面 runOnUiThread(new Runnable() { @Override public void run() { // 畫面更新的流程 Toast.makeText(MainActivity.this, \"ui Test\", Toast.LENGTH_SHORT).show(); Log.e(TAG,\"ui Thread Test\"); } }); } }).start();// 啟動背景執行緒"
  },"/pages/java/constructor/": {
    "title": "建構子",
    "keywords": "",
    "url": "/pages/java/constructor/",
    "body": "子類別預設呼叫super() 以下看似什麼都沒有做。 1 2 class Father {} class Child extends Father {} 但實際上子類別的建構子，會先呼叫super()父類別無參數建構子super，建立完父類別，才建立自己。 1 2 3 4 5 6 7 8 9 class Father { public Father() { } } class Child extends Father{ public Child() { super(); // 先呼叫父類別無參數建構子，建立父類別 // 建立完父類別，才建立自己 } } 如果父類別沒有無參數建構子，會產生錯誤。 父類別沒有無參數建構子 以下父類別沒有無參數建構子Parent() {} 1 2 3 4 5 6 7 8 9 10 11 public class Parent { String name; int age; Parent(String name) { this.name = name; } Parent(String name, int age) { this.name = name; this.age = age; } } 子類別繼承父類別，會產生錯誤。 1 public class Child extends Parent {} 原因是，父類別沒有無參數建構子Parent() {}，編譯器在編譯時，會添加super()在子類別的建構子中。 以下是編譯器自動增加的: 1 2 3 4 5 public class Child extends Parent{ Child() { super(); //父類別沒有無參數建構子，所以產生error } } 解決辦法 子類別呼叫任何一個有參數的父建構子 在 Java 中，當一個類別（Child）繼承自另一個類別（Parent），而父類別沒有無參數的建構函式（default constructor）時，子類別必須明確地呼叫父類別的某個建構函式（使用 super(…)）。 不管如何，子類別至少呼叫任何一個有參數的父建構子。 1 2 3 4 5 public class Child extends Parent{ Child(String name) { super(name); } } 父類別加上無參數建構子 父類別加上無參數建構子 1 2 3 4 5 6 7 8 9 10 11 12 public class Parent { String name; int age; Parent(String name) { this.name = name; } Parent(String name, int age) { this.name = name; this.age = age; } Parent() {} } 子類別就無需呼叫父類別的無參數建構子，編譯器會自動產生在程式碼。 1 2 public class Child extends Parent{ } 父類別與子類別建立順序 建立Child 1 2 3 public static void main(String[] args) { Child child = new Child(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Grandpa { public Grandpa() { // 3.建立Grandpa System.out.println(\"Grandpa無參數建構子\"); } } class Father extends Grandpa{ public Father() { super(); // 2.先呼叫父類別無參數建構子 // 4. 建立Father System.out.println(\"Father無參數建構子\"); } } class Child extends Father{ public Child() { super(); // 1.先呼叫父類別無參數建構子 // 5. 建立Child System.out.println(\"Child無參數建構子\"); } } Grandpa無參數建構子 Father無參數建構子 Child無參數建構子 子類別有參數建構子呼叫順序 執行以下程式碼，執行順序是什麼？ 1 2 3 public static void main(String[] args) { Child child = new Child(\"Momo\"); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Grandpa { public Grandpa() { // 3.建立Grandpa System.out.println(\"Grandpa無參數建構子\"); } } class Father extends Grandpa{ public Father() { super(); // 2.先呼叫父類別無參數建構子 // 4. 建立Father System.out.println(\"Father無參數建構子\"); } } class Child extends Father{ public Child() { super(); System.out.println(\"Child無參數建構子\"); } public Child(String name) { super(); // 1.先呼叫父類別無參數建構子 // 5. 建立Child System.out.println(\"Child有參數建構子\"); } } Grandpa無參數建構子 Father無參數建構子 Child有參數建構子 注意！呼叫有參數的建構子，不會再去呼叫無參數建構子。 this()呼叫無參數建構子 執行以下程式碼，執行順序是什麼？ 1 2 3 public static void main(String[] args) { Child child = new Child(\"Momo\"); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Grandpa { public Grandpa() { // 4.建立Grandpa System.out.println(\"Grandpa無參數建構子\"); } } class Father extends Grandpa{ public Father() { super(); // 3.先呼叫父類別無參數建構子 // 5. 建立Father System.out.println(\"Father無參數建構子\"); } } class Child extends Father{ public Child() { super();// 2.先呼叫父類別無參數建構子 // 6. System.out.println(\"Child無參數建構子\"); } public Child(String name) { this(); // 1.呼叫無參數建構子 // 7. 這裡執行完有參數建構子，才建立Child System.out.println(\"Child有參數建構子\"); } } Grandpa無參數建構子 Father無參數建構子 Child無參數建構子 Child有參數建構子 super()與this()只能擇一，且只能放第一行 以下編譯錯誤 1 2 3 4 5 6 7 8 9 10 class Child extends Father{ public Child() { super(); } public Child(String name) { this(); super(); // this與super只能擇一 // 且只能在第一行，super不能放在第二行 } 最後一定會呼叫Object() 所有建構子，最後一定會呼叫Object()建構子，因為Object是所有類別的父類別。 滑鼠對著子類別名稱，按下ctrl + h，出現以下階層圖，可以由此圖知道Object是所有類別的父類別。 以下為呼叫過程圖，最後會在Heap中建立一個記憶體空間0x00055，包含每個父類別的「屬性」，而父類別「們」的方法則存放在metadata的vtable中。 匿名程式碼區塊 英文是Anonymous code blocks {}花括號裡面的內容，就是匿名程式碼區塊 { // 花括號裡面的內容 } 先執行匿名程式碼區塊，再執行建構子 建立物件時，會先執行匿名稱式碼區塊，再執行建構子 1 2 3 4 5 6 7 8 9 10 11 public class Test { { System.out.println(\"匿名區塊\"); } Test() { System.out.println(\"建構子區塊\"); } public static void main(String[] args) { Test test = new Test(); } } 匿名區塊 建構子區塊"
  },"/pages/java/extends_constructor/": {
    "title": "建構子",
    "keywords": "",
    "url": "/pages/java/extends_constructor/",
    "body": "匿名程式碼區塊 英文是Anonymous code blocks {}花括號裡面的內容，就是匿名程式碼區塊 { // 花括號裡面的內容 } 先執行匿名程式碼區塊 建立物件時，會先執行匿名稱式碼區塊，再執行建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { { System.out.println(\"匿名區塊\"); } Test() { System.out.println(\"建構子區塊\"); } public static void main(String[] args) { Test test = new Test(); } } 靜態區塊 匿名區塊 父類別沒有無參數建構子 以下父類別沒有無參數建構子Parent() {} 1 2 3 4 5 6 7 8 9 10 11 public class Parent { String name; int age; Parent(String name) { this.name = name; } Parent(String name, int age) { this.name = name; this.age = age; } } 子類別繼承父類別，會產生錯誤。 1 2 public class Child extends Parent{ } 原因是，父類別沒有無參數建構子Parent() {}，編譯器在編譯時，會添加super()在子類別的建構子中。 以下是編譯器自動增加的: 1 2 3 4 5 public class Child extends Parent{ Child() { super(); //父類別沒有無參數建構子，所以產生error } } 解決辦法 子類別呼叫任何一個有參數的父建構子 在 Java 中，當一個類別（Child）繼承自另一個類別（Parent），而父類別沒有無參數的建構函式（default constructor）時，子類別必須明確地呼叫父類別的某個建構函式（使用 super(…)）。 不管如何，子類別至少呼叫任何一個有參數的父建構子。 1 2 3 4 5 public class Child extends Parent{ Child(String name) { super(name); } } 父類別加上無參數建構子 父類別加上無參數建構子 1 2 3 4 5 6 7 8 9 10 11 12 public class Parent { String name; int age; Parent(String name) { this.name = name; } Parent(String name, int age) { this.name = name; this.age = age; } Parent() {} } 子類別就無需呼叫父類別的無參數建構子，編譯器會自動產生在程式碼。 1 2 public class Child extends Parent{ }"
  },"/pages/java/polymorphism/": {
    "title": "多型",
    "keywords": "",
    "url": "/pages/java/polymorphism/",
    "body": "編譯類型 與 執行類型 編譯類型，英文是Compile-time type。 執行類型，英文是Runtime type。 什麼是編譯類型？什麼是執行類型？ 下方的程式碼，等號左邊是編譯類型，等號右邊是執行類型。 1 2 編譯類型 = 執行類型 Parent parent = new Child(); 說白話一點就是，雖然類型是父類別，但實際上指向的是子類別物件。 多型就是，物件的「類型是父類別」，但實際上是用「子類別」的「建構子建立」物件。 Memory Layout Prerequisites: Object Layout core 基本型態與Wrapper Classes 下面的程式碼有Animal、Dog，Dog繼承Animal。 1 2 3 4 5 6 7 8 9 10 class Animal { int i = 10; // 父類欄位 void speak() { System.out.println(i); } } class Dog extends Animal { int i = 5; // 子類同名欄位 } Dog Memory Layout如下: 記憶體開始位置/ 佔記憶體大小/ 型別/ 變數/ 存放的值 OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x010033f8 Dog方法記憶體位址 12 4 int Animal.i 10 16 4 int Dog.i 5 20 4 (object alignment gap) 物件大小Instance size: 24 bytes 發現Dog物件中有二個變數，一個變數值為10，來自父類別Animal.i，另一個變數值為5是自己的Dog.i。 記憶體開始位置/ 佔記憶體大小/ 型別/ 變數/ 存放的值 OFF SZ TYPE DESCRIPTION VALUE 12 4 int Animal.i 10 16 4 int Dog.i 5 反射 取得父類別所有方法 使用反射知道子類繼承那些方法。 javap 使用javap知道執行時物件是誰？執行的方法是來自那個物件。 Dog繼承Animal，執行時使用多型，變數類型是父類Animal，指向Dog物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Animal { public void speak() { System.out.println(\"Animal sound\"); } public void eat() { System.out.println(\"Animal eating\"); } } class Dog extends Animal { @Override public void speak() { System.out.println(\"Bark!\"); } public void fetch() { System.out.println(\"Fetching...\"); } } public class Test1 { public static void main(String[] args) throws Exception { Animal a = new Dog(); // 多型 a.speak(); // 輸出: Bark! Thread.sleep(5 * 60 * 1000); // 讓程序一直執行 } } 編譯以上程式碼 javac Test1.java 執行javap javap -c -v Test1 實際呼叫的是Dog()建構子，但使用父類別Animal.speak()。 #3 = Methodref #2.#20 // Dog.&lt;init&gt;:()V #4 = Methodref #22.#23 // Animal.speak:()V #20 = NameAndType #10:#11 // \"&lt;init&gt;\":()V #21 = Utf8 Dog #22 = Class #29 // Animal #23 = NameAndType #30:#11 // speak:()V 0: new #2 // class Dog 4: invokespecial #3 // Method Dog.\"&lt;init&gt;\":()V 9: invokevirtual #4 // Method Animal.speak:()V vtable 在Memory Layout中，從8byte開始到11byte結束，佔了4個byte記憶體空間，存放的是vtable的記憶體位址，什麼是vtable？ 儲存Dog物件的所有方法。 以下表格第4行為vtable的記憶體位置。 Dog Memory Layout如下: 記憶體開始位置/ 佔記憶體大小/ 型別/ 變數/ 存放的值 OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x010033f8 &lt;- Dog物件的所有方法 記憶體位址 12 4 int Animal.i 10 16 4 int Dog.i 5 20 4 (object alignment gap) 物件大小Instance size: 24 bytes 由於呼叫vtable語法太困難了，以下的vtable是AI模擬出來。 從下面可以發現，Dog有三個方法，分別是equals(), hashCode(), speak()。 vtable for Dog: [0] Object.equals()@addr1 # 繼承自 Object [1] Object.hashCode()@addr2 # 繼承自 Object [2] Animal.speak()@addr3 # 繼承自 Animal 由於Dog沒有覆寫父類別的speak()方法，因為在vtable中，speak()方法是來自父類別Animal。 因此以下程式碼執行時，會去看Dog的vtable中的speak()方法，然後才知道要去呼叫Animal.speak()，因為是呼叫Animal類別，所以使用的是Animal類別中的i屬性，印出的結果是10。 1 2 3 4 5 6 7 8 9 10 class Animal { int i = 10; // 父類欄位 void speak() { System.out.println(i); } } class Dog extends Animal { int i = 5; // 子類同名欄位 } 1 2 3 4 5 6 public class Test2 { public static void main(String[] args) { Animal myPet = new Dog(); // 多型 myPet.speak(); // 輸出：10（非 5！） } } 覆寫之後的vtable 若是Dog類別有覆寫speak()方法，vtable裝的是什麼？ 1 2 3 4 class Dog extends Animal { int i = 5; // 子類同名欄位 void speak() { System.out.println(i); } } vtable for Dog: [0] Animal.equals()@123456 # 繼承自 Object [1] Animal.hashCode()@234567 # 繼承自 Object [2] Dog.speak()@345678 由上面可以發現，vtable[2]已經變成Dog.speak()。 執行以下程式碼，結果為5，因為是呼叫Dog類別，所以使用的是Dog類別中的i屬性。 1 2 3 4 5 6 public class Test2 { public static void main(String[] args) { Animal myPet = new Dog(); // 多型 myPet.speak(); } } 父類別轉型子類別 自動轉型 子類別轉父類別只會有一個父類別，因此使用自動轉型。 1 2 // 以下是自動轉型 Animal myPet = new Dog(); 強制轉型 父類別下面會有多個子類別，不確定要轉成那個子類別，因此採用強制轉型，也就是使用括號，括號中是要轉型的(子類別)。 1 2 3 Animal myPet = new Dog(); // 強制轉型成子類別 Dog dog = (Dog) myPet; 強轉回子類別就可以用子類別的屬性與方法。"
  },"/pages/math/sec/": {
    "title": "秒的換算",
    "keywords": "",
    "url": "/pages/math/sec/",
    "body": "1 毫秒（millisecond，ms） = 0.001 秒（s） 也就是： 1 毫秒 = 1/1000 秒 換算範例： 100 毫秒 = 0.1 秒 500 毫秒 = 0.5 秒 1000 毫秒 = 1 秒 毫秒常用於測量極短的時間間隔，例如電腦反應速度、網路延遲等。"
  },"/pages/design_pattern/callback/": {
    "title": "Callback模式",
    "keywords": "",
    "url": "/pages/design_pattern/callback/",
    "body": "Prerequisites: 介面 Callback回呼介面 Callback（回呼）是一種常見的設計模式，允許一個類別在特定事件發生時通知另一個類別。 建立Callback介面 1 2 3 public interface SimpleCallback { void onComplete(String result); } 實作Callback介面 1 2 3 4 5 6 public class CallbackHandler implements SimpleCallback { @Override public void onComplete(String result) { System.out.println(\"Callback 收到結果: \" + result); } } 使用已實作的Callback介面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Task { public void executeTask(SimpleCallback callback) { System.out.println(\"任務執行中...\"); // 模擬長時間運算 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } // 任務完成後呼叫 callback callback.onComplete(\"任務完成!\"); } } 主程式 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { Task task = new Task(); SimpleCallback callback = new CallbackHandler(); System.out.println(\"開始執行任務...\"); task.executeTask(callback); System.out.println(\"任務已啟動 (非同步執行)\"); } }"
  },"/pages/design_pattern/deepclone/": {
    "title": "DeepClone",
    "keywords": "",
    "url": "/pages/design_pattern/deepclone/",
    "body": "Prerequisites: ByteArray串流 序列化與反序列化 芭比工廠要生廠100隻一模一樣的芭比與肯尼，二隻娃娃一起放在盒子中賣。請問如何寫？ Barbie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.io.*; public class Barbie implements Serializable { public String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Ken ken; public Ken getKen() { return ken; } public void setKen(Ken ken) { this.ken = ken; } public Barbie deepclone() { // 寫到記憶體緩衝區 ByteArrayOutputStream bos = null; // 物件裝飾串流 ObjectOutputStream oos = null; // 讀取記憶體緩衝區 ByteArrayInputStream bis = null; // 讀取物件 ObjectInputStream ois = null; try { // 建立串流 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 物件寫到記憶體緩衝區 oos.writeObject(this); // toByteArray() 將記憶體緩衝區複製到byte[]傳回 // 建立讀取串流 bis = new ByteArrayInputStream(bos.toByteArray()); // 讀取物件 ois = new ObjectInputStream(bis); // readObject()是Object物件 // 向下轉型成Barbie才能使用Barbie的方法 Barbie copy = (Barbie) ois.readObject(); return copy; } catch (Exception e) { e.printStackTrace(); return null; } finally { try { // 只需要關閉裝飾串流，詳見裝飾串流文章 ois.close(); oos.close(); } catch (Exception e) { e.printStackTrace(); } } } } Ken 1 2 3 4 5 6 7 8 9 public class Ken implements Serializable { public String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test { public static void main(String[] args) { Barbie barbie = new Barbie(); barbie.setName(\"經典芭比\"); Ken ken = new Ken(); ken.setName(\"Sugar Daddy 肯尼\"); barbie.setKen(ken); //複製3隻經典芭比 Barbie barbie1 = barbie.deepclone(); System.out.println(barbie1.getName() + \"/\" + barbie1.getKen().getName() + \"/hashcode:\" + barbie1.hashCode()); Barbie barbie2 = barbie.deepclone(); System.out.println(barbie2.getName() + \"/\" + barbie2.getKen().getName() + \"/hashcode:\" + barbie2.hashCode()); Barbie barbie3 = barbie.deepclone(); System.out.println(barbie3.getName() + \"/\" + barbie3.getKen().getName() + \"/hashcode:\" + barbie3.hashCode()); } } 經典芭比/Sugar Daddy 肯尼/hashcode:1673605040 經典芭比/Sugar Daddy 肯尼/hashcode:693632176 經典芭比/Sugar Daddy 肯尼/hashcode:326549596"
  },"/pages/java/abstract/": {
    "title": "抽象",
    "keywords": "",
    "url": "/pages/java/abstract/",
    "body": "Prerequisites: 多型 抽象類別 用關鍵字abstract修飾的類別稱為抽象類別(abstract class) 1 2 abstract class Parent { } 抽象方法 在方法傳回值類型前面加上abstract，注意!最後面不能有花括號{}方法主體，直接以分號;結束。 1 abstract int speak(); 為什麼要使用抽象類別？ 有一些方法還沒想到內容要怎麼寫，所以就先不寫，由繼承的子類別去覆蓋掉原本的抽象方法。 以下的程式碼，不知道人類要說什麼語言，因為不知道，就先不寫，由繼承的子類別去覆蓋speak()方法，也許子類別就知道要說什麼語言。 1 2 3 abstract class Human { public abstract void speak(); } 抽象類別不能new，不能建立 不能使用new來建立類別。 以下是人的抽象類別。 1 2 3 abstract class Human { abstract void speak(); } 以下語法會編譯錯誤，抽象類別不能new，不能建立。 1 Human human = new Human(); 抽象類別繼承抽象類別 抽象繼承抽象，不用覆寫。 以下是抽象「亞洲人」繼承「人」，不用覆寫speak()的方法。 因為亞洲人種很多，不確定是會說什麼語言，所以先不覆蓋speak()方法。 1 2 abstract class Asian extends Human{ } 子類別繼承抽象類別 中國人繼承抽象類別，就一定要覆寫抽象方法，因為很明確知道說什麼語言。 1 2 3 4 5 6 public class Chinese extends Asian{ @Override void speak() { System.out.println(\"說中文\"); } } 抽象類別中可以有「非」抽象方法 以下是人的類別，但是有睡覺這個非抽象方法，所有身為人一定會有的共同行為，只要是繼承Human，都一定擁有這個sleep()的方法。 1 2 3 4 5 6 7 abstract class Human { abstract void speak(); // 非抽象方法 void sleep() { System.out.println(\"作夢\"); } } 抽象類別多型 多型，類型是父類別，但實際上指向的是子類別物件。 以下類型是Human,實際上是Chinese。 1 2 3 4 5 6 public class Teest { public static void main(String[] args) { Human obj1 = new Chinese(); obj1.speak(); } } 抽象類別多型範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test { public static void main(String[] args) { // 抽象類別的物件指向美國人 Human human = new American(); // 使用子類別覆寫抽象類別的方法 human.speak(); // 抽象類別的物件指向中國人 human = new Chinese(); // 使用子類別覆寫抽象類別的方法 human.speak(); // 抽象類別的物件指向日本人 human = new Japanese(); // 使用子類別覆寫抽象類別的方法 human.speak(); } } OOP原則 為什麼要使用父類別物件指向子類別，而不是使用子類別指向子類別物件？ 根據設計模式原則，寫程式是針對抽象、介面而寫，而不是針對類別而寫。 以下建立一個聲音播放器物件，可以接收不同國家的人的說話聲音。 1 2 3 4 5 6 7 8 9 public class RedioPlayer { private Human speaker; public void setSpeaker(Human speaker) { this.speaker = speaker; } public void play() { speaker.speak(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { RedioPlayer player = new RedioPlayer(); // 說中文的播放器 player.setSpeaker(new Chinese()); player.play(); // 說英文的播放器 player.setSpeaker(new American()); player.play(); // 說日文的播放器 player.setSpeaker(new Japanese()); player.play(); } } 說中文 speak english. 說日文 若讓型別指向底層類別，這個播放器就要為setSpeaker()方法設置各國人的參數。 1 2 3 4 5 public void setSpeaker(Chinese speaker) {} public void setSpeaker(American speaker) {} public void setSpeaker(Japanese speaker) {} public void setSpeaker(Korean speaker) {} public void setSpeaker(Spanish speaker) {}"
  },"/pages/java/anonymous_class/": {
    "title": "匿名類別",
    "keywords": "",
    "url": "/pages/java/anonymous_class/",
    "body": "Prerequisites: 多型 抽象類別 介面 抽象類別的匿名子類別 建立抽象類別Human，與抽象方法speak() 1 2 3 abstract class Human { abstract void speak(); } 建立一個簡單的類別TestHuman，類別中有一個test()方法。 參數是Human類別，用來測試多型，只要是Human的子類別，都可以作為參數傳入。 1 2 3 4 5 public class TestHuman { void test(Human human) { human.speak(); } } 建立TestHuman物件，並使用test()方法 1 2 3 4 5 6 public class Test { public static void main(String[] args) { TestHuman testHuman = new TestHuman(); testHuman.test(要在這裡建立匿名類別); } } 匿名的方式建立子類別1 語法 new 抽象類別() {} 呼叫test()，參數為new 抽象類別() {} 1 testHuman.test(new 抽象類別 () {}); 在花括號{}中，覆寫speak() 1 2 3 4 5 6 testHuman.test(new Human() { @Override void speak() { } }); 加上要覆寫的內容 1 2 3 4 5 6 7 testHuman.test(new Human() { @Override void speak() { // 覆寫的內容 System.out.println(\"說中文\"); } }); 說中文 匿名花括號{} 在上一段程式碼利用花括號{}建立沒有名字的繼承抽象類別的子類別，可以視為花括號{}中的內容是子類別的body。 { 子類別的body } 匿名的方式建立子類別2 宣告japan變數為父類別Human new 父類別Human() 加上花括號{} 覆寫speak方法 此時japan就是Human的子類別 1 2 3 4 5 6 7 Human japan = new Human() { @Override void speak() { System.out.println(\"說日文\"); } }; japan.speak(); 說日文 匿名的方式建立子類別3 new 父類別Human() 加上花括號{} 覆寫speak方法 1 2 3 4 5 6 new Human() { @Override void speak() { System.out.println(\"說日文\"); } }.speak(); 說日文 類別的匿名子類別 除了抽象類別建立的匿名類別，一般類別也可以透過匿名的方式建立子類別 建立一個Car類別，裡面有一個print()方法。 1 2 3 4 5 public class Car { public void print() { System.out.println(\"car\"); } } 建立「匿名」Car的子類別，注意！加上花括號{}，表達的不是Car這個類別，而是繼承Car的子類別。 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Car toyota = new Car() { @Override public void print() { System.out.println(\"我是Toyota\"); } }; toyota.print(); } 我是Toyota 1 2 3 4 5 6 7 8 public static void main(String[] args) { new Car() { @Override public void print() { System.out.println(\"我是Toyota\"); } }.print(); } 我是Toyota 方法參數為匿名類別 建立一個測試參數為Car的類別，TestCar.java 1 2 3 4 5 public class TestCar { public void test(Car car) { car.print(); } } 方法參數為「匿名」Car的子類別，注意！加上花括號{}，表達的不是Car這個類別，而是繼承Car的子類別，即便{}花括號的內容是空的，這裡的意思是子類別，不是Car這個類別，Car變成父類別，這個沒有名字的子類別擁有父類別繼承來的print()方法。 1 2 3 4 5 public static void main(String[] args) { TestCar testCar = new TestCar(); // 建立Car的子類別 testCar.test(new Car() {}); } car 覆寫(重寫)繼承Car的子類別的print()方法 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { TestCar testCar = new TestCar(); testCar.test(new Car() { @Override public void print() { System.out.println(\"我是Toyota\"); } }); } 我是Toyota 介面(Interface)的匿名類別 建立一個Fly介面 1 2 3 public interface Fly { void fly(); } 介面匿名步驟: new 介面() 加上花括號{} 覆寫fly方法 透過new 介面() {} 的方式，建立介面的匿名類別 方式1: 1 2 3 4 5 6 new Fly() { @Override public void fly() { System.out.println(\"蚊子飛\"); } }.fly(); 蚊子飛 方式2: 1 2 3 4 5 6 7 8 9 public static void main(String[] args) { Fly mosquito = new Fly() { @Override public void fly() { System.out.println(\"蚊子飛\"); } }; mosquito.fly(); } 蚊子飛"
  },"/pages/java/callby_value/": {
    "title": "Call by value",
    "keywords": "",
    "url": "/pages/java/callby_value/",
    "body": "Prerequisites: 記憶體模型 引數與參數 一進入方法，若引數是物件，也就是記憶體位址，參數複製傳進來的引數，稱為Call by value。 修改成員變數 以下的程式碼要傳遞testClz變數給copyAddress()方法。 TestClz 1 2 3 class TestClz { public int age; } Test 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { Test test = new Test(); TestClz testClz = new TestClz(); testClz.age = 50; // 把testClz傳進copyAddress() test.copyAddress(testClz); System.out.println(testClz.age); } public void copyAddress(TestClz arg1) { arg1.age = 100; } } 「複製」testClz變數「記憶體位址」給arg1變數(參考下圖)。 arg1存的0x0033 testClz變數存的0x0033 arg1存的0x0033與testClz變數存的0x0033一樣，所以修改arg1.age，也就是修改0x0033記憶體位址中的物件。 1 arg1.age = 100; 執行結果為100 100 參數設成新的記憶體位址 TestClz 1 2 3 class TestClz { public int age; } Test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { Test test = new Test(); TestClz testClz = new TestClz(); testClz.age = 50; test.copyAddress(testClz); System.out.println(testClz.age); } public void copyAddress(TestClz arg1) { // 參數設成新的記憶體位址 arg1 = new TestClz(); arg1.age = 60; } } 參數arg1存其它記憶體位址。 1 arg1 = new TestClz(); arg1存的0x0066與testClz變數存的0x0033不一樣，所以修改arg1.age，也就是修改0x0066記憶體位址中的物件，而不是修改0x0033記憶體中的物件。 執行結果是50 50 執行完copyAddress()方法後，參數arg1就會被記憶體釋放，包含0x0066也會被記憶體釋放，所謂的記憶體釋放就是把arg1設為null，JVM發現有變數指向null，就會把這個變數刪掉，不浪費記憶體空間。 下圖中，離開copyAddress()方法後，Stack堆疊已經沒有arg1參數，Heap堆也沒有0x0066。 此處是「複製記憶體位址」到「參數」中，並非「指向」記憶體位址，跟C++的call by address與call by reference完全不同的概念。 畫圖檔案名稱為func_copy_address.drawio"
  },"/pages/java/extends_memory/": {
    "title": "繼承Memory Layout",
    "keywords": "",
    "url": "/pages/java/extends_memory/",
    "body": "Prerequisites: Java Memory Model 建構子 子類別、父類別、祖父類別 1 2 3 4 5 6 7 8 9 class GrandPa { String name = \"GrandPa\"; } class Father extends GrandPa{ String name = \"Father\"; } class Child extends Father{ String name = \"Child\"; } 建立子類別 1 2 3 4 5 public class Test { public static void main(String[] args) { Child child = new Child(); } } 建立步驟 new Child()，發現子類別有父類別，依下方順序載入metadata到記憶體中。 GrandPa Metadata Father Metadata Child Metadata 建立子類別 建立子類別記憶體空間 變數child指向記憶體空間。 根據建構子，預設會先呼叫祖父建構子，建立祖父物件。 先在String Pool中建立GrandPa的文字 name指向String Pool中的記憶體位址。 呼叫父類別建構子，建立物件。 先在String Pool中建立Father的文字 name指向String Pool中的記憶體位址。 建立Child物件。 先在String Pool中建立Child的文字。 name指向String Pool中的記憶體位址。"
  },"/pages/java/innerclass/": {
    "title": "內部類別",
    "keywords": "",
    "url": "/pages/java/innerclass/",
    "body": "內部類別與外部類別 在一個類別中，宣告一個類別，這個類別就是內部類別。 包含內部類別的類別稱為外部類別。 內部類別是外部類別的成員。 所謂的成員，就像是屬性、方法，都屬於類別的成員。 1 2 3 4 5 public class Outter { //外部類別 public class Inner{ // 內部類別 } } 內部類別是一個類別 一般類別該有的存取權限(public、private、protected、default)、屬性、方法、建構子、匿名程式碼區塊、靜態程式碼區塊、靜態變數、靜態方法…等等，內部類別也有。 建立內部類別 使用new建立內部類別 先建立外部類別物件 建立方式如下 外部類別.內部類別 inner = 外部類別物件.new 內部類別() 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.new Inner();; } } class Outter { //外部類別 // 內部類別 public class Inner { } } 外部類別提供public方法 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.getInner(); } } class Outter { //外部類別 public Inner getInner() { return new Inner(); } public class Inner {} } 外部類別的成員屬性是內部類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { Outter outter = new Outter(); // 直接使用內部類別 outter.inner.print(); } } class Outter { public Inner inner; // 成員屬性是內部類別 public class Inner{ void print() {} } public Outter() { // 建立Outter物件的時候，建立內部類別 inner = new Inner(); } } 外部類別可以存取private內部類別與屬性 內部類別權限設為private，代表只有外部類別可以存取，其它類別不能存取內部類別。 以下程式碼呼叫private方法與使用private內部類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test { public static void main(String[] args) { Outter outter = new Outter(); outter.callInner(); } } class Outter { //外部類別 public void callInner() { // 建立private內部類別物件 Inner inner = new Inner(); // 呼叫private方法 inner.print(); } private class Inner { private void print() { System.out.println(\"私有內部類別的方法\"); } } } 私有內部類別的方法 內部類別建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.new Inner();; } } class Outter { //外部類別 public class Inner{ Inner() { System.out.println(\"內部類建構子\"); } } } 內部類建構子 內部類別可以存取外部類別所有屬性 外部類別的private變數、方法、靜態變數、靜態方法，在內部類別是可以存取。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); inner.print(); } } class Outter { private String name = \"變數\"; private static String staticval = \"靜態變數\"; private static void staticMethod() { System.out.println(\"靜態方法\"); } private void method1() { System.out.println(\"方法\"); } public class Inner{ void print() { // 呼叫外部private方法 method1(); // 使用外部private變數 System.out.println(name); // 呼叫外部private靜態方法 staticMethod(); // 外部private靜態變數 System.out.println(staticval); } } } 方法 變數 靜態方法 靜態變數 內部類別繼承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Test { public static void main(String[] args) { Outter outter = new Outter(); outter.callInnerChild(); } } class Outter { // 內部類別 private class Inner{ void print() {} } // 繼承內部類別 private class InnerChild extends Inner { // 覆寫父類別的print() @Override void print() { System.out.println(\"test\"); } } public void callInnerChild() { // 建立private內部類 InnerChild innerChild = new InnerChild(); // 呼叫覆寫的方法 innerChild.print(); } } test 內部類別與外部類別屬性名字相同 內部類別有name，外部類別有name，使用Outter.this，就可以在內部類別取得外部類別的物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); inner.print(); } } class Outter { // 外部類別name private String name = \"Outter\"; public class Inner { // 內部類別name public String name = \"Inner\"; public void print() { // 印出內部類別name System.out.println(\"Inner name = \" + name); // 印出外部類別name System.out.println(\"Outter name = \" + Outter.this.name); } } } Inner name = Inner Outter name = Outter 外部類別.this Outter.this與建立outter物件，hashCode都是一模一樣，為相同的物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); System.out.println(outter.hashCode()); inner.print(); } } class Outter { private String name = \"Outter\"; public class Inner { public String name = \"Inner\"; public void print() { System.out.println(\"Inner = \" + Outter.this.hashCode()); } } } 989110044 Inner = 989110044 區域內部類別 定義在方法或匿名程式碼區塊中的類別 不能使用 public、private 或 protected 修飾 只能被該方法或匿名程式碼區塊的程式碼使用。 方法中的內部類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public void method1() { // 內部類別 class LocalInner { public void method() { System.out.println(\"區域內部類別中的方法\"); } } LocalInner localInner = new LocalInner(); localInner.method(); } public static void main(String[] args) { Test2 test = new Test2(); test.method1(); } } 區域內部類別中的方法 程式碼區塊的內部類別 將內部類別寫在static{}靜態程式碼區塊中。 不管建立幾次Test物件，在靜態程式碼區塊只執行一次，所以內部類別只被建立一次。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { static { class Inner { public void method() { System.out.println(\"呼叫內部類別方法\"); } } Inner inner = new Inner(); inner.method(); } public static void main(String[] args) { // 建立3次物件 Test test1 = new Test(); Test test2 = new Test(); Test test3 = new Test(); } } 呼叫內部類別方法 區域內部類別繼承 區域內部類別可以被繼承。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test { public void method1() { class LocalInner { public void method() { System.out.println(\"區域內部類別中的方法\"); } } class InnerChild extends LocalInner{ @Override public void method() { System.out.println(\"子類別覆寫\"); } } LocalInner child = new InnerChild(); child.method(); } public static void main(String[] args) { Test test = new Test(); test.method1(); } } 子類別覆寫"
  },"/pages/java/interface/": {
    "title": "介面",
    "keywords": "",
    "url": "/pages/java/interface/",
    "body": "什麼是Interface? 介面(Interface)可以想成是「功能」，但功能的內容由實作(implements)的類別自己去完成。 實作介面的子類別，這個關係有點像是繼承，但不能把這個稱為繼承。 有一個Fly飛的功能，飛機去實作怎麼飛的功能，可以把飛機說它是一個Fly飛嗎？ 只能說飛機可以像鳥一樣飛，Fly like a bird。 這是一個like a的關係，像…什麼什麼…一樣，有它的功能。 不能因為鳥有飛的功能，就把飛機繼承鳥。 1 2 3 class AirPlane extends Bird { } 飛機跟鳥，不是Is A(是一個)，飛機不是一個鳥。 但飛機可以像鳥一樣飛，是Like A(像一個)的關係。 建立介面Interface 使用關鍵字interface來宣告這是一個介面(Interface)，這個介面(Interface)的名字是Fly。 1 2 public interface Fly { } 屬性 介面的屬性存取權限一定是public，只能是final與static，final是無法再被實作的子類別修改，static是靜態屬性，static + final就是常數constant。 可以省略public final static，編譯會自動加上。 1 2 3 4 5 public interface Fly { public final static int VERSION = 1; // 上面這句與以下相等，二者是相同意思。 // int VERSION = 1; } 使用介面.屬性 1 System.out.println(Fly.VERSION); 無法再被更改。 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { System.out.println(Fly.VERSION); // 以下會編譯失敗，因為是final，不可再被更改。 Fly.VERSION = \"addfdf\"; } } 抽象方法 介面中的方法不寫內容，所以用分號;來結尾，由子類別去實作方法。 抽象方法存取權限一定是public，因為設為private就沒有辦法給子類別實作。 編譯器會自動加上為方法加上public、abstract。 1 2 3 4 5 public interface Fly { void fly(); // 上面這句與以下相等，二者是相同意思。 // public abstract void fly(); } 實作 所謂的實作就是把介面的抽象方法覆蓋掉，覆寫一個屬於自己的方法，即便內容是空的，只有花括號{}包住，也是覆寫。 使用implements關鍵字實作Fly介面，並且一定要覆寫(Override)抽象方法fly() 1 2 3 4 5 6 public class Airplane implements Fly{ @Override public void fly() { // 即便內容是空的，只有花括號包住，也是覆寫。 } } 實作多個Interface implements Fly, Swim 以上語法使用逗號隔開不同介面，Fly, Swim都是介面(Interface)。 1 2 3 4 5 6 7 8 public class Duck implements Fly, Swim{ // 覆寫Fly介面的fly()方法 @Override public void fly() {} @Override public void swim() {} } 介面的範例 飛的功能 1 2 3 public interface Fly { void fly(); } 游泳的功能 1 2 3 public interface Swim { void swim(); } 飛機實作飛的功能 1 2 3 4 5 6 public class AirPlane implements Fly { @Override public void fly() { System.out.println(\"飛機用引擎飛\"); } } 鴨子實作飛與游泳的功能 1 2 3 4 5 6 7 8 9 10 11 public class Duck implements Fly, Swim{ @Override public void fly() { System.out.println(\"鴨子用翅膀飛\"); } @Override public void swim() { System.out.println(\"鴨子用腳掌划\"); } } 狗實作游泳的功能 1 2 3 4 5 6 public class Dog implements Swim { @Override public void swim() { System.out.println(\"狗游狗爬式\"); } } 潛水艇實作游泳功能 1 2 3 4 5 6 public class Submarine implements Swim{ @Override public void swim() { System.out.println(\"潛水艇會潛水\"); } } 測試程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { AirPlane airPlane = new AirPlane(); airPlane.fly(); Duck duck = new Duck(); duck.swim(); duck.fly(); Submarine submarine = new Submarine(); submarine.swim(); Dog dog = new Dog(); dog.swim(); } } 飛機用引擎飛 鴨子會游泳 鴨子用翅膀飛 潛水艇會潛水 狗游狗爬式 多型 什麼是編譯類型？什麼是執行類型？ 下方的程式碼，等號左邊是編譯類型，等號右邊是執行類型。 1 2 3 編譯類型 = 執行類型 Fly bird = new Bird(); Fly airplane = new Airplane(); 介面作為類型，可以指向實作Fly介面的子類別。 雖然編譯類型是介面，但執行時指向的是實作介面的子類別。 呼叫介面的fly()，實際上是呼叫子類別的fly()。 1 2 Fly bird = new Bird(); bird.fly(); 介面多型陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test { public static void main(String[] args) { // 介面作為類型，只要是實作Fly的子類別都可以放進這個陣列 Fly[] arr = new Fly[2]; arr[0] = new AirPlane(); arr[1] = new Bird(); for (Fly obj : arr) { obj.fly(); } } } class AirPlane implements Fly { @Override public void fly() { System.out.println(\"飛機飛\"); } } class Bird implements Fly { @Override public void fly() { System.out.println(\"鳥會飛\"); } } 飛機飛 鳥會飛 判斷子類別 飛機有一個呼叫塔台的功能。 1 2 3 4 5 6 7 8 9 10 class AirPlane implements Fly { @Override public void fly() { System.out.println(\"飛機飛\"); } public void call() { System.out.println(\"呼叫塔台\"); } } 使用instanceof與強制轉型成子類別，就可以呼叫子類別的方法。因為Fly介面只有fly()方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { Fly[] arr = new Fly[2]; arr[0] = new AirPlane(); arr[1] = new Bird(); for (Fly obj : arr) { if (obj instanceof AirPlane) { ((AirPlane) obj).call(); } obj.fly(); } } } 介面的多型(參數) 寫一個fly()方法，參數是有實作Fly的類別都可以放進來。 寫一個Swim()方法，參數是有實作Swim的類別都可以放進來。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test { public void fly(Fly something) { something.fly(); } public void swim(Swim something) { something.swim(); } public static void main(String[] args) { Test test = new Test(); test.fly(new AirPlane()); test.fly(new Duck()); test.swim(new Duck()); test.swim(new Submarine()); test.swim(new Dog()); } } 飛機用引擎飛 鴨子用翅膀飛 鴨子會游泳 潛水艇會潛水 狗游狗爬式 由以上可以發現，介面跟繼承是完全不同的概念，類別(AirPlane)實作介面(Fly)的抽象方法(fly)，AirPlane就是介面(Fly)。 介面的多型 建立一個Operator運算子的介面，介面中有抽象的計算方法calculate() Operator.java 1 2 3 4 // 運算子 public interface Operator { int calculate(int x, int y); } 加法運算子，實作Operator介面，覆寫calculate()方法 1 2 3 4 5 6 public class Add implements Operator{ @Override public int calculate(int x, int y) { return x + y; } } 減法運算子，實作Operator介面，覆寫calculate()方法 1 2 3 4 5 6 public class Minus implements Operator{ @Override public int calculate(int x, int y) { return x - y; } } 乘法運算子，實作Operator介面，覆寫calculate()方法 1 2 3 4 5 6 public class Multiply implements Operator{ @Override public int calculate(int x, int y) { return x * y; } } 計算機，注意！calculate的第1個參數是Operator介面，也就是只要有實作Operator的類別(加法運算子、減法運算子、乘法運算子)都可以丟進去。 1 2 3 4 5 public class Calculator { public int calculate(Operator operator, int x, int y) { return operator.calculate(x,y); } } 主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void main(String[] args) { // 建立計算機 Calculator calculator = new Calculator(); int x = 10; int y = 5; // 加法，第1個參數把實作Operator介面的Add類別丟進去 int add_result = calculator.calculate(new Add(), x, y); System.out.println(x + \"+\" + y + \" = \" + add_result); // 減法，第1個參數把實作Operator介面的Minus類別丟進去 int minus_result = calculator.calculate(new Minus(), x, y); System.out.println(x + \"-\" + y + \" = \" + minus_result); // 乘法，第1個參數把實作Operator介面的Multiply類別丟進去 int multiply_result = calculator.calculate(new Multiply(), x, y); System.out.println(x + \"*\" + y + \" = \" + multiply_result); } 10+5 = 15 10-5 = 5 10*5 = 50 由上面例子發現，Operator介面可以是Add，可以是Minus、Multiply，類別只要實作Operator介面，這個類別就是Operator。 Interface的default方法、static方法 jdk1.8之後有default方法、static方法。 前面有提過，介面有一點像繼承的關係，但又不是繼承，因為有一點像繼承，所以實作介面的子類別，都會自動擁有父介面的方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface Fly { int VERSION = 0; // 抽象方法 void fly(); // default方法 default void dosomething() { fly(); } // 靜態方法 static void print() { System.out.println(VERSION); } } 鳥實作Fly介面。 1 2 3 4 5 6 class Bird implements Fly { @Override public void fly() { System.out.println(\"鳥會飛\"); } } 測試 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { Bird bird = new Bird(); // 鳥類擁有介面的屬性與方法 bird.dosomething(); } } 鳥會飛 但物件沒有擁有介面的屬性，使用介面的屬性，仍是要用「類別.介面屬性」或「介面.屬性」。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Fly bird = new Bird(); System.out.println(Bird.VERSION); } }"
  },"/pages/java/static/": {
    "title": "Static",
    "keywords": "",
    "url": "/pages/java/static/",
    "body": "Prerequisites: Memory Model metadata Classloader類別載入 靜態變數 在類別中，除了有成員變數之外，靜態變數也是類別的成員之一。 什麼是靜態變數？靜態變數指向metadata中一個儲存靜態變數「值」的記憶體位址，只儲存值，所有物件的靜態變數都指向同一個記憶體位址。 靜態變數的建立 Student類別載入至記憶體，會在Metaspace建立metadata，裡面包含有Student類別所有屬性名、方法名、建構子、靜態變數名、靜態變數「值」。 count靜態變數此時為0。 靜態變數的Memory Model 在Heap中建立記憶體位址是0x0022的記憶體空間，Stack的s1變數指向0x0022。 建構子把靜態變數count++ 把metadata中的儲存靜態變數的「值」+1。 s1中的count屬性的記憶體位址是指向metadata中的儲存靜態值的位址0x0011。 在Heap中建立記憶體位址是0x0044的記憶體空間，Stack的s2變數指向0x0044。 建構子把靜態變數count++ 把metadata中的儲存靜態變數的「值」+1。 s2中的count屬性的記憶體位址是指向metadata中的儲存靜態值的位址0x0011。 由上圖知道，s1與s2的count屬性，指向的記憶體位址都是0x0011，共用同一個記憶體位址。 建立3個學生，並統計數量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Test { public static void main(String[] args) { Student s1 = new Student(\"Mary\"); Student s2 = new Student(\"Bill\"); Student s3 = new Student(\"Andy\"); System.out.println(s1.getName() + \":\" + s1.getCount()); System.out.println(s2.getName() + \":\" + s2.getCount()); System.out.println(s3.getName() + \":\" + s3.getCount()); } } class Student { private String name; private static int count; public Student (String name) { this.name = name; count++; } public String getName() { return name; } public int getCount() { return count; } } Mary:3 Bill:3 Andy:3 靜態變數使用方法 語法 類別名.靜態變數 物件.靜態變數 大部分都是使用「類別名.靜態變數」。 也可以使用「物件.靜態變數」，在Memory Model中，物件的靜態變數的記憶體位址，也是指向Mataspace中metadata靜態變數「值」的記憶體位址。 1 2 3 4 5 6 public class Test { public static String static_name = \"靜態變數\"; public static void main(String[] args) { System.out.println(Test.static_name); } } 靜態變數 靜態方法 語法 類別名.靜態方法() 靜態方法屬於類別的方法，只能存取靜態變數與靜態方法，通常作為工具類別，進行跟物件無關的操作。 1 2 3 4 5 6 7 8 public class Test { public static void staticMethod1() { System.out.println(\"靜態方法\"); } public static void main(String[] args) { Test.staticMethod1(); } } 靜態方法 靜態區塊 語法 1 2 3 static { System.out.println(\"靜態區塊\"); } 建構子的文章中，提到建立物件會先呼叫「匿名區塊」，才呼叫建構子。 那如果加上靜態區塊？誰先執行？答案是靜態區塊先執行，然後才是匿名區塊，最後是建構子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test { // 靜態區塊 static { System.out.println(\"靜態區塊\"); } { System.out.println(\"匿名區塊\"); } Test() { System.out.println(\"建構子區塊\"); } public static void main(String[] args) { Test test1 = new Test(); } } 靜態區塊 匿名區塊 建構子區塊 靜態只產生一次 把前一個程式碼的main主程式改成下方，會發現靜態區塊只產生一次。 1 2 3 4 public static void main(String[] args) { Test test1 = new Test(); Test test2 = new Test(); } 靜態區塊 匿名區塊 建構子區塊 匿名區塊 建構子區塊 由以上結果可知，執行2次new建立物件，但「靜態區塊」只會產生一次，不管建立多少次物件，靜態變數、靜態方法、靜態區塊，只會產生一次。 靜態方法只能存取靜態變數、靜態方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class StaticExample { public static String static_name = \"static_name\"; public String name = \"name\"; public static void staticMethod1() { System.out.println(\"呼叫靜態方法:\"); staticMethod2(); System.out.println(\"印出靜態變數:\" + static_name); } public static void staticMethod2() { System.out.println(\"呼叫 staticMethod2()\"); } public static void main(String[] args) { StaticExample.staticMethod1(); } } 呼叫靜態方法: 呼叫 staticMethod2() 印出靜態變數:static_name 成員方法可以存取靜態變數、靜態方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class StaticExample { public static String static_name = \"static_name\"; public String name = \"name\"; public static void staticMethod1() { System.out.println(\"呼叫靜態方法:\"); staticMethod2(); System.out.println(\"印出靜態變數:\" + static_name); } public static void staticMethod2() { System.out.println(\"呼叫 staticMethod2()\"); } public void method1() { System.out.println(\"印出成員變數:\" + name); System.out.println(\"呼叫靜態方法:\"); staticMethod2(); System.out.println(\"印出靜態變數:\" + static_name); } public static void main(String[] args) { StaticExample example = new StaticExample(); example.method1(); } } 印出成員變數:name 呼叫靜態方法: 呼叫 staticMethod2() 印出靜態變數:static_name main主程式也是靜態方法 main主程式也是靜態方法，可以直接存取類別的靜態方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class StaticExample { public static String static_name = \"static_name\"; public String name = \"name\"; public static void staticMethod1() { System.out.println(\"呼叫靜態方法:\"); staticMethod2(); System.out.println(\"印出靜態變數:\" + static_name); } public static void staticMethod2() { System.out.println(\"呼叫 staticMethod2()\"); } public void method1() { System.out.println(\"印出成員變數:\" + name); System.out.println(\"呼叫靜態方法:\"); staticMethod2(); System.out.println(\"印出靜態變數:\" + static_name); } public static void main(String[] args) { staticMethod1(); } } 呼叫靜態方法: 呼叫 staticMethod2() 印出靜態變數:static_name"
  },"/pages/java/amateras/": {
    "title": "安裝Amateras",
    "keywords": "",
    "url": "/pages/java/amateras/",
    "body": "參考以下文章: https://blog.csdn.net/2401_84160087/article/details/137486030 輸入http://download.eclipse.org/tools/gef/updates/releases/ 輸入https://takezoe.github.io/amateras-update-site/ 加在eclipse.ini最下面 --add-opens=java.desktop/java.beans=ALL-UNNAMED 建立類別圖 點擊類別，滑鼠右鍵增加成員屬性與方法"
  },"/pages/java/uml/": {
    "title": "UML類別圖",
    "keywords": "",
    "url": "/pages/java/uml/",
    "body": "類別圖製作工具 https://app.diagrams.net/ 安裝Amateras 使用Eclipse的plugin: Amateras 成員屬性與方法增加 此處的成員屬性就是成員變數，二者意思相同 此處的成員方法就是成員函式，二者意思相同 Add Attribute增加成員變數 Add Operation增加方法 成員屬性與方法 注意！冒號:後面會空一格 屬性 名稱: 類型 name: String 方法 方法名(參數名: 參數類型): 傳回值類型 setName(name: String): void getName(): String 存取權限 + public - private # protected ~ default(package) 本篇類別圖如同「Head First Design Patterns」深入淺出設計模式一書中，都不用存取權限修飾子符號。 關係 依賴、組合、聚合，都是在描述類別與類別之間的關係。 依賴 在類別中「用到」其它類別就是依賴。 A類別「用到」B類別，箭頭圖:A類別 -&gt; B類別 圖中灰色的箭頭線 依賴有以下方式: 方法參數 方法傳回值 區域變數 A類別 1 2 3 4 5 6 public class A { // 方法參數用到B類別 void doBmethod(B b) { b.method1(); } } B類別 1 2 3 4 5 6 7 8 9 10 11 public class B { void method1() { System.out.println(\"B method1 do something.\"); } void method2() { System.out.println(\"B method2 do something.\"); } void method3() { System.out.println(\"B method3 do something.\"); } } 聚合 聚合的方式，使用成員屬性與setter方法 下圖中，A類有一個B的屬性與setB()方法，空心菱形圖案代表聚合，把B聚合給A，菱形放在目標對象，A是目標對象，B當作來源。 A類別 1 2 3 4 5 6 public class A { B b; void setB(B b) { this.b = b; } } B類別與上述的一樣，不再另寫程式碼。 組合 組合的意思代表一個類別建立，也會把另一個類別建立，二個類別不可分開。 建立A類別的時候，也把B類別new出來，並把B類別設給成員屬性。 A類別建構子中建立B類別，也是屬於組合的關係。 下圖中，A類別有一個B的屬性，黑色實心菱形圖案代表組合，把B組合給A，菱形放在目標對象，A是目標對象，B當作來源。 A類別 1 2 3 public class A { B b = new B(); } 若是用建構子，也屬於組合，A類別建立的時候，需要B類別，二者為生死相隨，不可分離，一起建立，一起被記憶體回收。 A類別 1 2 3 4 5 6 public class A { private B b; public A(B b) { this.b = b; } } B類別與上述的一樣，不再另寫程式碼。 關聯關係 有箭頭代表示單方面擁有這個類別，沒箭頭代表二邊都擁有彼此的類別。 1對1單向(有箭頭) 圖中會在線的二端各寫上1，屬性名稱-b A類別擁有B類別成員屬性 1 2 3 public class A { B b; // A類別擁有B類別成員屬性 } B類別沒有A類別成員屬性 1 2 3 public class B { } 1對1雙向(沒箭頭) 圖中會在線的二端各寫上1，屬性名稱-a與-b A類別擁有B類別成員屬性 1 2 3 public class A { B b; // A類別擁有B類別成員屬性 } B類別擁有A類別成員屬性 1 2 3 public class B { A a; // B類別擁有A類別成員屬性 } 繼承 線條是實線 A類別 1 2 public class A { } B類別 1 2 public class B extends A{ } 實作 線條為虛線 A類別 1 2 interface A { } B類別 1 2 public class B implements A{ } 抽象類別覆寫 線條為虛線 1 2 3 4 5 6 7 8 9 10 public abstract class Shape { abstract void draw(); } public class Circle extends Shape { @Override void draw() { System.out.println(\"畫一個圓\"); } } 說明 下圖有一個說明方框還有線，描述這個類別是做什麼的，注意線要為虛線。"
  },"/pages/design_pattern/depend_inverse/": {
    "title": "依賴反轉原則",
    "keywords": "",
    "url": "/pages/design_pattern/depend_inverse/",
    "body": "Prerequisites: 類別圖 多型 介面 抽象 概念 英文Dependence Inversion Principle， Abstractions should not depend on details. Details should depend on abstractions. 依賴抽象，不要依賴具體類別。 這裡的抽象包括介面，因為介面中都是抽象方法。 也跟之前提到「寫程式是針對抽象、介面而寫，而不是針對實踐方式(具體類別)而寫」，是一樣的意思。 未優化前程式碼 以下程式碼，Person收到e-mail訊息並把訊息顯示出來。 1 2 3 4 5 6 7 8 9 10 11 class Email { void getInfo() { System.out.println(\"e-mail\"); } } class Person { void receive(Email email) { email.getInfo(); } } main主程式 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Person person = new Person(); person.receive(new Email()); } } 優化思維 請問，若今天要收到Line、收到手機簡訊、收到FB的Message請問要怎麼做？是改成如下的方式嗎？那如果有100個通訊軟體，要一直寫100個receive()方法？100個參數？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person { void receive(Email email) { email.getInfo(); } void receive(Line line) { line.getInfo(); } void receive(SMS sms) { sms.getInfo(); } void receive(FBMessage fbMessage) { fbMessage.getInfo(); } } 寫程式是針對抽象、介面而寫，而不是針對具體類別而寫。 所以我們要做一個抽象類別或介面，裡面定義抽象方法，由實作介面的類別或繼承抽象類別的子類別，去實作抽象方法。 下圖中，介面IReceive有一個抽象方法getInfo()，實作此介面的類別(Email, Line, SMS, FBMessage)都要覆寫(Override)getInfo()的方法。 下圖中，Person類別的receive()方法使用到IReceive這個介面，作為方法參數。 程式碼如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 interface IReceive { void getInfo(); } class Email implements IReceive{ @Override public void getInfo() { System.out.println(\"email\"); } } class FBMessage implements IReceive{ @Override public void getInfo() { System.out.println(\"FB Message\"); } } class Line implements IReceive{ @Override public void getInfo() { System.out.println(\"Line\"); } } Person 1 2 3 4 5 class Person { void receive(IReceive receive) { receive.getInfo(); } } main主程式 1 2 3 4 5 6 public static void main(String[] args) { Person person = new Person(); person.receive(new Email()); person.receive(new Line()); person.receive(new FBMessage()); } email Line FB Message"
  },"/pages/design_pattern/segregation/": {
    "title": "介面切割原則",
    "keywords": "",
    "url": "/pages/design_pattern/segregation/",
    "body": "Prerequisites: 類別圖 多型 介面 介面切割原則 英文是Interface Segregation Principle 我覺得稱為介面最小化原則比較適合。 下圖中有Interface1，ImplementA與ImplementB去實作Interface1 A與B類別會用到Interface1 Interface1 1 2 3 4 5 6 public interface Interface1 { public void method1(); public void method2(); public void method3(); public void method4(); } ImplementA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ImplementA implements Interface1 { @Override public void method1() { } @Override public void method2() { } @Override public void method3() { } @Override public void method4() { } } ImplementB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ImplementB implements Interface1 { @Override public void method1() { } @Override public void method2() { } @Override public void method3() { } @Override public void method4() { } } A類別用到Interface1，呼叫method1與method2與method3。 1 2 3 4 5 6 7 8 9 10 11 12 public class A { public void call1(Interface1 interface1) { interface1.method1(); } public void call2(Interface1 interface1) { interface1.method2(); } public void call3(Interface1 interface1) { interface1.method3(); } } B類別用到Interfac1，呼叫method3與method4 1 2 3 4 5 6 7 8 public class B { public void call3(Interface1 interface1) { interface1.method3(); } public void call4(Interface1 interface1) { interface1.method4(); } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { A a = new A(); B b = new B(); ImplementA implementA = new ImplementA(); ImplementB implementB = new ImplementB(); a.call1(implementA); a.call2(implementA); a.call3(implementA); b.call3(implementB); b.call4(implementB); } } 問題 以上程式碼是類別圖的實作，但會出現以下問題 ImplementA與ImplementB實作Interface1全部方法 Interface1的方法，A類別B類別不會全部用到 A類別不會用到ImplementA實作的method4()。 B類別不會用到ImplementB實作的method1()與method2()不會用到。 改善方法 A類別會用到method1(),method2(),method3() B類別會用到method3(),method4() A類別,B類別都會用到method3()，把method3()抽出來成為一個介面。 A類別還會用到method1()與method2()，把這二個抽出來成為一個介面。 B類別還會用到method4()，把method4()抽出來作為單獨的介面。 切割過的介面類別圖如下: ImplementA實作Interface12與Interface3 ImplementB實作Interface4與Interface3 以下的類別圖加上A類別與B類別: A類別會用到Interface12與Interface3 B類別會用到Interface4與Interface3 切割過的Interface程式碼如下: 1 2 3 4 5 6 7 8 9 10 11 12 public interface Interface12 { public void method1(); public void method2(); } public interface Interface3 { public void method3(); } public interface Interface4 { public void method4(); } ImplementA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ImplementA implements Interface12, Interface3 { @Override public void method1() { } @Override public void method2() { } @Override public void method3() { } } ImplementB 1 2 3 4 5 6 7 8 9 10 11 12 public class ImplementB implements Interface3, Interface4 { @Override public void method3() { } @Override public void method4() { } } A類別 1 2 3 4 5 6 7 8 9 10 11 public class A { public void call1(Interface12 interface12) { interface12.method1(); } public void call2(Interface12 interface12) { interface12.method2(); } public void call3(Interface3 interface3) { interface3.method3(); } } B類別 1 2 3 4 5 6 7 8 public class B { public void call3(Interface3 interface3) { interface3.method3(); } public void call4(Interface4 interface4) { interface4.method4(); } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { A a = new A(); B b = new B(); ImplementA implementA = new ImplementA(); ImplementB implementB = new ImplementB(); a.call1(implementA); a.call2(implementA); a.call3(implementA); b.call3(implementB); b.call4(implementB); } } View.OnClickListener View.OnClickListener 可參考Android的View類別內的OnClickListener介面，只有一個抽象方法。 1 2 3 public interface OnClickListener { void onClick(View v); }"
  },"/pages/design_pattern/demeter/": {
    "title": "最少知道原則",
    "keywords": "",
    "url": "/pages/design_pattern/demeter/",
    "body": "Prerequisites: 類別圖 多型 迪米特原則 英文是Law of Demeter 迪米特原則也就是最少知道原則。 什麼是最少知道原則？假設A類別用到B類別的方法，A類別不會想知道B類別的內部結構以及程式是如何寫的，B類別只要提供一個public的方法給A類呼叫就好。 朋友關係 A類別用到B類別，所謂的「用到」，可能是依賴、聚合、組合、關連的關係，以下都是朋友關係。 方法參數(依賴) setter(聚合) 成員變數(組合或關聯) 傳回值 區域變數就不是朋友關係。 根據最少知道原則，類別與類別之間的關係，一定要是朋友關係。 朋友關係範例 Student類別 1 2 3 4 5 6 7 class Student { String name; Student() {} Student(String name) { this.name = name; } } 對於getAllStudent()方法中，傳回值類型有Student，所以Student是朋友。 1 2 3 4 5 6 7 8 9 10 class StudentManager { List&lt;Student&gt; getAllStudent() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10 ; i++) { Student student = new Student(\"student\" + i); list.add(student); } return list; } } 不是朋友範例 參數StudentManager是printAll()方法的朋友 1 2 3 4 5 6 7 8 class PrintManager { void printAll(StudentManager studentManager) { List&lt;Student&gt; students = studentManager.getAllStudent(); for (int i = 0; i &lt; students.size(); i++) { System.out.println(students.get(i).name); } } } 但是區域變數List，Student既不是方法參數也不是傳回值類型，所以Student不是朋友。 1 List&lt;Student&gt; students = studentManager.getAllStudent(); 如何修正？ 先前有提到「A類別用到B類別的方法，A類別不會想知道B類別的內部結構以及程式是如何寫的，B類別只要提供一個public的方法給A類呼叫就好。」 但是PrintManager.printAll()，居然取出studentManager中的學生清單，違反「不會知道其它類別的內部結構」。 把印出學生姓名的程式碼，放回StudentManager，提供一個public的printAllStudent()方法給別人呼叫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class StudentManager { List&lt;Student&gt; getAllStudent() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10 ; i++) { Student student = new Student(\"student\" + i); list.add(student); } return list; } // 印出學生 void printAllStudent() { List&lt;Student&gt; students = this.getAllStudent(); for (int i = 0; i &lt; students.size(); i++) { System.out.println(students.get(i).name); } } } PrintManager修改成，透過朋友，也就是參數studentManager，去印出學生 1 2 3 4 5 class PrintManager { void printAll(StudentManager studentManager) { studentManager.printAllStudent(); } }"
  },"/pages/design_pattern/has_a/": {
    "title": "HAS-A比IS-A更好",
    "keywords": "",
    "url": "/pages/design_pattern/has_a/",
    "body": "Prerequisites: 類別圖 多型 有一個比是一個更好 HAS-A是「有一個」，IS-A是「是一個」。 HAS-A意思是多用依賴、聚合、組合，少用繼承IS-A。 所謂的依賴、聚合、組合，請參考類別圖的解釋，才能繼續看以下文章。 里氏替換原則，英文是Liskov Substitution Principle 無法一言以蔽之，請看以下的內容。 下圖，A類別是父類別，B類別是A類別的子類別。 程式碼中，B類別覆寫A類別的method1()方法 1 2 3 4 5 6 7 8 9 10 11 12 class A { void method1() { System.out.println(\"A method1\"); } } class B extends A{ @Override void method1() { System.out.println(\"B method1\"); } } 多型的時候，父類別A想呼叫的是A類別自己的method1()，但A不知道B已經覆寫method1()，執行時是呼叫B類別的method1() 1 2 3 4 public static void main(String[] args) { A a = new B(); a.method1(); } B method1 由以上的程式碼可以發現，子類別覆寫到跟父類別相同的方法，就會影嚮預期，也許其它程式碼想呼叫的是父類別的方法，但在參數為多型的時候，卻呼叫到子類別覆寫的方法。 解決方式 降低耦合，使用「有一個」HAS-A，而非繼承IS-A。 HAS-A意思是多用依賴、聚合、組合。 B類別想使用A類別的method1()，透過依賴使用A類別，而不是使用繼承來使用A類別的method1(); B類別改成依賴的方式呼叫A類別的method1() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A { void method1() { System.out.println(\"A method1\"); } } class B { void method1() { System.out.println(\"B method1\"); } void callA_method1(A a) { a.method1(); } } main主程式 1 2 3 4 public static void main(String[] args) { B b = new B(); b.callA_method1(new A()); } A method1"
  },"/pages/design_pattern/open_close/": {
    "title": "開放關閉原則",
    "keywords": "",
    "url": "/pages/design_pattern/open_close/",
    "body": "開放關閉原則 英文是Open Close Principle 對修改關閉，對擴充開放。 意思是增加一個新類別，不用修改程式碼。 會變動的程式碼、細節的部分，寫在實作的具體類別，不會變動程式碼寫在抽象類別或介面。 未優化前程式碼 下圖，有一個形狀Shape的類別，Circle、Rectangle、Square都繼承Shape CreateShape類別中，drawShap()的參數用到Shape類別。 程式碼如下: 形狀相關的程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Shape { int type = 0; } public class Circle extends Shape{ Circle() { super.type = 1; } } public class Square extends Shape{ Square() { super.type = 2; } } public class Rectangle extends Shape{ Rectangle() { super.type = 3; } } CreateShape 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class CreateShape { void drawShap(Shape shape) { if (shape.type == 1) drawCircle(); else if (shape.type == 2) drawSquare(); else if (shape.type == 3) drawRectangle(); } void drawCircle() { System.out.println(\"圓形\"); } void drawRectangle() { System.out.println(\"長方形\"); } void drawSquare() { System.out.println(\"正方形\"); } } main主程式 1 2 3 4 public static void main(String[] args) { CreateShape createShape = new CreateShape(); createShape.drawShap(new Circle()); } 圓形 問題 請問，若要加上一個三角形，會動到那些程式碼？ 開放關閉原則是增加一個新類別，不用修改程式碼，但以上的程式碼要大幅度修改CreateShape這個類別。 優化程式碼 把以上會變動、細節部分的程式碼寫在實作的類別裡，不會變動的部分就寫在抽象裡。 Shape變成抽象類別，有一個抽象方法draw()，至於怎麼畫的細節就由子類別去覆寫draw()方法。 CreateShape只要呼叫Shape.draw()就好了，畫draw()這個「行為」是不會變的，至於怎麼畫怎麼變動的細節就是子類別處理。 形狀類別程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public abstract class Shape { abstract void draw(); } public class Circle extends Shape { @Override void draw() { System.out.println(\"畫一個圓\"); } } public class Rectangle extends Shape{ @Override void draw() { System.out.println(\"畫一個長方形\"); } } public class Square extends Shape{ @Override void draw() { System.out.println(\"畫一個正方形\"); } } CreateShape 1 2 3 4 5 public class CreateShape { void drawShap(Shape shape) { shape.draw(); } } Main主程式 1 2 3 4 public static void main(String[] args) { CreateShape createShape = new CreateShape(); createShape.drawShap(new Circle()); } 畫一個圓 新增三角形 最後，再問同個問題，新增一個三角形Triangle，要改動那些程式碼？答案是，不用改！只要建立一個Triangle類別並繼承Shape，覆寫draw()方法，把怎麼畫三角形都細節全寫進去。 1 2 3 4 5 6 public class Triangle extends Shape{ @Override void draw() { System.out.println(\"畫一個三角形\"); } } Main主程式 1 2 3 4 public static void main(String[] args) { CreateShape createShape = new CreateShape(); createShape.drawShap(new Triangle()); } 畫一個三角形"
  },"/pages/design_pattern/singleton/": {
    "title": "Singleton",
    "keywords": "",
    "url": "/pages/design_pattern/singleton/",
    "body": "Prerequisites: static 本篇文章需要相當多大量知識，了解類別載入，metadata，靜態變數、靜態區塊、靜態內部類別、final、執行緒、synchronized，擁有以上的知識，才能了解下面的內容。 Singleton 有很多中文翻譯，如∶ 獨體，單例 什麼是Singleton？Singleton是類別的靜態變數，而這個靜態變數是類別本身的物件。 而類別的變數只會在類別載入記憶體時，建立一次，確保不會被其它人建立多次。 何時用到Singleton，消耗系統資源的建立的物件，但又頻繁使用，只想只建立一次，不想頻繁的建立。 靜態變數建立Singleton 步驟如下: 把建構子變成私有。 私有靜態變數來存放本身類別的物件。 提供public靜態的方法，傳回物件。 為什麼建構子要變成私有，確保只有類別本身才可以呼叫建構子，其它類別都不能呼叫建構子建立物件。 1 2 3 4 5 6 7 8 9 10 class Singleton1 { // 1. 把建構子存取權限改成private private Singleton1() {} // 2. 私有靜態變數，存放物件 private static Singleton1 instance = new Singleton1(); // 3. 提供public static方法，傳回物件 public static Singleton1 getInstance() { return instance; } } 測試是否只產生一個物件，測試結果hashCode都是相同，證明不管產生幾次都為相同物件。 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { Singleton1 singleton1 = Singleton1.getInstance(); Singleton1 singleton2 = Singleton1.getInstance(); System.out.println(\"singleton1 = \" + singleton1.hashCode()); System.out.println(\"singleton2 = \" + singleton2.hashCode()); boolean result = (singleton1 == singleton2); System.out.println(\"singleton1 == singleton2 = \" + result); } } singleton1 = 821270929 singleton2 = 821270929 singleton1 == singleton2 = true Singleton寫在靜態區塊 靜態區塊 靜態只產生一次 靜態變數是在靜態區塊中才建立物件，跟之前的作法沒什麼不同。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton1 { // 1. 把建構子存取權限改成private private Singleton1() {} private static Singleton1 instance; // 2. 寫在靜態區塊 static { instance = new Singleton1(); } // 3. 提供public static方法，傳回物件 public static Singleton1 getInstance() { return instance; } } 優缺點分析 優點 static方法、static變數、static區塊，ClassLoader類別載入時就已經存放在metadata。 靜態相關屬性、方法、變數，不管產生多少次物件，都只載入記憶體一次。 缺點 不管有沒有使用到，都會產生一次物件，若沒使用到這個物件就會浪費記憶體位址去存放這個物件。 如果singleton物件要消耗很多執行時間，可能要網路連線、資料庫連線、檔案載入，執行速度就會很慢。 靜態內部類別建立Singleton final 靜態內部類 使用到靜態內部類別才會被建立 外部類別存取private內部類別 為了解決先前提到的缺點，使用靜態內部類別，可以做到使用的時候，才會建立。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton1 { // 1. 把建構子存取權限改成private private Singleton1() {} // 靜態內部類別 private static class InnerClz { // final代表不能再被修改 private static final Singleton1 INSTANCE = new Singleton1(); } // 2. 提供public static方法，傳回物件 public static Singleton1 getInstance() { return InnerClz.INSTANCE; } } 優點 靜態只產生一次物件。 使用到靜態內部類別才會被建立，要使用的時候才去建這個類別，才不會造成記憶體空間浪費。 synchronized加上雙重檢查 不使用靜態內部類別，使用靜態方法 + synchronized，也可以有靜態內部類別的效果(使用的時候才建立物件)。 未優化前(不推薦使用) 在靜態方法前加上synchronized，一次只能有一個執行緒進入靜態方法執行，執行完成後輪下一個執行緒執行此方法，若後面有1000個執行緒要執行這個方法，會造成執行緒排隊等待，執行效能緩慢，以下方法不推薦。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Singleton1 { // 1. 把建構子存取權限改成private private Singleton1() {} // 靜態變數 private static Singleton1 instance; // 2. 提供public static方法，傳回物件 public static synchronized Singleton1 getInstance() { if (instance == null) { instance = new Singleton1(); } return instance; } } 雙重檢查Double-Checked Locking 靜態同步方法 好幾百個執行緒進來要取得instance，確保只有一個執行緒建立一個instance。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Singleton1 { // 1. 把建構子存取權限改成private private Singleton1() {} private static volatile Singleton1 instance; // 2. 提供public static方法，傳回物件 public static Singleton1 getInstance() { if (instance == null) { synchronized(Singleton1.class) { if (instance == null) { instance = new Singleton1(); } } } return instance; } } 為什麼是用synchronized(Singleton1.class)？ Singleton1.class是Class類別的物件。 getInstance()是類別的靜態方法，同步鎖，鎖的是類別，所以使用synchronized(類別.class) 為什麼要檢查二次 為什麼要檢查二次 if (instance == null) ? 下面這個程式碼只有一次if (instance == null) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Singleton1 { private Singleton1() {} private static volatile Singleton1 instance; public static Singleton1 getInstance() { if (instance == null) { synchronized(Singleton1.class) { instance = new Singleton1(); } } return instance; } } 想像一下，有一個執行緒A執行完第一個if (instance == null)，然後同步區塊有執行緒B使用中(尚未建立物件)，所以執行緒A在同步區塊外面等待，然後在同步區塊中的執行緒B， 建立好物件instance，離開同步區塊，接著就輪到執行緒A進入同步區塊，接著就建立好第2個instance。 為了不讓人建立第2個物件，所以在同步synchronized區塊內加上第二次 if (instance == null)。 加快效率 第3個執行緒只要看到第一個 if (instance == null)，此時instance已經被建立了，就會跳離這個if判斷式，然後就不用再執行synchronized區塊，也就是說synchronized區塊最多只被執行2次。 volatile 1 private static volatile Singleton1 instance; volatile中文是可見性 每個變數都有自己的cache(暫存空間)，有變更不會立刻改變，好幾百個執行緒讀取這個變數，各個執行緒可能會先cache暫存起來，加上volatile，就是不讓各個執行緒把這個變數暫存，永遠重新讀取變數的值。"
  },"/pages/design_pattern/abstract_factory/": {
    "title": "抽象工廠",
    "keywords": "",
    "url": "/pages/design_pattern/abstract_factory/",
    "body": "Prerequisites: 簡單工廠模式 在簡單工廠模式中，使用工廠生產各個種類的Pizza。 若今天在各個國家都有工廠，根據不同國家生產符合他們口味的Pizza，請問要怎麼改？ 假設現在有台灣Pizza工廠、日本Pizza工廠 台灣工廠的口味是珍珠奶茶Pizza、臭豆腐Pizza 日本工廠的口味是章魚燒Pizza、大阪燒Pizza 首先要先建立的抽象工廠，裡面有一個createPizza()方法，由各個工廠去覆寫。 Pizza抽象類別，下面有各種口味的Pizza。 還有一個訂購Pizza的類別 如下圖: 工廠相關程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public abstract class AbsFactory { public abstract Pizza createPizza(String pizzaType); } public class TWFactory extends AbsFactory{ @Override public Pizza createPizza(String pizzaType) { Pizza pizza = null; if (pizzaType.equals(\"tofu\")) { pizza = new TofuPizza(); pizza.setName(\"臭豆腐pizza\"); } else if (pizzaType.equals(\"bubble\")) { pizza = new BubblePizza(); pizza.setName(\"珍珠奶茶pizza\"); } return pizza; } } public class JAPFactory extends AbsFactory{ @Override public Pizza createPizza(String pizzaType) { Pizza pizza = null; if (pizzaType.equals(\"taco\")) { pizza = new TacoPizza(); pizza.setName(\"章魚燒pizza\"); } else if (pizzaType.equals(\"oko\")) { pizza = new BubblePizza(); pizza.setName(\"大阪燒pizza\"); } return pizza; } } Pizza相關程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public abstract class Pizza { private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } // 不同的pizza準備的材料不同，由不同的pizza去覆寫 public abstract void prepare(); // 相同的作法就統一寫 public void bake() { System.out.println(\"放進烤箱\"); } public void cut() { System.out.println(\"把pizza切片\"); } public void box() { System.out.println(\"pizza裝進盒子\"); } } public class BubblePizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:珍珠\"); } } public class TofuPizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:臭豆腐\"); } } public class TacoPizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:章魚燒\"); } } public class OkoPizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:高麗菜\"); } } 訂購相關 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class OrderPizza { private AbsFactory factory; public void setFactory(AbsFactory factory) { this.factory = factory; } public void order() { Pizza pizza = null; String pizzaType; do { pizzaType = getType(); pizza = factory.createPizza(pizzaType); if (pizza == null) break; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza type:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } main主程式 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(); orderPizza.setFactory(new JAPFactory()); orderPizza.order(); } } input pizza type: oko 大阪燒pizza有:珍珠 放進烤箱 把pizza切片 pizza裝進盒子 input pizza type: taco 章魚燒pizza有:章魚燒 放進烤箱 把pizza切片 pizza裝進盒子"
  },"/pages/design_pattern/simple_factory/": {
    "title": "Simple Factory",
    "keywords": "",
    "url": "/pages/design_pattern/simple_factory/",
    "body": "Prerequisites: 開放關閉原則 未優化前 以下是一個訂購Pizza與制作Pizza的流程。 制作Pizza Pizza 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public abstract class Pizza { private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } // 不同的pizza準備的材料不同，由不同的pizza去覆寫 public abstract void prepare(); // 相同的作法就統一寫 public void bake() { System.out.println(\"放進烤箱\"); } public void cut() { System.out.println(\"把pizza切片\"); } public void box() { System.out.println(\"pizza裝進盒子\"); } } CheesePizza 1 2 3 4 5 6 public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:起士\"); } } TomatoPizza 1 2 3 4 5 6 public class TomatoPizza extends Pizza{ @Override public void prepare() { System.out.println(getName() + \"有:蕃茄\"); } } 訂購pizza OrderPizza 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class OrderPizza { public OrderPizza() { Pizza pizza = null; String pizzaType; do { pizzaType = getType(); if (pizzaType.equals(\"tomato\")) { pizza = new TomatoPizza(); pizza.setName(\"瑪格麗特pizza\"); } else if (pizzaType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\"起士pizza\"); } else { // 輸入其它的字就離開迴圈 break; } pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza type:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } } main 主程式 1 2 3 4 5 public class PizzaStore { public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(); } } input pizza type: cheese 起士pizza有:起士 放進烤箱 把pizza切片 pizza裝進盒子 input pizza type: tomato 瑪格麗特pizza有:蕃茄 放進烤箱 把pizza切片 pizza裝進盒子 input pizza type: a 優化 以上的問題是，為什麼產生pizza的程式碼在訂購的流程中？ 1 2 3 4 5 6 7 8 9 10 if (pizzaType.equals(\"tomato\")) { pizza = new TomatoPizza(); pizza.setName(\"瑪格麗特pizza\"); } else if (pizzaType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\"起士pizza\"); } else { // 輸入其它的字就離開迴圈 break; } 把產生pizza的程式碼放入工廠的類別中，由Pizza工廠來生產pizza，只需要給它pizzaType的參數。 SimpleFactory 1 2 3 4 5 6 7 8 9 10 11 12 13 public class SimpleFactory { public Pizza createPizza(String pizzaType) { Pizza pizza = null; if (pizzaType.equals(\"tomato\")) { pizza = new TomatoPizza(); pizza.setName(\"瑪格麗特pizza\"); } else if (pizzaType.equals(\"cheese\")) { pizza = new CheesePizza(); pizza.setName(\"起士pizza\"); } return pizza; } } OrderPizza類別增加設置Pizza工廠 1 2 3 4 private SimpleFactory factory; public void setFactory(SimpleFactory factory) { this.factory = factory; } OrderPizza增加order()的方法，只負責取得pizza的種類、事前準備prepare()、烤、切、裝盒子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void order() { Pizza pizza = null; String pizzaType; do { pizzaType = getType(); // 產生pizza pizza = factory.createPizza(pizzaType); // 跳離迴圈 if (pizza == null) break; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } 類別圖如下: setFactory是聚合的關係，所以是用空白菱型，請見類別圖文章。 完整的OrderPizza 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class OrderPizza { private SimpleFactory factory; public void setFactory(SimpleFactory factory) { this.factory = factory; } public void order() { Pizza pizza = null; String pizzaType; do { pizzaType = getType(); pizza = factory.createPizza(pizzaType); if (pizza == null) break; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } while (true); } public OrderPizza() { } private String getType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza type:\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } }"
  },"/pages/design_pattern/interface_adapter/": {
    "title": "介面轉接器",
    "keywords": "",
    "url": "/pages/design_pattern/interface_adapter/",
    "body": "Prerequisites: 介面切割原則 匿名類別 原理 在認識此模式之前，一定要先了解介面切割原則，二者為互斥。 先前是介面最小原則，本篇是介面不用切割了，使用一個抽象的Adapter，把所有介面的所有方法都「空」實作。 繼承Adapter的類別，要用到那些介面的方法，再去覆寫，完全大大改善「介面切割原則」會產生許多介面與實作的類別數量問題。 類別圖 Interface 程式碼如下 1 2 3 4 5 6 public interface Interface1 { void method1(); void method2(); void method3(); void method4(); } Adapter 抽象的Adapter，把所有介面的所有方法都「空」實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 public abstract class Adapter1 implements Interface1{ @Override public void method1() {} @Override public void method2() {} @Override public void method3() {} @Override public void method4() {} } 繼承Adapter的類別 A類別，把需要覆寫的方法寫一寫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class A extends Adapter1{ @Override public void method1() { System.out.println(\"A method1\"); } @Override public void method2() { System.out.println(\"A method2\"); } @Override public void method3() { System.out.println(\"A method3\"); } } B類別，把需要覆寫的方法寫一寫。 1 2 3 4 5 6 7 8 9 10 public class B extends Adapter1{ @Override public void method3() { System.out.println(\"B method3\"); } @Override public void method4() { System.out.println(\"B method4\"); } } 測試 main主程式 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { A a = new A(); a.method1(); a.method2(); a.method3(); B b = new B(); b.method3(); b.method4(); } } A method1 A method2 A method3 B method3 B method4 使用匿名類別實作 這種方式是最多人使用，把需要覆寫的方法寫一寫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { public static void main(String[] args) { Interface1 test = new Adapter1() { @Override public void method1() { System.out.println(\"A method1\"); } @Override public void method2() { System.out.println(\"A method2\"); } @Override public void method3() { System.out.println(\"A method3\"); } }; test.method1(); test.method2(); test.method3(); } } A method1 A method2 A method3 AnimationListener與AnimationListenerAdapter source code AnimationListener 1 2 3 4 5 public static interface AnimationListener { void onAnimationStart(Animation animation); void onAnimationEnd(Animation animation); void onAnimationRepeat(Animation animation); } AnimationListenerAdapter空實作AnimationListener所有方法 1 2 3 4 5 6 7 8 9 10 public class AnimationListenerAdapter implements AnimationListener { @Override public void onAnimationStart(Animation animation) {} @Override public void onAnimationEnd(Animation animation) {} @Override public void onAnimationRepeat(Animation animation) {} } 可透過匿名類別只實作Adapter1個方法 1 2 3 4 5 6 new AnimationListenerAdapter() { @Override public void onAnimationStart(Animation animation) { // 只實作1個方法 } }"
  },"/pages/design_pattern/object_adapter/": {
    "title": "物件轉接器",
    "keywords": "",
    "url": "/pages/design_pattern/object_adapter/",
    "body": "比如到大陸去旅遊，他們的電壓是220v，要買個轉接器把220v轉成5v，才能給手機充電使用，手機只能用5v。 下圖中轉接器Adapter用到Voltage220類別，Adapter要實作output5v的方法，把220v轉成5v輸出 因為使用new Adater()時把Voltage220類別傳入，所以是有生死相隨的關係，使用實心菱形，代表組合，組合的意思是關係無法分開，一起建立一起被記憶體回收。 Phone類別，有一個chage()充電的方法，用到Voltage5類別。 程式碼 Voltage5V 1 2 3 public interface Voltage5V { int output5v(); } Voltage220 1 2 3 4 5 public class Voltage220 { int output220v() { return 220; } } Adapter 1 2 3 4 5 6 7 8 9 10 public class Adapter implements Voltage5V{ private Voltage220 voltage220; public Adapter(Voltage220 voltage220) { this.voltage220 = voltage220; } @Override public int output5v() { return voltage220.output220v() / 44; } } Phone 1 2 3 4 5 6 7 8 9 public class Phone { public void charg(Voltage5V voltage5V) { if ( voltage5V.output5v() == 5) { System.out.println(\"can charging\"); } else { System.out.println(\"can not charging\"); } } } main主程式 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { Voltage5V voltage5V = new Adapter(new Voltage220()); Phone phone = new Phone(); phone.charg(voltage5V); } } can charging"
  },"/pages/java/format/": {
    "title": "Java程式碼格式",
    "keywords": "",
    "url": "/pages/java/format/",
    "body": "Prerequisites: c++程式碼格式 Java程式碼格式跟C++程式碼格式差距「很大」，特別列出。 Java風格指南 C++風格指南 縮排2個空格 4.2 Block indentation: +2 spaces Java與C++一樣是2個空格，不是4個空格！ 換行 C++ 風格（Google C++ Style Guide） 原則：空行越少越好 目標：讓程式碼緊湊，提高螢幕空間利用率，方便追蹤控制流程。 範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { public: MyClass() { Init(); } void DoSomething() { if (condition) { // ... } else { // ... } } private: int value_; }; Java 風格（Google Java Style Guide） 原則：適度空行提升可讀性 目標：讓程式碼結構更清晰，便於閱讀和理解。 情境 空行數量 類別宣告與第一個方法之間 2 行 方法與方法之間 1 行 靜態區塊、成員變數、構造方法之間 1 行 註解與程式碼之間 視情況 （通常 1 行） 範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Example { private static final int CONSTANT = 100; // 成員變數與方法之間空 2 行 public Example() { // ... } // 方法之間空 1 行 public void method1() { if (condition) { // ... } // 邏輯轉換處可加空行 else { // ... } } public void method2() { // ... } } 類別成員順序 Java（靜態→實例→方法） 靜態成員 實例成員 建構子 方法 內部類別 可讀性優先 C++（方法在前，變數在後） public: 方法 protected: 方法 private: 方法 成員變數 封裝性優先 Java 的類別成員擺放順序（Google Java Style Guide) 靜態成員（static） static final 常數（public → private) static 變數（public → private) static 初始化區塊（static { … }） 實例成員（instance） public 常數（final） private 常數（final） public 變數 private 變數 實例初始化區塊（{ … }） 建構子（Constructors） 方法（Methods） public 方法 → private 方法 可依功能分組（如 getter/setter 放一起） 內部類別（Inner Classes）（如果有） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class MyClass { // 1. 靜態成員 public static final int PUBLIC_CONSTANT = 1; private static final int PRIVATE_CONSTANT = 2; private static int staticVar; static { // 靜態初始化區塊 staticVar = 10; } // 2. 實例成員 public final int instanceFinalVar = 5; private int instanceVar; { // 實例初始化區塊 instanceVar = 20; } // 3. 建構子 public MyClass() {} public MyClass(int value) { this.instanceVar = value; } // 4. 方法 public void publicMethod() {} private void privateMethod() {} // 5. 內部類別（可選） private static class InnerClass {} } C++ 的類別成員擺放順序（Google C++ Style Guide） public: 建構子（Constructors） 方法（Methods） protected: 方法 private: 方法 成員變數（static → 非 static） 原則：空行越少越好 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyClass { public: // 1. 建構子 MyClass(); explicit MyClass(int value); // 2. 公開方法 void PublicMethod(); protected: // 3. 保護方法（可選） void ProtectedMethod(); private: // 4. 私有方法 void PrivateMethod(); // 5. 成員變數（最後） static int static_var_; int instance_var_; }; 結論 程式碼風格確實存在許多分歧，甚至可能讓人覺得「過度糾結」。 過度糾結風格確實浪費時間 如果團隊在「空行數量」或「縮排用空格還是 Tab」爭論半天，這些時間本可用來解決實際問題。 使用工具自動化，避免手動檢查，爭吵空行與縮排是沒有意義的。"
  },"/pages/java/reflect/": {
    "title": "反射",
    "keywords": "",
    "url": "/pages/java/reflect/",
    "body": "Prerequisites: Memory Model metadata Classloader類別載入 在Classloader文章已經說明Class類別載入的過程。 反射英文是Reflection Class Class知道類別的所有屬性、方法，透過Class類別可以取得屬性、方法、建構子。 測試的程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Duck extends Animal implements Fly, Swim{ public String name; private String info; static { System.out.println(\"Duck 被classloader載入\"); } public Duck() { System.out.println(\"物件被jvm建立\"); } private Duck(String name) { this.name = name; } @Override public void eat() { System.out.println(\"鴨子吃\"); } @Override public void fly() { System.out.println(\"鴨子飛\"); } @Override public void swim() { System.out.println(\"鴨子游泳\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } Class.forName forName(““)的參數是package名字.類別名組成，用點來區隔。 執行結果會被classLoader載入 1 2 Class class1 = Class.forName(\"reflect.Duck\"); System.out.println(class1); Duck 被classloader載入 class reflect.Duck 類別名.class 執行結果「不會」被classLoader載入 1 2 Class class2 = Duck.class; System.out.println(class2); class reflect.Duck getClass() 執行結果會被classLoader載入 1 2 3 Duck duck = new Duck(); Class class3 = duck.getClass(); System.out.println(class3); Duck 被classloader載入 物件被jvm建立 class reflect.Duck 取得父類別 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) throws Exception { Class class1 = Duck.class; Class superclass = class1.getSuperclass(); System.out.println(superclass); } } class reflect.Animal 取得介面 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) throws Exception { Class class1 = Duck.class; Class[] interfaces = class1.getInterfaces(); for (Class cls : interfaces) { System.out.println(cls); } } } interface reflect.Fly interface reflect.Swim 取得public屬性 1 2 3 4 5 Class class1 = Duck.class; Field[] fields = class1.getFields(); for (Field field : fields) { System.out.println(field); } public java.lang.String reflect.Duck.name 取得所有屬性 1 2 3 4 Field[] dfields = class1.getDeclaredFields(); for (Field field : dfields) { System.out.println(field); } public java.lang.String reflect.Duck.name private java.lang.String reflect.Duck.info 取得public方法與所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) throws Exception { Class class1 = Duck.class; // getMethods只有public的方法 Method[] methods = class1.getMethods(); for (Method method : methods) { System.out.println(method); } // getDeclaredMethods() 包含所有public,private方法 Method[] dmethods = class1.getDeclaredMethods(); for (Method method : dmethods) { System.out.println(method); } } } public java.lang.String reflect.Duck.getInfo() public void reflect.Duck.eat() public void reflect.Duck.fly() public void reflect.Duck.swim() public void reflect.Duck.setInfo(java.lang.String) 取得父類別所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Test3 { public static void main(String[] args) { Class&lt;?&gt; clazz = Dog.class; System.out.println(\"Methods in class: \" + clazz.getName()); for (Method method : clazz.getDeclaredMethods()) { System.out.println(method); } // parent Class&lt;?&gt; superclass = clazz.getSuperclass(); System.out.println(\"Methods in Parent: \" + clazz.getName()); for (Method method : superclass.getDeclaredMethods()) { System.out.println(method); } } } class Animal { int i = 10; // 父類欄位 void speak() { System.out.println(i); } // 印出 this.i } class Dog extends Animal { int i = 5; // 子類同名欄位 //void speak() { System.out.println(i); } } Methods in class: wrap.Dog Methods in Parent: wrap.Dog void wrap.Animal.speak() 將以上取得父類別方法改善如下，方便以後做測試，只要輸入「package.類別名」。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test { public static void main(String[] args) throws ClassNotFoundException { // 參數是「package.類別名」 getClzMethod(Class.forName(\"inherit.A\")); } public static void getClzMethod(Class&lt;?&gt; clz) { Class&lt;?&gt; clazz = clz; System.out.println(\"Methods in class: \" + clazz.getName()); for (Method method : clazz.getDeclaredMethods()) { System.out.println(method); } System.out.println(\"------------------\"); // parent Class&lt;?&gt; superclass = clazz.getSuperclass(); System.out.println(\"Methods in Parent: \" + clazz.getName()); for (Method method : superclass.getDeclaredMethods()) { System.out.println(method); } } } 取得public建構子與private建構子 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) throws Exception { Class class1 = Duck.class; Constructor[] constructors = class1.getConstructors(); // getDeclaredConstructors() 包含所有public,private Constructor[] dconstructors = class1.getDeclaredConstructors(); for (Constructor constructor : dconstructors) { System.out.println(constructor); } } } public reflect.Duck() private reflect.Duck(java.lang.String) 使用private建構子建立物件並呼叫私有方法 先把public建構子 1 2 3 public Duck() { System.out.println(\"物件被jvm建立\"); } 改成 1 2 3 private Duck() { System.out.println(\"物件被jvm建立\"); } 增加private 方法 1 2 3 private void getAddress() { System.out.println(\"private getAddress() test\"); } 呼叫private建構子與private方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws Exception { Class class1 = Duck.class; // 呼叫private建構子建立物件 Constructor dc = class1.getDeclaredConstructor(); // 把private改成public dc.setAccessible(true); Object instance = dc.newInstance(); // 呼叫私有方法 Method dm1 = class1.getDeclaredMethod(\"getAddress\"); // 設置成public dm1.setAccessible(true); // 參數代入instance dm1.invoke(instance); } Duck 被classloader載入 物件被jvm建立 private getAddress() test 使用public建構子與參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.lang.reflect.Method; import java.util.Scanner; public class Test { public static void main(String[] args) throws Exception { Scanner sc= new Scanner(System.in); System.out.println(\"輸入package.類別\"); String strName = sc.next(); System.out.println(\"請輸入一個數\"); int a = sc.nextInt(); System.out.println(\"請輸入另一個數\"); int b = sc.nextInt(); Class class1 = Class.forName(strName); // 呼叫public建構子，建立物件 Object ins = class1.newInstance(); // 取出方法與設定參數類型 Method md = class1.getDeclaredMethod(\"sum\", int.class, int.class); // 呼叫方法，第1個參數是物件，a與b是方法參數 md.invoke(ins, a, b); } } 編譯，並執行 在另一個Project，跟上一個程式碼同一個package下寫以下程式碼，並編譯 1 2 3 4 5 6 public class Cal { public void sum(int a, int b) { System.out.println(\"result = \"); System.out.println(a + b); } } 熱部署 熱部署（英：Hot deployment）是，伺服器不需要重新啟動的情況下，修改軟體或者軟體。 將上面的程式碼產生出來的class檔放在已經正在運行的class目錄下 回到剛才執行”使用public建構子與參數”，輸入package name與類別 輸入package.類別 reflect.Cal 請輸入一個數 5 請輸入另一個數 3 result = 8"
  },"/pages/design_pattern/chain/": {
    "title": "責任鏈",
    "keywords": "",
    "url": "/pages/design_pattern/chain/",
    "body": "需求 想像一下你是公務員，有很多承包商的報價需求，需要長官審核，長官有下列幾位 職等 審核金額 主管 0 - 49999 會計 50000 - 99999 老闆 10000以上 主管會處理0 - 49999元，金額超過這個範圍，給會計處理。 會計處理5萬以上，10萬以下，金額超過這個範圍，給老闆處理。 老闆只處理10萬元以上，10萬元以下，老闆不處理，給主管處理。 有看出這個環狀結果嗎，主管-&gt;會計-&gt;老闆-&gt;主管。 類別圖 Request是報價需求，有編號與價錢二個成員屬性。 Approver是抽象類別，中文意思是簽呈者，成員屬性有nextApprover設定下一個處理的人，process()是抽象方法，繼承的子類別一定要覆寫。 Approver子類別如下ManagerApprover, AccountApprover, BossApprover，分別是主管簽呈、會計簽呈、老闆簽呈。 Request需求 有編號與價錢二個成員屬性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Request { private int id; private int price; public Request(int id, int price) { this.id = id; this.price = price; } public int getId() { return id; } public int getPrice() { return price; } } Approver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public abstract class Approver { private String name; // nextApprover設定下一個處理的人 protected Approver nextApprover; // 設定簽呈人的名字 public Approver(String name) { this.name = name; } // 抽象方法，子類別一定要實作，處理需求 public abstract void process(Request request); public String getName() { return name; } // 設定下一個處理的人 public void setNextApprover(Approver nextApprover) { this.nextApprover = nextApprover; } } Approver子類別 子類別都要覆寫process()抽象方法 主管 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ManagerApprover extends Approver{ public ManagerApprover(String name) { super(name); } @Override public void process(Request request) { // 處理金額範圍 if (request.getPrice() &gt; 0 &amp;&amp; request.getPrice() &lt;= 49999) { System.out.println(\"需求編號 =\" + request.getId() +\"被\" + getName() + \"處理\"); } else { nextApprover.process(request); // 給下一個人處理 } } } 會計 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class AccountApprover extends Approver{ public AccountApprover(String name) { super(name); } @Override public void process(Request request) { // 處理金額範圍 if (request.getPrice() &gt;= 50000 &amp;&amp; request.getPrice() &lt;= 99999) { System.out.println(\"需求編號 =\" + request.getId() +\"被\" + getName() + \"處理\"); } else { nextApprover.process(request); // 給下一個人處理 } } } 老闆 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class BossApprover extends Approver{ public BossApprover(String name) { super(name); } @Override public void process(Request request) { // 處理金額範圍 if (request.getPrice() &gt;= 100000) { System.out.println(\"需求編號 =\" + request.getId() +\"被\" + getName() + \"處理\"); } else { nextApprover.process(request); // 給下一個人處理 } } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test { public static void main(String[] args) { // 建立需求 Request request1 = new Request(1, 200000); Request request2 = new Request(2, 3500); Request request3 = new Request(3, 50000); // 建立簽呈的人 ManagerApprover managerApprover = new ManagerApprover(\"主管\"); AccountApprover accountApprover = new AccountApprover(\"會計\"); BossApprover bossApprover = new BossApprover(\"老闆\"); // 設定下一個處理的人 managerApprover.setApprover(accountApprover); accountApprover.setApprover(bossApprover); // 設定若金額太小，下一個可以處理的人是誰，要形成環狀 bossApprover.setApprover(managerApprover); // 處理需求 managerApprover.process(request1); // 測試金額3500，會不會給下一個人處理 bossApprover.process(request2); managerApprover.process(request3); } } 需求編號 =1被老闆處理 需求編號 =2被主管處理 需求編號 =3被會計處理"
  },"/pages/design_pattern/composite/": {
    "title": "合成模式(樹狀結構)",
    "keywords": "",
    "url": "/pages/design_pattern/composite/",
    "body": "樹狀結構的物件。 Componet為抽象類別，裡面有name的屬性，有add()、remove()，還有一個抽象方法print()，繼承的子類別一定要覆寫print()。 Leaf為樹狀結構最尾端的節點，在他的下面不會再有任何節點，所以不允許使用add()與remove()的方法。 Composite下面一定會有子節點，子節點可以是Composite也可以是Leaf，可以使用add()與remove()的方法增加子節點。 接下來我們要寫一個學校的樹狀結構 大學University -&gt; College學院 -&gt; Department系 XX大學 -&gt; 電資學院 -&gt; 通訊系 XX大學 -&gt; 商學院 -&gt; 會計系 Component 1 2 3 4 5 6 7 8 9 public abstract class Component { protected String name; public void add(Component component) {} public void remove(Component component) {} public abstract void print(); } University 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class University extends Component{ List&lt;Component&gt; componentList = new ArrayList&lt;&gt;(); public University(String name) { super(); this.name = name; } @Override public void add(Component component) { componentList.add(component); } @Override public void remove(Component component) { componentList.remove(component); } @Override public void print() { System.out.println(\"====\" + name + \"========\"); for (Component element : componentList) { element.print(); } } } College的程式碼與University一模一樣 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class College extends Component{ List&lt;Component&gt; componentList = new ArrayList&lt;&gt;(); public College(String name) { super(); this.name = name; } @Override public void add(Component component) { componentList.add(component); } @Override public void remove(Component component) { componentList.remove(component); } @Override public void print() { System.out.println(\"====\" + name + \"========\"); for (Component element : componentList) { element.print(); } } } Department，葉子節點 1 2 3 4 5 6 7 8 9 10 11 public class Department extends Component { public Department(String name) { super(); this.name = name; } @Override public void print() { System.out.println(name); } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test { public static void main(String[] args) { Component university = new University(\"XX大學\"); Component eletricCollege = new College(\"電資學院\"); Department edpt1 = new Department(\"通訊系\"); Department edpt2 = new Department(\"資工系\"); Department edpt3 = new Department(\"電機系\"); eletricCollege.add(edpt1); eletricCollege.add(edpt2); eletricCollege.add(edpt3); Component businessCollege = new College(\"商學院\"); Department bdpt1 = new Department(\"會計系\"); Department bdpt2 = new Department(\"國貿系\"); Department bdpt3 = new Department(\"應用數學系\"); businessCollege.add(bdpt1); businessCollege.add(bdpt2); businessCollege.add(bdpt3); university.add(eletricCollege); university.add(businessCollege); university.print(); } } ====XX大學======== ====電資學院======== 通訊系 資工系 電機系 ====商學院======== 會計系 國貿系 應用數學系"
  },"/pages/design_pattern/decorator/": {
    "title": "裝飾者模式",
    "keywords": "",
    "url": "/pages/design_pattern/decorator/",
    "body": "需求 開了一家飲料店，有綠茶、紅茶…各種茶。 客人可以加錢加配料，比如加上珍珠、鮮奶、粉角、椰果、小芋圓，不同配料價錢不同。 珍珠可以加2份或3份、其它配料也是，沒有限定只能加一次。 設計一家飲料店，要求是不用修改程式，就可以添加新的茶飲與新的配料如仙草、米苔米，並計算添加配料後一杯飲料要多少錢。 以下複雜的計算流程是不被允許，若有新的配料又要改判斷與價錢。 1 2 3 4 5 6 7 8 9 10 int cost = 0; if (有珍珠) cost += 5; if (有粉角) cost += 10; if (有鮮奶) cost += 15; . . . 類別圖解釋 飲料(Drink)與配料(Decorator)都繼承抽象類別Component，所以飲料與配料也是Component，飲料與配料都要覆寫cost()方法。 注意！配料(Decorator)中有一個屬性是component，它可以是飲料Drink也可以是配料Decorator，所以才有二個黑色菱形都指向component屬性。 黑色菱形為組合，會使用建構子，參數為飲料或配料，建構子傳遞參數就是組合，請見類別圖。 飲料Drink下面有綠茶、紅茶、咖啡。 配料Decorator下面有牛奶、珍珠、果凍。 Component抽象類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public abstract class Component { // 價格 private int price; // 描述 private String desc; // 抽象方法 abstract int cost(); // 取得價格 public int getPrice() { return price; } // 設定價格 public void setPrice(int price) { this.price = price; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } Drink飲料 1 2 3 4 5 6 7 public class Drink extends Component{ @Override int cost() { // 使用父類別的getPrice()方法 return super.getPrice(); } } Decorator配料 注意事項: component 成員屬性(十分重要) 建立建構子，參數就是component 覆寫cost()方法，使用super.getPrice() + component.cost()，注意！是加component.cost()，不是component.getPrice() 覆寫desc()方法，注意！使用super.getDesc()，以免stack overflow，不能自己呼叫自己。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Decorator extends Component{ // component可能是飲料或配料 private Component component; // component可能是飲料或配料 public Decorator(Component component) { this.component = component; } @Override int cost() { // 使用父類別的getPrice()方法 // 配料的價格 + component的「總費用」(Component可能是飲料或配料) return super.getPrice() + component.cost(); } @Override public String getDesc() { // 使用父類別的getDesc()方法，使用this.getDesc()會stack overflow，因為自己呼叫自己 // 印出配料的品項與配料的價格，componet的desc包含先前加上的配料品項與價格 return super.getDesc() + \"=\" + super.getPrice() + \" &amp; \" + component.getDesc(); } } 繼承Drink類別 設定價格 設定品項 紅茶 1 2 3 4 5 6 7 8 public class BlackTea extends Drink { public BlackTea() { // 設定價格 setPrice(35); // 設定品項 setDesc(\"紅茶 = \" + getPrice()); } } 綠茶 1 2 3 4 5 6 7 8 public class GreenTea extends Drink{ public GreenTea() { // 設定價格 setPrice(40); // 設定品項 setDesc(\"綠茶 = \" + getPrice()); } } 繼承Decorator配料 設定價格 設定品項 珍珠 1 2 3 4 5 6 7 8 9 10 public class Bubble extends Decorator{ public Bubble(Component component) { // 使用父類別Decorator建構子 super(component); // 設定價格 setPrice(5); // 設定品項 setDesc(\"珍珠\"); } } 牛奶 1 2 3 4 5 6 7 8 9 10 public class Milk extends Decorator { public Milk(Component component) { // 使用父類別Decorator建構子 super(component); // 設定價格 setPrice(10); // 設定品項 setDesc(\"牛奶\"); } } 使用方法 先建立飲料 用配料的建構子，傳進飲料 下圖中，包在最裡面的是飲料，其它都是配料。 可以想像一下，每一個方框都是建構子，包在最裡面飲料，其它都是配料。 1 new Jelly(new Bubble(new Milk(new BlackTea()))); 所以先前才會說Decorator的建構子參數component可能是飲料或配料。 Main 主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { // 建立綠茶 Component greenTea = new GreenTea(); // 加牛奶 greenTea = new Milk(greenTea); // 加第2份牛奶 greenTea = new Milk(greenTea); // 加珍珠 greenTea = new Bubble(greenTea); // 印出品項與價格 System.out.println(greenTea.getDesc()); // 印出全部花費 System.out.println(greenTea.cost()); } } 珍珠=5 &amp; 牛奶=10 &amp; 牛奶=10 &amp; 綠茶 = 40 65"
  },"/pages/design_pattern/iterator/": {
    "title": "Iterator",
    "keywords": "",
    "url": "/pages/design_pattern/iterator/",
    "body": "以下的類別圖分二類，左邊是集合Aggregate，右邊是Iterator疊代器。 Aggregate Aggregate介面有createIterator()方法必須實作。 實作Aggregate類別，成員屬性有elements，可以是陣列、List、任何集合類別。 createIterator()取得跟elements類別相關的Iterator，比如elements是陣列，就要取得陣列的Iterator，elements是List，就要取得List的Iterator，elements是Map，就要取得Map的Iterator。 以上提到的Iterator自己要實作。 Iterator Iterator介面有hasNext()、next()、remove()三個方法要實作。 hasNext(): 有沒有下一個元素(element)？傳回值型態為boolean next(): 傳回下一個元素(element)。 remove(): 刪除元素 Iterator使用系統就有的，不另外自己寫。 實作Iterator類別，這個要自己實作。 陣列集合與Iterator 下圖中，實作Aggregate類別的elements的類型已換成陣列。 寫一個電腦課程的集合與iterator 課程Course 1 2 3 4 5 6 7 8 9 10 11 public class Course { private String name; public Course(String name) { this.name = name; } public String getName() { return name; } } Component介面 1 2 3 public interface Component { Iterator createIterator(); } 電腦課程集合 要實作createIterator()方法，並把elements傳給iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import java.util.Iterator; public class ComputerCourse implements Component{ // 陣列元素 private Course[] elements; // index索引 private int index = 0; public ComputerCourse() { // 最多就10堂課 elements = new Course[10]; } //增加課程 public void addCourse(String name) { // 最多就10堂課 if (index &lt; 10) { Course course = new Course(name); elements[index] = course; index++; } } // 覆寫取得Iterator @Override public Iterator createIterator() { // 要把elements傳入 return new ComputerCourseIter(elements); } } 實作陣列的Iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.Iterator; public class ComputerCourseIter implements Iterator { Course[] elements; int index = 0; public ComputerCourseIter(Course[] elements) { this.elements = elements; } // 判斷是否有下一個元素 @Override public boolean hasNext() { // index 超出大小 或 值是null，因為我們有建立10個陣列大小，沒設課程都會是null if (index &gt;= elements.length || elements[index] == null) { return false; } return true; } // 取出下一個元素 @Override public Object next() { // 傳回值 Course rtnObj = elements[index]; // index移到下一個元素的索引 index++; return rtnObj; } @Override public void remove() { // 目前沒此需求，先不寫 } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Iterator; public class Test { public static void main(String[] args) { ComputerCourse computerCourse = new ComputerCourse(); computerCourse.addCourse(\"C++\"); computerCourse.addCourse(\"Java\"); computerCourse.addCourse(\"Android\"); computerCourse.addCourse(\"Swift\"); Iterator iter = computerCourse.createIterator(); while(iter.hasNext()) { Course course = (Course) iter.next(); System.out.println(course.getName()); } } } C++ Java Android Swift List集合與Iterator 實作elements為List的集合與Iterator。 寫一個英語課程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class EnglishCourse implements Component{ private List&lt;Course&gt; elements; public EnglishCourse() { elements = new ArrayList&lt;&gt;(); } public void addCourse(String name) { Course course = new Course(name); elements.add(course); } @Override public Iterator createIterator() { return new EnglishCourseIter(elements); } } 實作Iterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import java.util.Iterator; import java.util.List; public class EnglishCourseIter implements Iterator { private List&lt;Course&gt; elements; private int index = 0; public EnglishCourseIter(List&lt;Course&gt; elements) { this.elements = elements; } @Override public boolean hasNext() { if (index &gt;= elements.size()){ return false; } return true; } @Override public Object next() { Course rtnObj = elements.get(index); index++; return rtnObj; } @Override public void remove() { // 目前沒此需求，先不寫 } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.Iterator; public class Test { public static void main(String[] args) { EnglishCourse englishCourse = new EnglishCourse(); englishCourse.addCourse(\"自然發音\"); englishCourse.addCourse(\"文法\"); englishCourse.addCourse(\"會話\"); Iterator iter = englishCourse.createIterator(); while(iter.hasNext()) { Course course = (Course) iter.next(); System.out.println(course.getName()); } } } 自然發音 文法 會話"
  },"/pages/design_pattern/builder/": {
    "title": "建造者模式",
    "keywords": "",
    "url": "/pages/design_pattern/builder/",
    "body": "建造者模式，把「產品」與「建造過程」與「控制那個流程誰先誰後」，三者分開，三者解耦，符合迪米特原則。 經典的建造者類別圖 Product產品 要做出來的東西 Builder建造者介面 定義要做出東西的「過程」或「步驟」。 以下為要做出東西的方法method: buildPartA()、buildPartB()、buildPartC() 這些過程是抽象方法，由實作的子類別去覆寫這些方法。 成員屬性有product，用組合(黑色菱形)的方法，用new Product()方式組合在Builder介面。 ConcreateBuilder實作建造者 覆寫抽象方法buildPartA()、buildPartB()、buildPartC() 在這些方法寫上製作這個產品的實際內容。 Director指揮者 成員屬性有builder，用聚合(空心菱形)的方法，用setBuilder()方式聚合。 construct()方法，把製作產品的過程、步驟、方法統整起來，最後傳回一個Product產品出來。 建造各種房子 以上是經典類別圖，現在根據經典類別圖，來建造房子吧！我們要建造小木屋Cabin、別墅Villa二種房子，建造過程一定是不同的。 Builder建造者介面 以下為建立房子的過程: buildBase()建造地基 buildWalls()建造牆壁 buildRoof()建造屋頂 build()會傳回house物件 ConcreateBuilder實作建造者 CabinBuilder、VillaBuilder有二個建造者。 程式碼 House，這次要建造的產品是房子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class House { private String base; private String roof; private String wall; public String getBase() { return base; } public void setBase(String base) { this.base = base; } public String getRoof() { return roof; } public void setRoof(String roof) { this.roof = roof; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } } Builder建造者抽象類別 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class Builder { // 用組合的方式，把house組合在Builder介面 protected House house = new House(); // 建地基 public abstract void buildBase(); // 建牆壁 public abstract void buildWalls(); // 建屋頂 public abstract void buildRoof(); // 傳回house物件 public House build() { return house; } } CabinBuilder小木屋建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class CabinBuilder extends Builder{ @Override public void buildBase() { house.setBase(\"木頭地基\"); System.out.println(\"開始建造木頭地基\"); } @Override public void buildWalls() { house.setWall(\"木牆\"); System.out.println(\"開始建造木牆\"); } @Override public void buildRoof() { house.setRoof(\"木製屋頂\"); System.out.println(\"開始建造木製屋頂\"); } } VillaBuilder別墅建造者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class VillaBuilder extends Builder{ @Override public void buildBase() { house.setBase(\"鋼筋水泥地基\"); System.out.println(\"開始建造鋼筋水泥地基\"); } @Override public void buildWalls() { house.setWall(\"鋼筋水泥牆\"); System.out.println(\"開始建造鋼筋水泥牆\"); } @Override public void buildRoof() { house.setRoof(\"鋼筋水泥屋頂 + 游泳池\"); System.out.println(\"開始建造防漏水鋼筋水泥屋頂 + 游泳池\"); } } Director指揮者，負責建造流程與產生房子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Director { private Builder builder; // 用聚合的方式，把builder聚合在Director public void setBuilder(Builder builder) { this.builder = builder; } // 控管建造流程，最後把建造完成的房子傳回 public House construct() { builder.buildBase(); builder.buildWalls(); builder.buildRoof(); return builder.build(); } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { public static void main(String[] args) { // 指揮者 Director director = new Director(); System.out.println(\"==========建造小木屋===========\"); // 把小木屋建造者放入參數 director.setBuilder(new CabinBuilder()); // 建造小木屋 House house = director.construct(); System.out.println(\"Base = \" + house.getBase()); System.out.println(\"Wall = \" + house.getWall()); System.out.println(\"Roof = \" + house.getRoof()); System.out.println(\"========建造別墅=============\"); // 把別墅建造者放入參數 director.setBuilder(new VillaBuilder()); // 建造別墅 house = director.construct(); System.out.println(\"Base = \" + house.getBase()); System.out.println(\"Wall = \" + house.getWall()); System.out.println(\"Roof = \" + house.getRoof()); } } ==========建造小木屋=========== 開始建造木頭地基 開始建造木牆 開始建造木製屋頂 Base = 木頭地基 Wall = 木牆 Roof = 木製屋頂 ========建造別墅============= 開始建造鋼筋水泥地基 開始建造鋼筋水泥牆 開始建造防漏水鋼筋水泥屋頂 + 游泳池 Base = 鋼筋水泥地基 Wall = 鋼筋水泥牆 Roof = 鋼筋水泥屋頂 + 游泳池"
  },"/pages/design_pattern/observer/": {
    "title": "觀察者模式",
    "keywords": "",
    "url": "/pages/design_pattern/observer/",
    "body": "需求 台灣氣象站提供一個天氣API，Line與Google會訂閱氣象站，一旦氣溫、溼度的資料更新，會通知有訂閱的網站更新氣象資料。 類別圖 Subject主題介面，要實作的方法有register()、remove()、notifyObserver()。 WeatherAPI實作Subject，成員屬性有observers，setData()為設定溫度與溼度的方法。 Observer觀察者介面，要實作的方法update() Line與Google實作Observer。 Subject主題 1 2 3 4 5 public interface Subject { void register(Observer o); void remove(Observer o); void notifyObserver(); } Observer觀察者 1 2 3 public interface Observer { void update(float temperature, float humidity); } WeatherAPI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class WeatherAPI implements Subject{ // 溫度 private float temperature; // 溼度 private float humidity; // 觀察者們 private List&lt;Observer&gt; observers; public WeatherAPI() { observers = new ArrayList&lt;&gt;(); } //註冊 @Override public void register(Observer o) { observers.add(o); } // 刪除 @Override public void remove(Observer o) { observers.remove(o); } //通知 @Override public void notifyObserver() { for (Observer o: observers) { // 通知觀察者們更新氣象資訊 o.update(getTemperature(),getHumidity()); } } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public void setData(float temperature, float humidity) { this.temperature = temperature; this.humidity = humidity; // 通知觀察者們 notifyObserver(); } } Google,Line Google 1 2 3 4 5 6 7 8 public class Google implements Observer{ @Override public void update(float temperature, float humidity) { System.out.println(\"=====Google=======\"); System.out.println(\"temperature: \" + temperature); System.out.println(\"humidity: \" + humidity); } } Line 1 2 3 4 5 6 7 8 public class Line implements Observer{ @Override public void update(float temperature, float humidity) { System.out.println(\"=====Line=======\"); System.out.println(\"temperature: \" + temperature); System.out.println(\"humidity: \" + humidity); } } Main主程式 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { WeatherAPI weatherAPI = new WeatherAPI(); // 註冊觀察者們 weatherAPI.register(new Google()); weatherAPI.register(new Line()); // 更新天氣 weatherAPI.setData(27f, 68f); } } =====Google======= temperature: 27.0 humidity: 68.0 =====Line======= temperature: 27.0 humidity: 68.0"
  },"/pages/design_pattern/strategy/": {
    "title": "策略模式",
    "keywords": "",
    "url": "/pages/design_pattern/strategy/",
    "body": "建一個鳥的類別，然後要定義飛這個行為。 1 2 3 class Bird { void fly(); } 但所有的鳥類都會飛嗎？公雞就不會飛、駝鳥也不會飛，鴨子會飛一些，所以要把會飛這個行為變成一種策略，有些鳥類飛的很好，有些會飛一些，有些不會飛。 建立FlyBehavior介面。 實作flyBehavior，建立「會飛」、「飛很差」、「不會飛」三種飛的行為。 鳥的類別把flyBehavior作為成員變數。 鳥的fly()方法呼叫flyBehavior.fly()，如果flyBehavior有設定的話。 鳥的「子」類別去設定飛的行為。 FlyBehavior飛的行為，有fly()方法 FlyWell、NotFly、FlyBadly實作FlyBehavior介面 Bird為抽象類別有flyBehavior成員變數與fly()方法 Chicken、Sparrow麻雀、Douck為Bird的子類。 FlyBehavior介面 1 2 3 4 public interface FlyBehavior { // 抽象方法 void fly(); } FlyWell,NotFly,FlyBadly 實作FlyBehavior，都要覆寫抽象方法fly() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class FlyWell implements FlyBehavior { @Override public void fly() { System.out.println(\"Fly very well\"); } } public class NotFly implements FlyBehavior { @Override public void fly() { System.out.println(\"Can not fly.\"); } } public class FlyBadly implements FlyBehavior { @Override public void fly() { System.out.println(\"Fly very Badly.\"); } } Bird抽象類別 flyBehavior設為成員屬性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class Bird { // 成員屬性 protected FlyBehavior flyBehavior; // 聲音 public abstract void sound(); // 飛的方法 public void fly() { // 如果有飛的行為，就用 if (flyBehavior != null) flyBehavior.fly(); } } Chicken,Sparrow,Duck 子類別使用建構子設定飛的行為 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Chicken extends Bird { public Chicken() { // 建構子設定飛的行為 flyBehavior = new NotFly(); } @Override public void sound() { System.out.println(\"咕咕咕\"); } } public class Sparrow extends Bird{ public Sparrow() { // 建構子設定飛的行為 flyBehavior = new FlyWell(); } @Override public void sound() { System.out.println(\"吱吱\"); } } public class Duck extends Bird { public Duck() { // 建構子設定飛的行為 flyBehavior = new FlyBadly(); } @Override public void sound() { System.out.println(\"嘎嘎\"); } } main主程式 可以動態修改飛的行為 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { Chicken chicken = new Chicken(); System.out.println(\"=== chicken ===\"); chicken.fly(); Sparrow sparrow = new Sparrow(); System.out.println(\"=== Sparrow ===\"); sparrow.fly(); Duck duck = new Duck(); System.out.println(\"=== duck ===\"); duck.fly(); System.out.println(\"=== setting duck again ===\"); // 動態修改飛的行為 duck.flyBehavior = new FlyWell(); duck.fly(); } } === chicken === Can not fly. === Sparrow === Fly very well === duck === Fly very Badly. === setting duck again === Fly very well"
  },"/pages/design_pattern/bridge/": {
    "title": "橋樑模式",
    "keywords": "",
    "url": "/pages/design_pattern/bridge/",
    "body": "Prerequisites: HAS-A比IS-A更好 依賴反轉原則 開放關閉原則 類別圖 需求 為手機品牌A寫遊戲 1 2 3 4 5 class BrandAGame { public void play() { System.out.println(\"Brand A Game!\"); } } 為手機品牌B寫遊戲 1 2 3 4 5 class BrandBGame { public void play() { System.out.println(\"Brand B Game!\"); } } 把以上二個類別整合成如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class Game { abstract void play(); } class BrandAGame extends Game { public void play() { System.out.println(\"Brand A Game!\"); } } class BrandBGame extends Game { public void play() { System.out.println(\"Brand B Game!\"); } } 那如果要再增加通訊錄在各品牌手機，要如何修正？如下圖嗎？ 那如果要再增加新的手機品牌，與拍照功能要如何修正？如下圖嗎？ 是依軟體來分嗎？ 還是依品牌來分？ 若還要增加10種手機品牌，還要新增錄音、導航、行事曆…等等軟體，請問類別圖怎麼畫？ 有一個比是一個更好 這種已經無法畫下去了，首先我們需要取消繼承關係，不要軟體中有品牌，也不要品牌中有軟體，要符合「單一職責原則」，一個類別就做一件事，分成「手機品牌抽象類別」與「軟體抽象類別」二類。 而在手機品牌類別中，用有一個Has-A的方式，把「軟體抽象類別」聚合在手機品牌中，使用抽象類別或介面(Interface)符合依賴反轉原則，依賴抽象，而不是依賴具體的子類別。 而且新增手機品牌與新增錄音、導航、行事曆…等等軟體，不用改動架構，比較好加入新的類別，符合開放關閉原則，對修改關閉，對擴充開放。 橋樑 注意上圖，那條菱形的線，橫跨手機品牌與軟體，就像一個橋，把二個不同的類別連接在一起，所以才稱之為橋樑模式(Bridge Pattern)。 經典橋樑模式類別圖 Abstraction意思是抽象，「手機品牌」，就是一個抽象的概念，手機品牌A、手機品牌B是品牌的子類別。 Implementor意思是實作，「軟體」有很多不同的軟體與實作方式。 但我覺得不用為名詞特別綁定一定要是抽象的概念才能歸類在Abstraction，我一開始也為此卡住，此模式的精神在於分類，單一職責、有一個比是一個更好、依賴反轉原則、開放關閉原則。 程式碼 軟體 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface Software { void operationImp(); } public class Game implements Software{ @Override public void operationImp() { System.out.println(\"遊戲開始\"); } } public class Contacts implements Software{ @Override public void operationImp() { System.out.println(\"列出聯絡人\"); } } 品牌 最重要在於software成員變數是set過來的，在operation()方法是呼叫software.operationImp()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public abstract class Brand { private Software software; public void operation() { software.operationImp(); } public void setSoftware(Software software) { this.software = software; } } public class BrandA extends Brand{ @Override public void operation() { super.operation(); System.out.println(\"Brand A\"); } } public class BrandB extends Brand{ @Override public void operation() { super.operation(); System.out.println(\"BrandB\"); } } main主程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test { public static void main(String[] args) { System.out.println(\"======Brand A=========\"); Brand brandA = new BrandA(); brandA.setSoftware(new Game()); brandA.operation(); brandA.setSoftware(new Contacts()); brandA.operation(); System.out.println(\"======Brand B=========\"); Brand brandB = new BrandB(); brandB.setSoftware(new Game()); brandB.operation(); brandB.setSoftware(new Contacts()); brandB.operation(); } } ======Brand A========= 遊戲開始 Brand A 列出聯絡人 Brand A ======Brand B========= 遊戲開始 BrandB 列出聯絡人 BrandB"
  },"/pages/design_pattern/proxy/": {
    "title": "Proxy代理人模式",
    "keywords": "",
    "url": "/pages/design_pattern/proxy/",
    "body": "Prerequisites: 類別圖 代理人的作用是代替別人，去做那個人該做的事。 就好像現實世界中，我們買機票是透過旅行社去買，旅行社再跟航空公司買，而不是我們直接去跟航空公司買，但實際付錢的人是我們，不是旅行社。 而旅行社就是代理人，旅客是真正的類別，買機票是方法。 類別圖 Agency 旅行社 BuyTicket 介面 Tourist 旅客 Client 測試用的客戶端 首先要有一個介面(BuyTicket)，旅行社Agency與旅客Tourist都要去實作介面pay()方法。 旅行社Agency的成員屬性要有旅客Tourist，使用建構子參數，把旅客傳入旅行社，所以是屬於共生共死的組合關係，菱形是實心。 旅行社Agency的pay()方法，實際上是呼叫旅客的pay()方法。 而測試時，是用旅行社去買機票，不是旅客去買機票。 程式碼 BuyTicket介面 1 2 3 public interface BuyTicket { void pay(); } 旅客實作BuyTicket介面的pay方法。 1 2 3 4 5 6 public class Tourist implements BuyTicket{ @Override public void pay() { System.out.println(\"旅客提供信用卡 卡號付錢\"); } } 旅行社實作BuyTicket介面的pay方法，實際上是旅客付錢。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Agency implements BuyTicket{ // 成員屬性要有旅客Tourist private Tourist tourist; // 使用建構子參數，把旅客傳入旅行社 public Agency(Tourist tourist) { this.tourist = tourist; } @Override public void pay() { // 實際上是呼叫旅客的pay()方法 tourist.pay(); } } Client測試 1 2 3 4 5 6 7 8 9 10 public class Client { public static void main(String[] args) { // 建立旅客 Tourist tourist = new Tourist(); // 把旅客傳入旅行社的建構子 Agency agency = new Agency(tourist); // 旅行社付錢，實際上旅客付的。 agency.pay(); } } 旅客提供信用卡 卡號付錢 Thread 執行緒 執行緒也是代理人模式，執行緒都會實作Runnable代理介面。 以下是執行緒代理人。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class ThreadProxy implements Runnable{ private Runnable target; @Override public void run() { // 真正呼叫的是target的run方法。 if (target != null) { target.run(); } } public ThreadProxy(Runnable target) { this.target = target; } // 啟動執行緒 public void start() { start0(); } private void start0() { run(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test3 { public static void main(String[] args) { // 使用匿名內部類的方法，建立一個匿名的實作Runnable介面的物件 Runnable r1 = new Runnable() { @Override public void run() { System.out.println(\"執行r1的run方法\"); } }; // 把real class傳入建構子 ThreadProxy threadProxy = new ThreadProxy(r1); // 真正執行的是匿名內部類別的run方法。 threadProxy.start(); } } Java動態代理介面 反射 使用反射，傳回代理介面，呼叫代理介面的方法，也可以呼叫到Tourist的方法。 類別圖 ProxyFactory 代理工廠，建構子傳入Tourist BuyTicke 介面 Tourist Client 測試類別 程式碼 BuyTicket與Tourist跟先前的一模一樣。 使用java.lang.reflect.Proxy Proxy.newProxyInstance(classLoader(), Interfaces(), InvocationHandler()); 第一個參數為類別的classLoader 第二個參數為介面BuyTicket 第三個參數為InvocationHandler() 透過反射的方法，建立代理人。 ProxyFactory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 反射需要的類別 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class ProxyFactory { // 類型為Object private Object tourist; // 參數類型為Object public ProxyFactory(Object tourist) { this.tourist = tourist; } // 傳回值類型是Object public Object getProxyInstance() { return Proxy.newProxyInstance( tourist.getClass().getClassLoader(), // 取得classloader tourist.getClass().getInterfaces(), // 取得介面 new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 第1個參數為tourist Object instance = method.invoke(tourist, args); return instance; } }); } } Client 1 2 3 4 5 6 7 8 9 10 public class Client { public static void main(String[] args) { // 編譯類型為BuyTicket介面，執行類型Tourist BuyTicket tourist = new Tourist(); // 轉型成BuyTicket介面，參數代入tourist BuyTicket agency = (BuyTicket) new ProxyFactory(tourist).getProxyInstance(); // 呼叫pay方法，但實際上執行Tourist的pay()方法 agency.pay(); } } 旅客提供信用卡 卡號付錢"
  },"/pages/design_pattern/state/": {
    "title": "狀態模式",
    "keywords": "",
    "url": "/pages/design_pattern/state/",
    "body": "這是一個轉變狀態的模式。 需求 設計一個線上購物程式，並設計以下幾種狀態。 無訂單狀態 訂購商品 裝箱 寄送商品 接收產品 訂購產品的時候，由無訂單狀態 -&gt; 訂購商品狀態 -&gt; 裝箱狀態 -&gt; 寄送狀態 -&gt; 接收產品狀態 -&gt; 無訂單狀態 類別圖 Eshopping 儲存共用的變數count，各種狀態(沒訂單狀態、訂單狀態、裝箱狀態、寄送狀態、收到狀態)、state為目前狀態。 setState()設定目前狀態 order() 呼叫orderState訂單狀態的order() box() 呼叫boxState裝箱狀態的box() delivery() 呼叫deliveryState寄送狀態的delivery() receiveState() 呼叫receiveState接收狀態的receive() noOrder() 呼叫noOrderState沒有訂單狀態的noOrder() setCount() 設定產品變數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 public class Eshopping { // 沒訂單狀態 private State noOrderState; // 訂單狀態 private State orderState; // 裝箱狀態 private State boxState; // 寄送狀態 private State deliveryState; // 收到狀態 private State receiveState; // 目前狀態 private State state; // 產品數量 private int count = 0; public Eshopping() { // 建立所有狀態 noOrderState = new NoOrderState(this); orderState = new OrderState(this); boxState = new BoxState(this); deliveryState = new DeliveryState(this); receiveState = new ReceiveState(this); // 預設為沒有訂單狀態 state = noOrderState; } // 沒有訂單 public void noOrder() { state.noOrder(); } // 訂購 public void order() { state.order(); } // 產品裝箱 public void box() { state.box(); } // 產品寄送 public void delivery() { state.deliver(); } // 收到產品 public void receive() { state.receive(); } // 設定狀態 public void setState(State state) { this.state = state; } // 取得無訂單狀態 public State getNoOrderState() { return noOrderState; } public State getOrderState() { return orderState; } public State getBoxState() { return boxState; } public State getDeliveryState() { return deliveryState; } public State getReceiveState() { return receiveState; } // 設定產品數量 public void setCount(int count) { this.count = count; } //取得產品數量 public int getCount() { return count; } } State介面 定義介面要實作的方法 1 2 3 4 5 6 7 8 9 10 11 12 public interface State { // 沒訂單 void noOrder(); // 訂購 void order(); // 裝箱 void box(); // 寄送 void deliver(); // 收到產品 void receive(); } AbstractState抽象狀態 此處用到介面轉接器模式 把介面所有的方法全部實作，繼承的子類別，只要選擇性覆寫特定方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public abstract class AbstractState implements State { @Override public void noOrder() { // do nothing } @Override public void order() { // do nothing } @Override public void box() { // do nothing } @Override public void deliver() { // do nothing } @Override public void receive() { // do nothing } } 無訂單狀態 重點在於轉換到其它狀態的部分，狀態轉到訂單狀態，並呼叫訂單狀態的order方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class NoOrderState extends AbstractState { private Eshopping eshopping; public NoOrderState(Eshopping eshopping) { this.eshopping = eshopping; } @Override public void noOrder() { if (eshopping.getCount() == 0) System.out.println(\"產品數量不足\"); System.out.println(\"無訂單狀態\"); } @Override public void order() { // 狀態轉到訂單狀態 eshopping.setState(eshopping.getOrderState()); // 呼叫訂購 eshopping.order(); } } 訂購狀態 重點在於轉換到其它狀態的部分，訂單狀態轉到裝箱狀態，並呼叫裝箱狀態的box()。 若產品數量不足，無法提供訂購，訂單狀態轉到沒有訂單，並呼叫沒有訂單狀態的noOrder()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class OrderState extends AbstractState { private Eshopping eshopping; public OrderState(Eshopping eshopping) { this.eshopping = eshopping; } @Override public void order() { if (eshopping.getCount() &gt; 0) { System.out.println(\"訂購產品\"); // 數量減1 eshopping.setCount(eshopping.getCount() - 1); // 狀態轉到裝箱 eshopping.setState(eshopping.getBoxState()); eshopping.box(); } else { // 狀態轉到沒有訂單 eshopping.setState(eshopping.getNoOrderState()); // 呼叫沒有訂單的方法 eshopping.noOrder(); } } } 裝箱狀態 重點在於轉換到其它狀態的部分，狀態轉到寄送狀態，並呼叫寄送狀態的delivery()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class BoxState extends AbstractState{ private Eshopping eshopping; public BoxState(Eshopping eshopping) { this.eshopping = eshopping; } @Override public void box() { // 裝箱 System.out.println(\"裝箱完成\"); // 狀態轉到寄送 eshopping.setState(eshopping.getDeliveryState()); eshopping.delivery(); } } 寄送狀態 重點在於轉換到其它狀態的部分，狀態轉到接收狀態，並呼叫接收狀態的receivey()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class DeliveryState extends AbstractState { private Eshopping eshopping; public DeliveryState(Eshopping eshopping) { this.eshopping = eshopping; } @Override public void deliver() { System.out.println(\"出貨\"); // 狀態轉到接收 eshopping.setState(eshopping.getReceiveState()); eshopping.receive(); } } 接收狀態 重點在於轉換到其它狀態的部分，狀態轉到沒有訂單狀態，並呼叫沒有訂單狀態的noOrder()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ReceiveState extends AbstractState { private Eshopping eshopping; public ReceiveState(Eshopping eshopping) { this.eshopping = eshopping; } @Override public void receive() { System.out.println(\"貨品已送達\"); // 狀態轉到沒有訂單 eshopping.setState(eshopping.getNoOrderState()); eshopping.noOrder(); } } 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { Eshopping eshopping = new Eshopping(); //設定數量 eshopping.setCount(2); //訂購 eshopping.order(); System.out.println(\"===========================\"); eshopping.order(); System.out.println(\"===========================\"); eshopping.order(); } } 訂購產品 裝箱完成 出貨 貨品已送達 商品剩餘數量 = 1 =========================== 訂購產品 裝箱完成 出貨 貨品已送達 商品剩餘數量 = 0 =========================== 產品數量不足 無訂單狀態 商品剩餘數量 = 0"
  },"/pages/design_pattern/mediator/": {
    "title": "中介者模式",
    "keywords": "",
    "url": "/pages/design_pattern/mediator/",
    "body": "中介者模式 Mediator，中文是調解員，在「深入淺出設計模式」一書是協調者。 意思是，類別與類別不互相溝通，由調解員來做中間者，幫助類別彼此溝通，就像買屋的人與賣屋的人不互相溝通，由房仲跟二邊的人溝通。 類別圖 AbstructColleague: 抽象同事類別 Colleague: 具體同事類別 Manager: 主管類別 Mediator 抽象中介者 Union 工會 AbstructColleague與Mediator是一條直線，因為二邊都有彼此的成員變數，是1對1雙向關係。 Mediator抽象中介者 要讓中間人，知道是誰要彼此溝通。 Mediator類別有個屬性colleague”s”，類型是List。 addColleague()方法，放置要透過中間人溝通的類別。 Mediator類別sendMessage Mediator類別sendMessage(String message, AbstractColleague sender) 子類別要覆寫處理各個類別的溝通方式，sender是溝通的時候，子類別物件把自己傳過來當作參數。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public abstract class Mediator { // 要透過中間人幫助溝通的類別 private List&lt;AbstractColleague&gt; colleagues; public Mediator() { colleagues = new ArrayList&lt;&gt;(); } // 加入要溝通的類別 public void addColleague(AbstractColleague colleague) { colleagues.add(colleague); } // 處理中間人怎麼跟類別溝通 public abstract void sendMessage(String message, AbstractColleague sender); public List&lt;AbstractColleague&gt; getColleagues() { return colleagues; } } Union工會 作為中間人，與其它類別溝通。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 工會，中間人 public class Union extends Mediator { // 參數2是發訊息的人 @Override public void sendMessage(String message, AbstractColleague sender) { // 發送訊息給所有人 for (AbstractColleague user: getColleagues()) { // 除了發送訊息本人之外，把訊息發給所有人 // 透過sender取得發訊息的人的資訊 if (!user.name.equals(sender.getName())) { // 讓其它人接收來自sender的訊息 user.receiveMessage(sender.getName() + \"說\" + message); } } } } AbstractColleague抽象同事 要把中間人 Mediator 作為成員屬性 抽象的sendMessage()，子類別要覆寫 抽象的receiveMessage()，子類別要覆寫 AbstractColleague 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public abstract class AbstractColleague { // Mediator 成員屬性 protected Mediator mediator; // 姓名 protected String name; // 建構子 public AbstractColleague(Mediator mediator, String name) { this.mediator = mediator; this.name = name; } // 發送訊息，實際上是呼叫Mediator.sendMessage() public abstract void sendMessage(String message); // 接收訊息 public abstract void receiveMessage(String message); // 取得名字 public String getName() { return name; } public void setName(String name) { this.name = name; } } Colleague同事 sendMessage()方法，實際上是呼叫Mediator.sendMessage()，第二個參數this，是把自己作為參數傳入。 Colleague 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Colleague extends AbstractColleague{ public Colleague(Mediator mediator, String name) { // 建構子，預設使用父類別建構子 super(mediator, name); } // 實際上是呼叫Mediator.sendMessage() // 第2個參數是把自己物件本身傳入 public void sendMessage(String message) { mediator.sendMessage(message, this); } // 接收訊息 public void receiveMessage(String message) { System.out.println(\"name = \" + getName() + \", msg = \" + message); } } Manager主管 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Manager extends AbstractColleague{ public Manager(Mediator mediator, String name) { super(mediator, name); } public void sendMessage(String message) { mediator.sendMessage(message, this); } public void receiveMessage(String message) { System.out.println(\"Manager name = \" + getName() + \", msg = \" + message); } } Client測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Client { public static void main(String[] args) { Union union = new Union(); //工會 // 同事 AbstractColleague colleague1 = new Colleague(union, \"Alex\"); AbstractColleague colleague2 = new Colleague(union, \"May\"); AbstractColleague colleague3 = new Colleague(union, \"Bill\"); AbstractColleague manager1 = new Manager(union, \"主管1\"); AbstractColleague manager2 = new Manager(union, \"主管2\"); // 要讓中介者知道要協助溝通的人 union.addColleague(colleague1); union.addColleague(colleague2); union.addColleague(colleague3); union.addColleague(manager1); union.addColleague(manager2); // 向中介者發送訊息，中介者收到訊息再把訊息傳給其它人。 colleague1.sendMessage(\"Hello!\"); colleague2.sendMessage(\"Hi\"); manager2.sendMessage(\"I'm manager.\"); } } name = May, msg = Alex說Hello! name = Bill, msg = Alex說Hello! Manager name = 主管1, msg = Alex說Hello! Manager name = 主管2, msg = Alex說Hello! name = Alex, msg = May說Hi name = Bill, msg = May說Hi Manager name = 主管1, msg = May說Hi Manager name = 主管2, msg = May說Hi name = Alex, msg = 主管2說I'm manager. name = May, msg = 主管2說I'm manager. name = Bill, msg = 主管2說I'm manager. Manager name = 主管1, msg = 主管2說I'm manager."
  },"/pages/design_pattern/template/": {
    "title": "樣板模式",
    "keywords": "",
    "url": "/pages/design_pattern/template/",
    "body": "Prerequisites: 抽象方法 樣板模式的重點，把不變的內容放在抽象父類別，會變的放在子類別。 什麼是樣板模式？ 想像成問卷，題目是一樣，把一樣的題目放在父類別。 但每個人回答的答案是不一樣的，不一樣的地方，就由子類別自己去覆寫。 父類別放一樣的內容 1 2 3 4 5 6 7 8 9 10 11 public abstract class Question { public void getQuestion() { // 題目都一樣 System.out.println(\"你最喜歡的夜市美食是什麼？\"); // 回答內容不一樣，由子類別覆寫 answer(); } // 回答內容不一樣，由子類別覆寫 public abstract void answer(); } 子類別覆寫不一樣的內容 Answer1 1 2 3 4 5 6 public class Answer1 extends Question{ @Override public void answer() { System.out.println(\"蚵仔煎\"); } } Answer2 1 2 3 4 5 6 public class Answer2 extends Question{ @Override public void answer() { System.out.println(\"臭豆腐\"); } } Answer3 1 2 3 4 5 6 public class Answer3 extends Question{ @Override public void answer() { System.out.println(\"雞排\"); } } Client測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Client { public static void main(String[] args) { Question ans1 = new Answer1(); ans1.getQuestion(); System.out.println(\"=======================\"); Question ans2 = new Answer2(); ans2.getQuestion(); System.out.println(\"=======================\"); Question ans3 = new Answer3(); ans3.getQuestion(); System.out.println(\"=======================\"); } } 你最喜歡的夜市美食是什麼？ 蚵仔煎 ======================= 你最喜歡的夜市美食是什麼？ 臭豆腐 ======================= 你最喜歡的夜市美食是什麼？ 雞排 ======================= 計算執行時間樣板 計算執行時間的方式是固定的，但執行的程式碼不知道怎麼執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class CaculateJobTime { // 不知道怎麼執行的程式碼，改成抽象方法，由子類別去覆蓋這個方法 abstract void job(); // 計算程式執行時間 public void caculate() { long start = System.currentTimeMillis(); // 要執行的程式碼 job(); // 計算執行時間 long end = System.currentTimeMillis(); System.out.println(\"執行 \" + (end - start) + \" 毫秒\"); } } 1 2 3 4 5 6 7 8 class JobA extends CaculateJobTime { @Override void job() { for (int i = 0 ; i &lt; 10000000; i++) { long result = i * i; } } } 1 2 3 4 5 6 7 8 class JobB extends CaculateJobTime { @Override void job() { for (int i = 0 ; i &lt; 50000000; i++) { long result = i * i; } } } 測試 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { JobA jobA = new JobA(); jobA.caculate(); JobB jobB = new JobB(); jobB.caculate(); } } 執行 4 毫秒 執行 5 毫秒"
  },"/pages/java/generics/": {
    "title": "泛型",
    "keywords": "",
    "url": "/pages/java/generics/",
    "body": "如何理解什麼是泛型呢？ 1 2 3 4 5 int i; i = 100; i = 55; i = 22; i是變數。 以上等號右邊的值，可以為100、55、22。 1 2 3 4 T = Integer; T = Double; T = ArrayList; T = Object; T為Type類型的英文字母。 T是變數。 以上等號右邊的值，可以為Integer, Double, ArrayList, Object。 所以下面文章內容所有的T, R, K, V …，任何英文字母，請把它看作變數，而變數中的值，就是類型。 自訂類型 在類別名後面，用尖括號包住&lt;自訂類型&gt;。 自訂類型T, R, M 可用英文字母任意一個大寫字母。 1 2 class Cat&lt;T, R, M&gt; { } 屬性 泛型可以用在屬性類型。 1 2 3 4 5 class Cat&lt;T, R, M&gt; { private T t; private R r; private M m; } 建構子 泛型可以用在建構子參數類型。 1 2 3 4 5 6 7 8 9 10 11 class Cat&lt;T, R, M&gt; { private T t; private R r; private M m; public Cat(T t, R r, M m) { this.t = t; this.r = r; this.m = m; } } get,set方法 泛型可以用在方法參數類型與傳回值類型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Cat&lt;T, R, M&gt; { private T t; private R r; private M m; public T getT() { return t; } public void setT(T t) { this.t = t; } public R getR() { return r; } public void setR(R r) { this.r = r; } public M getM() { return m; } public void setM(M m) { this.m = m; } 宣告與建立物件編譯器才會知道類型 1 Cat&lt;String, Integer, Dog&gt; cat = new Cat&lt;String, Integer, Dog&gt;(); jdk8以後可以省略後面的尖括號中的類型，因為前面已經宣告泛型(T,R,M)的類型是什麼，後面的可由前面的尖括號內容進行自動推導。 1 Cat&lt;String, Integer, Dog&gt; cat = new Cat&lt;&gt;(); 沒泛型類型，預設Object 沒設定泛型類型。 1 Cat cat = new Cat(); 編譯器自動認為泛型類型是Object。 1 Cat&lt;Object, Object, Object&gt; cat = new Cat&lt;&gt;(); 泛型類型可以使用子類別 類別B繼承類別A 1 2 class A {} class B extends A {} Student，有泛型類型T屬性，與建構子。 1 2 3 4 5 6 7 class Student&lt;T&gt; { private T t; public Student(T t) { this.t = t; } } 由以下的範例可以知道，泛型類型是可以用子類別。 1 2 3 Student&lt;A&gt; s3 = new Student&lt;&gt;(new A()); // 泛型類型是父類別A，但建構子放的是子類別B Student&lt;A&gt; s4 = new Student&lt;&gt;(new B()); 以下的程式碼也都是正確的，ArrayList是List的子類別，也是Object的子類別。 1 2 Student&lt;List&gt; s1 = new Student&lt;&gt;(new ArrayList&lt;&gt;()); Student&lt;Object&gt; s2 = new Student&lt;&gt;(new ArrayList&lt;&gt;()); 基本型別自動轉成包裝類別 包裝類別 貓咪類別 1 2 3 4 5 6 7 8 9 10 11 class Cat&lt;T, R, M&gt; { private T t; private R r; private M m; public Cat(T t, R r, M m) { this.t = t; this.r = r; this.m = m; } } 指定泛型類型，並建立物件，注意！建構子的參數都是基本型態，但內部會自動把12.5轉成Double類別，1轉成Integer類別。 1 Cat&lt;Double, Boolean, Integer&gt; cat = new Cat&lt;&gt;(12.5, true, 1); 使用getClass()知道泛型類型 1 2 3 4 5 6 7 8 9 10 11 12 13 class Cat&lt;T, R, M&gt; { public void showType() { System.out.println(t.getClass()); System.out.println(r.getClass()); System.out.println(m.getClass()); } } public class Test { public static void main(String[] args) { Cat&lt;Double, Boolean, Integer&gt; cat = new Cat&lt;&gt;(12.5, true, 1); cat.showType(); } } class java.lang.Double class java.lang.Boolean class java.lang.Integer 不能使用泛型的情況 泛型不可以new 以下二種new是不被允許，因為編譯器根本不知道T是什麼類型，又怎麼會知道要在記憶體建立多大空間來裝這個物件。 1 2 3 4 class Cat&lt;T, R, M&gt; { private T t = new T(); private T[] arr = new T[10]; } 泛型不可以用在靜態變數與靜態方法 memory_model static 靜態變數是在Class物件中，Class物件比物件更早建立，泛型要在物件建立的時候才指定類型，但靜態物件早就建立好了，根本不可能指定靜態變數的類型。 以下三種都不能使用。 1 2 3 4 5 6 7 8 9 10 11 12 class Cat&lt;T, R, M&gt; { // static屬性 public static T t; // static方法 public static T getStaticT() { } // static方法 public static void setStaticT(T t) { } } 不能用基本型態 基本型態有short, int, long, double, float, boolean, char 以下內容編譯不過。 1 Cat&lt;int, double, char&gt; cat = new Cat&lt;&gt;(); 以下是另一種筆記。 語法 在類別名後面，自訂類型。 自訂類型的名稱可用T, R, K, V 任意一個大寫字母。 1 2 3 class 類別名&lt;T, R, U&gt; { } T代表Type，也就是類型。 T可以是成員變數的類型，也可以是成員方法參數類型。 成員變數類型 1 2 3 class 名稱&lt;T&gt; { T 變數名; } 1 2 3 class Obj1&lt;T&gt; { T id; } 參數類型 1 2 3 4 5 class Obj2&lt;T&gt; { public void showMsg(T msg) { msg.toString(); } } 類型為T，只能用toString()的方法，toString()是由Object類別(所有類別的父類別)所提供的。 傳回值類型 1 2 3 4 5 6 class Obj3&lt;T&gt; { private T[] elements; public T getElements(int index) { return elements[index]; } } 使用泛型 宣告 在類別名後面有尖括號，尖括號中寫上實際的類型。 1 2 類別名&lt;類型&gt; 變數; Obj1&lt;String&gt; test; 建立物件 new 類別名後面有尖括號，尖括號中寫上實際的類型。 語法 1 new 類別名&lt;類型&gt;(); JDK7以前一定要寫類型 1 Obj1&lt;String&gt; test = new Obj1&lt;String&gt;(); JDK7就可以不用在尖括號中寫類型，因為編譯器可以從宣告的時候就推斷類型。 1 Obj1&lt;String&gt; test = new Obj1&lt;&gt;(); 範例 Cat類別，重寫toString()的方法 1 2 3 4 5 6 class Cat { @Override public String toString() { return \"貓貓貓\"; } } Dog類別，重寫toString()的方法 1 2 3 4 5 6 class Dog { @Override public String toString() { return \"狗狗狗\"; } } ShowObj，使用泛型，參數是泛型，什麼類型都可以。 1 2 3 4 5 class ShowObj&lt;T&gt; { public void showObj(T obj) { System.out.println(obj.toString()); } } 宣告ShowObj是Cat類型，showObj()方法參數只能是Cat類型，不能放Dog類型，不然編譯時會出錯。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { ShowObj&lt;Cat&gt; show1 = new ShowObj&lt;&gt;(); show1.showObj(new Cat()); } } 貓貓貓 宣告ShowObj是Dog類型，showObj()方法參數只能是Dog類型，不能放Cat類型，不然編譯時會出錯。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { ShowObj&lt;Dog&gt; show2 = new ShowObj&lt;&gt;(); show2.showObj(new Dog()); } } 狗狗狗"
  },"/pages/java/generics_interface/": {
    "title": "泛型介面",
    "keywords": "",
    "url": "/pages/java/generics_interface/",
    "body": "Prerequisites: 介面 泛型 語法 在類別名後面，用尖括號包住&lt;自訂類型&gt;。 自訂類型可用T, R, K, V 任意一個大寫字母。 1 2 interface 介面名&lt;T, R, M&gt; { } 抽象方法 介面中的方法都是抽象。 1 2 3 4 interface IMove&lt;T, R, M&gt; { R doMove(M m); void move(T t1, T t2, R r1, M m1); } 繼承時要指定泛型類型 以下程式碼，IFly繼承IMove時，要指定泛型類型Integer, String, Object，才能繼承。 1 2 3 4 5 6 7 8 interface IMove&lt;T, R, M&gt; { R doMove(M m); void move(T t1, T t2, R r1, M m1); } interface IFly extends IMove&lt;Integer, String, Object&gt; { } Duck實作IFly繼承下來的抽象方法，會自動替換類型，T, R, M 替換成 Integer, String, Object。 實作抽象方法。 選取要實作的抽象方法，按ok。 方法中的類型被自動填寫。 1 2 3 4 5 6 7 8 9 10 11 12 class Duck implements IFly { @Override public String doMove(Object o) { return null; } @Override public void move(Integer t1, Integer t2, String r1, Object m1) { } } 實作時要指定泛型類型 泛型介面 1 2 3 interface ISwim&lt;T, R, M&gt; { void swim(T t1, T t2, R r1, M m1); } 實作時要指定介面的泛型類型。 1 2 3 4 5 6 7 class Fish implements ISwim&lt;Object, Character, String&gt; { @Override public void swim(Object t1, Object t2, Character r1, String m1) { } } 沒指定泛型類型，預設用Object 潛水艇(Submarine)類別實作ISwim沒指定泛型類型，預設泛型類型為Object，所以swim方法的參數類型全部都是Object。 1 2 3 4 5 6 class Submarine implements ISwim { @Override public void swim(Object t1, Object t2, Object r1, Object m1) { } } 上面的程式碼與下面的程式碼是相同意思。 1 2 3 4 5 6 class Submarine implements ISwim&lt;Object, Object, Object&gt; { @Override public void swim(Object t1, Object t2, Object r1, Object m1) { } } 不能使用泛型的情況 不能用靜態static 以下為其它筆記。 泛型介面主要用途在於檢查介面的類型是否正確。 語法 interface 介面名後面有一對&lt;&gt;尖括號，尖括號包著的是泛型T。 1 2 interface 介面名&lt;T&gt; { } T，代表什麼類型都可以，除了基本類型(int, float, double …)之外。 1 2 3 interface Listen&lt;T&gt; { void listen(T obj); } 使用泛型介面 類別實作泛型介面，要指定型別。 Listen泛型介面 1 2 3 interface Listen&lt;T&gt; { void listen(T obj); } Piano 1 2 3 4 5 class Piano { void play() { System.out.println(\"Piano play\"); } } Guitar 1 2 3 4 5 class Guitar { void play() { System.out.println(\"Guitar play\"); } } 一般類別實作泛型介面要指定類型。 1 2 3 4 5 6 class Student implements Listen&lt;Piano&gt; { @Override public void listen(Piano obj) { obj.play(); } } 一般類別實作泛型介面要指定類型。 1 2 3 4 5 6 class Teacher implements Listen&lt;Guitar&gt; { @Override public void listen(Guitar obj) { obj.play(); } } 測試 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { Student student = new Student(); // 只能放Piano，不然會出錯 student.listen(new Piano()); Teacher teacher = new Teacher(); teacher.listen(new Guitar()); } } Piano play Guitar play"
  },"/pages/java/file/": {
    "title": "File",
    "keywords": "",
    "url": "/pages/java/file/",
    "body": "語法 File(String 檔案路徑與檔名); File(String 目錄名, String 檔名); File(File 目錄, String 檔名); 取得檔案資訊 1 2 3 4 5 6 7 8 9 10 public class FileTest { public static void main(String[] args) { File file = new File(\"/Users/cici/testc\", \"file_test\"); System.out.println(file.getName()); // 文件長度 System.out.println(file.length()); // 文件路徑 System.out.println(file.getAbsolutePath()); } } file_test 6 /Users/cici/testc/file_test 建立檔案 Java輸出入操作一定要用try catch，所以建立檔案時，要try catch錯誤，並且要判斷是否重覆建立。 1 2 3 4 5 6 7 8 try { // 判斷是否重覆建立 if (!file2.exists()) { file2.createNewFile(); } } catch (IOException e) { throw new RuntimeException(e); } 取得目錄下的檔案 file.list()方法傳回值為String陣列 1 String[] list() 取得目錄下的檔案 1 2 3 4 5 6 // 目錄 File file4 = new File(\"/Users/cici/testc\"); String[] filenames2 = file4.list(); for (String name: filenames2) { System.out.println(name); } testc.c libTest.a test file_test2 test.o file_test testc.cpp testc.o libTest.so testc 取得目錄下的檔案(限定附檔名) 先建立FileAccept，要去實作FilenameFilter，覆寫accept()方法。 1 2 3 4 5 6 7 8 9 import java.io.File; import java.io.FilenameFilter; public class FileAccept implements FilenameFilter { @Override public boolean accept(File dir, String name) { return name.endsWith(\".c\"); } } 使用FileAccept 1 2 3 4 5 6 7 File file3 = new File(\"/Users/cici/testc\"); FileAccept fileAccept = new FileAccept(); // 使用fileAccept String[] filenames = file3.list(fileAccept); for (String name: filenames) { System.out.println(name); } testc.c"
  },"/pages/java/buffer_io/": {
    "title": "Buffered串流",
    "keywords": "",
    "url": "/pages/java/buffer_io/",
    "body": "Buffered Buffered是指把讀取或寫入的資料，保存在記憶體緩衝區中。 BufferedReader與BufferedWriter 建構子 參數只能接收Reader的子類別(處理字元的串流)。 1 2 BufferedReader(Reader in) BufferedWriter(Writer out) readLine() 提供一列一列讀取的功能，讀完資料沒有資料可以讀會傳回null。 1 2 // Reads a line of text String readLine() 內部使用緩衝buffer功能，提高讀取效率。 1 2 3 4 5 6 7 8 BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(\"/Users/cici/testc/file_test\")); String line = null; while((line = bufferedReader.readLine()) != null) { System.out.println(line); } } 測試程式 java程式設計 write()與newLine() write()不會自動換行，需使用BufferedWriter.newLine()才會換行。 1 2 3 4 5 6 7 8 9 10 11 12 BufferedWriter bufferedWriter = null; try { bufferedWriter = new BufferedWriter(new FileWriter(\"/Users/cici/testc/file_test\")); // 寫一行 bufferedWriter.write(\"測試程式\"); // 換行 bufferedWriter.newLine(); // 寫一行 bufferedWriter.write(\"java程式設計\"); // 換行 bufferedWriter.newLine(); } 測試程式 java程式設計 BufferedInputStream與BufferedOutputStream 位元組資料都存在記憶體緩衝區，對緩衝區進行讀取與寫入。 以下是檔案拷貝程式碼。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 BufferedInputStream buff_in = null; BufferedOutputStream buff_out = null; try { buff_in = new BufferedInputStream(new FileInputStream(\"/Users/cici/testc/1.png\")); buff_out = new BufferedOutputStream(new FileOutputStream(\"/Users/cici/testc/3.png\")); // 每次迴圈讀到的byte數 int len = 0; // 建立buffer byte[] buff = new byte[1024]; while ((len = buff_in.read(buff)) != -1) { // 寫入 buff_out.write(buff, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (buff_in != null) buff_in.close(); if (buff_out != null) buff_out.close(); } catch (IOException ex) { ex.printStackTrace(); } }"
  },"/pages/java/convert_io/": {
    "title": "InputStreamReader與OutputStreamWriter",
    "keywords": "",
    "url": "/pages/java/convert_io/",
    "body": "Prerequisites: Buffered串流 轉換串流 InputStream與OutputStream是處理位元組資料的串流。 Reader與Writer抽象父類別，是處理字元資料的串流。 InputStream + Reader 位元組串流，可以變成讀取字元資料串流。 OutputStream + Writer 位元組串流，可以變成寫入字元資料串流。 InputStreamReader與OutputStreamWriter，建構子參數是InputStream與OutputStream。 意思是可以透過InputStreamReader與OutputStreamWriter，把「位元組」串流轉換成「字元」串流，還可以設定編碼。 可以處理亂碼的串流。 InputStreamReader建構子 第2個參數設定編碼，若沒設定第2個參數，預設是用java vm 設定的編碼。 InputStreamReader(InputStream in) InputStreamReader(InputStream in, String charsetName) OutputStreamWriter建構子 第2個參數設定編碼，若沒設定第2個參數，預設是用java vm 設定的編碼。 OutputStreamWriter(OutputStream out) OutputStreamWriter(OutputStream out, Charset cs) InputStreamReader與FileInputStream 我有一個編碼為big5的文件，我嘗試讀取它。 Mac可以使用文字編輯textedit，設定編碼。 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"/Users/cici/testc/401\"), \"big5\")); String line = reader.readLine(); System.out.println(line); reader.close(); } } 你好台灣 OutputStreamWriter與FileOutputStream 1 2 3 OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"/Users/cici/testc/401\"), \"big5\"); writer.write(\"測試測試\"); writer.close(); InputStreamReader與ByteArray串流 ByteArray串流 除了檔案編碼，在Socket串流中，常常使用記憶體緩衝區串流(ByteArrayInputStream)與轉換串流的應用。 1 2 3 4 5 6 7 8 9 10 public class Test4 { public static void main(String[] args) throws IOException { ByteArrayInputStream byteArrInput = new ByteArrayInputStream(\"測試測試\".getBytes()); BufferedReader reader = new BufferedReader(new InputStreamReader(byteArrInput)); String line = reader.readLine(); System.out.println(line); reader.close(); } } 測試測試"
  },"/pages/java/decorator_io/": {
    "title": "裝飾串流",
    "keywords": "",
    "url": "/pages/java/decorator_io/",
    "body": "Prerequisites: 串流基礎概念 IO裝飾者模式 有附加功能的串流 原文: adds functionality to stream 意思是在以下8種串流基礎上，增加其它功能的串流，稱作裝飾串流。 串流讀寫格式分為byte位元組、字元。 byte位元組串流 讀寫位置 輸入(讀) 輸出(寫) 檔案 FileInputStream FileOutputStream 記憶體緩衝區 ByteArrayInputStream ByteArrayOutputStream 字元串流 讀寫位置 輸入(讀) 輸出(寫) 檔案 FileReader FileWriter 記憶體緩衝區 CharArrayReader CharArrayWriter 裝飾串流 裝飾串流指的是有附加功能串流，並非以上8種串流。 裝飾串流建構子必須傳入其它串流才能使用。 有很多裝飾串流，目前只想說明下列幾種，下圖已經把裝飾串流的功能寫上。 byte串流 char串流 要了解裝飾串流的原理，可以查看IO裝飾者模式 關閉串流 直接關閉最外層的裝飾串流，程式會使用前面提到的8種內部串流(檔案串流或記憶體緩衝區串流)，把串流關閉，內部的串流在原始碼的變數為in。 什麼是最外層的裝飾串流？以下裝飾串流分別為ObjectInputStream、BufferedInputStream，最外層的裝飾串流是ObjectInputStream，最內部串流是FileInputStream。 1 ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(\"/Users/cici/testc/1.dat\"))); 以下程式碼，把檔案讀取串流變成一個變數fis，裝飾串流buff_in變數，關閉串流不用把二個close，直接關閉最外層的裝飾串流buff_in。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 FileInputStream fis = null; // 把位元組資料存在記憶體緩衝區 BufferedInputStream buff_in = null; try { fis = new FileInputStream(\"/Users/cici/testc/1.png\"); buff_in = new BufferedInputStream(fis); } catch (IOException e) { e.printStackTrace(); } finally { try { // 只要關閉最外面的裝飾串流 if (buff_in != null) buff_in.close(); } catch (IOException ex) { ex.printStackTrace(); } }"
  },"/pages/java/fileio/": {
    "title": "檔案串流",
    "keywords": "",
    "url": "/pages/java/fileio/",
    "body": "串流固定寫法 為什麼一定要關閉串流？ 不關閉串流，資料會存在記憶體，不會寫到檔案裡，有關閉的動作，才會有flush的動作，把資料寫到檔案裡。 關閉串流 因為串流產生的Error是屬於IOException，強制一定要補捉錯誤，若是Exception或RuntimeException就不用補捉錯誤。 宣告串流要在try…catch…final的外面，若宣告在try{}裡面，變數可見範圍只在try{}裡面，但串流不管有沒有錯誤，最後都一定要在final{}之中，close()關閉串流，宣告在try…catch…final的外面，變數的可見範圍才可以在final{}使用。 一定要關閉串流。 在try{}之中，建立串流。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 1.宣告串流 FileInputStream fileInputStream = null; try { // 3.建立串流 fileInputStream = new FileInputStream(\"/Users/cici/file_test\"); } catch (IOException e) { e.printStackTrace(); } finally { // 2.關閉串流 try { // 關閉時可能會有錯誤，所以要再catch一次 if (fileInputStream != null) fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } 自動關閉串流 JDK7有自動關閉串流的功能(Try-with-resources)，不用處理關閉串流，也不能自行撰寫關閉串流，不然會呼叫close()二次(因為你又再寫一次close())。 在try()括號之間，建立串流。 1 2 3 4 5 6 7 8 // 建立串流 try (FileInputStream fileInputStream = new FileInputStream(\"/Users/cici/file_test\")) { } catch (IOException e) { // 仍是要補捉IOException，有可能檔案沒有 System.err.println(\"發生錯誤: \" + e.getMessage()); e.printStackTrace(); } FileInputStream讀取檔案 建構子 有下列二個建構子，參數為檔案或字串。 1 2 FileInputStream(File) FileInputStream(String filename) read() int read() 一次讀一個位元組byte，傳回值為資料，型態為int，若值為其它類型，要轉型。 以下範例為每次只讀取一個byte，正常狀況下不會使用這個，因為一次讀一個byte速度很慢。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 宣告串流 FileInputStream fileInputStream = null; try { // 建立串流 fileInputStream = new FileInputStream(\"/Users/cici/testc/file_test\"); int data = 0; // -1 代表沒有資料讀取完畢 while ((data = fileInputStream.read())!= -1) { // 強制轉型 System.out.println((char) data); } } catch (IOException e) { // ...避免程式碼過多，截掉 h e l l o read(byte[]) int read(byte[]) 一次讀取多個位元組，假設1024，一次讀取1024個位元組，並把讀到的資料放在byte[]，傳回值為讀到的byte數量。 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 FileInputStream fileInputStream = null; try { // 建立串流 fileInputStream = new FileInputStream(\"/Users/cici/testc/file_test\"); // 存放讀到的byte數量 int len = 0; byte[] buffer = new byte[1024]; // -1 代表沒有資料讀取完畢 while ((len = fileInputStream.read(buffer)) != -1) { // 透過String建構子(位元組, 0, 讀到的byte數量)，建立字串 System.out.println(new String(buffer, 0, len)); } } // ..避免程式碼過多，截掉 hello 值得注意的是，若buffer大小為3，若只使用new String()，沒有指定截取的數量。結果會出錯，因為每一次讀完，陣列buffer不會被清空，會存著上一次讀取的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 FileInputStream fileInputStream = null; try { // 建立串流 fileInputStream = new FileInputStream(\"/Users/cici/testc/file_test\"); // 存放每次讀取的數量 int len = 0; byte[] buffer = new byte[3]; // -1 代表沒有資料讀取完畢 while ((len = fileInputStream.read(buffer)) != -1) { // byte[]轉字串 System.out.println(new String(buffer)); } }// ...避免程式碼過多，截掉 hel lol 預期應該會出現hel與lo，並非hel與lol。 FileOutputStream寫檔案 建構子 有下列二個建構子，參數為檔案或字串，預設為覆蓋原有檔案，第2個參數是不覆蓋原有檔案，而是從檔案末尾開始寫資料。 1 2 3 4 FileOutputStream(File file) FileOutputStream(File file, boolean append) FileOutputStream(String name) FileOutputStream(String name, boolean append) write(int)寫一個byte 1 2 3 4 5 6 7 FileOutputStream fileOutputStream = null; try { // 建立檔案輸出串流 fileOutputStream = new FileOutputStream(\"/Users/cici/testc/file_test\"); // 寫入輸出串流 fileOutputStream.write('A'); }// ...避免程式碼過多，截掉 A write(byte[]) 1 2 3 4 5 6 7 8 9 // 宣告檔案輸出串流 FileOutputStream fileOutputStream = null; try { // 建立檔案輸出串流 fileOutputStream = new FileOutputStream(\"/Users/cici/testc/file_test\"); String str = \"Hello world!\"; // 字串轉byte陣列 fileOutputStream.write(str.getBytes()); }// ...避免程式碼過多，截掉 Hello world! write(byte[],int,int) 第2個參數，開始位置 第3個參數，寫入byte數量 1 write(byte[] b, int off, int len) 1 2 3 4 5 6 7 8 FileOutputStream fileOutputStream = null; try { // 建立檔案輸出串流 fileOutputStream = new FileOutputStream(\"/Users/cici/testc/file_test\"); String str = \"Hello world!\"; // 寫入輸出串流 fileOutputStream.write(str.getBytes(), 2, 6); }// ...避免程式碼過多，截掉 llo wo FileInputStream與FileOutputStream 拷貝圖片，以下是邊讀邊寫。 之前提過，每一次讀完，陣列buffer不會被清空，會存著上一次讀取的值，所以一定要使用write(byte[],int,int)，指定寫入的數量，假設最後一次迴圈只有讀到10byte，但buffer[1024]，1024個byte只有前面10個byte是這次讀到的值，而剩下的1014byte都是上一個迴圈舊的資料，如果把1014byte也寫到檔案，會造成檔案損毀，無法開啟。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 宣告串流 FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try { // 建立輸入(讀)串流 fileInputStream = new FileInputStream(\"/Users/cici/testc/1.png\"); // 建立輸出(寫)串流 fileOutputStream = new FileOutputStream(\"/Users/cici/testc/2.png\"); // 存放每次讀取的數量 int len = 0; byte[] buffer = new byte[1024]; // -1 代表沒有資料讀取完畢 while ((len = fileInputStream.read(buffer)) != -1) { // 邊讀邊寫 // 一定要指定寫入數量len fileOutputStream.write(buffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { // 關閉串流 try { // 關閉讀串流 if (fileInputStream != null) fileInputStream.close(); // 關閉寫串流 if (fileOutputStream != null) fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } FileReader讀取文字檔 只能讀取文字檔，不能讀取圖片或壓縮檔，可以處理中文字、UTF-8。 read()讀取字元 int read() 一次讀一個字元，傳回值為int。 傳回值是真正的資料，每次讀取完的字元存放在data變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 FileReader reader = null; try { // 檔案內容llo wo reader = new FileReader(\"/Users/cici/testc/file_test\"); // 存放值 int data = 0; // -1 代表沒有資料讀取完畢 while ((data = reader.read()) != -1) { System.out.println((char)data); } } catch (IOException e) { e.printStackTrace(); } finally { // 關閉串流 try { if (reader != null) reader.close(); } catch (IOException e) { e.printStackTrace(); } } l l o w o read(char[]) int read(char[]) 一次讀取多個字元，假設設定8，一次讀取8字元，並把讀到的資料放在char[]。 傳回值是讀到的數量。 1 2 3 4 5 6 7 8 9 10 11 FileReader reader = null; try { // 檔案內容llo wo reader = new FileReader(\"/Users/cici/testc/file_test\"); int len = 0; char[] buffer = new char[3]; while ((len = reader.read(buffer)) != -1) { System.out.println(new String(buffer, 0, len)); } } // ...避免程式碼過多，截掉 llo wo FileWriter寫到文字檔 只能寫文字檔，不能寫圖片或壓縮檔，可以處理中文字、UTF-8。 一定要關閉串流，不然不會寫到檔案裡，只會暫存在記憶體。 write(int c) 寫入一個字元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 FileWriter writer = null; try { writer = new FileWriter(\"/Users/cici/testc/file_test\"); writer.write('A'); } catch (IOException e) { e.printStackTrace(); } finally { // 關閉串流 try { if (writer != null) writer.close(); } catch (IOException e) { e.printStackTrace(); } } A write(char[]) 1 2 3 4 5 6 FileWriter writer = null; try { writer = new FileWriter(\"/Users/cici/testc/file_test\"); char[] chars = {'A', 'B', 'C'}; writer.write(chars); } ABC write(String) 輸入中文字串 1 2 3 4 5 FileWriter writer = null; try { writer = new FileWriter(\"/Users/cici/testc/file_test\"); writer.write(\"測試\"); } 測試 write(String,int,int) 1 2 3 4 5 6 FileWriter writer = null; try { writer = new FileWriter(\"/Users/cici/testc/file_test\"); // 從索引2，取2個 writer.write(\"測試程式語言\", 2, 2); } 程式"
  },"/pages/java/io/": {
    "title": "串流基礎概念",
    "keywords": "",
    "url": "/pages/java/io/",
    "body": "串流分成輸入串流與輸出串流。 輸入串流InputStream 讀取資料到程式裡用輸入串流。 輸出串流OutputStream 從程式裡把資料寫出去用輸出串流。 串流抽象父類別 串流分二類，一個是用byte位元組來讀取與輸出，另一個是用char字元來讀取與輸出。 byte位元組 以下都是抽象類別，不能用new關鍵字建立。 InputStream讀取位元組 OutputStream以「位元組」方式寫出去 char字元 以下都是抽象類別，不能用new關鍵字建立。 Reader讀取字元 Writer以「字元」方式寫出去 讀取與寫出的位置 資料的讀取與寫出的位置有二種，一種是檔案，一種是記憶體緩衝區。 記憶體緩衝區為電腦暫時置放輸出或輸入資料的位址。 用byte來讀取與輸出 讀寫位置 輸入(讀) 輸出(寫) 檔案 FileInputStream FileOutputStream 記憶體 ByteArrayInputStream ByteArrayOutputStream 用char字元來讀取與輸出 讀寫位置 輸入(讀) 輸出(寫) 檔案 FileReader FileWriter 記憶體 CharArrayReader CharArrayWriter 檔案 以Byte方式 FileInputStream讀取檔案，InputStream子類別，可以用new關鍵字建立。 java.io.InputStream ↳ java.io.FileInputStream FileOutputStream寫檔案，OutputStream子類別，可以用new關鍵字建立。 java.io.OutputStream ↳ java.io.FileOutputStream 以字元方式 FileReader讀取檔案，Reader子類別，可以用new關鍵字建立。 java.io.Reader ↳java.io.InputStreamReader ↳ java.io.FileReader FileWriter寫檔案，Writer子類別，可以用new關鍵字建立。 java.io.Writer ↳java.io.OutputStreamWriter ↳ java.io.FileWriter 記憶體緩衝區 讀取與寫入的位置是記憶體緩衝區，就像變數在記憶體中會有個位址存放值，二者都是存在記憶體。 ByteArrayInputStream 讀取記憶體緩衝區資料 java.io.InputStream ↳ java.io.ByteArrayInputStream ByteArrayOutputStream 寫到記憶體緩衝區資料 java.io.OutputStream ↳ java.io.ByteArrayOutputStream 建立1024個byte 1 byte[] bytes = new byte[1024]; 建立Byte陣列的輸出串流 1 ByteArrayOutputStream baos = new ByteArrayOutputStream(); 以上二者都是在記憶體建立byte[]陣列的空間，存放資料。 父類別方法 抽象父類別會提供基本的讀取與寫入方法。 Byte位元組 抽象父類別InputStream、OutputStream InputStream read()傳回 -1 代表沒有資料讀取完畢。 int read() 一次讀一個位元組byte，傳回值為資料，型態為int，若值為其它類型，要轉型。 int read(byte[]) 一次讀取多個位元組，假設1024，一次讀取1024個位元組，並把讀到的資料放在byte[] int read(byte[], int start, int len) 第2個參數是從那個陣列索引index開始讀，第3個參數是要讀幾個，並把讀到的資料放在byte[] close() 關閉串流 OutputStream write(int n) 寫一個位元組。 write(byte[]) 寫位元組。 write(byte[], int start, int lne) 第2個參數是從那個陣列索引index開始寫，第3個參數是要寫幾個。 close() 關閉串流 字元 抽象父類別Reader、Writer Reader read()傳回 -1 代表沒有資料讀取完畢。 int read() 一次讀一個字元，傳回值為int，值為資料內容，要轉型。 int read(char[]) 一次讀取多個字元，假設設定8，一次讀取8字元，並把讀到的資料放在char[]。 int read(char[], int start, int len) 第2個參數是從那個索引index開始讀?第3個參數是要讀幾個，並把讀到的資料放在char[]。 close() 關閉串流 Writer write(int n) 寫一個字元 write(char[]) 寫入字元陣列 write(char[], int start, int lne) 第1個參數為寫入的位置，第2個參數是從那個索引index開始寫?第3個參數是要寫幾個。 close() 關閉串流"
  },"/pages/java/note/": {
    "title": "java記事",
    "keywords": "",
    "url": "/pages/java/note/",
    "body": "jdk安裝路徑 /Library/Java/JavaVirtualMachines"
  },"/pages/java/string_io/": {
    "title": "String與char[]和byte[]",
    "keywords": "",
    "url": "/pages/java/string_io/",
    "body": "建構子 1 2 3 4 5 6 new String(char[]); // 指定開始位置與要拷貝的長度 new String(char[], int start, int len); new String(byte[]); // 指定開始位置與要拷貝的長度 new String(byte[], int start, int len); 字元陣列轉字串 1 2 3 4 // 字元陣列轉字串 char[] charArr = {'A', 'B', 'C'}; String str2 = new String(charArr); System.out.println(str2); ABC 1 2 3 4 char[] charArr = {'A', 'B', 'C'}; // 指定開始位置與要拷貝的長度 String str3 = new String(charArr, 1, 2); System.out.println(str3); BC 字串轉字元陣列 1 2 3 4 5 6 String s1 = \"ABCDE\"; // 字串轉字元陣列 char[] charArr2 = s1.toCharArray(); for (char c : charArr2) { System.out.println(c); } A B C D E Byte陣列轉字串 建構子 1 2 3 4 // 建構子是byte[] public String (byte[] bytes) // 從陣列位置offset開始，第2參數是拷貝幾個byte public String (byte[] bytes, int offset, int length) 1 2 3 4 5 // byte陣列 byte[] b = {'A', 'B', 'C'}; // 轉字串 String s2 = new String(b); System.out.println(s2); ABC 從陣列位置1開始，拷貝2個byte 1 2 3 4 5 // byte陣列 byte[] b = {'A', 'B', 'C'}; // 轉字串 String s3 = new String(b, 1, 2); System.out.println(s3); BC 字串轉Byte陣列 語法 1 2 3 public byte[] getBytes () // 參數可以是字元編碼 public byte[] getBytes (String charsetName) 1 2 3 4 5 6 7 8 9 10 // byte陣列 byte[] b = {'A', 'B', 'C'}; // 轉字串 String s2 = new String(b); // 字串轉成byte陣列 byte[] b2 = s2.getBytes(); System.out.println(\"print byte\"); for (byte b1 : b2) { System.out.println(b1); } print byte 65 66 67 字串常用方法 開頭,結尾,包含 1 2 3 4 5 6 7 8 9 10 String s1 = \"Hello World\"; // 是否以Hel開頭的？ boolean isStart = s1.startsWith(\"Hel\"); System.out.println(isStart); // 是否以Hel結尾的？ boolean isEnd = s1.endsWith(\"Hel\"); System.out.println(isEnd); // 是否包含abc boolean isContain = s1.contains(\"abc\"); System.out.println(isContain); true false false 尋找字串 1 2 3 4 5 6 7 8 9 10 String s1 = \"Hello World\"; // 查詢參數在字串中第一次出現的位置，索引值從0開始數 int position1 = s1.indexOf(\"ol\"); System.out.println(position1); // 從指定的位置開始找 position1 = s1.indexOf(\"o\", 6); System.out.println(position1); // 字串最後出現的位置 position1 = s1.lastIndexOf(\"ol\"); System.out.println(position1); 3 7 3 取得字串中的子字串 1 2 3 4 5 6 7 String s1 = \"Hello World\"; // 取得字串中的子字串 String str4 = s1.substring(2); System.out.println(str4); // 取得位置2到6的字元 str4 = s1.substring(2, 6); System.out.println(str4); llo World llo 去掉字串前後 1 2 3 // trim去掉前後空格 String str5 = \" Hello World! \".trim(); System.out.println(str5); Hello World! 字串轉基本類型 int基本類型包了一個殼，就變成類別Interger，就可以使用類別的方法，如Interger.parseInt()字串變成數字 1 2 3 4 5 6 7 8 9 10 // 字串轉基本類型 // 轉int int i = Integer.parseInt(\"12345\"); System.out.println(i); // 轉double double d = Double.parseDouble(\"12.55\"); System.out.println(d); // 基本類型轉字串 System.out.println(String.valueOf(i)); System.out.println(String.valueOf(d)); 12345 12.55 12345 12.55"
  },"/pages/design_pattern/decorator_io/": {
    "title": "IO裝飾者模式",
    "keywords": "",
    "url": "/pages/design_pattern/decorator_io/",
    "body": "Prerequisites: 裝飾者模式 串流基礎 檔案串流 類別圖 以下類別圖與裝飾者模式幾乎一樣 InputStream_是抽象父類別，read()方法是子類別要實作覆寫內容。 FileInputStream_與ByteArrayInputStream_是InputStream_子類別，是最主要的類別，實作read()方法。 Decorator是裝飾者父類別，最重要的成員屬性是in，類型是InputStream_，由建構子Decorator(in)把in設值。 in成員屬性可以是主要類別FileInputStream_或ByteArrayInputStream_。 in成員屬性也可以是裝飾者類別，所以會用菱形實心線條指向自己，因為in成員屬性可以是自己。 Decorator.read()方法，是呼叫成員屬性in.read() Decorator下面有二個子類別，都是裝飾者，不是主要的類別，分別是BufferInputStream_與ObjectInputStream_，都是為主要的類別增加「附加功能」。 FileInputStream_與ByteArrayInputStream_跟裝飾者模式中的Drink飲料(紅茶、綠茶、咖啡)一樣，是最主要的類別，其它BufferInputStream_與ObjectInputStream_都只是裝飾品，等同裝飾者模式中的Decorator類別(牛奶、珍珠、果凍)。 有些書本會說裝飾者模式是包裝者wrap模式，如下圖: FileInputStream_是最主要類別，包在最裡面，BufferInputStream_與ObjectInputStream_都是裝飾者(包裝者)。 換成程式碼如下: 1 new ObjectInputStream_(new BufferInputStream_(new FileInputStream_())); 最裡面的是最主要的類別，因為它的建構子是不用有參數的。 ByteArrayInputStream_是最主要類別，包在最裡面，BufferInputStream_與ObjectInputStream_都是裝飾者(包裝者)。 換成程式碼如下: 1 new ObjectInputStream_(new BufferInputStream_(new ByteArrayInputStream_())); 最裡面的是最主要的類別，因為它的建構子是不用有參數的。 程式碼 抽象父類別InputStream_ 1 2 3 public abstract class InputStream_ { public abstract String read(); } 主要類別，被裝飾(被包裝)的主類別 FileInputStream_ 1 2 3 4 5 6 public class FileInputStream_ extends InputStream_{ @Override public String read() { return \"FileInputStream_\"; } } ByteArrayInputStream_ 1 2 3 4 5 6 public class ByteArrayInputStream_ extends InputStream_{ @Override public String read() { return \"ByteArrayInputStream_\"; } } 裝飾者Decorator Decorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Decorator extends InputStream_ { // 最重要的成員屬性 private InputStream_ in; // 建構子 public Decorator(InputStream_ in) { this.in = in; } @Override public String read() { // 呼叫成員屬性in.read() return in.read() ; } } BufferInputStream_ 1 2 3 4 5 6 7 8 9 10 public class BufferInputStream_ extends Decorator{ public BufferInputStream_(InputStream_ in) { super(in); } @Override public String read() { return super.read() + \" + \" + \"This is BufferInputStream\"; } } ObjectInputStream_ 1 2 3 4 5 6 7 8 9 10 public class ObjectInputStream_ extends Decorator{ public ObjectInputStream_(InputStream_ in) { super(in); } @Override public String read() { return super.read() + \" + \" + \"This is ObjectInputStream_\"; } } Client測試程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Client { public static void main(String[] args) { // 來源串流是FileInputStream FileInputStream_ fileInputStream_ = new FileInputStream_(); System.out.println(fileInputStream_.read()); BufferInputStream_ bufferInputStream = new BufferInputStream_(fileInputStream_); System.out.println(bufferInputStream.read()); ObjectInputStream_ objStream = new ObjectInputStream_(bufferInputStream); System.out.println(objStream.read()); System.out.println(\"===============================\"); // 來源串流是FileInputStream ByteArrayInputStream_ byteArrstream = new ByteArrayInputStream_(); System.out.println(byteArrstream.read()); bufferInputStream = new BufferInputStream_(byteArrstream); System.out.println(bufferInputStream.read()); objStream = new ObjectInputStream_(bufferInputStream); System.out.println(objStream.read()); } } FileInputStream_ FileInputStream_ + This is BufferInputStream FileInputStream_ + This is BufferInputStream + This is ObjectInputStream_ =============================== ByteArrayInputStream_ ByteArrayInputStream_ + This is BufferInputStream ByteArrayInputStream_ + This is BufferInputStream + This is ObjectInputStream_ 以上是此模式的精神是幫主要類別增加功能，真實的BufferInputStream提供readLine()的方法，讀取檔案時以一列一列的方式讀取，提高讀取效率，ObjectInputStream提供從檔案或記憶體byte[]陣列中讀取物件，但實際上讀取動作仍是由FileInputStream與ByteArrayInputStream在讀的，裝飾者是在做優化或額外附加功能。"
  },"/pages/java/bytearr_io/": {
    "title": "ByteArray串流",
    "keywords": "",
    "url": "/pages/java/bytearr_io/",
    "body": "Prerequisites: 位元組與字串互轉 串流基礎 檔案串流 串流分為二類，一種是檔案串流，一種是記憶體緩衝區串流。 記憶體緩衝區串流，就是資料讀取與寫入都在記憶體緩衝區，記憶體緩衝區就是到byte[]陣列。 ByteArrayInputStream 從記憶體緩衝區讀取資料。 建構子，一定要有byte[]參數 1 ByteArrayInputStream(byte[] buf) 讀取資料 1 public int read (byte[] b) 參數是存放資料的byte變數 讀取完成或沒資料可讀會傳回-1 讀取緩衝區中的資料，與讀取檔案 1 2 3 4 5 6 7 8 ByteArrayInputStream bis = new ByteArrayInputStream(\"測試測試\".getBytes()); byte[] buffer = new byte[1024]; int len = 0; while((len = bis.read(buffer)) != -1) { String s = new String(buffer, 0, len); System.out.println(s); } bis.close(); ByteArrayOutputStream 建構子 建構子是沒有參數，寫入到記憶體緩衝區。 1 ByteArrayOutputStream() 方法 toByteArray() 將記憶體緩衝區的資料轉成byte陣列。 1 byte[] toByteArray () 使用方法 1 byte[] data = baos.toByteArray(); toString () 將位元組串流轉成字串，若沒寫編碼參數，用系統預設的編碼格式，取決於作業系統。 1 2 3 String data = baos.toString(); String data = baos.toString(StandardCharsets.UTF_8); String data = baos.toString(\"UTF-8\"); write 寫入資料到記憶體緩衝區。 1 write (byte[] b, int offset, int len) 第1個參數是寫入的資料(類型為byte[]) 第2個參數是從byte[]中第幾個索引index開始寫 第3個參數要寫入多少個數量 寫入byte陣列。 1 writeBytes (byte[] b) 寫入char 1 write (int b) size() 取得串流大小。 1 baos.size(); 寫入 寫入到記憶體緩衝區，並把緩衝區資料轉為byte陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ByteArrayOutputStream baos = null; try { baos = new ByteArrayOutputStream(); String str = \"測試測試\"; // 字串寫入，轉byte[] baos.write(str.getBytes()); // 字串寫入，轉byte[] baos.write(\"哈囉哈囉\".getBytes()); // 將記憶體緩衝區的資料轉成byte陣列 byte[] data = baos.toByteArray(); // 將位元組串流轉成字串 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); } finally { try { if (baos != null) baos.close(); } catch (IOException e) { e.printStackTrace(); } } 測試測試哈囉哈囉 ByteArrayInputStream與ByteArrayOutputStream 將讀取資料從記憶體緩衝區，寫入資料到記憶體緩衝區，二者結合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test4 { public static void main(String[] args) throws IOException { // 讀取資料從記憶體緩衝區 ByteArrayInputStream bis = new ByteArrayInputStream(\"測試測試\".getBytes()); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while((len = bis.read(buffer)) != -1) { // 寫入資料到記憶體緩衝區 bos.write(buffer, 0, len); } // 將位元組串流轉成字串 System.out.println(bos.toString()); // 將記憶體緩衝區的資料轉成byte陣列 byte[] bosData = bos.toByteArray(); bis.close(); bos.close(); } } 測試測試 ByteArrayInputStream的建構子參數也可以是ByteArrayOutputStream 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test5 { public static void main(String[] args) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); bos.write(\"哈囉，你好\".getBytes()); bos.write(\"測試\".getBytes()); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); int len = 0; byte[] buffer = new byte[1024]; while ((len = bis.read(buffer)) != -1) { String s1 = new String(buffer, 0, len); System.out.println(s1); } } } 哈囉，你好測試 InputStream轉成byte陣列工具 可寫成工具，給人使用。 1 2 3 4 5 6 7 8 9 10 11 public static byte[] streamToByteArray(InputStream is) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1) { bos.write(buffer, 0, len); } byte[] byteArr = bos.toByteArray(); bos.close(); return byteArr; } 使用方式，可以是文字檔案，也可以是圖片檔案。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test4 { public static byte[] streamToByteArray(InputStream is) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1) { bos.write(buffer, 0, len); } byte[] byteArr = bos.toByteArray(); bos.close(); return byteArr; } public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"/Users/cici/testc/pic.png\"); byte[] bytes = streamToByteArray(fis); } } 文字檔 1 2 3 4 5 public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"/Users/cici/testc/print_out\"); byte[] bytes = streamToByteArray(fis); System.out.println(new String(bytes)); } 測試測試2"
  },"/pages/java/lambda/": {
    "title": "Lambda",
    "keywords": "",
    "url": "/pages/java/lambda/",
    "body": "Prerequisites: 介面 內部類別 匿名類別 介面只有一個抽象方法，可使用Lambda簡化實作介面的語法。 Lambda又稱Functional Interface函式介面。 實作Interface的各種方式 1 2 3 public interface Fly { void fly(); } 靜態內部類別 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test2 { static class Bird implements Fly { @Override public void fly() { System.out.println(\"Bird fly\"); } } public static void main(String[] args) { Fly bird = new Bird(); bird.fly(); } } 區域內部類別 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { class Balloon implements Fly { @Override public void fly() { System.out.println(\"氣球飛\"); } } Fly balloon = new Balloon(); balloon.fly(); } 匿名類別 1 2 3 4 5 6 7 Fly mosquito = new Fly() { @Override public void fly() { System.out.println(\"蚊子飛\"); } }; mosquito.fly(); Lambda 把上面的程式碼，留下括號()與花括號{}，其它全部去掉。 new Fly() { @Override public void fly() { System.out.println(“蚊子飛”); } }; 括號()與花括號{}之間有一個箭頭 -&gt; 作為區隔 1 2 3 4 Fly helicopter = () -&gt; { System.out.println(\"直升機飛\"); }; helicopter.fly(); 若花括號{}主體(body)只有一行程式，可以去掉花括號。 1 2 Fly helicopter = () -&gt; System.out.println(\"直升機飛\"); helicopter.fly(); 有參數的Lambda Interface加上參數，hour小時，km是公里。 1 2 3 public interface Fly { void fly(float km, int hour); } 1 2 3 4 Fly helicopter = (float km, int hour) -&gt; { System.out.println(\"直升機飛 \" + hour + \" 小時 \" + km + \"公里\"); }; helicopter.fly(600, 3); 去掉參數類型 1 2 3 4 Fly helicopter = (km, hour) -&gt; { System.out.println(\"直升機飛 \" + hour + \" 小時 \" + km + \"公里\"); }; helicopter.fly(600, 3); 若參數只有一個，也可以去掉括號() 1 2 Fly helicopter = km -&gt; System.out.println(\"直升機飛 \" + km + \"公里\"); helicopter.fly(600);"
  },"/pages/java/obj_stream/": {
    "title": "序列化與反序列化",
    "keywords": "",
    "url": "/pages/java/obj_stream/",
    "body": "Prerequisites: ByteArray串流 裝飾串流 裝飾串流ObjectInputStream與ObjectOutputStream ObjectOutputStream 把物件寫入。 ObjectInputStream 讀取物件。 寫入基本類型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public static void main(String[] args) { ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ObjectInputStream ois = null; try { // 讀取與寫入的位置是在記憶體緩衝區 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 寫入基本資料型態 // 寫入整數 oos.writeInt(100); // 寫入布林 oos.writeBoolean(true); // 寫入字元 oos.writeChar('A'); // 寫入浮點數 oos.writeDouble(5.99); // 寫入字串，是使用writeUTF() oos.writeUTF(\"測試\"); // 讀取物件 ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); // 要按照寫入順序讀取 System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readDouble()); System.out.println(ois.readUTF()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { try { // 只需要關閉裝飾串流，詳見裝飾串流文章 if (oos != null) oos.close(); if (ois != null) ois.close(); } catch (IOException e) { e.printStackTrace(); } } } 100 true A 5.99 測試 將物件寫到串流 物件都要implements Serializable Student 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Student implements Serializable { private String name; private int age; // 成員變數family是類別 private Family family; public Student() { family = new Family(); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getMother() { return family.getMother(); } public void setMother(String mother) { family.setMother(mother); } public String getFather() { return family.getFather(); } public void setFather(String father) { family.setFather(father); } } 成員變數類別也要implements Serializable Family是Student的成員變數類別，也要implements Serializable 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Family implements Serializable { private String mother; private String father; public String getMother() { return mother; } public void setMother(String mother) { this.mother = mother; } public String getFather() { return father; } public void setFather(String father) { this.father = father; } } 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public static void main(String[] args) { ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ObjectInputStream ois = null; try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 寫入基本資料型態 oos.writeInt(100); oos.writeBoolean(true); oos.writeChar('A'); oos.writeDouble(5.99); // 寫入字串 oos.writeUTF(\"測試\"); // 寫入物件 Student student = new Student(); student.setName(\"小美\"); student.setAge(10); student.setMother(\"小美媽\"); student.setFather(\"小美爸\"); oos.writeObject(student); // 讀取物件 ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); // 要按照寫入順序讀取 System.out.println(ois.readInt()); System.out.println(ois.readBoolean()); System.out.println(ois.readChar()); System.out.println(ois.readDouble()); System.out.println(ois.readUTF()); // readObject()是Object物件 // 向下轉型成Student才能使用Student的方法 Student copy = (Student) ois.readObject(); System.out.println(copy.getName()); System.out.println(copy.getAge()); System.out.println(copy.getFather()); System.out.println(copy.getMother()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { try { // 只需要關閉裝飾串流，詳見裝飾串流文章 if (oos != null) oos.close(); if (ois != null) ois.close(); } catch (IOException e) { e.printStackTrace(); } } } 100 true A 5.99 測試 小美 10 小美爸 小美媽 Deep Clone程式碼 Deep Clone 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 建立byte陣列寫出串流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 為byte陣列輸出串流 加上物件的功能 // 原文: adds functionality to output stream ObjectOutputStream oos = new ObjectOutputStream(baos); // 把物件寫入byte陣列 // 使用ObjectOutputStream.writeObject() oos.writeObject(object); // 建立byte陣列讀取串流， 資料的來源是byte陣列 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); // 為byte陣列輸入串流 加上物件的功能 // 原文: adds functionality to input stream ObjectInputStream ois = new ObjectInputStream(bais); // 把物件讀取出來 // 使用ObjectInputStream.readObject() return (T) ois.readObject();"
  },"/pages/java/wrap/": {
    "title": "基本型態與Wrapper Classes",
    "keywords": "",
    "url": "/pages/java/wrap/",
    "body": "基本型態Primitive Type Java提供基本型態如下 數字相關short,int,long,double,float 字元char boolean 注意！在Java中，char與boolean跟數字(Number)沒關係。在C++，char與boolean是整數型態，詳細內容請見: C++ char字元 C++ bool 包裝類別Wrapper Classes Java還提供對映基本型態的類別，稱為包裝類別。 類別圖 由圖中可發現，Boolean與Character不是Number的子類別。 包裝類別的組成 組成公式 由Header表頭12byte + 基本型態大小 + 自動補齊(Alignment gap)所組成。 所謂自動補齊，包裝類別是以8byte為一個單位，也就是不是8的倍數，就會自動補齊成8byte的倍數。 例: Short 12(表頭) + 2(基本型態) = 14 以上相加只有14，並非8的倍數，所以自動補齊2byte，就變成16，16為8的倍數。 Short 12(表頭) + 2(基本型態) + 2(自動補齊) = 16 其它包裝類別的組成 Byte 12(表頭) + 1(基本型態) + 3(自動補齊) = 16 Double 12(表頭) + 8(基本型態) + 4(自動補齊) = 24 要為8的倍數 Integer 12(表頭) + 4(基本型態) + 0(自動補齊) = 16 Character 12(表頭) + 2(基本型態) + 2(自動補齊) = 16 Java Object Layout 可使用Java Object Layout物件佈局，查看產生的記憶體大小。 基本型態與包裝類別記憶體大小 非Number類型 基本型態 佔Stack大小 包裝類別 佔Heap大小 boolean 1 byte Byte 16 byte char 2 byte Character 16 byte Number類型 基本型態 佔Stack大小 包裝類別 佔Heap大小 byte 1 byte Byte 16 byte short 2 byte Short 16 byte int 4 byte Integer 16 byte long 8 byte Long 24 byte float 4 byte Float 16 byte double 8 byte Double 24 byte 記憶體位置 什麼是Stack？什麼是Heap？ Stack與Heap都是記憶體空間，Stack放變數與基本型態(char, int, long, float…)，Heap放由類別產生的物件(Character, Integer, Long, Float, Double)。詳見Java Memory Model 基本型態優點 從上面的表格中，可以發現基本型態與包裝類別佔用的記憶體大小差距很大。 基本型態占用記憶體小，不用像包裝類別要建立物件，要被記憶體回收釋放記憶體，int[]陣列比Integer[]陣列更省記憶體空間。 基本型態使用CPU0指令集，使用加法(ADD)減法(SUB)乘(MUL)除(DIV)、XOR、AND、OR…暫存器操作，所以速度很快。 為什麼要用包裝類別？ 那為什麼使用包裝類別呢？因為基本型態只能做基本運算，如果要用到集合List或泛型，或使用包裝類別的方法(如Integer.compareTo())就要用到包裝類別了。 基本型態與包裝類別功能分類 功能分類 基本型態 類別 記憶體位置 Stack Heap 記憶體大小 1-8 byte 16-24 byte GC管理 不用 要記憶體釋放 功能 基本運算 支持集合、泛型T型別參數、使用類別方法 null 不支持 可以設為null 結論 需要高效數學運算，使用基本型態。 使用物件相關的程式，使用包裝類別。 裝箱與拆箱 裝箱 裝箱英文是boxing，是把基本型態轉成包裝類別。 語法 包裝類別.valueOf(基本型態) 1 2 3 4 5 // 基本型態 int n1 = 10; // 基本型態 -&gt; 包裝類別 Integer integer1 = Integer.valueOf(n1); 自動裝箱 jdk1.5時推出自動裝箱(Auto boxing)的功能，不用使用valueOf()的方法。 1 2 3 int n2 = 100; // 基本資料型態 -&gt; 物件 Integer integer2 = n2; 拆箱 拆箱英文是unboxing，是把包裝類別轉成基本型態。 語法 包裝類別.intValue(基本型態) 1 2 3 4 5 6 int n1 = 10; // 基本型態 -&gt; 包裝類別 Integer integer1 = Integer.valueOf(n1); // 包裝類別 -&gt; 基本資料型態 int i1 = integer1.intValue(); 自動拆箱 jdk1.5時推出自動拆箱(Auto unboxing)的功能，不用使用intValue()的方法。 1 2 3 4 5 6 int n1 = 10; // 基本型態 -&gt; 包裝類別 Integer integer1 = n1; // 包裝類別 -&gt; 基本資料型態 int i1 = integer1; 自動拆裝箱原理 自動拆箱裝箱，實際上仍是使用valueOf()與intValue()。 打開Integer原始檔，Mac電腦可使用Cmd+滑鼠對著「Integer」按下左鍵，進入原始檔，找到valueOf()方法，加上中斷點。 在自動裝箱的程式碼也加上中斷點。 啟動Debug執行，搭配「step into」，就會發現會進入valueOf()方法。"
  },"/pages/kotlin/type/": {
    "title": "變數與基本類型",
    "keywords": "",
    "url": "/pages/kotlin/type/",
    "body": "印出 1 println() 結尾不用分號; 每一段程式碼後面不用加上分號; val唯讀變數 不可修改的變數。 1 2 val str = \"Hello World!\" println(str) var可變變數 變數是可以被改變，用var宣告參數 1 2 3 var str = \"Hello World!\" str = \"Test\" println(str) const常數 只能在函式之外宣告並且定義，要寫在main()主函式外面，const常數只能使用基本類型String, Int, Double, Float, Long, Short, Char, Byte, Boolean 1 2 3 4 const val MAX = 100 fun main() { println(MAX) } 100 Unit Unit 物件，等同java的void Any Any 是kotlin中所有類別的根 基本類型 Java 基本型態 基本類型String, Int, Double, Float, Long, Short, Char, Byte, Boolean，字首全部大寫。 Kotlin的基本類型，是類別。 變數類型 定義變數的類型的方式，變數後面一個冒號，加上一個空白，接下來是類型。 1 val str: String = \"Test\" 推斷類型 變數有初始值，類型可以從初始值推斷，就可以省略類型 1 2 3 val str: String = \"Hello\" // becomes val str = \"Hello\" 數值類型 整數類型 最小值 最大值 Byte -128 127 Short -32768 32767 Int -2147483648(-2^31) 2147483647(-2^31-1) Long -2^63 2^63-1 kotlin未超出Int，默認Int kotlin超出Int最大值，推斷為Long類型 1 2 3 4 val one = 1 //默認Int類型 val threeBillion = 30000000000 //Long類型 超出Int最大 val oneLong = 1L //大寫L表示Long類型 val oneByte: Byte = 1 //指定為Byte的類型 基本類型轉換 不能不同類型隨便轉換，使用toXXX()才能轉換 toByte() toShort() toInt() toLong() toFloat() toDouble() toChar() 1 2 3 val a: Int = 1 //val b: Long = a //error Type mismatch. val b: Long = a.toLong() 1 2 3 var a11: Int = 1 var c: Byte = 2 a11 = c.toInt() 1 2 3 4 5 //字串與數字相連，先把數字toString，才能用+加號 連起來 val b1: String = \"asd\" println(a11.toString() + b1) // 現在都是用字串模板印出 println(\"${a11}${b1}\") 2asd 2asd Float,Double 浮點類型有Float、Double 有小數點，編譯器默認為Double 若要指定為浮點數，後面要加f或F。 1 2 3 4 val pi = 3.14 //Double val e = 2.7182818384 //Double val eFloat = 2.7182818384f //Float 但精度丟失 只到2.7182817 println(eFloat) 2.7182817 Kotlin沒有自動轉型 1 2 3 4 5 6 7 8 9 10 11 12 13 // 定義函式 // 函式參數只接收Double類型 fun printDouble(d: Double) { println(d) } var i = 1 val d = 1.1 var f = 1.1f printDouble(d) //printDouble(i)//error Type mismatch. //printDouble(f)//error Type mismatch. 1.1 Char Char宣告單個字元，必須用’‘來表示。 1 2 3 4 var char1: Char char1 = 'a' //數值不能塞char //char1 = 1 //The integer literal does not conform to the expected type Char 在kotlin不能把字元拿來跟數字比 1 2 3 4 5 6 val a1 = 'a' //if(a1 == 97) //Operator '==' cannot be applied to 'Char' and 'Int' //必須寫 if (a1.toInt() == 97) { println(\"Equal\") } Char轉成其它類型 1 2 3 4 5 6 7 8 9 10 var char1: Char char1 = 'a' var var1 = char1.toByte() var var2 = char1.toInt() var var3 = char1.toString() var var4 = char1.toFloat() println(\"var1 =&gt; $var1\") println(\"var2 =&gt; $var2\") println(\"var3 =&gt; $var3\") println(\"var4 =&gt; $var4\") var1 =&gt; 97 var2 =&gt; 97 var3 =&gt; a var4 =&gt; 97.0 字串模板 把變數與運算結果輸出到螢幕上顯示。 印出變數 使用錢$字號，後面是變數。 1 2 3 4 val name: String = \"Tom\" var age: Int = 18 age = 19 println(\"My name is $name, I'm $age\") hello My name is Tom, I'm 19 印出運算結果 要用該變數的屬性或做任何的運算，只要額外使用$錢字大括號{}把它包圍即可 1 2 3 4 5 val name: String = \"Tom\" var age: Int = 18 age = 19 println(\"My name have ${name.length} char\") println(\"1 + 2 = ${1 + 2}\") My name have 3 char 1 + 2 = 3 1 2 val flag = false println(\"Ans: ${if (flag) \"ok\" else \"error\"}\") Ans: error 印出排板 1 2 3 4 5 6 val code = \"\"\" val names = arrayOf(\"Tome\",\"GG\") |for(name in names) |println(name) \"\"\" println(code) val names = arrayOf(\"Tome\",\"GG\") |for(name in names) |println(name) 不要有多餘的縮排及空行，用trimMargin()函式消除 trimMargin使用行的開頭，默認使用| 符號，做為每一行的開頭 1 2 3 4 5 6 val code2 = \"\"\" |val names = arrayOf(\"Tome\",\"GG\") |for(name in names) |println(name) \"\"\".trimMargin() println(code2) val names = arrayOf(\"Tome\",\"GG\") for(name in names) println(name) 也可以換成其它的符號&gt;，做為替換行的符號 1 2 3 4 5 6 val code3 = \"\"\" &gt;val names = arrayOf(\"Tome\",\"GG\") &gt;for(name in names) &gt;println(name) \"\"\".trimMargin(\"&gt;\") println(code3) val names = arrayOf(\"Tome\",\"GG\") for(name in names) println(name)"
  },"/pages/kotlin/code_style/": {
    "title": "Coding Style",
    "keywords": "",
    "url": "/pages/kotlin/code_style/",
    "body": "Kotlin Coding Style 命名 駝峰式大小寫 命名步驟如下: 將所有內容（包括首字母縮寫）小寫、將ISO、XML、IP這些常見大寫字母也變小寫。 將每個單字的第一個字元大寫，以產生Pascal 大小寫。 將除第一個單字之外的每個單字的第一個字元大寫。 未大小寫前 正確 錯誤 XML Http Request XmlHttpRequest XMLHTTPRequest new customer ID newCustomerId newCustomerID inner stopwatch innerStopwatch innerStopWatch supports IPv6 on iOS supportsIpv6OnIos supportsIPv6OnIOS YouTube importer YouTubeImporter YoutubeImporter 此處命名方式跟C++、Java不同，C++與Java是ISO、XML、IP不用轉小寫。 變數 採用camelCase 大小寫形式寫成。物件屬性、參數、可變集合。 1 2 3 val variable = \"var\" val nonConstScalar = \"non-const\" val mutableCollection: MutableSet 常數 常數大寫，單字用底線分隔。 什麼是常數呢？ 常數是沒有自訂get函式的val屬性，其內容絕對不可變，不可變類型和不可變集合，以及const都為常數。 1 2 3 4 5 const val NUMBER = 5 val NAMES = listOf(\"Alice\", \"Bob\") val AGES = mapOf(\"Alice\" to 35, \"Bob\" to 32) val COMMA_JOINER = Joiner.on(',') // Joiner is immutable val EMPTY_ARRAY = arrayOf 函式 函式名稱以camelCase 大小寫形式編寫，通常是動詞或動詞片語。例如，sendMessage或stop。 1 2 3 fun sendMessage(name: String) { // … } 測試函式:允許在測試函式名稱中出現底線，用於分隔名稱的邏輯組成部分。 1 2 3 @Test fun pop_emptyStack() { // … } 類別與介面 類別名稱採用PascalCase 大小寫形式編寫，第一個字母大寫，通常是名詞。例如，Character或ImmutableList。介面名稱也可以是名詞或名詞片語（例如List），但有時也可以是形容詞或形容詞片語（例如Readable）。 1 class MyClass { } 1 class Bar { } 測試類別 測試類別的命名方式是以測試的類別的名稱開頭且以Test結尾。例如，HashTest或HashIntegrationTest。 1 class HashTest { } 有註解的函式 JetPackCompose中帶有@Composable註解且返回Unit的函式，函式名字首大寫，採用大小寫形式並以名詞形式命名。 1 2 3 4 @Composable fun NameTag(name: String) { // … } 縮排 縮排四個空格。 程式語言 縮排 C++ 2格 Java 2格 Kotlin 4格 換行 類別換行 類別的連續成員（屬性、建構子、函式、巢狀類別等）之間 邏輯分組、將程式碼分割為一些邏輯子部分，可換行。 函式與函式之間有換行 1 2 3 4 5 6 7 fun sum3(vararg num:Int){ // ... } fun sum4(vararg num:Int){ // ... } 函式參數換行 當函式簽章不適合放在一行上時，應讓每個參數宣告獨佔一行。以此格式定義的參數應使用單縮排(+4)。右圓括號( )) 和傳回型別獨佔一行，沒有額外的縮排。 1 2 3 4 5 6 7 fun &lt;T&gt; Iterable&lt;T&gt;.joinToString( separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\" ): String { // … } 變數換行 當屬性初始化式不適合放在一行時，應在等號( =) 後面換行，並進行縮排。 1 2 private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file) get set換行 宣告get和/或set函式的屬性應讓每個函式獨佔一行，並使用正常的縮排(+4)。對它們進行格式設定時，使用的規則與函式相同。 1 2 3 4 var directory: File? = null set(value) { // … } 只讀屬性可以使用適合放在一行的較短語法。 1 val defaultExtension: String get() = \"kt\" if、for、when、do、while空格 if後面有空格，左大括號{前面有空格，else前後與大括號之間都有空格。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // WRONG! if (list.isEmpty()){ } // Okay if (list.isEmpty()) { } // WRONG! }else { } // Okay } else { } // WRONG! for(i in 0..1) { } // Okay for (i in 0..1) { } 運算式空格 1 2 3 4 5 // WRONG! val two = 1+1 // Okay val two = 1 + 1 Lambda空格 箭頭 -&gt; 前後都有空格 1 2 3 4 5 // WRONG! ints.map { value-&gt;value.toString() } // Okay ints.map { value -&gt; value.toString() } 變數、參數類型冒號 注意變數後面沒有空格，冒號後面一個空格，再來是類型。 1 val str: String = \"Hello\" 函式參數，注意d變數後面沒有空格，冒號後面一個空格，再來是類型。 1 2 3 fun printDouble(d: Double) { println(d) } 繼承、介面、泛型冒號 繼承冒號(:)前後要空格 1 2 3 4 5 // WRONG! class Foo: Runnable // Okay class Foo : Runnable 泛型T的繼承，繼承冒號(:)前後要空格 注意T : Comparable 1 2 3 4 5 6 // WRONG fun &lt;T: Comparable&gt; max(a: T, b: T) // Okay // 注意T : Comparable fun &lt;T : Comparable&gt; max(a: T, b: T) 1 2 // WRONG fun &lt;T&gt; max(a: T, b: T) where T: Comparable&lt;T&gt; 1 2 3 // Okay // 注意T : Comparable fun &lt;T&gt; max(a: T, b: T) where T : Comparable&lt;T&gt; 逗號後面空格 逗號後面要一個空白，前面不用空白 1 2 3 4 5 // WRONG! val oneAndTwo = listOf(1,2) // Okay val oneAndTwo = listOf(1, 2) 不用空格 ::前後沒有空格 1 2 3 4 5 // WRONG! val toString = Any :: toString // Okay val toString = Any::toString 範圍運算子(..) 1 2 3 4 5 6 7 8 9 // WRONG for (i in 1 .. 4) { print(i) } // Okay for (i in 1..4) { print(i) } if、for、when、do、while大括號 if、for、when分支、do和while語句及表達式都需要大括號，即使主體為空或僅包含一個語句也是如此。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (string.isEmpty()) return // WRONG! if (string.isEmpty()) { return // Okay } if (string.isEmpty()) return // WRONG else doLotsOfProcessingOn(string, otherParametersHere) if (string.isEmpty()) { return // Okay } else { doLotsOfProcessingOn(string, otherParametersHere) } 大括號{}換行 1 2 3 4 5 6 7 8 try { doSomething() } catch (e: Exception) {} // WRONG! try { doSomething() } catch (e: Exception) { } // Okay 列舉的大括號，可以不用換行。 1 enum class Answer { YES, NO, MAYBE } 省略{}大括號 if/else條件語句只有一行才能省略大括號。 1 val value = if (string.isEmpty()) 0 else 1 // Okay 超過一行，還是要有大括號。 錯誤範例 1 2 3 4 val value = if (string.isEmpty()) // WRONG! 0 else 1 對的範例 1 2 3 4 5 val value = if (string.isEmpty()) { // Okay 0 } else { 1 } 省略類型 變數、函式傳回值有初始值可以推斷類型，就可以省略類型。 省略變數類型 1 2 3 val str: String = \"Hello\" // becomes val str = \"Hello\" 省略函式傳回類型 1 2 3 override fun toString(): String = \"Hey\" // becomes override fun toString() = \"Hey\" 省略變數類型 1 2 3 private val ICON: Icon = IconLoader.getIcon(\"/icons/kotlin.png\") // becomes private val ICON = IconLoader.getIcon(\"/icons/kotlin.png\") 列舉 將枚舉中的常數放在單獨的行上時，它們之間不需要空白行，但它們有主體body(大括號{}包起來的部分)時，需要空白行隔開。 1 2 3 4 5 6 7 8 9 enum class Answer { YES, NO, MAYBE { // 主體body override fun toString() = \"\"\"¯\\_(ツ)_/¯\"\"\" } }"
  },"/pages/design_pattern/flyweight/": {
    "title": "共享模式",
    "keywords": "",
    "url": "/pages/design_pattern/flyweight/",
    "body": "主要精神 共用的物件沒有在cache快取中，就創建一個新物件在cache，若物件有存在cache快取中，就從cache快取中抓出來。 本篇以Integer與String pool字串池作為解說。 不變與會變動 此模式很多書都用下棋解釋，這個模式要分清楚那一個是不變的，那一個是會變的，棋盤是不變的，每個玩家的下棋位置是會變的(比如圍棋黑子、白子玩家放下的位置)。 不會變的: 棋盤全部x,y座標位置。 會變的: 玩家的下棋位置 於是把棋盤全部x,y座標只存一次在cache中，假設有100場遊戲，都用cache中固定棋盤座標，而玩家下棋位置則是另外存放，才不會浪費記憶體空間，總不可能有100場遊戲，就儲存100份棋盤x,y座標+玩家下棋位置。 把可以共用的(棋盤x,y座標)抽出來共享，不能共用的，就另外儲存。 分享與不能分享 以上的案例，不變的就是可以分享的，如全部的棋盤位置，會變的就不能分享，如每個玩家的下棋位置。 Integer 以下是Integer的原始碼，Integer有一個cache快取空間，low是-128, high是127，也就是說值介於-128與127之間，就是用快取，超出這個範圍就用新的物件，目的是增加效率，不要頻繁的建立物件占用記憶體。 共享的部分是-128到127，不能共享的部分是超過範圍，就建立新的物件。 Integer.valueOf() 1 2 3 4 5 6 7 8 public static Integer valueOf(int i) { //low是-128, high是127 // 介於-128至127，用快取 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; // 不是-128至127，就建立新的物件 return new Integer(i); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private static final class IntegerCache { // low = -128是重點!!!! static final int low = -128; static final int high; @Stable static final Integer[] cache; // cache是重點!!!! static Integer[] archivedCache; static { // h = 127 high = h是重點!!!! 127 int h = 127; high = h; CDS.initializeFromArchive(IntegerCache.class); // 陣列大小127-(-128) + 1 = 256，所以索引0是-128，索引255是127 int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size &gt; archivedCache.length) { // 這個是重點!!!! 建立快取！ Integer[] c = new Integer[size]; // . // . // .中間截掉一些程式碼 // . // archivedCache是c陣列 archivedCache = c; } // cache 是 archivedCache cache = archivedCache; Integer比較是否相等。 以下使用new的方式已經被廢棄。 new Integer(127); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class Test { public static void main(String[] args) { // Java類型分2種，基本資料型態與物件 // 基本資料型態的比較==，比較是否相等 // 基本資料型態int, long, double, float, char小寫開頭的 // 基本資料型態的比較==，判斷「值」是否相同 System.out.println(\"=== 基本資料型態比較 -128 =====\"); int num1 = -128; int num2 = -128; System.out.println(num1 == num2); // true System.out.println(\"=== 基本資料型態比較 128 =====\"); num1 = 128; num2 = 128; System.out.println(num1 == num2); // true // Integer物件資料型態的比較，判斷是否相等 // -128至127都是指向相同物件 System.out.println(\"=== -128 =====\"); Integer x = Integer.valueOf(-128); Integer y = Integer.valueOf(-128); Integer z = -128; System.out.println(x == y); // true System.out.println(x == z); // true System.out.println(x.equals(y)); // true System.out.println(\"=== 127 =====\"); Integer x1 = Integer.valueOf(127); Integer y1 = Integer.valueOf(127); Integer z1 = 127; System.out.println(x1 == y1); // true System.out.println(x1 == z1); // true System.out.println(x1.equals(y1)); // true System.out.println(\"=== 128 =====\"); Integer a = Integer.valueOf(128); Integer b = Integer.valueOf(128); System.out.println(a == b); // false System.out.println(a.equals(b)); // true } } === 基本資料型態比較 -128 ===== true === 基本資料型態比較 128 ===== true === -128 ===== true true true === 127 ===== true true true === 128 ===== false true String pool字串池 以下字串變數指向”Jack”常數。 1 String name = \"Jack\"; 在Java memory model記憶體模型，有一個區塊是放常數，常數區塊中，又有一個區塊是放String pool字串池。 String Pool，用來儲存重複利用的字串。 在字串池有3個常數分別是Jack, Mary, Alex 以下的程式碼比較變數的記憶體位址是否相同，結果全是true，3個變數都存放相同的記憶體位址。 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { String name1 = \"Jack\"; String name2 = \"Jack\"; String name3 = \"Jack\"; System.out.println(name1 == name2); // true System.out.println(name2 == name3); // true } } true true 下圖中，name1, name2, name3三個變數存放的是0x33的記憶體位址。 如果變數設成新的值，比如”Bill”，Bill沒有在String Pool中，就會建立一個新的字串常數，值是Bill。"
  },"/pages/java/memory_model/": {
    "title": "Java Memory Model",
    "keywords": "",
    "url": "/pages/java/memory_model/",
    "body": "Java Memory Model，中文是記憶體模型。 記憶體分為3個區塊，3個區塊分別為Stack、Heap、Metaspace Stack堆疊，存放變數，以及基本型態(int,char,float,double,long,byte,boolean)。 Heap堆，存放物件，會根據物件的大小建立一個記憶體空間，提供記憶體位址與變數對映。 Metaspace，存放類別的metadata。 String Pool字串池放在Heap，存放字串常數。 基本資料型別 基本資料型別有int, char, float, double, boolean，字母以小寫開頭。 基本資料型別的值是放在stack中，以下是放入stack中的過程。 陣列記憶體位址複製 陣列是物件，「物件」都是放在「Heap」空間，「Stack」放的是「變數」，「變數」的值是存放「Heap」空間的「記憶體位址」。 陣列複製 遇到new關鍵字，就是在Heap中建立一個記憶體空間，空間大小根據物件類型所定義，此處定義大小為3。 Stack中的變數，存放「Heap」空間的「記憶體位址」。 箭頭指向for{}最後，代表已經執行完for迴圈，Heap中的記憶體位址中的值也被設成跟arr1的值是一樣的。 2維陣列 陣列存的是1維陣列的記憶體位址。 物件建立過程 Dog類別 1 2 3 4 5 6 7 8 9 10 11 class Dog { public String name; public int age; public String color; public Dog (String name, int age, String color) { this.name = name; this.age = age; this.color = color; } } 建立Dog 1 2 3 Dog white_dog = new Dog(\"小白\",5,\"白色\"); Dog yellow_dog = new Dog(\"小黃\",6,\"黃色\"); Dog black_dog = new Dog(\"小黑\",7,\"黑色\"); new關鍵字(1)，在Heap建立記憶體空間0x0070(2)，Stack的white_dog變數存的是0x0070(3)，Heap中0x0070位址中的name與age與color，全用預設值，int基本型別用0，name與color是String物件用null。 進入建構子，在String pool字串常數池，建立”小白”字串常數記憶體空間，Heap空間的物件name的值設成”小白”的記憶體位址。 age是int基本型別，直接設數字5。 color是String類別，在String pool字串常數池，建立”白色”字串常數記憶體空間，物件的color設成”白色”的記憶體位址。 三個物件建立完畢的記憶體模型 164 165 176 194 199 203 466"
  },"/pages/kotlin/equals/": {
    "title": "記憶體位址是否相同",
    "keywords": "",
    "url": "/pages/kotlin/equals/",
    "body": "== 二個等於是比較「值」。 非空值類型=== 如果是基本資料型別String, Int, Double, Float, Long, Short, Char, Byte, Boolean 比較的仍是「值」。 空值類型=== 「空值類型」，比較的是「記憶體位址」。 要繼續讀下面的內容，一定要先了解共享模式，Integer與String pool。 共享模式 Integer 值為127，記憶體位址都是相等。 1 2 3 4 5 6 7 8 9 10 11 12 13 println(\"=========非空值類型127=============\") val x = 127 val y = 127 println(\"位址相等 = ${x === y}\") println(\"值相等 = ${x == y}\") println(\"=========空值類型127=============\") val x1:Int? = 127 val y1:Int? = 127 println(\"位址相等 = ${x1 === y1}\") println(\"值相等 = ${x1 == y1}\") println(\"=========空值與非空值類型127=============\") println(\"位址相等 = ${x1 === x}\") println(\"值相等 = ${x1 == x}\") =========非空值類型127============= 位址相等 = true 值相等 = true =========空值類型127============= 位址相等 = true 值相等 = true =========空值與非空值類型127============= 位址相等 = true 值相等 = true 超出128，以下記憶體位址只有非空值類型是相等，空值類型都不是相等。 1 2 3 4 5 6 7 8 9 10 11 12 13 println(\"=========非空值類型128=============\") val x = 128 val y = 128 println(\"位址相等 = ${x === y}\") println(\"值相等 = ${x == y}\") println(\"=========空值類型128=============\") val x1:Int? = 128 val y1:Int? = 128 println(\"位址相等 = ${x1 === y1}\") println(\"值相等 = ${x1 == y1}\") println(\"=========空值與非空值類型128=============\") println(\"位址相等 = ${x1 === x}\") println(\"值相等 = ${x1 == x}\") =========非空值類型128============= 位址相等 = true 值相等 = true =========空值類型128============= 位址相等 = false 值相等 = true =========空值與非空值類型128============= 位址相等 = false 值相等 = true String 以下程式碼，不管是非空值類型與空值類型，都是指向同一個記憶體位址，指向同一個String Pool中的常數。 1 2 3 4 5 6 7 8 val str1 = \"Jack\" val str2 = \"Jack\" println(\"位址相等 = ${str1 === str2}\") println(\"值相等 = ${str1 == str2}\") val s1:String? = \"Jack\" val s2:String? = \"Jack\" println(\"位址相等 = ${s1 === s2}\") println(\"值相等 = ${s1 == s2}\") 位址相等 = true 值相等 = true 位址相等 = true 值相等 = true"
  },"/pages/kotlin/fun/": {
    "title": "函式",
    "keywords": "",
    "url": "/pages/kotlin/fun/",
    "body": "函式宣告 以fun開頭後面接函式名，有函式名的稱為有名字的函式。 有名字的函式要用return傳回值。 fun 函式名(參數: 參數類型): 傳回值類型 { return 傳回值 } 多參數 fun 函式名(參數1: 參數類型, 參數2: 參數類型): 傳回值類型 { return 傳回值 } 以下程式碼圓括號裡是參數(參數1: 參數類型, 參數2: 參數類型)。 : Int為傳回值型別。 1 2 3 4 5 6 7 fun sum(a: Int, b: Int): Int { return a + b } fun main() { // 有帶參數記得加上花括號印出${} println(\"result = ${sum(1, 2)}\") } result = 3 簡化 如果只有一行，省略花括號{}，省略return。 1 2 3 fun a(): Int { return 1 } 使用等於= 1 fun b():Int = 1 若傳回值類型可以自動推導，可以省略傳回值類型。 1 fun c() = 1 指派 用 = 來指派傳回值的運算式 1 2 3 4 fun plus(a: Int, b: Int) : Int = a + b fun main() { println(plus(1,2)) } 3 if在函式中省略return過程 if在函式有return 1 2 3 4 5 6 7 8 9 10 fun chooseMax(a:Int, b:Int) : Int { if(a &gt; b) { return a } else { return b } } fun main() { println(\"chooseMax fun = ${chooseMax(10, 20)}\") } chooseMax fun = 20 if 條件運算子 1 2 3 4 5 6 fun chooseMax2(a:Int, b:Int):Int{ return if (a &gt; b) a else b } fun main() { println(\"chooseMax2 fun = ${chooseMax2(10, 20)}\") } chooseMax2 fun = 20 省略return，用指派= 1 2 3 4 fun chooseMax3(a:Int, b:Int) = if (a &gt; b) a else b fun main() { println(\"chooseMax3 fun = ${chooseMax3(10, 20)}\") } chooseMax3 fun = 20 if多行條件語句，用指派，省略return。 1 2 3 4 5 6 7 8 9 10 fun chooseMax4(a:Int, b:Int) = if (a &gt; b) { println(\"a最大\") a //結果值放在最後一行，不要加return } else { println(\"b最大\") b } fun main() { println(\"chooseMax4 fun = ${chooseMax4(10, 20)}\") } b最大 chooseMax4 fun = 20 函式中的函式 函式中的函式可以存取外部函式的變數，但外部函式無法存取內部函式的變數。 func_level1()函式無法使用func_level2()與func_level3()裡面的變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fun main() { val level0 = 0 fun func_level1() { println(\"level0 = $level0\") val level1 = 1 fun func_level2() { println(\"=============\") println(\"level0 = $level0\") println(\"level1 = $level1\") val level2 = 2 fun func_level3() { println(\"=============\") println(\"level0 = $level0\") println(\"level1 = $level1\") println(\"level2 = $level2\") } func_level3() } func_level2() } func_level1() } level0 = 0 ============= level0 = 0 level1 = 1 ============= level0 = 0 level1 = 1 level2 = 2 參數預設值 參數可以有預設值。 1 2 3 4 5 6 7 8 9 10 11 fun sum2(a: Int = 0, b: Int = 3, c: Int){ println(a + b + c) } fun main() { // 使用參數名稱指定值，略過有預設值的B sum2(a = 3, c = 6) // 略過有預設值的a和b sum2(c = 5) // 以名稱指定參數的值，就可以忽略原始參數的順序 sum2(c = 9, a = 1, b = 3 ) } 12 8 13 Unit函式 Unit函式指的是沒有傳回值的函式，等同java的void，但java的void不是類型，傳回值Unit是一種類型。 1 2 3 4 5 //無參數，無傳回值的函式 fun foo() {} fun main() { println(foo()) } kotlin.Unit 函式參考 使用2個冒號::後面是有名字的函式，呼叫函式時，有帶參數記得加上花括號印出${} 1 2 3 4 5 6 fun calculate(x: Int): Int { return x + 3 } val funRef = ::calculate // 有帶參數記得加上花括號印出${} println(\"result = ${funRef(6)}\") 9 匿名函式 沒有名字的函式，沒有函式名，只有fun關鍵字。 1 2 3 4 5 val useAnonymousFun = fun(x: Int): Int { return x + 3 } //有帶參數記得加上花括號印出${} println(\"use AnonymousFun:${useAnonymousFun(6)}\") 9 inline 在fun關鍵字前面加上inline，意思是編譯的時候把程式碼複製到呼叫的位置。 1 2 3 4 5 6 7 8 inline fun calculate(x: Int): Int { return x + 3 } fun main() { println(\"inline function1 = ${calculate(5)}\") println(\"inline function2 = ${calculate(6)}\") println(\"inline function3 = ${calculate(7)}\") } 按2次shift鍵，輸入show kotlin bytecode 按下「Decompile」按鈕，可以看到轉碼過後的java程式碼。 為什麼要使用inline呢？因為每個函式都會占記憶體，使用inline直接把函式中的程式碼複製過去，可以減少函式記憶體，但這個函式的內容不多才可以這樣做。 私有函式 預設是public，全部的.kt文件都可以使用，若要變成私有，前面要加上private，函式只能被所在的位置.kt文件使用，不同文件.kt文件不能用。 1 2 3 private fun sum(a: Int, b: Int): Int { return a + b }"
  },"/pages/kotlin/lambda/": {
    "title": "Lambda",
    "keywords": "",
    "url": "/pages/kotlin/lambda/",
    "body": "Prerequisites: Java Lambda Lambda就是匿名函式，沒有名字的函式。 Lambda是變數類型 Lambda的類型是由「傳入的參數」與「傳回值類型」所決定的。 此處的Lambda與C++的函式指標有相同的概念。 有名字的函式 有名字的函式要用return傳回值。 fun 函式名(參數): 傳回值類型 { return 傳回值 } 1 2 3 fun sum(a: Int, b: Int): Int { return a + b } 沒有名字的函式Lambda 用花括號{}開始跟結束，使用-&gt;將參數跟函式內容分開，參數可以1個、多個、或沒有。 函式內容可以有多行，最後計算的運算式作為Lambda傳回值，例如下面程式碼傳回x + 5的結果。 -&gt;用於分隔任何參數。 -&gt;後面要傳回的結果，Lambda不用有return。 如果Lambda沒有參數，可以省略-&gt; Lambda 1 { x: Int -&gt; \"The value is $x\" } 把Lambda指派給變數，並執行。 1 2 3 val msg = { x: Int -&gt; \"The value is $x\" } // 執行Lambda有代入參數，要用${運算式} println(\"pass 6 to msg:${msg(6)}\") pass 6 to msg:The value is 6 Lambda類型 變數的類型是Lambda，Lambda類型是「傳入的參數類型與個數」+「傳回值類型」所組合。 Lambda可以指派給變數，以下把{ x: Int, y: Int -&gt; x + y }指派給變數sum。 {}大括號是函式主體body，函式主體中有「參數」與「傳回值」，與Lambda類型是一致的。 1 2 3 // 變數: (傳入的參數類型) -&gt; 傳回值類型 = {參數: 類型, 參數: 類型 -&gt; 傳回值} val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y } println(sum(10, 20)); 30 自動推導Lambda類型 變數的Lambda類型是可以自動推導的，就可以省略Lambda類型。 1 2 3 4 // 省略Lambda類型(Int, Int) -&gt; Int val sum = { x: Int, y: Int -&gt; x + y } // 有帶參數記得加上花括號印出${} println(\"sum = ${sum(15, 25)}\"); sum = 40 sendMsg1的Lambda類型是可以自動推導，就可以省略Lambda類型。 1 2 3 4 5 6 // 省略Lambda類型() -&gt; String val sendMsg1 = { val appendMsg = \"nice to meet you.\" \"傳回訊息1 = $appendMsg\" } println(sendMsg1()) 傳回訊息1 = nice to meet you. 省略函式主體參數類型 如果Lambda類型沒有省略，{}大括號稱為函式主體body，函式主體中的參數「類型」是可以省略。 1 2 // 變數: (傳入的參數類型) -&gt; 傳回值類型 = {參數, 參數 -&gt; 傳回值} val sum: (Int, Int) -&gt; Int = { x, y -&gt; x + y } 參數只有一個，使用it 參數只有一個。 1 2 3 // 變數: (傳入的參數類型) -&gt; 傳回值類型 = {參數 -&gt; 傳回值} val sendMsg: (String) -&gt; String = { msg -&gt; \"傳回訊息 = $msg\" } println(sendMsg(\"Hello world!\")) 傳回訊息 = Hello world! 省略msg參數，省略-&gt;箭頭，把$msg變成$it，只針對「參數只有一個」。 1 2 val sendMsg: (String) -&gt; String = { \"傳回訊息 = $it\" } println(sendMsg(\"Hello world!\")) 傳回訊息 = Hello world! 多行程式碼，最後一行是傳回值 在函式主體{}中，可以有多行程式碼，最後一行是傳回值。 1 2 3 4 5 val sendMsg: (String) -&gt; String = { val appendMsg = \"${it} nice to meet you.\" \"傳回訊息 = $appendMsg\" } println(sendMsg(\"Hello world!\")) 傳回訊息 = Hello world! nice to meet you. Lambda參數是Lambda Lambda也是匿名函式，匿名函式的參數是匿名函式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val callback: (Int) -&gt; String = { when (it) { 404 -&gt; \"找不到網頁\" 500 -&gt; \"Server error!\" else -&gt; \"其它錯誤\" } } val sendMsg3: (Int, (Int) -&gt; String) -&gt; String = { code, function1 -&gt; function1(code) } println(\"Lambda參數是Lambda，結果 = ${sendMsg3(404, callback)}\") Lambda參數是Lambda，結果 = 找不到網頁 解釋: callback變數的Lambda類型是，參數是Int，傳回值是String。 sendMsg3變數的Lambda類型是，參數有二個，分別是Int與Lambda，傳回值是String類型。 sendMsg3()，參數2的Lambda類型是(Int) -&gt; String，參數是Int，傳回值是String。 1 println(\"Lambda參數是Lambda，結果 = ${sendMsg3(404, callback)}\") 使用字串模板運算式${} 呼叫sendMsg3()函式 參數1，404 參數2，callback變數 有名字的函式參數是Lambda 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun sendMsg4(code:Int, function1: (Int) -&gt; String): String { return function1(code) } fun main() { val callback: (Int) -&gt; String = { when (it) { 404 -&gt; \"找不到網頁\" 500 -&gt; \"Server error!\" else -&gt; \"其它錯誤\" } } println(\"有名字的函式的參數是Lambda，結果 = ${sendMsg4(500, callback)}\"); 有名字的函式的參數是Lambda，結果 = Server error! 解釋: callback變數的Lambda類型是，參數是Int，傳回值是String。 sendMsg4()定義在main()函式之外。 sendMsg4()，傳回值是String類型，參數有二個，分別是Int與Lambda。 sendMsg4()，參數2的Lambda的類型是(Int) -&gt; String，參數是Int，傳回值是String類型。 sendMsg4()是有名字的函式，要有return關鍵字。 最後一個參數是Lambda sendMsg5()Lambda類型是，參數1是Int類型，參數2是Lambda，傳回值是Unit，沒有傳回值。 sendMsg5()，參數2的Lambda的類型是(Int) -&gt; String，參數是Int，傳回值是String類型。 code是參數1的變數名，function1是參數2的變數名。 1 2 3 4 val sendMsg5: (Int, (Int) -&gt; String) -&gt; Unit = { code, function1 -&gt; println(\"Lambda在參數最後 = ${function1(code)}\") } 把函式主體{}移出圓括號，花括號{}是Lambda，是參數2。 1 2 3 4 5 6 7 sendMsg5(200) { if (it == 200) { \"網頁正常\" } else { \"其它錯誤\" } } Lambda在參數最後 = 網頁正常 參數只有一個Lambda，去掉圓括號 sendMsg6()，參數1的Lambda類型為(Int) -&gt; String，參數是Int，傳回值是String類型。 1 2 3 val sendMsg6: ((Int) -&gt; String) -&gt; Unit = { println(\"參數只有一個Lambda = ${it(200)}\") } 未省略圓括號前。 1 2 3 4 5 6 7 sendMsg6 ({ if (it == 200) { \"網頁正常\" } else { \"其它錯誤\" } }) 省略圓括號，花括號{}是Lambda，是參數。 1 2 3 4 5 6 7 sendMsg6 { if (it == 200) { \"網頁正常\" } else { \"其它錯誤\" } } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 val sendMsg6: ((Int) -&gt; String) -&gt; Unit = { println(\"參數只有一個Lambda = ${it(200)}\") } sendMsg6 { if (it == 200) { \"網頁正常\" } else { \"其它錯誤\" } } 參數只有一個Lambda = 網頁正常 透過Lambda把標準函式重寫(覆寫) 1 2 3 4 var str = \"Hello World\" val o_count = str.count ({ letter -&gt; letter == 'o' }) letter是參數。 只要計算字母為o的字元數量。 1 letter == 'o' 簡化2，圓括號去掉 1 2 3 4 var str = \"Hello World\" val o_count = str.count { letter -&gt; letter == 'o' } 簡化3，letter與-&gt;箭頭去掉，因為只有一個參數，可以去掉，默認用it代替一個參數。 1 2 3 4 var str = \"Hello World\" val o_count = str.count { it == 'o' } 印出字元個數 1 2 3 var str = \"Hello World\" println(\"字元個數 = ${str.count()}\") println(\"o字元個數 = ${o_count}\") 字元個數 = 11 o字元個數 = 2 傳回值是Lambda 以下是有名字的函式，所以會用到return，注意，它的傳回值是Lambda類型(Int) -&gt; String，函式參數是url。 1 2 3 4 5 6 7 8 9 10 fun sendMsg7(url: String) : (Int) -&gt; String { val contact = \"xxx@xxx.mail.com\" return { code: Int -&gt; when (code) { 404 -&gt; \"${url} 找不到網頁, please contact ${contact}\" 500 -&gt; \"${url} Server error!, please contact ${contact}\" else -&gt; \"${url} 其它錯誤, please contact ${contact}\" } } } 傳回值解說: {}大括號就是Lambda主體body，參數是code，會傳回String，Lambda可以用外部函式sendMsg7()的參數url與變數contact。 1 2 3 4 5 6 7 return { code: Int -&gt; when (code) { 404 -&gt; \"${url} 找不到網頁, please contact ${contact}\" 500 -&gt; \"${url} Server error!, please contact ${contact}\" else -&gt; \"${url} 其它錯誤, please contact ${contact}\" } } msgfun變數接收到的是傳回值函式，就是上面大括號{}包住的程式碼，傳回值函式的類型是(Int) -&gt; String。 msgfun(404)是把參數代入，傳回值是String 1 2 3 4 fun main() { val msgfun = sendMsg7(\"http://www.xxx.com\") println(msgfun(404)) } http://www.xxx.com 找不到網頁, please contact xxx@xxx.mail.com 參數沒使用，用_代表 1 2 3 4 val useLambda2: (Int, Int) -&gt; Unit = { x, _ -&gt; println(\"First:$x\") } useLambda2(6, 9) First:6"
  },"/pages/kotlin/null/": {
    "title": "Null",
    "keywords": "",
    "url": "/pages/kotlin/null/",
    "body": "非空值類型 在宣告變數時就能確定它是有值的，不能是null，若把變數設為null，會編譯錯誤。 非空值類型「不可以」儲存 null 值的變數。 1 2 3 var name: String = \"Tom\" //null不能是非空值類型字符串的值 編譯錯誤 //name = null 空值類型 空值類型，是「可以」儲存 null 值的變數。 官方建議，用var宣告。 類型後面加上?，類型不可省略。 var 變數名:類型? 代表此變數「可以」儲存 null 值。 1 2 var b: String? = \"Tom\" b = null 這個變數的值有二種情況:值或null 使用這個變數時就必須額外檢查null，否則編譯器不會讓這個程式碼通過 存取空值變數的屬性 Kotlin 編譯器會對可為空值類型強制執行「null 檢查」。 以下程式碼會編譯失敗，因為沒有檢查空值類型。 1 2 var b: String? = \"Tom\" println(b.length) if null 在檢查的範圍內，可以使用變數的屬性。 1 2 3 4 var b: String? = \"Tom\" if (b != null) { println(b.length) } 3 這樣做更好，若為null，就傳回0 1 2 3 4 5 6 7 var b: String? = \"Tom\" var result = if (b != null) { b.length } else { 0 } println(result) 安全呼叫?. 使用?.符號來安全呼叫成員屬性。 1 2 3 var b: String? = \"Tom\" //如果B有值就存取它的length屬性 println(b?.length) 3 安全呼叫?.存取null屬性 即使嘗試存取 null 變數的 length 屬性，該程式仍不會停止運作。安全呼叫運算式只會傳回 null。 語法 ?.method 1 2 var b: String? = null println(b?.length) null 貓王(Elvis)運算子?: 什麼是貓王(Elvis)運算子?: 物件是null，傳回預設值。 變數 ?: 預設值 存取null物件的屬性，需搭配安全呼叫?. 變數?.屬性 ?: 預設值 1 2 3 var name2:String? = null println(name2 ?: \"no data\") println(name2?.length ?: \"no data\") no data no data 使用了一個安全呼叫?.後面的呼叫也必須使用安全呼叫，有一個呼叫是null，後面的安全呼叫就都不執行。 1 2 val name3: String? = null println(name3?.uppercase()?.replace(\"T\",\"J\")?.length ?: \"name 3 is null\") name 3 is null let安全呼叫 即使嘗試存取 null 變數，該程式仍不會停止運作，安全呼叫運算式只會傳回 null。 若不為null，才會執行let{} Lambda函式，否則傳回null。 1 2 val name3: String? = null println(name3?.let { if (name3.isNotBlank()) name3 else \"blank\" }) null 強制呼叫!! 確定有值，用在可為空值類型的變數，不打算使用安全呼叫，使用雙驚嘆號!! 語法 !!.method 若變數是null，就會產生 Exception in thread “main” java.lang.NullPointerException 1 2 var c: String? = \"Tom\" println(c!!.length)"
  },"/pages/kotlin/range/": {
    "title": "IntRange區間與in",
    "keywords": "",
    "url": "/pages/kotlin/range/",
    "body": "in 在某個範圍內。 !in not in，不在某個範圍內。 Range作為變數 1 2 3 val charRange = 'a' .. 'z' //全包區間 val intRange = 1 until 10 //半包區間，不包含10 val stepRange = 1 .. 10 step 2 判斷是否有在範圍內。 1 2 3 4 5 val range1 = 1 .. 10 var c = 10 println(c in range1) //true c = 11 println(c !in range1) true true 判斷是否有在範圍內。 1 2 3 4 val range1 = 1 until 10 var c = 10 println(c in range1) println(c !in range1) false true for與in 全包區間.. 0 .. 6 代表包含0到包含6 1 2 3 4 5 // in關鍵字會將變數i的值限制在指定範圍內 for (i in 0 .. 6) { // i在每次徝環時取得一個+1的值 println(i) } 0 1 2 3 4 5 6 印出a到e。 1 2 3 4 for (c in 'a' .. 'e') { // c在每次徝環時取得一個+1的值 println(c) } a b c d e 半包區間until 不包含尾端的值 1 2 3 for (i in 0 until 6) { println(i) } 1 2 3 4 5 downTo 徝環順序要反過來由大到小，使用downTo 1 2 3 4 for (i in 6 downTo 0) { // i在每次徝環時取得一個-1的值 println(i) } 6 5 4 3 2 1 0 step 每次跳2位數 1 2 3 for (i in 0..6 step 2) { println(i) } 0 2 4 6 while與in 1 2 3 4 5 6 7 8 // Range作為變數 val range = 0 .. 10 var a = 1 //如果a 在 range中就返回true，否則返回false while (a in range) { a++ println(\"$a\") } 2 3 4 5 6 7 8 9 10 11"
  },"/pages/kotlin/scope_fun/": {
    "title": "let,run,with,also,apply…",
    "keywords": "",
    "url": "/pages/kotlin/scope_fun/",
    "body": "Prerequisites: null Lambda Lambda參數與傳回值 Lambda參數為呼叫Lambda函式(let, run, with, also, apply)的物件。 Lambda函式 參數 傳回值 let it 最後一行決定 run this 最後一行決定 with this 最後一行決定 also it 呼叫它的物件 apply this 呼叫它的物件 let it，為呼叫Lambda函式的物件。 傳回值是lambda最後一行。 setWritable() 和 setExecutable() 這些方法的返回值是 Boolean，表示操作是否成功 1 2 3 4 5 6 7 val var1 = File(\"/Users/cici/testc/file_test\").let { it.setWritable(true) it.setWritable(true) it.setExecutable(true) //最後一行的結果才是傳回值 } println(\"var1 = $var1\") println(var1::class) file1 = true boolean (Kotlin reflection is not available) run this，為呼叫Lambda函式的物件。 傳回值是lambda最後一行。 1 2 3 4 5 6 7 val var3 = File(\"/Users/cici/testc/file_test\").run { setWritable(true) setWritable(true) setExecutable(true) //最後一行的結果才是傳回值 } println(\"var3 = $var3\") println(var3::class) var3 = true boolean (Kotlin reflection is not available) run可以呼叫函式參考 with this，為呼叫Lambda函式的物件。 傳回值是lambda最後一行。 使用參數的方式代入，with(參數) {} 1 2 3 4 5 6 7 val var5 = with(File(\"/Users/cici/testc/file_test\")) { setWritable(true) setWritable(true) setExecutable(true) //最後一行的結果才是傳回值 } println(\"var5 = $var5\") println(var5::class) var5 = true boolean (Kotlin reflection is not available) also it，為呼叫Lambda函式的物件。 傳回值是呼叫它的物件，此處是File。 1 2 3 4 5 6 7 val file2 = File(\"/Users/cici/testc/file_test\").apply { setWritable(true) setWritable(true) setExecutable(true) } println(\"file2 = $file2\") println(file2::class) file2 = /Users/cici/testc/file_test class java.io.File (Kotlin reflection is not available) apply it，為呼叫Lambda函式的物件。 傳回值是呼叫它的物件，此處是File。 1 2 3 4 5 6 7 val file4 = File(\"/Users/cici/testc/file_test\").also { it.setWritable(true) it.setWritable(true) it.setExecutable(true) } println(\"file4 = $file4\") println(file4::class) file4 = /Users/cici/testc/file_test class java.io.File (Kotlin reflection is not available) 用法 Lambda參數為呼叫Lambda函式(let, run, with, also, apply)的物件。 Lambda函式 參數 傳回值 用法 let it 最後一行決定 null安全呼叫、修改內容 run this 最後一行決定 運算、判斷true或false、函式參考 with this 最後一行決定 與run功能相同，但沒有函式參考 also it 呼叫它的物件 鏈式呼叫（Method chaining）對同一個物件進行一系列的操作 apply this 呼叫它的物件 初始化、config設定 初始化、config設定 1 2 3 4 val file = File(\"/Users/cici/testc/file_test\").apply { setWritable(true) setReadable(true) } 取出資料 1 2 3 val lines = file.let { it.readLines() } 對同一個物件進行一系列的操作。 1 2 3 4 5 6 7 file.also { println(\"file size = ${it.length()}\") }.also { println(\"file path = ${it.path}\") }.also { println(\"file content= ${it.readText()}\") } file size = 30 file path = /Users/cici/testc/file_test file content= 測試程式 java程式設計 計算、判斷true或false 1 2 3 4 val res = file.run { this.readText().contains(\"Java\") } println(\"res = $res\") res = false with與run功能相同 1 2 3 4 5 val res2 = with(file) { //\"file name = ${name} length = ${length()} byte.\" this.readText().contains(\"Java\") } println(\"res2 = $res2\") res2 = false 也可作為多行程式碼運算，或資料整理，最後一行回傳最後結果。 1 2 3 4 val fileInfo = with(file) { \"file name = ${name} length = ${length()} byte.\" } println(fileInfo) file name = file_test length = 30 byte. let與null 配合安全呼叫問號?，不是null才呼叫let花括號{}中的內容，最後再配合:?貓王運算子，得到null結果時指定預設值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fun main() { // String類型後面加上問號?代表可以是null var msg: String? = null; println(\"${showMsg(msg)}\") println(\"=================\") msg = \"Hello World!\" println(\"${showMsg(msg)}\") } fun showMsg(arg1: String?) : String { // 若為null，就不執行let{}中的內容，顯示預設值null data return arg1?.let { \"Your msg is $arg1\" } ?: \"null data\" } null data ================= Your msg is Hello World! also與null 配合安全呼叫問號?，若file為空值，後面的also就不會再執行了。 1 2 3 4 5 6 7 file?.also { println(\"file size = ${it.length()}\") }.also { println(\"file path = ${it.path}\") }.also { println(\"file content= ${it.readText()}\") } run與函式參考 鏈式呼叫與函式參考二者結合，都會把Lambda最後一行，傳到下一個函式中，最後把showMsg2()的結果印出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fun main() { \"abcdefegdddffdfd\" .run(::isLong) .run(::showMsg2) .run(::println) } fun isLong(str: String): Boolean = str.length &gt; 10 fun showMsg2(isLong: Boolean): String { return if (isLong) { \"String is too long\" } else { \"String is not too long\" } } String is too long 其它 以下為有條件的Lambda takeIf it，為呼叫Lambda函式的物件。 根據條件傳回呼叫它的物件，或null。 判斷是否符合條件，符合條件傳回呼叫它的物件，否則傳回null，takeIf{…}?，後面要加上問號?，因為有可能會為null，是空值類型。 以下範例是做鏈式呼叫，若條件成立，會傳回File物件，然後呼叫readText()，若條件不成立，就直接傳回null，不繼續執行readText。 1 2 var result = File(\"/Users/cici/adbd\").takeIf { it.exists() }?.readText() println(result) null takeUnless it，為呼叫Lambda函式的物件。 根據條件傳回呼叫它的物件，或null。 與takeIf相反，不符合條件，才會進入let{}中。 1 2 3 4 var result2 = File(\"/Users/cici/adbd\").takeUnless { it.exists() }.let { \"file is not exist.\" } println(\"result = $result2\") result = file is not exist."
  },"/pages/kotlin/stdlib/": {
    "title": "常用函式庫",
    "keywords": "",
    "url": "/pages/kotlin/stdlib/",
    "body": "取出亂數 List 1 val randomId = (1 .. 100).shuffled().first() shuffled()傳回List，first()取出List中的第一個元素。"
  },"/pages/kotlin/when_if/": {
    "title": "if, when, while",
    "keywords": "",
    "url": "/pages/kotlin/when_if/",
    "body": "if 條件運算子 1 2 3 val b: Any = 1 val res3: Boolean = if (b == 1) true else false println(\"res3:$res3\") res3:true if 接收傳回值 什麼時候會判斷if是要有傳回值的？ 拿變數去接收它會自動判斷if是要去獲取傳回值的。 但一定要帶上else，因為它要判斷如果if條件不相等，要帶上其它值。 不用有return，預設程式碼區塊{}的最後一行是傳回值。 1 2 3 4 5 6 7 8 9 val b: Any = 1 val res: Int = if (b == 1) { 3 } else if (b == 3) { 1 } else { 2 } println(res) // 3 1 2 3 4 5 6 7 8 9 val count = 42 val answerString: String = if (count == 42) { \"I have the answer.\" } else if (count &gt; 35) { \"The answer is close.\" } else { \"The answer eludes me.\" } println(answerString) I have the answer. if條件語句不只有一行，省略return 如果if條件語句內的程式碼不只一行，必須把結果放在最後一行，而且不可以加return。 使用if條件語句作為傳回值的時候，一定要有else區塊，確保有值，才能指派給變數 1 2 3 4 5 6 7 8 9 10 var a = 3 val b = 9 val chooseMax = if (a &gt; b) { println(\"a最大\") a //結果值放在最後一行，不要加return } else { println(\"b最大\") b } println(\"chooseMax = $chooseMax\") b最大 chooseMax = 9 when 程式碼區塊 when每個程式碼區塊{}是用 -&gt; 箭頭指向程式碼區塊{}，預設程式碼區塊{}的最後一行是傳回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val str: Any = \"abc\" when(str) { // 判斷b == 1 or b== 2，可以寫在同一排 1, 2 -&gt; { println(\"是1\") } // 要把c設成Any，就不會自動推導Int，若沒設Any，會有型別錯誤 is String -&gt; { println(\" is str\") } // 判斷是不是在1到10的區間中 in 1 .. 10 -&gt; { println(\" 1 到 10 \") } else -&gt; { println(\"沒有東西\") } } 如果只有一行，就不用寫花括號，if也是一樣。 1 2 3 4 5 6 7 8 9 val b:Any = 1 println( when (b) { 1, 2 -&gt; 2 is String -&gt; 3 in 1 .. 10 -&gt; 4 else -&gt; 5 } ) 2 when的條件判斷不會像java的switch自動向下執行，所以不必使用break來終止。 當if - else條件過多時，建議改用when。 注意x變數的類型是Any。 1 2 3 4 5 6 7 8 9 10 11 12 13 var x: Any = 1 when { // x 等於1的時候執行，箭頭表示符合時要如何處理 x == 1 -&gt; println(\"x 是 1\") // x 等於2,3或者等於4的時候 x == 2 || x == 3 || x == 4 -&gt; println(\"x 可能是2 3 4\") // x 在 5-10 的時候執行 x in 5 .. 10 -&gt; println(\"x 在 5-10 的時候執行\") // x 是 int的類型 x is Int -&gt; println(\"x是整數\") // 其它情況 else -&gt; println(\"無法判斷\") } x 是 1 把x放在when的參數裡。 1 2 3 4 5 6 7 8 9 var x: Any = 1 when (x) { 1 -&gt; println(\"x 是 1\") 2, 3, 4 -&gt; println(\"x 可能是2 3 4\") in 5 .. 10 -&gt; println(\"x 在 5-10 的時候執行\") is Int -&gt; println(\"x是整數\") else -&gt; println(\"無法判斷\") // 如果所有可能條件都列出時，可以省略else } x 是 1 拿message變數去接收when。 1 2 3 4 5 6 7 8 9 10 11 var x: Any = 1 val message = when(x) { 1 -&gt; println(\"x 是 1\") 2, 3, 4 -&gt; println(\"x 可能是2 3 4\") in 5 .. 10 -&gt; println(\"x 在 5-10 的時候執行\") is Int -&gt; println(\"x是整數\") else -&gt; { // 可以寫很多東西，要記得把結果放在最後一行 println(\"無法判斷\") } } x 是 1 拿變數去接收條件語句會自動判斷when是要去獲取傳回值的。 但一定要有else，若之前的條件都不滿足，要有個else取得默認的傳回值。 注意，b變數是Any類型，預設程式碼區塊{}的最後一行是傳回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 val b: Any = 1 val res2 = when(b) { // 判斷b == 1 or b== 2，可以寫在同一排 1, 2 -&gt; { 2 } // 要把b設成Any，就不會自動推導Int，若沒設Any，會有型別錯誤 is String -&gt; { 3 } // 判斷是不是在1到10的區間中 in 1 .. 10 -&gt; { 4 } else -&gt; { 5 } } println(res2) // 2 for continue 1 2 3 4 5 //跳過4 for (i in 1..10) { if (i == 4) continue println(i) } 1 2 3 5 6 7 8 9 10 break 1 2 3 4 for (i in 1..10) { if (i == 5) break; println(i) } 1 2 3 4 foreach 1 2 3 (0 .. 5).forEach { println(it) } 0 1 2 3 4 5 repeat 重覆執行某段程式碼一定的次數 1 2 3 repeat(3) { println(\"hello\") } hello hello hello while 1 2 3 4 5 var i = 0 while (i &lt; 6) { println(i) i++ } 0 1 2 3 4 5 1 2 i = 0 while (i &lt; 6) println(i++) 0 1 2 3 4 5 加1放在前面表示先加1再加上自己 1 2 i = 0 while (i &lt; 6) println(++i) 1 2 3 4 5 6 即使條件不滿足，也至少執行一次 1 2 3 4 5 i = 6 do { println(i) i++ } while (i &lt; 6) 6 標籤\\@ 某些情況下想離開外面的那個迴圈 break標籤\\@ 標籤名稱@ 指定要跳離的迴圈 1 2 3 4 5 6 7 8 9 10 11 i = 0 abc@ do { println(\"out loop $i\") i++ var j = 0 while (j &lt; 3) { println(\"-- in loop $j\") j++ break@abc } } while (i &lt; 6) out loop 0 -- in loop 0 外迴圈、內迴圈只跑一次 continue標籤\\@ 1 2 3 4 5 6 7 8 9 10 11 i = 0 outer@ do { println(\"out loop $i\") i++ var j = 0 while (j &lt; 3) { println(\"-- in loop $j\") j++ continue@outer } } while (i &lt; 6) out loop 0 -- in loop 0 out loop 1 -- in loop 0 out loop 2 -- in loop 0 out loop 3 -- in loop 0 out loop 4 -- in loop 0 out loop 5 -- in loop 0 外迴圈跑6遍，內迴圈參與一次 return標籤\\@ 類似continue功能。 不要印出2，遇到2就continue下一個for loop，其它的都要印。 1 2 3 4 5 (0 .. 10).forEach b@{ if(it == 2) return@b println(it) } 1 3 4 5 6 7 8 9 10 以上沒有印2 run標籤\\@ 跳離forEach 要跳出整個foreach如何使用？使用run, run也是lambda ,結束run這個循環在run的循環加上標注 1 2 3 4 5 6 7 run c@{ (0 .. 10).forEach { if(it == 2) return@c println(it) } } 0 1 return return 會跳離迴圈最接近的函式。 不管是否為巢狀迴圈，永遠會跳離最接近的函式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun foo(){ for (i in 0..1) { println(\"for i start: $i\") for (j in 0 .. 3) { println(\"for j start: $j\") if (j == 2) { println(\"out foo()\") return } println(\"for j finish: $j\") } println(\"for i finish $i\") } println(\"finish foo()\") } foo() for i start: 0 for j start: 0 for j finish: 0 for j start: 1 for j finish: 1 for j start: 2 out foo()"
  },"/pages/kotlin/array/": {
    "title": "Array",
    "keywords": "",
    "url": "/pages/kotlin/array/",
    "body": "陣列無法新增值，因為陣列是一個固定大小的陣列，可以修改。 建立陣列 陣列類型 建立陣列語法 IntArray intArrayOf DoubleArray doubleArrayOf LongArray longArrayOf ShortArray shortArrayOf ByteArray byteArrayOf FloatArray floatArrayOf BooleanArray booleanArrayOf Array&lt;物件&gt; arrayOf 建立int陣列 1 2 3 val intarr: IntArray = intArrayOf(10, 20, 30) // 可省略類型，會自動推導。 val intarr = intArrayOf(10, 20, 30) 建立double陣列 1 var d1: DoubleArray = doubleArrayOf(1.0, 2.0, 3.0) 指定大小，但值全為0 指定大小，但值為0的 int array，注意！array的內容不是5。 是用大寫開頭的IntArray()建立陣列。 1 2 3 4 val a3: IntArray = IntArray(5) for(i in a3){ println(i) } 0 0 0 0 0 arrayOf 除了用intArrayOf()，也可使用arrayOf()建立Int陣列。 arrayOf 通過&lt;T&gt;泛型，來決定陣列類型。 其中的&lt;Int&gt;不用寫，透過1,2,3的值來自動推導類型 1 var a: Array&lt;Int&gt; = arrayOf&lt;Int&gt;(1,2,3) 改成以下的方式建立Int陣列 1 var a: Array&lt;Int&gt; = arrayOf(1,2,3) 變數的類型可以再省略，透過1,2,3的值來自動推導類型 1 var a = arrayOf(1,2,3) 建立String物件陣列 1 2 3 val arr: Array&lt;String&gt; = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") // 可省略類型，會自動推導。 val arr = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") 二維陣列 1 2 var number2 = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6), arrayOf(7, 8, 9)) println(\"Number:${number2[2][1]}\") Number:8 陣列可以有各種類型 1 2 3 4 5 var number = arrayOf(1, 2, 3, 'Y') number[0] = 'A' // char 類型 println(\"First elements:${number[0]}\") number[0] = \"TEST\" // String 類型 println(\"First elements:${number[0]}\") First elements:A First elements:TEST 建立空的array 以下程式碼編譯錯誤，因為arrayOf沒有設定類型。 1 val names = arrayOf(\"\") // val cannot be reassigned 1 val a2 = arrayOf&lt;Int&gt;() 想不出為什麼可以建立空的array，因為陣列是一個固定大小的陣列，建立空的陣列也沒辦法新增。 陣列相關方法 陣列轉List 1 names.asList() 安全取值 get(索引)可以取得元素的值，但搭配以下二種更安全。 語法 無此元素，就傳回預設值 集合變數.getOrElse(索引) { \"預設值\"} 無此元素傳回null，使用貓王運算子?:，印出預設值 集合變數.getOrNull(索引) ?: \"預設值\" 1 2 3 4 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(names.get(0)) println(names.getOrElse(5) { \"no data\" }) println(names.getOrNull(5) ?: \"no data\") Tom no data no data 索引取值 語法 ${變數[索引]} 1 2 3 4 5 6 7 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"${names[0]}\") println(\"${names[1]}\") println(\"${names[2]}\") // 超出範圍 //println(\"${names[5]}\") // Index 5 out of bounds for length 3 Tom Kevin Lucy 修改 1 2 3 4 5 6 7 8 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") names[0] = \"Julien\" // 原來的tom改成julien println(\"[0]:${names[0]}\") // 印出Julien第二個字母u println(\"[0][1]:${names[0][1]}\") // 印出長度 println(\"Length of Julien:${names[0].length}\") [0]:Julien [0][1]:u Length of Julien:6 first() 取出第一個元素。 1 2 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"first of elements: ${names.first()}\") first of elements: Tom last() 取出最後一個元素。 1 2 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"last of elements:${names.last()}\") last of elements:Lucy size 1 2 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"names elements:${names.size}\") names elements:3 indexOf 搜尋在第幾個索引，找不到傳回-1 1 2 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"search index = ${namelist.indexOf(\"Amy\")}\") search index = 1 contains 1 2 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"array contains = ${names.contains(\"Tom\")}\") array contains = true in 與contains功能一樣，都有包含的意思。 1 2 val names = arrayOf(\"Tom\",\"Kevin\",\"Lucy\") println(\"Tom\" in names) true 遍歷集合 for裡面的i變數，前面不會有val或var，也不會有變數類型，只要記住以下3種for即可。 for 1 2 3 4 val arr = arrayOf(1, 2) for (i in arr) { println(i) } 1 2 foreach 1 2 3 4 val arr = arrayOf(1, 2) arr.forEach { it -&gt; println(it) } 1 2 forEachIndexed 1 2 3 4 5 val arr = arrayOf(1, 2) arr.forEachIndexed { index, i -&gt; println(\"$index $i\") } 0 1 1 2 其它遍歷方式 只要記得上面3種for，下面若仍有腦容量再記住吧。 iterator iterator 通過iterator拿到陣列中每一項。 透過Array中的iterator()拿到 Iterator的介面。 next()取得陣列中的值。 hasNext()是否還有下一個元素讓你拿。 1 2 3 val arr = arrayOf(1, 2) println(arr.iterator().next()) println(arr.iterator().hasNext()) indices indices為index的複數，傳回array的索引值。 1 2 3 4 val arr = arrayOf(1, 2) for (i in arr.indices) { println(i) } 0 1 想拿到index跟valaue 同時想拿到index跟valaue，可以使用withIndex.返回一個對象有index跟value的屬性。 1 2 3 4 val arr = arrayOf(1, 2) for(i in arr.withIndex()) { println(\"index:${i.index}, value:${i.value}\") } index:0, value:1 index:1, value:2 要索引值使用withIndex()方法 1 2 3 4 var names2: List&lt;String&gt; = listOf(\"Tom\", \"Jack\", \"lucy\") for((index,name) in names.withIndex()) { println(\"$index:$name\") } 0:Tom 1:Jack 2:lucy indices會傳回陣列或集合的範圍 1 2 3 4 var names: List&lt;String&gt; = listOf(\"Tom\",\"Jack\",\"lucy\") for(index in names.indices) { println(\"$index: ${names[index]}\") } 0: Tom 1: Jack 2: lucy"
  },"/pages/java/exception/": {
    "title": "Exception",
    "keywords": "",
    "url": "/pages/java/exception/",
    "body": "什麼是例外？ 什麼是例外？不正常的錯誤導致程式執行到一半停止。 以下程式碼會產生計算錯誤，因為不能除0，程式會執行到第7行時就停止，第8行以後都不執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 package exception; public class Test { public static void main(String[] args) { int num1 = 10; int num2 = 0; int result = num1 / num2; if (result &gt; 0) { System.out.println(\"可以除\"); } System.out.println(\"result = \" + result); } } Exception in thread \"main\" java.lang.ArithmeticException: / by zero at exception.Test.main(Test.java:7) java.lang.ArithmeticException: / by zero 告訴你錯誤原因，ArithmeticException是計算錯誤。 at exception.Test.main(Test.java:7) 告訴你程式停止在那一行，之後的程式碼就不執行了。 那要如何才能讓發生錯誤的程式碼，之後的程式碼還可以執行呢？就是要去補捉例外。 例外分類 例外分二類，分別為Error與Exception。 Error是程式設計師無法控制，Exception是程式設計師可以控管。 Error StackOverFlow、Out of memory(OOM)，Stack堆疊或Heap的記憶體被占滿，導致Crash，程序崩潰。 Stack堆疊存放變數與值是基本資料類型(int,char,byte,float,double)。 Heap存放物件，透過new關鍵字建立與物件類型一致的記憶體空間，而Stack中的變數存放的是Heap的物件記憶體位址，圖文內容請見Java Memory Model 程式(Program)是原始碼，程序(Process)是把程式碼載入到記憶體，從執行到執行完畢的一個過程，一個程式可以產生多個程序。 Exception Exception又分為執行時例外(Runtime Exception)與編譯例外。 編譯例外 編譯例外是在寫程式時候，由編譯器檢查出來的錯誤，不是邏輯或語法錯誤，語法錯誤例如變數沒有宣告類型就使用。 語法錯誤 1 str = \"Hello World!\"; 編譯語法 javac 檔名.java 比如IO串流程式碼，強制一定要去try-catch補捉IOException，但卻沒有去補捉，以下編譯器會在FileInputStream會有紅色底線，滑鼠移到上方，會寫Unhandled exception: java.io.FileNotFoundException 1 2 3 4 5 public class Test { public static void main(String[] args) { FileInputStream fileInputStream = new FileInputStream(\"/fdfddffdf/fdfdfd\"); } } 執行時例外 執行時才發現有問題，比如發現檔案不存在，或者執行時才發現變數是null。 執行語法，注意！沒有副檔名。 java 檔名 以下指派一個不存在的檔案路徑。 1 fileInputStream = new FileInputStream(\"/Users/cici/abdcfd\"); str是null，null呼叫length()，產生NullPointException。 1 2 String str = null; System.out.println(\"str len = \" + str.length()); 除0，會產生ArithmeticException: / by zero 1 2 3 int num1 = 10; int num2 = 0; int result = num1 / num2; 繼承架構 Error與Exception的父類別 Object是所有類別的父類別，Throwable是Error與Exception的父類別。 Error的子類別 Error下面有StackOverflowError與OutOfMemoryError，Exception下面有執行時例外RuntimeException。 編譯例外的子類別 下圖看黃色方塊，父類別是Exception，IOException與ReflectiveOperationException是子類別。 ReflectiveOperationException下面又有 ClassNotFoundException NoSuchFieldException NoSuchMethodException 編譯例外主要針對IO串流與類別反射相關，可看IO串流與反射。 重要！!編譯例外的子類別，強制一定要補捉try-catch或拋出例外throws。 IOException的jdk文件: ReflectiveOperationException的jdk文件: 執行時例外的子類別。 RuntimeException，沒有強制一定要補捉try-catch，不然程式碼到處都是try-catch。 RuntimeException的jdk文件: 上圖有畫底線的子類別例外如下: NullPointerException 有null空值 ArithmeticException 計算錯誤 ClassCastException 類別轉型失敗 IndexOutOfBoundsException 超出陣列索引範圍 NoSuchElementException 陣列中元素不存在 IllegalStateException與IllegalArgumentException為Kotlin空值函式的類別 NumberFormatException 無法轉換成數字 處理例外的方式 try-catch 補捉例外，由程式設計師自己處理。 throws 由呼叫這個方法的呼叫者自己處理。 try-catch 補捉例外，如果沒有發生例外，就不會執行catch。 語法 try { 可能會產生錯誤的程式碼 } catch (Exception e) { 1. 印出錯誤訊息 2. throw e 拋出例外 } finally { 不管有沒有例外，都會執行這個程式碼區塊 } 上述語法，第2行產生Exception的物件，會把Exception物件作為參數放在catch (Exception e) try-catch範例 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test4 { public static void main(String[] args) { try { System.out.println(\"start\"); // 1 String str = null; System.out.println(str.length()); } catch (Exception e) { throw new RuntimeException(e); // 2 } finally { System.out.println(\"finally\"); // 3 } } } start null finally 多個catch 可以有多個catch，但只會進到其中一個，且例外類別必須由子類別到父類別。 第一個catch是子類別NullPointerException，第2個catch是父類別Exception 1 2 3 4 5 6 7 8 try { String str = null; System.out.println(str.length()); } catch (NullPointerException e) { System.out.println(\"catch1: \" + e.getMessage()); } catch (Exception e) { System.out.println(\"catch2: \" + e.getMessage()); } catch1: Cannot invoke \"String.length()\" because \"str\" is null finally catch多個補捉例外 要用|分開多個例外，只能使用一個變數e。 1 2 3 4 5 6 FileInputStream fis; try { fis = new FileInputStream(\"/dddd\"); } catch (NullPointerException | IOException e) { e.printStackTrace(); } 有try-catch，就不用throws拋出例外 只能二選一，不能try-catch，又throws。 throws拋出例外 為什麼會有throws拋出例外？代表該方法沒有能力處理例外，所以把例外往呼叫者拋出。 jvm呼叫main()方法，main()方法呼叫func1()，func1()呼叫func2()，func2()拋出例外給呼叫者func1()，func1不try-catch，拋出例外給呼叫者main()，main()也拋出例外，jvm收到例外後，「印出錯誤訊息」然後就「停止程序」。 throws 後面可以是例外的父類別，或是產生例外的類別。 拋出throws FileNotFoundException。 1 2 3 4 5 public class Test2 { public static void main(String[] args) throws FileNotFoundException { FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } 拋出父類別throws IOException 1 2 3 4 5 public class Test2 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } throws拋出多個例外 拋出二個例外，用逗號區隔。 throws IOException, NullPointerException 1 2 3 4 5 public class Test2 { public static void main(String[] args) throws IOException, NullPointerException { FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } 預設throws 若程式都沒有寫try-catch，也沒有寫throws，預設會用throws拋出例外給呼叫者，至於拋出什麼例外，就看程式碼的例外而認定。 如果都沒寫try-catch，也沒有寫throws，預設會用throws。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { String str = null; System.out.println(str.length()); } } 預設拋出NullPointerException。 1 2 3 4 5 6 public class Test { public static void main(String[] args) throws NullPointerException { String str = null; System.out.println(str.length()); } } 預設拋出ArithmeticException。 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) throws ArithmeticException { int num1 = 10; int num2 = 0; int result = num1 / num2; } } 子類別的throws 父類別method1()是拋出throws RuntimeException 1 2 3 4 5 class FatherException { public void method1() throws RuntimeException { } } 子類別method1()也要拋出throws RuntimeException或RuntimeException子類別。 1 2 3 4 5 6 class ChildException extends FatherException{ @Override public void method1() throws NullPointerException { super.method1(); } } 以下是錯誤示範，編譯不過，不能拋出Exception，因為Exception不是RuntimeException的子類別。 1 2 3 4 5 6 class ChildException extends FatherException{ @Override public void method1() throws Exception { super.method1(); } } 方法的throws IOException是屬於編譯例外，所以強制一定要處理例外，如果是RuntimeException就不用處理拋出例外，預設有throws會處理(前面有提到預設throws)。 以下程式碼會編譯錯誤，因為func1()沒有處理func2()拋出的IOException。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test2 { public static void main(String[] args) { func1(); } public static void func1() { func2(); } public static void func2() throws IOException{ FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } 如何處理？以下二擇一，try-catch或throws相同例外或throws 父類別例外。 func1() throws IOException，main() throws Exception。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test2 { public static void main(String[] args) throws Exception { func1(); } public static void func1() throws IOException{ func2(); } public static void func2() throws IOException{ FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } try-catch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) { func1(); } public static void func1() { try { func2(); } catch (IOException e) { e.printStackTrace(); } } public static void func2() throws IOException { FileInputStream fis = new FileInputStream(\"/Users/cici/abdfdfd\"); } } throw 後面沒有s，是在方法「中」，throw拋出例外。 而throws是在定義方法()後面，throws拋出例外。 語法 throw new 例外類別(\"錯誤訊息\"); 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { String str = null; System.out.println(str.length()); if (str == null) throw new NullPointerException(\"error msg = null\"); } } Exception in thread \"main\" java.lang.NullPointerException: error msg = null at exception.Test.main(Test.java:8) 拋出 放在那裡？ 後面是什麼 範例 throws 方法定義 throws 類別 public void func2() throws IOException throw 方法中 throw new 物件(錯誤訊息) throw new NullPointerException(\"錯誤\") finally 不管有沒有例外，都要執行，常用在關閉串流，資源(檔案打開與關閉、資料庫連線、網路連線)釋放與關閉。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test4 { public static void main(String[] args) { try { System.out.println(\"start\"); // 1 String str = null; // 產生例外物件，傳入catch() System.out.println(str.length()); } catch (Exception e) { // 最終由Throwable父類別印出錯誤 throw new RuntimeException(e); // 2 } finally { System.out.println(\"finally\"); // 3 } } } start null finally try…finally 這個語法沒有補捉例外，一樣會crash，主要意義在於，不管執行過程有沒有例外，在程序crash前，一定要執行finally{}程式區塊。 可能用於寫Log或關閉釋放資源，什麼是資源？例如:打開檔案，讀取裡面的內容，檔案就是資源。DB資料庫連線，離開程序，要關閉DB資料庫連線，DB資料庫就是資源。網路連線，網路中斷，網路就是資源。 1 2 3 4 5 6 try { String str = null; System.out.println(str.length()); } finally { System.out.println(\"程序crash前先印出這段話。\"); } 程序crash前先印出這段話。 Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.length()\" because \"str\" is null at exception.Test4.main(Test4.java:11) finally執行順序 若throw、return在try{ … } 中，finally執行順序優先throw、return finally會先執行完，才執行throw、return 以下程式碼執行結果是什麼？程式碼中已經有寫執行順序。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Test3 { public static void main(String[] args) { try { func1(); } catch (Exception e) { System.out.println(e.getMessage()); // 4 } func2(); // 5 } public static void func1() { try { System.out.println(\"func1\"); // 1 throw new NullPointerException(\"null ptr error\"); // 3 } finally { System.out.println(\"func1 finally\"); // 2 } } public static void func2() { try { System.out.println(\"func2\"); // 6 return; // 8 } finally { System.out.println(\"func2 finally\"); // 7 } } } func1 func1 finally null ptr error func2 func2 finally 自訂例外 可以繼承Exception與RuntimeException。 建議繼承RuntimeException，因為不會強制一定要處理例外。 例外原始碼 以下語法會呼叫一個參數(message)建構子 1 new MyNullException(\"錯誤訊息\") 呼叫父類別一個參數(message)建構子 1 2 3 4 5 6 class MyNullException extends RuntimeException { public MyNullException(String message) { // 呼叫父類別一個參數(message)建構子 super(message); } } 最終由Throwable父類別的建構子處理message 1 2 3 4 5 public Throwable(String message) { fillInStackTrace(); // 由detailMessage變數處理message detailMessage = message; } 繼承RuntimeException main()方法不用throws Exception，會用預設的throws。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package exception; public class Test { public static void main(String[] args) { String str = null; if (str == null) throw new MyNullException(\"自訂NullException\"); } } class MyNullException extends RuntimeException { public MyNullException(String message) { super(message); } } Exception in thread \"main\" exception.MyNullException: 自訂NullException at exception.Test.main(Test.java:7) 繼承Exception 繼承Exception，強制要處理例外，方式為補捉try-catch，或者throws Exception。 main()方法要throws Exception，不然會產生編譯例外(如以下文字)，無法編譯。 Unhandled exception: exception.MyNullException 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package exception; public class Test { public static void main(String[] args) throws Exception { String str = null; if (str == null) throw new MyNullException(\"自訂NullException\"); } } class MyNullException extends Exception { public MyNullException(String message) { super(message); } } Exception in thread \"main\" exception.MyNullException: 自訂NullException at exception.Test.main(Test.java:7)"
  },"/pages/kotlin/exception/": {
    "title": "Exception",
    "keywords": "",
    "url": "/pages/kotlin/exception/",
    "body": "Prerequisites: Java 例外 try catch 1 2 3 4 5 6 var str: String? = null try { println(str!!.length) } catch (e: KotlinNullPointerException) { e.printStackTrace() } Exception in thread \"main\" java.lang.NullPointerException at LearnNullKt.testNull(LearnNull.kt:53) at LearnNullKt.main(LearnNull.kt:62) at LearnNullKt.main(LearnNull.kt) 自訂例外 Prerequisites: Java 自訂例外 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyNullException : RuntimeException(\"空值\") fun checkNull(str: String?) { str ?: throw MyNullException() } fun main() { var str: String? = null try { checkNull(str) } catch (e: Exception) { println(e) } } MyNullException: 空值 precondition functions 以下是kotlin提供的檢查值為null或值為false，所拋出的異常。 函式 檢查項目 Exception thrown checkNotNull null IllegalStateException require false IllegalArgumentException requireNotNull null IllegalStateException error null IllegalStateException assert false AssertError 1 2 3 4 5 6 var str: String? = null try { checkNotNull(str) {\"空值\"} } catch (e: Exception) { println(e) } java.lang.IllegalStateException: 空值"
  },"/pages/kotlin/list/": {
    "title": "List與MutableList",
    "keywords": "",
    "url": "/pages/kotlin/list/",
    "body": "唯讀List 語法 val 變數: List&lt;類型&gt; = listOf(物件, 物件, 物件..) 只能讀取，不能修改。 1 2 3 4 val names: List&lt;String&gt; = listOf(\"Tom\",\"Jack\",\"lucy\") for (name in names) { println(name) } Tom Jack lucy 建立可讀寫MutableList 建立MutableList 1 val mutableList = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\") 建立空的MutableList 1 val mutableList:MutableList&lt;Int&gt; = mutableListOf() MutableList新增刪除修改 新增 1 2 3 mutableList.add(\"Ray\") // 指定插入的索引位置 mutableList.add(1,\"Tina\") 刪除 1 2 3 mutableList.remove(\"Alice\") // 指定刪除索引位置 mutableList.removeAt(0) 刪除前判斷有存在才刪。 1 2 3 val mutableList = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\") mutableList.removeIf{it.contains(\"Alice\") } println(mutableList) [Bill, Gina] 清空 1 2 mutableList.clear() println(mutableList) [] 安全取值 get(索引)可以取得元素的值，但搭配以下二種更安全。 語法 無此元素，就傳回預設值 集合變數.getOrElse(索引) { \"預設值\"} 無此元素傳回null，使用貓王運算子?:，印出預設值 集合變數s.getOrNull(索引) ?: \"預設值\" 1 2 3 4 5 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"======== list data ============\") println(namelist.get(0)) println(namelist.getOrElse(5) { \"no data\"}) println(namelist.getOrNull(5) ?: \"no data\") Mary no data no data 索引取值 語法 ${變數[索引]} 1 2 3 4 5 6 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"list[0] = ${namelist[0]}\") println(\"list[1] = ${namelist[1]}\") println(\"list[2] = ${namelist[2]}\") println(\"list first = ${namelist.first()}\") println(\"list last = ${namelist.last()}\") list[0] = Mary list[1] = Amy list[2] = Jery 修改集合 1 2 3 val mutableList = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\") mutableList[0] = \"Gee\" println(mutableList[0]) Gee mutator 能用在MutableList，Array無法使用。 語法 += 新增元素 -= 刪除元素 新增 1 2 3 4 val mutableList = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\") mutableList += \"Momo\" mutableList += \"Yoyo\" println(mutableList) [Alice, Bill, Gina, Momo, Yoyo] 刪除 1 2 3 4 5 6 7 val mutableList = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\") mutableList += \"Momo\" mutableList += \"Yoyo\" println(mutableList) mutableList -= \"Momo\" mutableList -= \"Yoyo\" println(mutableList) [Alice, Bill, Gina] List與MutableList互轉 List轉MutableList 1 2 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") namelist.toMutableList() MutableList轉List 1 mutableList.toList() first() 取出第一個元素。 1 println(\"list first = ${namelist.first()}\") list first = Mary last() 取出最後一個元素。 1 println(\"list last = ${namelist.last()}\") list last = Jery size 1 2 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"list size = ${namelist.size}\") list size = 3 contains 1 2 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"list contains = ${namelist.contains(\"Amy\")}\") list contains = true in 與contains功能一樣，都有包含的意思。 1 2 val namelist = listOf&lt;String&gt;(\"Mary\", \"Amy\", \"Jery\") println(\"Mary\" in namelist) true empty 1 2 3 4 5 val mutableList:MutableList&lt;Int&gt; = mutableListOf() if (mutableList.isEmpty()) println(\"empty\") if (mutableList.isNotEmpty()) println(\"not empty\") empty distinct()去掉重覆 1 2 3 4 val mutableList1 = mutableListOf&lt;String&gt;(\"Alice\", \"Bill\", \"Gina\", \"Alice\") println(mutableList1) val distinctList = mutableList1.distinct() println(distinctList) [Alice, Bill, Gina, Alice] [Alice, Bill, Gina] 遍歷集合 for裡面的i變數，前面不會有val或var，也不會有變數類型。 內容請見陣列中的遍歷集合。"
  },"/pages/kotlin/map/": {
    "title": "Map,MutableMap",
    "keywords": "",
    "url": "/pages/kotlin/map/",
    "body": "to函式 to區分key與value。 以下是to函式原始碼，傳回值是一個Pair的類別。 1 public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) 也就是說，以下是在呼叫to的函式，傳回Pair，Pair再放入Map中，Map裡存放的都是Pair。 1 \"Alice\" to 18 Pair 可透過first與second取值 1 2 val pair = Pair&lt;String, Int&gt;(\"Alex\", 12) println(\"first = ${pair.first} second = ${pair.second}\") first = Alex second = 12 唯讀Map 以下key是姓名與value是年齡。 1 2 3 4 5 6 val map1 = mapOf( \"Alice\" to 18, \"Alex\" to 20, \"Momo\" to 5, \"Yoyo\" to 8 ) 使用Pair，以下等同上面。 1 2 3 4 5 6 val map3 = mapOf( Pair(\"Alice\", 18), Pair(\"Alex\", 20), Pair(\"Momo\", 5), Pair(\"Yoyo\", 8) ) 可讀寫MutableMap 1 2 3 4 5 6 val mutableMap = mutableMapOf( \"Alice\" to 18, \"Alex\" to 20, \"Momo\" to 5, \"Yoyo\" to 8 ) 讀取 [key] 沒有鍵\\/值，系統就會傳回null。 get(key) 沒有鍵\\/值，系統就會傳回null。 getOrDefault(“Momo”, 0) 沒有鍵\\/值就傳回預設值。 getOrElse(“Yoyo”) {0} 沒有鍵\\/值就傳回預設值。 1 2 3 4 5 6 7 8 val mutableMap = mutableMapOf( \"Alice\" to 18, \"Alex\" to 20, ) println(\"Alice age = ${mutableMap[\"Alice\"]}\") println(\"Alex age = ${mutableMap.get(\"Alex\")}\") println(\"Momo age = ${mutableMap.getOrDefault(\"Momo\", 0)}\") println(\"Yoyo age = ${mutableMap.getOrElse(\"Yoyo\") {0}}\") Alice age = 18 Alex age = 20 Momo age = 0 Yoyo age = 0 遍歷 1 2 3 4 5 6 7 8 9 val mutableMap = mutableMapOf( \"Alice\" to 18, \"Alex\" to 20, \"Momo\" to 5, \"Yoyo\" to 8 ) mutableMap.forEach{ println(\"key = ${it.key} , value = ${it.value}\") } key = Alice , value = 18 key = Alex , value = 20 key = Momo , value = 5 key = Yoyo , value = 8 1 2 3 mutableMap.forEach { key, value -&gt; println(\"key = $key , value = $value\") } 新增 1 2 3 4 5 6 7 8 9 val mutableMap = mutableMapOf( \"Alice\" to 18, \"Alex\" to 20, \"Momo\" to 5, \"Yoyo\" to 8 ) mutableMap += \"Bob\" to 10 mutableMap.put(\"Ray\", 25) println(mutableMap) {Alice=18, Alex=20, Momo=5, Yoyo=8, Bob=10, Ray=25} 沒有這個key，才新增，執行結果發現Momo仍是5歲，不是12歲。 1 2 mutableMap.getOrPut(\"Elsa\") { 12 } mutableMap.getOrPut(\"Momo\") { 12 } {Alice=18, Alex=20, Momo=5, Yoyo=8, Bob=10, Ray=25, Elsa=12} 修改 1 2 mutableMap[key] = value mutableMap[\"Momo\"] = 10 刪除 1 2 mutableMap.remove(key) mutableMap.remove(\"Momo\")"
  },"/pages/kotlin/set/": {
    "title": "Set",
    "keywords": "",
    "url": "/pages/kotlin/set/",
    "body": "Set沒有順序，不允許重複值的集合。 唯讀Set 1 2 val set1: Set&lt;String&gt; = setOf(\"Mary\", \"Mary\", \"Mary\", \"Alice\") println(set1) [Mary, Alice] 可讀寫MutableSet 1 val mutableSet1: MutableSet&lt;String&gt; = mutableSetOf(\"Mary\", \"Bill\", \"Jery\") 取得元素 1 2 3 println(set1.elementAt(0)) println(set1.elementAtOrElse(5) { \"no data\" }) println(set1.elementAtOrNull(5) ?: \"no data\") Mary no data no data 新增刪除 Set沒有順序，因此沒辦法用索引進行修改。 新增 1 2 3 4 val mutableSet1: MutableSet&lt;String&gt; = mutableSetOf(\"Mary\", \"Bill\", \"Jery\") mutableSet1.add(\"May\") mutableSet1 += \"Gigi\" println(mutableSet1) 刪除 1 2 3 mutableSet1.remove(\"Bill\") mutableSet1 -= \"Mary\" println(mutableSet1) list轉成set去掉重覆元素 1 2 3 4 val list1 = listOf(\"Alice\", \"Alice\", \"Alice\",\"Mary\") .toSet() .toList() println(\"list1 = $list1\") list1 = [Alice, Mary] distinct也有同樣效果。 1 2 3 val list2 = listOf(\"Alice\", \"Alice\", \"Alice\",\"Mary\") .distinct() println(\"list2 = $list2\") list2 = [Alice, Mary]"
  },"/pages/kotlin/string/": {
    "title": "String函式",
    "keywords": "",
    "url": "/pages/kotlin/string/",
    "body": "字串 1 2 3 4 5 6 7 8 9 10 11 12 fun main() { var str = \"Hello World\" println(\"字元個數 = ${str.count()}\") println(\"字串長度 = ${str.length}\") println(\"大寫 = ${str.uppercase()}\") println(\"小寫 = ${str.lowercase()}\") println(\"第一個字大寫 = ${str.capitalize()}\") // 注意！replace不會修改原來的值 // str.replace(\"o\",\"c\") // 原來的變數去接收replace()函式的結果 str = str.replace(\"o\", \"C\") println(\"把o取代成C = $str\") 字元個數 = 11 字串長度 = 11 大寫 = HELLO WORLD 小寫 = hello world 把o取代成C = Hello World 判斷字串是否為空 1 2 var s1 = \"871\" println(s1.isNotBlank()) 1 2 3 4 5 6 7 8 var s1 = \"871\" println(s1.toSortedSet())//對字串排序 //[1, 7, 8] var s2 = \"871aka\" println(s2.toSortedSet()) //[1, 7, 8, a, k] //排序後剩下一個a，因為是set 可以透過get與[]拿字串中的字母 1 2 3 4 5 6 var s = \"asd\" println(s.get(2)) //d println(s[2]) //d 字串與數字連接 1 2 3 4 5 6 7 val b = 1 //可直接連接數字，變成字串 val s3 = \"876\"+ 1 +\"aka\" println(s3) //8761aka //但改用$字號連接字串 val s4 = \"876${b}aka\"//要相連一起要使用花括號才不會把aka也視為變數的其中之一 //預設會把$符號後面字母設為一個變數"
  },"/pages/note/mental/": {
    "title": "療癒心理",
    "keywords": "",
    "url": "/pages/note/mental/",
    "body": "他人即地獄 被人觀察時就表現的很差，不被人觀察時就表現的很好。 他人的目光會影嚮自已。 不要在乎他人評價你的作品，迎合別人喜好而做出來的作品，不會是作品。 好的作品就是不要再乎他人喜好。 創意是不迎合他人。 烏合之眾 當眾人的技術與知識沒有提升，聚在一起做事，做出來的成品不會比一個有技術有知識的人做的好。"
  },"/pages/kotlin/constructor/": {
    "title": "建構式",
    "keywords": "",
    "url": "/pages/kotlin/constructor/",
    "body": "建構式跟Java建構子一樣，主要是用來建立物件。 建構式分為主要建構式(Primary constructor)與次要建構式(Secondary constructor)。 預設主要建構式 constructor()為主要建構式，與「class 類別名」同一行，放在「類別名」後面，預設建構式沒有參數。 語法 class 類別名 constructor() { } 1 2 3 class Dog constructor() { } Kotlin目的在簡化程式碼，若建構式沒有參數，也沒有權限修飾子，可以省略constructor()，Kotlin會自動產生預設建構式。 1 2 3 class Dog { } 若有參數，可以省略constructor的文字，只留下圓括號(參數)，代表它是主要建構式。 class 類別名 (參數) { } 主要建構式 之前在屬性的文章中提到，val唯讀屬性，不會有set()方法。 可由主要建構式設定val屬性的值，在類別中也不用再次定義val屬性。 語法，參數可以為var或val，沒有限定只能val。 class 類別名 (val 屬性: 類型, var 屬性: 類型, ...) { // 省略類別屬性，移到主要建構式 } 原本程式碼 1 2 3 4 class Cat { // 類別屬性 val name = \"\" } 改為主要建構式，注意！可以不用給初始值，但一定要有類型。 不給類型會有這個編譯錯誤，A type annotation is required on a value parameter。 這一部分跟Java final 建構子初始值的內容一樣。 1 2 3 4 // 屬性要有類型 class Cat (val name: String) { } 由「主要建構式」建立物件。 1 2 3 4 fun main() { val cat = Cat(\"小咪\") println(cat.name) } 小咪 主要建構式自動產生set()、get() 搭配val與var，會自動產生set()、get()，注意！val不會自動產生set()方法。 因為val是唯讀，不能修改。 Java原始碼，因為val name唯讀，所以只有getName()，沒有setName()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public final class Cat { @NotNull private final String name; @NotNull public final String getName() { return this.name; } public Cat(@NotNull String name) { Intrinsics.checkNotNullParameter(name, \"name\"); super(); this.name = name; } } 主要建構式 + 所有屬性預設值 每一個屬性都有預設值，建立物件時，只要代入屬性名 = 值，就可以設定屬性的值。 1 2 3 4 5 6 7 8 9 10 11 12 class Cat( val name: String = \"\", var age: Int = 0, var color: String = \"\" ) { } fun main() { // 主要建構式 屬性名 = 值 val cat = Cat(name = \"小咪\") println(cat.name) } 小咪 次要建構式 次要建構式使用方式 次要建構式參數數量，不能跟主要建構式參數數量一樣。 次要建構式無法使用val與var，不會自動產生set()、get()。 因為無法使用val與var，所以會由以下三種方式搭配次要建構式。 主要建構式 + 初始化所有屬性 + 次要建構式。 類別屬性 + 次要建構式 class 類別名 { // 類別屬性 var 屬性名: 屬性類型 = 初始值 val 屬性名: 屬性類型 = 初始值 } 主要建構式屬性 + 類別屬性 + 次要建構式 Kotlin 的設計原則是：「能用簡單寫法就不要複雜化」！ 類別屬性 + 次要建構式 次要建構式無法修改val的屬性。 若要透過次要建構式修改屬性，請設為var。 注意！次要建構式沒有val與var。 次要建構式由constructor(屬性:類型)，注意！屬性一定要有類型。 語法: class 類別名 { // 類別屬性 var 屬性1: 類型 = 初始值 var 屬性2: 類型 = 初始值 // 次要建構式 constructor(屬性1: 類型, 屬性2: 類型) { this.屬性1 = 屬性1 this.屬性2 = 屬性2 } } 範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 class Cat1 { // 類別屬性 var name: String = \"\" var age = 0 var color = \"\" // 次要建構式 constructor(name: String, age: Int) { this.name = name this.age = age } } 測試如下: 1 2 3 4 5 fun main() { val cat1 = Cat1(\"小咪\", 10) println(cat1.name) println(cat1.age) } 小咪 10 主要建構式屬性 + 類別屬性 + 次要建構式 主要建構式中的屬性可為val。 次要建構式無法修改val的屬性。 次要建構式後面就要加上 : this(屬性)，先呼叫主要建構式。 this(屬性)後面不用有類型。 範例: 1 2 3 4 5 6 7 8 9 10 11 12 13 // 主要建構式屬性 class Cat2(val name: String) { // 類別屬性 var age = 0 var color = \"\" // 次要建構式 constructor(name: String, age: Int) : this(name) { // name是val，不能透過次要建構式修改 // 注意！此處沒有this.name = name this.age = age } } 測試: 1 2 3 val cat2 = Cat2(\"喵喵\", 2) println(cat2.name) println(cat2.age) 喵喵 2 主要建構式 + 初始化所有屬性 + 次要建構式 1 2 3 4 5 6 7 8 9 10 11 // 主要建構式 + 初始化所有屬性 class Cat3( val name: String = \"\", var age: Int = 0, var color: String = \"\" ) { // 次要建構式 constructor(name: String, age: Int) : this(name) { this.age = age } } 測試 1 2 3 val cat3 = Cat3(\"嘟嘟\", 10) println(cat3.name) println(cat3.age) 嘟嘟 10 init初始化函式 Java匿名程式碼區塊 這部分的知識跟Java匿名程式碼區塊很像，但執行順序不同，Java是先執行程式碼區塊，再執行建構子。 Kotlin是先執行主要建構式 -&gt; 類別屬性 -&gt; init初始化函式 -&gt; 次要建構式。 以下這行不能編譯成功，Property must be initialized or be abstract 屬性必須要初始化。 1 2 3 class Dog { val name: String } 使用init初始化函式，類別中的屬性可以不用給初始值，由init函式初始化屬性。 這一部分跟Java final 匿名區塊初始化的內容一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Dog1 { val name: String init { // 由init函式初始化屬性 name = \"小白\" loadDB() } fun loadDB() { println(\"DB loading\") println(\"name = $name\") } } fun main() { val dog1 = Dog1() } DB loading name = 小白 主要建構式不用有val或var 主要建構式可以不用有val或var，沒有val與var的參數就不是類別屬性，會使用_底線在參數前面，代表只使用一次。 1 2 3 4 5 6 7 8 9 class Cat4 (_name: String, _age: Int) { var name:String = _name var age:Int = _age } fun main() { val cat4 = Cat4(\"喵喵\", 2) println(cat4.name) println(cat4.age) } 喵喵 2 可以與init搭配 1 2 3 4 5 6 7 8 9 10 11 12 13 class Cat4 (_name: String, _age: Int) { var name:String = \"\" var age:Int = 0 init { name = _name age = _age } } fun main() { val cat4 = Cat4(\"喵喵\", 2) println(cat4.name) println(cat4.age) | 喵喵 2 程式碼執行順序 主要建構式 類別屬性 init初始化函式 次要建構式 使用Decompile證明執行順序 Kotlin程式碼 1 2 3 4 5 6 7 8 9 10 11 12 class Cat4 (val name: String, _age: Int) { // 1. name private var age:Int = _age //2. private val hobby:String private var sleeptimes: Int = 0 init { println(\"init block ...\") // 3. hobby = \"swimming\" // 4. } constructor(name: String, _age: Int, sleeptimes: Int):this(name, _age) { this.sleeptimes = sleeptimes // 5. } } Java程式碼，以下已把建構子中的順序與Kotlin對映。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public final class Cat4 { private int age; private final String hobby; private int sleeptimes; @NotNull private final String name; @NotNull public final String getName() { return this.name; } public Cat4(@NotNull String name, int _age) { Intrinsics.checkNotNullParameter(name, \"name\"); super(); this.name = name; // 1. this.age = _age; // 2. String var3 = \"init block ...\"; // 3. System.out.println(var3); // 3. this.hobby = \"swimming\"; // 4. } public Cat4(@NotNull String name, int _age, int sleeptimes) { Intrinsics.checkNotNullParameter(name, \"name\"); this(name, _age); // 先呼叫2個參數的父類建構子 this.sleeptimes = sleeptimes; //5. } 屬性不能寫在後面 你不能像C++把屬性寫到最後面，會無法讀取到屬性，Kotlin執行順序是由上而下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Dog1 { init { loadDB() } fun loadDB() { println(\"DB loading\") // 無法讀取到屬性 println(\"name = $name\") } // 屬性寫到最後面 val name: String = \"小白\" } DB loading name = null"
  },"/pages/kotlin/field/": {
    "title": "set get",
    "keywords": "",
    "url": "/pages/kotlin/field/",
    "body": "屬性位置 屬性是放在類別中。 class 類別名 { var 屬性名: 屬性類型 = 初始值 val 屬性名: 屬性類型 = 初始值 // 屬性是空值類型，可指派空值，空值類型是var，因為要修改null值 var 屬性名: 屬性類型? = null } field get() set(value) Kotlin會自動為屬性產生field, get(), set(value)方法。 1 var name = \"Alex\" 預設會自動變成下面的程式碼。 1 2 3 4 5 var name = \"Alex\" get() = field set(value) { field = value } field field儲存屬性值在記憶體中，如果要使用get()讀取屬性值，或用set()更新屬性值，需要使用field來讀取或更新，field只能在get()方法跟set()方法使用。 為什麼要使用field？因為Java都要自己寫set(), get(), this.屬性 = 參數，this用的太多，簡化成用field省略大量程式碼。 覆寫get()方法 get()是讀取屬性，先前的內容說明get()會自動產生，但也可以自己覆寫。 覆寫get()方法，field代表name，把name轉成全大寫。 覆寫語法1 var 變數: 類型 = 初始值 get() { // 要記得加上return return 回傳值 } 1 2 3 4 5 6 class Student { var name: String? = null get() { return field?.uppercase() } } 覆寫語法2 var 變數: 類型 = 初始值 get() = field 1 2 3 4 class Student { var name: String? = null get() = field?.uppercase() } 覆寫set(value)方法 set(value)，是更新屬性，先前的內容說明set()會自動產生，但也可以自己覆寫。 語法，value為傳進來的參數。 var 變數: 類型 = 初始值 set(value) { field = value } trim()去掉前後空白，再把value指派到field，field代表name屬性。 1 2 3 4 5 6 7 class Student { var name: String? = null get() = field?.uppercase() set(value) { field = value?.trim() } } var與val var才能修改屬性，才會有set()更新方法。 val只能讀取，不能修改，不會有set()更新方法，只有get()讀取。 set(value)只能用field set(value)方法中，不能用屬性名稱。 value參數指派給屬性名(例如name)，程式碼就會進入無限迴圈。 1 2 3 4 5 6 7 8 class Student { var name: String? = null get() = field?.uppercase() set(value) { // 不能這樣寫，不能把value指派給屬性名 name = value?.trim() } } 覆寫可單獨只寫set()或get() 不用同時覆寫set()與get() 以下只覆寫set() 1 2 3 4 5 6 class Student { var name: String? = null set(value) { field = value?.trim() } } 測試 1 2 3 4 5 6 7 8 9 10 11 12 class Student { var name: String? = null get() = field?.uppercase() set(value) { field = value?.trim() } } fun main() { var student = Student() student.name = \" Bill \" println(student.name) } BILL 不使用field覆寫get() 建立一個randomId屬性，每次都取得不同的值，不使用field，也是可以覆寫get() 1 2 3 4 5 6 7 8 class Student { val randomId get() = (1 .. 100).shuffled().first() // 取出亂數 } fun main() { var student = Student() println(student.randomId) } 22 set()作為檢查的機制 指派給 speakerVolume 屬性的值介於 0 到 100 之間。 可以在 set() 函式中使用 in 關鍵字，並在後面加上值的範圍，以檢查 Int 值是否介於 0 到 100 的範圍內。如果該值在預期範圍內，系統會更新 field 值，否則屬性的值維持不變。 1 2 3 4 5 6 var speakerVolume = 2 set(value) { if (value in 0..100) { field = value } } 存取權限 若set前面加上private，代表不允許其它地方設值，只有本身的類別可以設值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Cat4 (_name: String, _age: Int) { var name:String = \"\" private set(value) { field = value } var age:Int = 0 init { name = _name age = _age } } fun main() { val cat4 = Cat4(\"喵喵\", 2) println(cat4.name) println(cat4.age) // 以下會編譯失敗 cat4.name = \"Momo\" } Java原始碼 var非空值屬性 Student類別中有一個var屬性。 1 2 3 class Student { var name = \"Alice\" } NotNull與checkNotNullParameter() 看產生的java檔，Decompile轉成Java檔 可以發現自動產生getName()、setName()，\\@NotNull是kotlin的Annotation，目的是檢查屬性、傳回值、參數是否為null，Annotation的作用在於檢查，發現是null，產生編譯例外。 checkNotNullParameter()方法是檢查是否為空值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public final class Student { @NotNull private String name = \"Alice\"; @NotNull public final String getName() { return this.name; } public final void setName(@NotNull String var1) { // checkNotNullParameter() Intrinsics.checkNotNullParameter(var1, \"&lt;set-?&gt;\"); this.name = var1; } } 修改屬性為Bill 1 2 3 4 5 6 7 class Student { var name = \"Alice\" } fun main() { var student = Student() student.name = \"Bill\" } Java程式檔，發現已經自動產生setName(\"Bill\") 1 2 3 4 5 public final class ClassTestKt { public static final void main() { Student student = new Student(); student.setName(\"Bill\"); } 屬性為空值類型 把name屬性改成空值類型。 1 2 3 4 5 6 7 class Student { var name: String? = null } fun main() { var student = Student() student.name = \"Bill\" } Nullable 與 checkNotNullParameter() Java程式碼，\\@Nullable代表可為空值。 1 2 3 4 5 6 7 8 9 10 11 12 13 public final class Student { @Nullable private String name; @Nullable public final String getName() { return this.name; } public final void setName(@Nullable String var1) { this.name = var1; } } 可為空值類型，產生出來的Java檔，就沒有checkNotNullParameter()方法。 1 2 3 4 public static final void main() { Student student = new Student(); student.setName(\"Bill\"); }"
  },"/pages/kotlin/intellij/": {
    "title": "Intellj快速鍵",
    "keywords": "",
    "url": "/pages/kotlin/intellij/",
    "body": "Decompile轉碼後的java 按2次shift鍵，輸入show kotlin bytecode 按下「Decompile」按鈕，可以看到轉碼過後的java程式碼。 全部快速鍵 win: ctrl + j mac: cmd + j 變數.屬性.sout s1.length.sout 1 2 var s1 = \"871\" // 輸入s1.length.sout 產生println(s1.length) 1 2 var s1 = \"871\" println(s1.length) 集合變數.for IntelliJ快速鍵: I IntelliJ快速鍵: 集合變數.for 1 2 3 4 5 var s = \"asd\" // s.for，就會有迴圈的指令 for (c in s) { println(c) } iterator迴圈 itit try-catch 先「選取」可能會發生錯誤的程式碼。 按下快速鍵 Win: ctrl + alt + t Mac: cmd + alt + t 選取你要的try…catch，我都是選6。 建立module sdk 設定 快速進入類別 對著類別名，按下快速鍵。 Win: ctrl + b Mac: cmd + b Structure"
  },"/pages/java/obj_layout_core/": {
    "title": "Java Object Layout",
    "keywords": "",
    "url": "/pages/java/obj_layout_core/",
    "body": "以下步驟是查看物件佔用記憶體大小(byte)。 下載jol-core.jar，點擊下圖方框的部分。 加入jol-core.jar 包裝類別的佔用記憶體大小 1 2 3 4 5 6 7 8 9 10 11 12 import org.openjdk.jol.info.ClassLayout; public class Test { public static void main(String[] args) { System.out.println(ClassLayout.parseInstance((byte)1).toPrintable()); // Byte System.out.println(ClassLayout.parseInstance('a').toPrintable()); // Character System.out.println(ClassLayout.parseInstance(1).toPrintable()); // Integer System.out.println(ClassLayout.parseInstance(1L).toPrintable()); // Long System.out.println(ClassLayout.parseInstance(1.0f).toPrintable()); // Float System.out.println(ClassLayout.parseInstance(1.0).toPrintable()); // Double } } =============Boolean=================== java.lang.Boolean object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00006390 12 1 boolean Boolean.value true 13 3 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external = 3 bytes total =============Character=================== java.lang.Character object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000002d6b418f01 (hash: 0x2d6b418f; age: 0) 8 4 (object header: class) 0x00023288 12 2 char Character.value a 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total =============Byte=================== java.lang.Byte object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x00000033affdfa01 (hash: 0x33affdfa; age: 0) 8 4 (object header: class) 0x00033da8 12 1 byte Byte.value 1 13 3 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 3 bytes external = 3 bytes total =============short=================== java.lang.Short object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000007413b5b301 (hash: 0x7413b5b3; age: 0) 8 4 (object header: class) 0x00035c40 12 2 short Short.value 1 14 2 (object alignment gap) Instance size: 16 bytes Space losses: 0 bytes internal + 2 bytes external = 2 bytes total =============Integer=================== java.lang.Integer object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x00000063c12bbe01 (hash: 0x63c12bbe; age: 0) 8 4 (object header: class) 0x00026830 12 4 int Integer.value 1 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total =============Long=================== java.lang.Long object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000001d9ff05801 (hash: 0x1d9ff058; age: 0) 8 4 (object header: class) 0x00037950 12 4 (alignment/padding gap) 16 8 long Long.value 1 Instance size: 24 bytes Space losses: 4 bytes internal + 0 bytes external = 4 bytes total =============Float=================== java.lang.Float object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00031228 12 4 float Float.value 1.0 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total =============Double=================== java.lang.Double object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x00032820 12 4 (alignment/padding gap) 16 8 double Double.value 1.0 Instance size: 24 bytes Space losses: 4 bytes internal + 0 bytes external = 4 bytes total"
  },"/pages/java/compare/": {
    "title": "Comparable與Comparator",
    "keywords": "",
    "url": "/pages/java/compare/",
    "body": "Prerequisites: 介面 泛型 泛型介面 傳回值 Comparable, Comparator都是比較介面，傳回值固定0、正數、負數。 0代表等於。 Comparable介面 Comparable是一個介面，有一個compareTo()方法，功用是比較大小。 Comparable介面原始檔 1 2 3 public interface Comparable&lt;T&gt; { public int compareTo(T o); } 使用方法 在泛型介面的文章中，有提到實作泛型介面時要指定泛型類型，以下程式碼指定的泛型類型為MyDate，Intellij實作介面時會把MyDate的類型替代原本的T。 1 2 3 4 5 6 class MyDate implements Comparable&lt;MyDate&gt; { @Override public int compareTo(MyDate o) { return 0; } } compareTo(MyDate)參數 每一個方法都有隱藏參數this，this就是自己本身物件，而MyDate參數，是外部傳來要比較的物件，不是自己本身。 比較 比較的方法內容自己寫。 比較方法: 自己(this)比參數大，傳正數。 自己(this)比參數小，傳負數。 二者相等傳0。 以下是使用相減作為比較結果，注意，如果是用o.year - this.year，這樣結果就不會符合比較方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MyDate implements Comparable&lt;MyDate&gt; { private int year; private int mon; private int date; public MyDate(int year, int mon, int date) { this.year = year; this.mon = mon; this.date = date; } @Override public int compareTo(MyDate o) { int diff_y = this.year - o.year; // 不相等代表比較出結果，直接傳回比較結果 // 之後的程式就沒必要再比較。 if (diff_y != 0) { return diff_y; } int diff_m = this.mon - o.mon; if (diff_m != 0) { return diff_m; } int diff_date = this.date - o.date; if (diff_date != 0) { return diff_date; } return 0; } } 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test { public static void main(String[] args) { MyDate myDate = new MyDate(2000, 11, 11); MyDate anotherDate = new MyDate(2000, 11, 5); int res = myDate.compareTo(anotherDate); System.out.println(res); System.out.println(\"==========\"); myDate = new MyDate(2000, 11, 1); anotherDate = new MyDate(2000, 11, 10); res = myDate.compareTo(anotherDate); System.out.println(res); System.out.println(\"==========\"); myDate = new MyDate(2000, 11, 11); anotherDate = new MyDate(2000, 11, 11); res = myDate.compareTo(anotherDate); System.out.println(res); } } 6 ========== -9 ========== 0 JDK8 String compareTo String 實作Comparable&lt;String&gt;。 String字串是用final char[]陣列儲存，注意！是final，代表不能更改為其它字串陣列。 1 2 3 4 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { private final char value[]; } compareTo() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public int compareTo(String anotherString) { // value是本身的字串陣列 int len1 = value.length; int len2 = anotherString.value.length; // 取得二個字串最小長度 int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; // 2個字串在最小長度下，比較內容 while (k &lt; lim) { char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) { return c1 - c2; } k++; } // 不同長度回傳 長度相減 return len1 - len2; } 情況1 value = abcdefg another = abdd 結果為c(99) - d(100) = -1 情況2 以下二個字串前4個字元都一樣，只有長度不同。 value = abcdefg another = abcd 傳回3 情況3 以下二個字串前4個字元都一樣，只有長度不同。 value = abcde another = abcdfg 傳回-3 Comparator 匿名類別 Lambda Comparator可以透過匿名類別、Lambda，建立物件，只要實作比較的內容，就可單獨使用。 MyDate2提供getYear()、getMon()、getDate()，供其它類別使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyDate2 { private int year; private int mon; private int date; public MyDate2(int year, int mon, int date) { this.year = year; this.mon = mon; this.date = date; } public int getYear() { return year; } public int getMon() { return mon; } public int getDate() { return date; } } 建立比較器物件，進行比較，compare方法跟Comparable邏輯一模一樣。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test { public static void main(String[] args) { MyDate2 myDate2 = new MyDate2(2000, 11, 11); MyDate2 another = new MyDate2(2000, 11, 10); // 透過匿名類別建立物件 Comparator&lt;MyDate2&gt; comparator = new Comparator&lt;MyDate2&gt;() { @Override public int compare(MyDate2 o1, MyDate2 o2) { int diff_y = o1.getYear() - o2.getYear(); if (diff_y != 0) { return diff_y; } int diff_m = o1.getMon() - o2.getMon(); if (diff_m != 0) { return diff_m; } int diff_date = o1.getDate() - o2.getDate(); if (diff_date != 0) { return diff_date; } return 0; } }; int result = comparator.compare(myDate2, another); System.out.println(result); } } 1 Arrays.sort()排序 sort()原始碼 第2個參數是把Comparator傳入，就可以自訂排序的方法。 1 2 3 4 5 6 7 8 9 10 public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) { if (c == null) { sort(a); } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); } } Arrays.sort()排序與Comparator MyDate2增加toString()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MyDate2 { private int year; private int mon; private int date; public int getYear() { return year; } public int getMon() { return mon; } public int getDate() { return date; } public MyDate2(int year, int mon, int date) { this.year = year; this.mon = mon; this.date = date; } @Override public String toString() { return \"\\nMyDate2{\" + \"year=\" + year + \", mon=\" + mon + \", date=\" + date + '}'; } } 排序使用自訂Comparator。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Test { public static void main(String[] args) { // 透過匿名類別建立物件 Comparator&lt;MyDate2&gt; comparator = new Comparator&lt;MyDate2&gt;() { @Override public int compare(MyDate2 o1, MyDate2 o2) { int diff_y = o1.getYear() - o2.getYear(); // 不相等代表比較出結果，直接傳回比較結果 // 之後的程式就沒必要再比較。 if (diff_y != 0) { return diff_y; } int diff_m = o1.getMon() - o2.getMon(); if (diff_m != 0) { return diff_m; } int diff_date = o1.getDate() - o2.getDate(); if (diff_date != 0) { return diff_date; } return 0; } }; // 建立Array，裡面的內容是沒按照年月日順序 MyDate2[] arr = { new MyDate2(2000, 11, 10), new MyDate2(2000, 1, 1), new MyDate2(2000, 3, 1) }; // 陣列排序，把自訂Comparator傳入。 Arrays.sort(arr, comparator); System.out.println(Arrays.toString(arr)); } } [ MyDate2{year=2000, mon=1, date=1}, MyDate2{year=2000, mon=3, date=1}, MyDate2{year=2000, mon=11, date=10}] 結果由小到大排列。 由大到小 想把排序結果由大到小排列，只要把o1與o2位置顛倒。 o2.getYear() - o1.getYear() o2.getMon() - o1.getMon() o2.getDate() - o1.getDate() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Test { public static void main(String[] args) { MyDate2 myDate2 = new MyDate2(2000, 11, 11); MyDate2 another = new MyDate2(2000, 11, 10); // 透過匿名類別建立物件 Comparator&lt;MyDate2&gt; comparator = new Comparator&lt;MyDate2&gt;() { @Override public int compare(MyDate2 o1, MyDate2 o2) { int diff_y = o2.getYear() - o1.getYear(); // 不相等代表比較出結果，直接傳回比較結果 // 之後的程式就沒必要再比較。 if (diff_y != 0) { return diff_y; } int diff_m = o2.getMon() - o1.getMon(); if (diff_m != 0) { return diff_m; } int diff_date = o2.getDate() - o1.getDate(); if (diff_date != 0) { return diff_date; } return 0; } }; MyDate2[] arr = { new MyDate2(2000, 11, 10), new MyDate2(2000, 1, 1), new MyDate2(2000, 3, 1) }; Arrays.sort(arr, comparator); System.out.println(Arrays.toString(arr)); } } [ MyDate2{year=2000, mon=11, date=10}, MyDate2{year=2000, mon=3, date=1}, MyDate2{year=2000, mon=1, date=1}] 結果由大到小排列。"
  },"/pages/java/compiler_sdk/": {
    "title": "Compiler SDK",
    "keywords": "",
    "url": "/pages/java/compiler_sdk/",
    "body": "下載jdk17u 開啟終端機，在Downloads目錄下，執行以下句子。 git clone https://github.com/openjdk/jdk17u 安裝一些必要的指令 # 安装基础编译工具和依赖 brew install autoconf freetype ccache pkg-config xcode-select --install # 确保Xcode命令行工具已安装 下載zulu 未避免遇到以下問題 configure: Could not find a valid Boot JDK. configure: This might be fixed by explicitely setting --with-boot-jdk configure: error: Cannot continue /Users/cici/Downloads/jdk8u/common/autoconf/generated-configure.sh: line 82: 5: Bad file descriptor 下載zulu # 下載在Downloads目錄下 curl -LO https://cdn.azul.com/zulu/bin/zulu16.30.15-ca-jdk16.0.1-macosx_x64.tar.gz ## 解壓 tar -xzf zulu16.30.15-ca-jdk16.0.1-macosx_x64.tar.gz ## 設置臨時JAVA_HOME，非永久 export JAVA_HOME=$(pwd)/zulu16.30.15-ca-jdk16.0.1-macosx_x64 ## 檢查版本 $JAVA_HOME/bin/java -version 確保執行結果為以下內容 openjdk version \"16.0.1\" 2021-04-20 OpenJDK Runtime Environment Zulu16.30+15-CA (build 16.0.1+9) OpenJDK 64-Bit Server VM Zulu16.30+15-CA (build 16.0.1+9, mixed mode, sharing) configure 進到jdk17u目錄 bash configure \\ --with-debug-level=fastdebug \\ --with-boot-jdk=$JAVA_HOME make 進到jdk17u目錄 make JOBS=2 images 確保出現以下句子 Finished building target 'images' in configuration 'macosx-x86_64-server-fastdebug' 使用PrintVtableStats 進到jdk17u目錄 ./build/macosx-x86_64-server-fastdebug/jdk/bin/java -XX:+UnlockDiagnosticVMOptions -XX:+PrintVtableStats -version | grep -i vtable 結果如下 openjdk version \"17.0.16-internal\" 2025-07-15 OpenJDK Runtime Environment (fastdebug build 17.0.16-internal+0-adhoc.cici.jdk17u) OpenJDK 64-Bit Server VM (fastdebug build 17.0.16-internal+0-adhoc.cici.jdk17u, mixed mode) vtable statistics: 7664 bytes fixed overhead (refs + vtable object header) 87360 bytes for vtable entries (8120 for arrays) ./build/macosx-x86_64-server-fastdebug/jdk/bin/javac -d . vtable_test/PolyExample.java ./build/macosx-x86_64-server-fastdebug/jdk/bin/java -XX:+UnlockDiagnosticVMOptions vtable_test.PolyExample Bark! Press Enter to exit… jps -l | grep PolyExample 99284 vtable_test.PolyExample ./build/macosx-x86_64-server-fastdebug/jdk/bin/jhsdb clhsdb –pid 1708 dumpheap：导出堆内存到文件（需后工具分析）。 print：打印对象字段值（更高级抽象）。 mem 两种查询方式： 单地址 + 长度：address/count 从 address 开始，显示 count 个字节。 地址范围：address,address 显示两个地址之间的内存。 你输入的 mem 0x00000008000c1228+B8 0x20 有两个问题： 不支持 +B8 偏移量语法：必须手动计算地址（如 0x00000008000c1228 + 0xB8 = 0x00000008000c12e0）。 第二个参数 0x20 格式错误：长度需要用 / 分隔，而不是空格。0x20不支援，要用32 hsdb&gt; mem 0x00000008000c1228/32 class Dog hsdb&gt; universe # 确认堆内存状态（你已执行） hsdb&gt; classes # 列出所有已加载的类 hsdb&gt; class Dog Dog @0x00000008000c1228 hsdb&gt; inspect 0x00000008000c1228 # inspect 查看对象结构，再用 mem 分析原始内存： hsdb&gt; dumpclass 0x00000008000c1228 Array&lt;Method&gt; InstanceKlass::_methods: Array&lt;Method*&gt; @ 0x000000011e40e958 inspect 0x000000011e40ea58"
  },"/pages/java/compiler_sdk8/": {
    "title": "Compiler JDK8",
    "keywords": "",
    "url": "/pages/java/compiler_sdk8/",
    "body": "下載jdk8 開啟終端機，在Downloads目錄下，執行以下句子。 git clone https://github.com/openjdk/jdk8u 安裝一些工具 # 安装基础编译工具和依赖 brew install autoconf freetype ccache pkg-config xcode-select --install # 确保Xcode命令行工具已安装 binutils brew install binutils echo 'export PATH=\"/usr/local/opt/binutils/bin:$PATH\"' &gt;&gt; ~/.zshrc # 立即生效 source ~/.zshrc 下載jdk7 為什麼要下載jdk7呢？ 編譯的時候需要jdk8的前一個版本的jdk。 我是mac，我下載的bin目錄的位置在此處。 /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 暫時設定Java Home export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home ## 檢查版本 $JAVA_HOME/bin/java -version 要確保印出以下內容 java version \"1.7.0_80\" Java(TM) SE Runtime Environment (build 1.7.0_80-b15) Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) 編譯 進到jdk8的目錄 cd jdk8u # 确保使用绝对路径 export OBJCOPY=$(which objcopy) # 完整配置命令（必须在一行） bash configure \\ --with-boot-jdk=$JAVA_HOME \\ --with-debug-level=slowdebug \\ --enable-debug-symbols \\ --with-native-debug-symbols=internal \\ OBJCOPY=$OBJCOPY make make JOBS=2 images 若要重新make，請先clean make clean rm -rf build 檢查PrintVtables功能 檢查是否可以用PrintVtables功能 ./build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java -XX:+UnlockDiagnosticVMOptions -XX:+PrintVtables JAVA_HOME 把build目錄中的編譯好的macosx-x86_64-normal-server-slowdebug，更改名jdk8_debug 修改zshrc vi ~/.zshrc export JAVA_HOME=/Users/cici/Downloads/jdk8u/build/jdk8_debug/jdk export PATH=$JAVA_HOME/bin:$PATH source ~/.zshrc 檢查版本 java -version openjdk version \"1.8.0_462-internal-debug\" OpenJDK Runtime Environment (build 1.8.0_462-internal-debug-cici_2025_05_27_10_21-b00) OpenJDK 64-Bit Server VM (build 25.462-b00-debug, mixed mode) 測試 java -XX:+UnlockDiagnosticVMOptions -XX:+PrintVtables PolyExample 測試檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Animal { public void speak() { System.out.println(\"Animal\"); } public void eat() { System.out.println(\"Animal eats\"); } } class Dog extends Animal { @Override public void speak() { System.out.println(\"Dog\"); } @Override public void eat() { System.out.println(\"Dog eats\"); } } class SuperDog extends Dog { @Override public void speak() { System.out.println(\"SuperDog\"); } @Override public void eat() { System.out.println(\"SuperDog eats\"); } } public class TestVtable { public static void main(String[] args) throws Exception { for (int i = 0; i &lt; 10000; i++) { Animal a = getAnimal(i); a.speak(); a.eat(); } Thread.sleep(300_000); // 等待觀察 } public static Animal getAnimal(int i) { if (i % 2 == 0) return new SuperDog(); else return new Dog(); } } 編譯 ./build/macosx-x86_64-normal-server-slowdebug/jdk/bin/javac TestVtable 執行 ./build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java \\ -Xcomp \\ -XX:+UnlockDiagnosticVMOptions \\ -XX:+PrintVtables \\ -XX:+TraceClassLoading \\ -XX:+TraceClassInitialization \\ TestVtable 2&gt;&amp;1 | tee vtables.log 檔案中尋找vtable grep -i vtable vtables.log grep -A10 'Vtable for class' vtables.log"
  },"/pages/java/string/": {
    "title": "String",
    "keywords": "",
    "url": "/pages/java/string/",
    "body": "Prerequisites: Memory Model == 比較 建立方式 建立方式有二種，一種是指向字串常數，一種是使用建構子。 字串常數 什麼是字串常數？\"\"雙引號包住的字串是常數。 1 String s1 = \"這個就是字串常數\"; 字串常數記憶體模型 在String pool找有沒有Hello的字串，沒有就建立記憶體空間放Hello。 Stack中s1變數指向String pool中Hello的記憶體位址。 建構子 1 String s1 = new String(String s); String有一個value屬性 value是final char[]，存放字串。 1 2 3 4 5 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { // 存放字串 private final char value[]; } 建構子記憶體模型 建立記憶體空間 將Stack中s1變數指向記憶體位址 在String pool找有沒有Hi的字串，沒有就建立記憶體空間放Hi。 String有一個value屬性，指向String pool中的Hi記憶體位址。 建構子與常數的記憶體位址不同 從以上的記憶體模型，可以發現常數建立的字串，是指向String Pool中的記憶體位址。 而用new String()建立的字串，變數指向的是Heap中的記憶體位址。 String是類別，==對類別而言，是用來比較記憶體位址是否相等。 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \"Hello\"; System.out.println(\"s1 == s2 \" + (s1 == s2)); String s3 = new String(\"Hello\"); String s4 = new String(\"Hello\"); System.out.println(\"s3 == s4 \" + (s3 == s4)); System.out.println(\"s1 == s3 \" + (s1 == s3)); } } s1 == s2 true s3 == s4 false s1 == s3 false 二者建立方式的記憶體模型 1 2 3 4 5 6 public class Test { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = new String(\"Hello\"); } } 在String pool找有沒有Hello的字串，沒有就建立記憶體空間放Hello。 s1變數指向String Pool中Hello的記憶體位址。 建立記憶體空間 將Stack中s2變數指向記憶體位址 在String pool找有沒有Hello的字串，沒有就建立記憶體空間放Hello。 String有一個value屬性，指向String pool中的Hello記憶體位址。 String equals String與equals() 相同的內容不想再寫一遍，請詳見上述連結。 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = new String(\"Hello\"); System.out.println(\"s1 equals s2 \" + s1.equals(s2)); System.out.println(\"s1 == s2 \" + (s1 == s2)); } } s1 equals s2 true s1 == s2 false String intern() intern() 取出String.value指向String Pool中的記憶體位址。 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = new String(\"Hello\"); System.out.println(\"s1 equals s2 \" + s1.equals(s2)); System.out.println(\"s1 == s2 \" + (s1 == s2)); System.out.println(\"s1 == s2.intern() \" + (s1 == s2.intern())); System.out.println(\"s2 == s2.intern() \" + (s2 == s2.intern())); // s2 指向Heap中的記憶體位址 // s2.intern()指向String Pool中的記憶體位址 } } s1 equals s2 true s1 == s2 false s1 == s2.intern() true s2 == s2.intern() false String被指派其它字串就是建立物件 Prerequisites: final value是final char[]，存放字串。 因為value屬性是final，不能直接指向其它陣列，所以String物件被指派其它字串，實際上就是在String Pool中建立新的String物件，並非更新字元陣列裡面的內容。 1 2 3 4 5 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { // 存放字串 private final char value[]; } String Pool建立Hello，s1指向Hello記憶體位址。 String Pool建立Hi，s1指向Hi記憶體位址。 Hello在String Pool中有，s1指向Hello記憶體位址。 二個字串常數相加 編譯器看到\"Hello\" + \" World\"就視為一組字串。 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { String s1 = \"Hello\" + \" World\"; String s2 = \"Hello World\"; System.out.println(\"s1 == s2 \" + (s1 == s2)); } } s1 == s2 true 由結果可知s1與s2是相等的。 二個字串變數相加 sb 字串變數相加會呼叫StringBuilder的append()方法，最後會回傳new String(value, 0, cout) 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \" World\"; String s3 = s1 + s2; // 傳回Heap中的記憶體位址 String s4 = \"Hello World\"; // 傳回String Pool中的記憶體位址 System.out.println(\"s3 == s4 \" + (s3 == s4)); } } s3 == s4 false 把上面s3 = s1 + s2;的程式碼過程如下。 1 2 3 4 StringBuilder sb = new StringBuilder(); sb.append(\"Hello\"); sb.append(\" World\"); String s3 = sb.toString(); String實作Comparable String與Comparable 請詳見上述連結。 String 與 IO String與char[]和byte[] 請詳見上述連結。"
  },"/pages/java/generics_extend_super/": {
    "title": "?與extends與super",
    "keywords": "",
    "url": "/pages/java/generics_extend_super/",
    "body": "泛型類型沒有多型 多型 不能像類別多型一樣，等號=左邊是父類別，等號=右邊是指向子類別。 以下的語法，不能編譯通過，即便String是Object的子類別。 1 List&lt;Object&gt; list = new ArrayList&lt;String&gt;(); ? extends 泛型類型只能是Number或Number的子類別。 1 &lt; ? extends Number&gt; 下圖中，只有Boolean與Character沒有在Number下。 範例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test1 { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(5); list.add(4); printNumberList(list); ArrayList&lt;Character&gt; charlist = new ArrayList&lt;&gt;(); // 以下編譯不過，因為Character不是Number子類 printNumberList(charlist); } // 參數泛型類型只能是Number或Number的子類別 public static void printNumberList(List&lt;? extends Number&gt; list) { for (Number number : list) { System.out.println(number); } } 5 4 ? supper 泛型類型只能是Integer或Integer父類別。 1 &lt; ? supper Integer&gt; 範例程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Test1 { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(5); list.add(4); // 以下編譯不過，因為Integer不是Character，也不是Character父類別。 printParent(list); ArrayList&lt;Character&gt; charlist = new ArrayList&lt;&gt;(); printParent(charlist); ArrayList&lt;Object&gt; objlist = new ArrayList&lt;&gt;(); printParent(objlist); } // 參數泛型類型只能是Number或Number的子類別 public static void printNumberList(List&lt;? extends Number&gt; list) { for (Number number : list) { System.out.println(number); } } // 參數泛型類型只能是Character或Character父類別 public static void printParent(List&lt;? super Character&gt; list) { for (Object o : list) { System.out.println(o); } } } ? 任何類型 ?代表泛型類型可以是任何類型。 1 &lt; ? &gt; 不管任何類型的list都可以使用printAnyType()方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Test1 { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(5); list.add(4); printAnyType(list); ArrayList&lt;Character&gt; charlist = new ArrayList&lt;&gt;(); printAnyType(charlist); ArrayList&lt;Object&gt; objlist = new ArrayList&lt;&gt;(); printAnyType(objlist); } // 參數泛型類型只能是Number或Number的子類別 public static void printNumberList(List&lt;? extends Number&gt; list) { for (Number number : list) { System.out.println(number); } } // 參數泛型類型只能是Character或Character父類別 public static void printParent(List&lt;? super Character&gt; list) { for (Object o : list) { System.out.println(o); } } // 參數泛型類型可以是任何類型 public static void printAnyType(List&lt;?&gt; list) { for (Object o : list) { System.out.println(o); } } }"
  },"/pages/java/generics_method/": {
    "title": "泛型方法",
    "keywords": "",
    "url": "/pages/java/generics_method/",
    "body": "Prerequisites: 介面 泛型 Wrap包裝類別 泛型方法與泛型是不同的東西。 泛型是在類別名後面，自訂類型。 泛型方法是在傳回值前面，自訂類型。 泛型方法是給方法使用，不是類別使用。 自訂類型 在傳回值前面，自訂類型&lt;R, U, V&gt;，用尖括號包住自訂類型。 參數類型為自訂類型&lt;R, U, V&gt;。 1 2 3 4 5 class Dog { public &lt;R, U, V&gt; void eat(R r, U u, V v) { } } 泛型中有泛型方法 下方程式，泛型方法eat的自訂類型X, Y, Z，不能跟泛型的自訂類型T, R, M英文字母一模一樣。 1 2 3 4 5 6 7 8 9 class Cat&lt;T, R, M&gt; { private T t; private T[] arr; private R r; private M m; public &lt;X, Y, Z&gt; void eat(X x, Y y, Z z) { } } 呼叫泛型方法，透過參數知道類型 參數若是基本型態(short, int, long, double, float, boolean, char)會自動轉換為包裝類別，包裝類別有Short, Integer, Long, Double, Float, Boolean, Character。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Test { public static void main(String[] args) { Cat&lt;Double, Boolean, Integer&gt; cat = new Cat&lt;&gt;(12.5, true, 1); // 透過參數知道類型 cat.eat(\"餅乾\", 1, new ArrayList&lt;Integer&gt;()); System.out.println(\"============================\"); cat.eat(new int[10], new ArrayList&lt;String&gt;(), 55.5); } } class Cat&lt;T, R, M&gt; { private T t; private T[] arr; private R r; private M m; public &lt;X, Y, Z&gt; void eat(X x, Y y, Z z) { System.out.println(x.getClass()); System.out.println(y.getClass()); System.out.println(z.getClass()); } public Cat(T t, R r, M m) { this.t = t; this.r = r; this.m = m; } } class java.lang.String class java.lang.Integer class java.util.ArrayList ============================ class [I class java.util.ArrayList class java.lang.Double 由執行結果可以發現參數int轉成Integer，double轉成Double。 分辦泛型與泛型方法 sleep()是泛型，eat()是泛型方法。 sleep是使用泛型自訂類型T,R。 eat是使用泛型方法自訂類型X,Y,Z。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Cat&lt;T, R, M&gt; { private T t; private T[] arr; private R r; private M m; public T sleep(R r) { return t; } public &lt;X, Y, Z&gt; void eat(X x, Y y, Z z) { System.out.println(x.getClass()); System.out.println(y.getClass()); System.out.println(z.getClass()); } } 泛型方法可以用泛型的自訂類型 run泛型方法，T是用泛型自訂類型，K是用泛型方法自訂類型。 1 2 3 4 5 6 7 8 9 10 11 12 class Cat&lt;T, R, M&gt; { private T t; public &lt;K&gt; void run(T t, K k) { } } public class Test { public static void main(String[] args) { Cat&lt;Double, Boolean, Integer&gt; cat = new Cat&lt;&gt;(12.5, true, 1); cat.run(55.0, new ArrayList&lt;Integer&gt;()); } } class java.lang.Double class java.util.ArrayList 執行結果可以看出參數1類型是用Double，參數2類型是ArrayList。"
  },"/pages/java/junit_test/": {
    "title": "Junit Test",
    "keywords": "",
    "url": "/pages/java/junit_test/",
    "body": "把以下的文字複製貼上在程式碼import的位置，如下圖一樣，滑鼠移到junit的字上，會出現下圖的畫面，若沒出現，可以把滑鼠放在junit的字之間，按下alt + Enter，看是否有任何反應。 import org.junit.jupiter.api.Test; 在方法上面寫上@Test，應該會出現如下圖中，2的部分多出一個執行按鈕。 在方法的內容輸入 1 System.out.println(\"測試\"); 可以選擇Run或debug。 會印出測試報告。"
  },"/pages/java/inheritance/": {
    "title": "繼承",
    "keywords": "",
    "url": "/pages/java/inheritance/",
    "body": "繼承概念 為什麼要用到繼承？當多個類別有相同的屬性與方法，可以把這些相同的屬性與方法抽出來做為父類別，子類別繼承父類別就擁有那些相同的屬性與方法，解決程式碼重覆。 以下A類別與B類別都有3個相同屬性與方法。 1 2 3 4 5 6 7 8 9 10 class A { private String s1; private String s2; private String s3; private String sa; public void method1() {} public void method2() {} public void method3() {} public void methodA() {} } 1 2 3 4 5 6 7 8 9 10 class B { private String s1; private String s2; private String s3; private String sb; public void method1() {} public void method2() {} public void method3() {} public void methodB() {} } 把相同屬性與方法抽出來變成父類別。 1 2 3 4 5 6 7 8 class Parent { private String s1; private String s2; private String s3; public void method1() {} public void method2() {} public void method3() {} } A類別與B類別繼承Parent，就可以跟之前一樣，各自擁有s1,s2,s3屬性與method1,method2,method3方法，A類別與B類別又各自保有跟其它類別不相同的屬性與方法，相同的抽取出來作為父類別，不同的作為子類別。 1 2 3 4 class A extends Parent{ private String sa; public void methodA() {} } 1 2 3 4 class B extends Parent{ private String sb; public void methodB() {} } 繼承關係階層圖 先把滑鼠移到子類別名。 按下ctrl + h Memory Layout Object Layout core 使用Object Layout core，可以看出物件記憶體內部屬性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.openjdk.jol.info.ClassLayout; public class Test { public static void main(String[] args) { System.out.println(ClassLayout.parseInstance(new A()).toPrintable()); System.out.println(ClassLayout.parseInstance(new B()).toPrintable()); } } class Parent { private String s1; private String s2; private String s3; public void method1() {} public void method2() {} public void method3() {} } class A extends Parent{ private String sa; public void methodA() {} } class B extends Parent{ private String sb; public void methodB() {} } 執行結果可以看出A物件與B物件裡面有3個屬性(s1,s2,s3)來自Parent類別，只有一個屬性是自己的。 inherit.A object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x01003410 12 4 java.lang.String Parent.s1 null 16 4 java.lang.String Parent.s2 null 20 4 java.lang.String Parent.s3 null 24 4 java.lang.String A.sa null 28 4 (object alignment gap) Instance size: 32 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total inherit.B object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x0000000000000001 (non-biasable; age: 0) 8 4 (object header: class) 0x0108c460 12 4 java.lang.String Parent.s1 null 16 4 java.lang.String Parent.s2 null 20 4 java.lang.String Parent.s3 null 24 4 java.lang.String B.sb null 28 4 (object alignment gap) Instance size: 32 bytes Space losses: 0 bytes internal + 4 bytes external = 4 bytes total 取得子類別所有方法 取得父類別所有方法 使用以下程式碼取得A類別所有方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test { public static void main(String[] args) throws ClassNotFoundException { // 參數是「package.類別名」 getClzMethod(Class.forName(\"inherit.A\")); } public static void getClzMethod(Class&lt;?&gt; clz) { Class&lt;?&gt; clazz = clz; System.out.println(\"Methods in class: \" + clazz.getName()); for (Method method : clazz.getDeclaredMethods()) { System.out.println(method); } System.out.println(\"------------------\"); // parent Class&lt;?&gt; superclass = clazz.getSuperclass(); System.out.println(\"Methods in Parent: \" + clazz.getName()); for (Method method : superclass.getDeclaredMethods()) { System.out.println(method); } } } Methods in class: inherit.A public void inherit.A.methodA() ------------------ Methods in Parent: inherit.A public void inherit.Parent.method1() public void inherit.Parent.method2() public void inherit.Parent.method3() 由以上執行結果，可以看出A類有methodA()。 其它method1()、method2()、method3()，都來自父類別。 呼叫誰的方法，就用誰的屬性 父類別有一個屬性i = 20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Parent { private String s1; private String s2; private String s3; int i = 20; // 父類別屬性i // 父類別方法 public void method1() { // 印出父類別屬性i System.out.println(\"i = \" + i); } public void method2() { } public void method3() { } } 子類別i = 10，並且覆寫method1()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A extends Parent { int i = 10; // 子類別屬性i private String sa; @Override public void method1() { // 印出子類別屬性i，如果子類別沒有屬性i，就用父類別的屬性i System.out.println(\"i = \" + i); } public void methodA() { // 使用super.呼叫父類別的method() super.method1(); } } 請問執行子類別的methodA()，會印出什麼？ 1 2 3 4 5 6 public class Test { public static void main(String[] args){ A test = new A(); test.methodA(); } } i = 20 執行結果是印出父類別屬性i = 20，而不是子類別i = 10。 請問執行子類別覆寫的method1()，會印出什麼？ 1 2 3 4 5 6 public class Test { public static void main(String[] args){ A test = new A(); test.method1(); } } i = 10 執行結果為10。 由此可證，呼叫父類別的方法，使用的是父類別屬性，呼叫子類別的方法，使用的是子類別屬性，除非子類別沒這個屬性，就會從父類別找有沒有這個屬性。 覆寫 以上A類別有覆寫method1()方法，什麼是覆寫?就是父類別原本有的方法，子類別寫一模一樣的方法覆蓋過去。 1 2 3 4 @Override public void method1() { System.out.println(\"i = \" + i); } 使用之前取得子類別所有方法的程式碼。 執行結果如下: Methods in class: inherit.A public void inherit.A.method1() public void inherit.A.methodA() ------------------ Methods in Parent: inherit.A public void inherit.Parent.method1() public void inherit.Parent.method2() public void inherit.Parent.method3() 可以看出子類別有method1()與methodA()。 父類別也有method1()，那二邊都有method1()，要執行誰的？ 根據等號=右邊是誰，就執行誰的方法，除非子類別沒有那個方法，才執行父類別的方法。 1 2 A test = new A(); test.method1(); // 執行A類別下的method11() 使用Debug工具，列出物件所有屬性 把斷點設在new 子類別()的下一行，滑鼠移到變數，本例是變數是test，會顯示物件所有屬性，包含父類別屬性，相同屬性，會用父類別名.屬性來區分。下圖中是用Parent.i，告知這是父類別的i屬性。 不用透過super取得父類別的屬性與方法 父類別的屬性與方法，子類別可以直接使用，不用透過super。 以下程式碼，子類別直接用n1,n2,method1()，沒有透過super使用父類別屬性方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 父類別 class Father { int n1; int n2; private int n3; public void method1() {} private void method2() {} } // 子類別 class Child extends Father{ public void show() { System.out.println(n1); System.out.println(n2); method1(); } } 父類別與子類別都有一樣的方法或屬性，就會用super來指定是要用父類別的，還是子類別的，若沒有寫super，預設用子類別。 子類別無法存取父類別private屬性與方法。 父類別私有屬性或方法，透過父類別public方法取得 即便子類別繼承父類別，但是private屬性與方法沒辦法存取。 父類別提供public的方法，給子類呼叫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Father { int n1; int n2; private int n3; public void method1() {} private void method2() {} // 取得私有屬性 public int getN3() { return n3; } // 呼叫私有方法 public void callMethod2() { method2(); } } 子類別透過public方法，取得private屬性與呼叫private方法。 1 2 3 4 5 6 class Child extends Father{ public void show() { System.out.println(getN3()); callMethod2(); } }"
  },"/pages/java/super/": {
    "title": "super與this",
    "keywords": "",
    "url": "/pages/java/super/",
    "body": "super的意義 可以與子類別「分開」執行父類別程式碼。 使用父類別的方法、屬性 只能使用父類別不是private的方法與屬性。 語法 super.方法() super.屬性 super()建構子 只能在子類別的建構子使用，而且只能放在第一行。 呼叫super()的意思是，呼叫父類別的無參數建構子。 呼叫super(參數)的意思是，呼叫父類別的有參數建構子。 當只有一個父類別屬性，this與super取得屬性是相同 父類別的name 1 2 3 4 5 6 7 class Father { String name = \"Father\"; String hobby = \"Running\"; private int age = 50; void method1() { } } 子類別沒有覆寫name，在method1印出name 1 2 3 4 5 6 7 8 9 class Child extends Father { @Override void method1() { // 以下三種呼叫都是相同的父類別的name System.out.println(super.name); System.out.println(this.name); System.out.println(name); } } 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Father obj = new Child(); obj.method1(); } } Father Father Father super.方法()直接去父類別找方法 在子類別中，使用super.方法()，跳過子類別，直接去父類別去找有沒有這個方法，找到就呼叫，找不到就找祖父類別，再找不到也不會回來找子類別有沒有這個方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Child extends Father { @Override void method1() { System.out.println(super.name); System.out.println(this.name); System.out.println(name); } void method2() { // 執行父類別的method1() super.method1(); } } this 代表new出來的物件。 類別 this = new 類別(); this.方法() this.屬性 繼承中this.方法()與this.屬性 父類有method1與method2，與hobby屬性 1 2 3 4 5 6 7 8 9 10 11 class Father { String name = \"Father\"; String hobby = \"Running\"; private int age = 50; void method1() { System.out.println(\"Father method1\"); } void method2() { System.out.println(\"Father method2\"); } } 子類別有method1(覆寫)、method3，請問，在子類別呼叫this.method2()與this.hobby，會呼叫誰的？ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Child extends Father { int count = 0; @Override void method1() { System.out.println(\"Child Method1\"); } void method3() { // 用this呼叫非子類別的method2() this.method2(); // 用this呼叫非子類別的hobby屬性 System.out.println(this.hobby); } } Father method2 Running 執行結果可以發現，this若本身的類別找不到，就會往父類別找有沒有方法與屬性。 this變數、方法尋找方式 先找本身的類別有沒有，本身的類別找不到，再往父類別找，父類別再找不到，繼續往上找，找到就停下來，不會再往上找。 super與this 關鍵字 方法與變數 this 先找本身類別，找不到找父類別，再找不到找祖父類別。 super 直接找父類別，找到就停止不往祖父類別找，不會回頭找子類別有沒有。 關鍵字 建構子 this() 只能在建構子中使用，放在第一行，呼叫本身類別建構子，根據建構子參數。 super() 只能在子類別建構子中使用，放在第一行，呼叫父類別建構子，根據建構子參數。"
  },"/pages/java/equals_compare/": {
    "title": "==與equals",
    "keywords": "",
    "url": "/pages/java/equals_compare/",
    "body": "Prerequisites: 基本型態與包裝類別 Java Memory Model 比較== 基本型態 基本型態是int,short,long,char,boolean,double,float,byte 對於基本型態來說，二個等於==是比較「值」。 以下程式碼是比較10與20，二個數值是否相同。 1 2 3 4 5 int i1 = 10; int i2 = 20; if (i1 == i2) { // do something } 類別 對於類別來說，二個等於==是比較「記憶體位址」。 1 2 3 4 5 Integer i1 = 10; // 使用自動裝箱 Integer i2 = 20; // 使用自動裝箱 if (i1 == i2) { // do something } Object equals() Object是所有類別的父類別，它的equals()是比較二個物件的記憶體位址是否相同。 1 2 3 public boolean equals(Object obj) { return (this == obj); } String equals() String繼承Object，覆寫equals()方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public boolean equals(Object anObject) { // 如果傳進來的物件與本身物件記憶體位址相同，代表是同一個物件 if (this == anObject) { return true; } // 如果傳進來的物件是String類型 if (anObject instanceof String) { String anotherString = (String)anObject; // value變數是本身用來儲存字串 int n = value.length; // 如果傳進來的物件value長度與本身value相同 if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // 迴圈比較二者char陣列中的ascii code是否相同 if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } Integer equals 使用拆箱，把物件轉成基本型態，再來比較數值是否相同。 1 2 3 4 5 6 7 8 public boolean equals(Object obj) { // 傳進來的物件是否為Integer if (obj instanceof Integer) { // 使用拆箱，進行數值比較 return value == ((Integer)obj).intValue(); } return false; }"
  },"/pages/java/static_inner/": {
    "title": "靜態內部類別",
    "keywords": "",
    "url": "/pages/java/static_inner/",
    "body": "Prerequisites: [Memory Model][3] Static 建構子 使用靜態內部類別 什麼是靜態內部類別？其實也是一個類別，只是外部類別變成名稱空間，呼叫靜態內部類別的靜態方法，這樣呼叫: 1 外部類別.靜態內部類別.靜態方法(); 呼叫靜態方法時，類別名也變成名稱空間，這樣呼叫: 1 類別.靜態方法(); 以上呼叫的方法如出一徹。 靜態內部類別是一個類別 靜態內部類別是一個類別，所以類別該有的存取權限(public、private、protected、default)、屬性、方法、建構子、匿名程式碼區塊、靜態程式碼區塊、靜態變數、靜態方法…等等，靜態內部類別也有。 static關鍵字 在內部類前面加上static的關鍵字就變成靜態內部類別。 1 2 3 4 class Outter { public static class StaticInner { } } 建立靜態內部類別 使用new 語法 外部類別.內部類別 變數 = new 外部類別.內部類別() 注意！靜態內部類別建立的方式為「內部類別」差距很大，不相同。 1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { Outter.StaticInner inner_s = new Outter.StaticInner(); } } class Outter { public static class StaticInner { } } 外部類別提供public static方法 因為靜態內部類別，是屬於類別，所以使用static方法取得靜態內部類別。 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { Outter.StaticInner inner_s = Outter.getStaticInner(); } } class Outter { public static class StaticInner { } public static StaticInner getStaticInner() { return new StaticInner(); } } 外部類別提供public static方法存取private 外部類別提供public static方法，去存取private靜態內部類別。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { System.out.println(Outter.getInnerStr()); } } class Outter { // 私有靜態內部類別 private static class StaticInner { // 私有靜態屬性 private static String str = \"私有內部屬性\"; } // 外部公有靜態方法 public static String getInnerStr() { // 取得private靜態內部類別.private靜態屬性 return StaticInner.str; } } 私有內部屬性 靜態內部類別建構子 靜態內部類別就是類別，所以一定有建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Test { public static void main(String[] args) { Outter.StaticInner inner_s = Outter.getStaticInner(); } } class Outter { public static class StaticInner { StaticInner() { System.out.println(\"建構子\"); } } public static StaticInner getStaticInner() { return new StaticInner(); } } 建構子 使用到靜態內部類別才會被建立 注意！當靜態內部類別要用到的時候，才會初始化。 初始化程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Test { { System.out.println(\"外部匿名區塊\"); } static { System.out.println(\"外部靜態區塊\"); } Test() { System.out.println(\"外部建構子區塊\"); } public static void staticMethod1() { System.out.println(\"外部靜態方法\"); } public static class Static_class { Static_class() { System.out.println(\"內部類別建構子\"); } { System.out.println(\"內部匿名區塊\"); } static { System.out.println(\"內部靜態區塊\"); } public static void innerStaticMethod1() { System.out.println(\"內部靜態方法\"); } } } 未使用靜態內部類別 1 2 3 public static void main(String[] args) { Test.staticMethod1(); } 外部靜態區塊 外部靜態方法 由以上的結果可以發現，呼叫外部類別的靜態方法時，不會呼叫任何靜態內部類別區塊。 使用靜態內部類別 1 2 3 public static void main(String[] args) { Test.Static_class.innerStaticMethod1(); } 外部靜態區塊 內部靜態區塊 內部靜態方法 由以上的結果可以發現，呼叫靜態內部類別的方法時，會呼叫靜態內部類別的「靜態區塊」。 建立外部類別 1 2 3 public static void main(String[] args) { Test test = new Test(); } 外部靜態區塊 外部匿名區塊 外部建構子區塊 由以上的結果可以發現，外部類別建立的時候，完全不會建立靜態內部類別的任何代碼。 建立靜態內部類別 1 2 3 public static void main(String[] args) { Test.Static_class test = new Test.Static_class(); } 外部靜態區塊 內部靜態區塊 內部匿名區塊 內部類別建構子 由以上的結果可以發現，外部類別只是名稱空間，建立靜態內部類別的時候，外部類別只會呼叫「靜態區塊」，外部的「匿名區塊」與外部「建構子」，完全沒被呼叫。 而靜態內部類別的「靜態區塊」與「匿名區塊」與「建構子」全呼叫。 靜態內部類別Singleton 外部類別可以存取private內部類別，透過這個原理，由靜態內部類別建立外部類別物件。 把外部類別的建構子設為private。 建立private靜態內部類別 靜態內部類別，建立private靜態且final的屬性，屬性的類型是外部類別。 靜態內部類別被建立時，屬性才會new Outter() 建立一個public static的方法。 取得靜態內部類別的私有靜態屬性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Test { public static void main(String[] args) { Outter outter1 = Outter.getInstance(); System.out.println(outter1.hashCode()); Outter outter2 = Outter.getInstance(); System.out.println(outter2.hashCode()); Outter outter3 = Outter.getInstance(); System.out.println(outter3.hashCode()); } } class Outter { // 1. private Outter() { System.out.println(\"建立物件\"); } // 2. private static class StaticInner { // 3. private static final Outter outter = new Outter(); // 4. } // 5. public static Outter getInstance() { // 6. return StaticInner.outter; } } 建立物件 989110044 989110044 989110044 由執行結果可以發現，「建立物件」，只執行一次。 每一個物件的hashCode都是一模一樣的，代表物件只被建立一次。"
  },"/pages/java/static_inner_method/": {
    "title": "靜態內部類別方法",
    "keywords": "",
    "url": "/pages/java/static_inner_method/",
    "body": "呼叫靜態內部類別.靜態方法 1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { Outter.StaticInner.innerSMethod1(); } } class Outter { public static class StaticInner { public static void innerSMethod1() { System.out.println(\"呼叫靜態內部類別.靜態方法\"); } } } 呼叫靜態內部類別.靜態方法 靜態內部類別.靜態方法 靜態方法只能存取靜態變數與靜態方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test { public static void main(String[] args) { Outter.StaticInner.innerSMethod1(); } } class Outter { public static String static_name = \"外部靜態變數\"; private static void staticMethod1() { System.out.println(\"外部靜態方法\"); } public static class StaticInner { static String inner_sname = \"內部靜態變數\"; public static void innerSMethod1() { System.out.println(static_name); System.out.println(inner_sname); staticMethod1(); innerSMethod2(); } // 內部類的靜態方法 public static void innerSMethod2() { System.out.println(\"內部靜態方法\"); } } } 外部靜態變數 內部靜態變數 外部靜態方法 內部靜態方法 靜態內部類別的成員方法 以下無法存取: 外部類別成員屬性、方法 其它都可以存取 內部類別成員屬性、方法 外部類別靜態屬性、靜態方法 內部類別靜態屬性、靜態方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Test { public static void main(String[] args) { Outter.StaticInner inner_s = Outter.getStaticInner(); inner_s.call(); } } class Outter { public String name = \"外部變數\"; public static String static_name = \"外部靜態變數\"; public void method() { System.out.println(\"外部方法\"); } private static void staticMethod() { System.out.println(\"外部靜態方法\"); } public static class StaticInner { String inner_name = \"內部變數\"; static String inner_sname = \"內部靜態變數\"; public void innerMethod() { System.out.println(\"內部方法\"); } // 內部類的靜態方法 public static void innerSMethod1() { System.out.println(\"內部靜態方法\"); } public void call() { // 呼叫外部靜態變數 System.out.println(static_name); // 呼叫外部靜態方法 staticMethod(); // 內部的變數、方法可以呼叫 System.out.println(inner_name); innerMethod(); // 內部的靜態變數、靜態方法可以呼叫 System.out.println(inner_sname); innerSMethod1(); } } public static StaticInner getStaticInner() { return new StaticInner(); } } 外部靜態變數 外部靜態方法 內部變數 內部方法 內部靜態變數 內部靜態方法"
  },"/pages/kotlin/any/": {
    "title": "Any",
    "keywords": "",
    "url": "/pages/kotlin/any/",
    "body": "Prerequisites: Java ==與equals Any是所有類別的父類別。 ===與== Any===與==都是比較記憶體位址是否相同。 class繼承Any若沒有覆寫equals的狀況下，==與===的功能是相同的，都是比較記憶體位址。 如同Java的Object，equals()的功能與==是相同的，都是比較記憶體位址是否相同。 obj1與obj2為二個物件。 1 2 3 4 5 6 7 8 fun main() { val obj1 = Airplane() val obj2 = Airplane() println(\"equals = ${obj1 == obj2}\") println(\"compare = ${obj1 === obj2}\") } class Airplane { } equals false compare false 將obj2指向obj1記憶體位址。 1 2 3 4 5 6 7 8 fun main() { val obj1 = Airplane() val obj2 = obj1 println(\"equals = ${obj1 == obj2}\") println(\"compare = ${obj1 === obj2}\") } class Airplane { } equals = true compare = true 執行結果==與===都是比較記憶體位址是否相同。 toString() 印出package+class name@16進制的hashCode 1 2 3 4 5 6 fun main() { val obj1 = Airplane(1, 500) println(obj1.toString()) } class Airplane(val id:Int, val capacity:Int = 0) { } Airplane@5674cd4d 印出物件，也是呼叫toString()的方法，以下程式碼的結果跟上面的一樣。 1 2 3 4 5 6 fun main() { val obj1 = Airplane(1, 500) println(obj1) } class Airplane(val id:Int, val capacity:Int = 0) { } Airplane@5674cd4d hashCode 使用記憶體位址進行運算，每個物件的hashCode是不相同的。 1 2 3 4 5 6 fun main() { val obj1 = Airplane(1, 500) println(obj1.hashCode()) } class Airplane(val id:Int, val capacity:Int = 0) { } 1450495309"
  },"/pages/kotlin/data_class/": {
    "title": "Data class",
    "keywords": "",
    "url": "/pages/kotlin/data_class/",
    "body": "Prerequisites: Any Java ==與equals ==與=== 一般類別繼承Any，所以==與===都是比較記憶體位址是否相同。 Data class資料類別會自動覆寫equals()， 所以==是比較內容是否相同，===是比較記憶體位址是否相同。 1 2 3 4 5 6 7 8 fun main() { val obj1 = Airplane(1, 500) val obj2 = Airplane(1, 500) println(\"equals = ${obj1 == obj2}\") println(\"compare = ${obj1 === obj2}\") } data class Airplane(val id:Int, val capacity:Int = 0) { } equals = true compare = false toString() Data class資料類別會自動覆寫toString()。 1 2 3 4 5 6 fun main() { val obj1 = Airplane(1, 500) println(obj1.toString()) } data class Airplane(val id:Int, val capacity:Int = 0) { } Airplane(id=1, capacity=500) copy() 拷貝 使用copy()拷貝物件，參數可以是要修改的屬性。 1 2 3 4 5 6 7 8 fun main() { val obj1 = Airplane(1, 500) // 參數可以為要修改的屬性 val obj2 = obj1.copy(id = 10) println(obj2) } data class Airplane(val id:Int, val capacity:Int = 0) { } Airplane(id=10, capacity=500) copy()不支援次要建構式 次要建構式多了weight屬性。 1 2 3 4 5 6 7 8 9 10 11 data class Airplane(val id: Int, val capacity: Int = 0) { var weight: Int = 0; constructor(id: Int, capacity: Int, weight: Int) : this(id, capacity) { this.weight = weight } override fun toString(): String { return \"Airplane(id=$id, capacity=$capacity, weight=$weight)\" } } 使用次要建構式測試。 1 2 3 4 5 6 fun main() { val obj1 = Airplane(1, 500, 100) println(obj1) val obj2 = obj1.copy(id = 10) println(obj2) } Airplane(id=1, capacity=500, weight=100) Airplane(id=10, capacity=500, weight=0) 由執行結果可以發現，obj2的weight仍是0，沒有跟著copy過來。 解構 Component 解構 Data Class自動就會寫Componet的語法，不用自己寫。 1 2 3 4 fun main() { val(id, capacity) = Airplane(7, 500) println(\"id = $id, capacity = $capacity\") } id = 7, capacity = 500"
  },"/pages/java/extends_tricky/": {
    "title": "繼承 Tricky",
    "keywords": "",
    "url": "/pages/java/extends_tricky/",
    "body": "Prerequisites: 建構子 父類別與祖父類別都有相同屬性 父類別與祖父類別都有hobby。 1 2 3 4 5 6 7 8 9 10 11 12 13 class GrandPa { String name = \"GrandPa\"; String hobby = \"Swimming\"; int age = 88; } class Father extends GrandPa{ String name = \"Father\"; String hobby = \"Running\"; private int age = 50; } class Child extends Father{ String name = \"Child\"; } 請問呼叫子類別hobby，會印出那個hobby？ 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Child child = new Child(); System.out.println(child.hobby); } } Running 從執行結果，子類會先從父類別搜尋有沒有hobby這個屬性，若有的話，就傳回，不再去搜尋祖父類別。 父類別屬性是private，祖父類別不是private 上面的程式碼中，父類別的age是private，但祖父類別的age不是private，請問子類別使用age，會發生什麼事？ 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Child child = new Child(); System.out.println(child.age); } } 執行結果是無法存取age屬性，因為先從父類別搜尋屬性，有搜尋到age屬性，但age是private，就傳回無法存取。因為有搜尋到屬性，即便是private，就不會再往祖父類別搜尋。"
  },"/pages/java/object/": {
    "title": "Object",
    "keywords": "",
    "url": "/pages/java/object/",
    "body": "toString() 印出package+class name@16進制的hashCode 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Test test = new Test(); System.out.println(test.toString()); } } inherit2.Test@33c7353a 印出物件，也是呼叫toString()的方法，以下程式碼的結果跟上面的一樣。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Test test = new Test(); System.out.println(test); } } inherit2.Test@33c7353a hashCode() 使用記憶體位址進行運算，每個物件的hashCode是不相同的。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Test test = new Test(); System.out.println(test.hashCode()); } } 868693306"
  },"/pages/kotlin/extends/": {
    "title": "繼承 覆寫 轉型",
    "keywords": "",
    "url": "/pages/kotlin/extends/",
    "body": "Prerequisites: 繼承父類別建構式 open Kotlin預設是不能被繼承，若要讓類別可以被繼承，在class前面加上open。 在fun前面加上open，才能被子類別覆寫。 在變數前面加上open，才能被子類別覆寫。 1 2 3 4 open class Parent { // 使用open class open var name: String = \"\" // 使用open 變數 open fun showData() {} // 使用open fun } override 子類別 : 父類別()來繼承父類別。 覆寫父類別的方法，前面要加上override。 1 2 3 4 open class Parent { // 使用open class open var name: String = \"Parent\" // 使用open 變數 open fun showData() {} // 使用open fun } 1 2 3 4 5 6 7 8 9 class Child : Parent() { override var name: String = \"Child\" set(value) { field = value.trim() } override fun showData() { // 使用override fun println(\"name = $name\") } } 1 2 3 4 5 6 fun main() { var child: Child = Child() child.showData() child.name = \" Alex \" child.showData() } name = Child name = Alex 多型 多型就是類型是父類別，實際上指向子類別，執行時也是子類別。 1 2 3 4 5 6 fun main() { var obj: Parent = Child() obj.showData() obj.name = \" Alex \" obj.showData() } name = Child name = Alex 轉型as 在子類別增加一個方法showInfo，這個方法只有子類別才有。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Child : Parent() { override var name: String = \"Child\" set(value) { field = value.trim() } override fun showData() { // 使用override fun println(\"name = $name\") } fun showInfo() { println(\"這是子類別才有的方法\") } } 在多型的狀況下，類型是父類別，根本找不到showInfo()的方法。 1 2 3 4 5 6 7 fun main() { var obj: Parent = Child() obj.showData() //以下無法執行 obj.showInfo() } 需要將類型是父類別，轉型成類型是子類別。 1 2 3 4 5 6 7 fun main() { var obj: Parent = Child() obj.showData() //以下可以執行了 (obj as Child).showInfo() } name = Child 這是子類別才有的方法 不可能每一次呼叫showInfo()都要轉型，kotlin支援只要執行過一次as，obj不用再轉型。 1 2 3 4 5 6 7 8 9 fun main() { var obj: Parent = Child() obj.showData() //以下可以執行了 (obj as Child).showInfo() obj.showInfo() obj.showInfo() } name = Child 這是子類別才有的方法 這是子類別才有的方法"
  },"/pages/kotlin/class/": {
    "title": "類別",
    "keywords": "",
    "url": "/pages/kotlin/class/",
    "body": "類別body body又稱為主體，包含屬性、方法、建構子、內部類別。 class 類別名 { // 類別body } Student類別。 1 2 3 4 class Student { // 屬性 var name = \"Alice\" } 建立物件 建立物件，並把物件指派給變數。 var 變數 = 類別名() val 變數 = 類別名() 建立物件，並把物件指派給student變數。 1 2 3 4 5 6 7 class Student { var name = \"Alice\" } fun main() { // 建立物件 var student = Student() } val物件變數 此處的val並不是不能修改物件的屬性，而是不能再把val物件變數指向其它物件。 1 2 3 4 5 6 7 8 9 class Student { var name = \"Alice\" } fun main() { // val物件變數 val student2 = Student() // 以下會出錯 因為Val cannot be reassigned student2 = Student() } val物件變數，可以修改物件的屬性，以下程式碼把name指派新的值。 1 2 3 4 5 6 7 8 class Student { var name = \"Alice\" } fun main() { val student2 = Student() student2.name = \"Doris\" println(student2.name) } Doris 方法 方法為類別的行為、動作。 在類別中，宣告一個方法用fun開頭。 1 2 3 4 5 6 7 8 class Student { fun goToSchool() { } fun takeClass() { } } 方法互相呼叫。 1 2 3 4 5 6 7 8 class Student { fun goToSchool() { takeClass() } fun takeClass() { } } 物件呼叫方法。 1 2 val student = Student() student.takeClass()"
  },"/pages/kotlin/extends_constructor/": {
    "title": "extends constructor",
    "keywords": "",
    "url": "/pages/kotlin/extends_constructor/",
    "body": "Prerequisites: constructor open Kotlin預設是不能被繼承，若要讓類別可以被繼承，在class前面加上open。 1 2 open class Parent { // 使用open class } 父類別無主要建構式 父類別預設主要建構式 父類別沒寫主要建構子，會有一個預設的主要建構式產生。 1 2 open class Parent { } 預設的主要建構式。 1 2 open class Parent constructor() { } 子類別繼承父類別 子類別繼承父類別時，要呼叫主要建構式，即便父類別沒寫主要建構式，子類別還是要用父類別()，呼叫主要建構式。 1 2 3 4 5 6 7 8 // 父類別沒寫主要建構子 open class Parent { } // 子類別繼承時要呼叫父類別的主要建構式() class Child : Parent() { } 父類別有主要建構式 1 2 open class Parent(val name: String, val age: Int) { } 子類別繼承父類別 子類別要把父類別的建構式的參數，寫在子類別的主要建構式中。 子類別主要建構式的參數，不能有val、var。 把子類別主要建構式的參數，代入繼承父類別建構式中。 參數會代入父類別的主要建構式。 1 2 class Child(name: String, age:Int) : Parent(name, age) { } 為什麼要這樣做？因為繼承的時候，要呼叫父類別的主要建構式，建立父類別屬性。 就像Java中，子類別繼承父類別，預設會呼叫super()，建立父類別。 子類別沒有主要建構式 若子類別沒有主要建構式，要在次要建構式中，使用super，呼叫父類別的主要建構式。 步驟如下: 繼承，不用 : 父類別(參數, 參數)，直接 : 父類別 使用constructor關鍵字，建立次要建構式。 把父類別的主要建構式的參數，寫在子類別的次要建構式中。 子類別次要建構式的參數，不能有val、var。 使用super關鍵字，把子類別次要建構式的參數，代入繼承父類別建構式。 參數會代入父類別的主要建構式。 1 2 3 4 class Child: Parent { constructor(name: String, age:Int) : super(name, age) { } } 繼承父類次要建構式 父類別有主要建構式和次要建構式 1 2 3 4 5 6 7 8 open class Parent(val name: String, val age: Int) { var hobby: String = \"\" constructor(name: String, age: Int, hobby: String) : this(name, age) { this.hobby = hobby } } 子類別繼承呼叫父類次要建構式。 1 2 3 4 5 class Child : Parent { constructor(name: String, age: Int, hobby: String) : super(name, age, hobby) { } } 父類別沒有主要建構式 1 2 3 4 open class Parent { constructor(name: String) { } } 子類別繼承呼叫父類次要建構式。 1 2 3 4 class Child : Parent { constructor(name: String) : super(name) { } } 主要建構式權限修飾子 若主要建構式有權限修飾子，要把constructor寫出來，次建構式要用this()呼叫主要建構式。 1 2 3 4 open class Parent protected constructor() { constructor(name: String) : this() { } } 結論 不管如何，都要繼承其中一個父類建構式，管它是主要建構式或次要建構式，一定要繼承其中一個。"
  },"/pages/kotlin/modifier/": {
    "title": "存取修飾子",
    "keywords": "",
    "url": "/pages/kotlin/modifier/",
    "body": "四種存取修飾子 public private protected internal 只能在同一個module中存取。 屬性 在屬性前面加上存取修飾子。 1 2 3 class Cat4 { private var age:Int = 0 } 在set前面加上存取修飾子，代表不允許其它地方設值，只有本身的類別可以設值。 1 2 3 4 5 6 class Cat4 { var name:String = \"\" private set(value) { field = value } } 可簡化為: 1 2 3 4 class Cat4 { var name:String = \"\" private set } 方法 在fun前面加上存取修飾子。 1 2 3 4 5 class Cat4 { protected fun run() { } } 建構子 1 2 open class Parent protected constructor (val name: String) { } 類別 1 2 internal open class Parent { }"
  },"/pages/kotlin/inner/": {
    "title": "內部類別",
    "keywords": "",
    "url": "/pages/kotlin/inner/",
    "body": "Prerequisites: Java內部類別 語法 外部類別{ 內部類別{ } } 1 2 3 4 5 6 7 class Outter2 { class Inner(val name: String) { fun show() { println(\"inner class name = $name\") } } } 使用方法 外部類別名.內部類別名(主要建構式).方法() 1 2 3 fun main() { Outter2.Inner(\"Mary\").show() } inner class name = Mary"
  },"/pages/kotlin/lazy/": {
    "title": "lazy",
    "keywords": "",
    "url": "/pages/kotlin/lazy/",
    "body": "所謂的lazy是指，當要使用時才初始化變數的內容。 類似靜態內部類別，使用到了，才會建立類別。 語法 val 變數名 by lazy { ... } 程式碼 1 2 3 4 5 6 7 8 class Test { // 使用的時候，才初始化變數 val info by lazy { load() } private fun load(): String { println(\"load setting\") return \"infomation\" } } 測試程式 1 2 3 4 5 6 7 fun main() { val test: Test = Test() // 暫停3秒 Thread.sleep(3000) // 3秒後才使用這個變數，使用的時候才初始化變數內容 println(test.info) }"
  },"/pages/kotlin/object_anonymous/": {
    "title": "object 匿名類別",
    "keywords": "",
    "url": "/pages/kotlin/object_anonymous/",
    "body": "Prerequisites: Java匿名類別 什麼是匿名類別？就是子類別沒有名字，由父類別或介面、或抽象類別的名字來建立的子類別。 語法 object : 類別 或 介面 或 抽象類別(建構子) { 子類別的內容 ....覆寫變數.... ....覆寫方法.... } 1 2 3 4 5 6 7 8 9 10 11 12 13 fun main() { // 建立Parent的子類別 val obj1 = object: Parent() { override fun showData() { println(\"匿名類別的方法\") } } obj1.showData() } open class Parent { // 使用open class open var name: String = \"Parent\" // 使用open 變數 open fun showData() {} // 使用open fun } 匿名類別的方法"
  },"/pages/kotlin/object_companion/": {
    "title": "object與companion object",
    "keywords": "",
    "url": "/pages/kotlin/object_companion/",
    "body": "Prerequisites: Singleton 靜態內部類別 object 類別 這裡的object，指的是就只有一個物件，不管被建立幾次，只會被建立一次。 Singleton的概念。 語法 object 類別名 { } 使用方法 類別名.方法() 類別名.屬性名 建立object物件 1 2 3 4 5 6 7 8 9 object Single { val name:String = \"Single\" fun method1() { println(\"method1\") } fun method2() { println(\"method2\") } } 測試 1 2 3 4 5 6 7 8 fun main() { Single.method1() Single.method2() println(Single.name) println(Single.hashCode()) println(Single.hashCode()) println(Single.hashCode()) } method1 method2 Single 1450495309 1450495309 1450495309 hashCode如同物件身份證，代表印出三次Single物件，hashCode都相同，代表同一個物件。 companion object 跟靜態內部類別一樣，用到的時候才會被載入。 class 外部類別 { companion object { 變數 方法 } } 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Outter { init { println(\"建立外部類別\") } companion object { val info: String = \"info\" init { println(\"建立內部類別\") } fun load() { println(\"載入資訊...\") } } } 只能透過類別名，才能呼叫companion object建立的變數與方法。 類別名.方法 類別名.變數 以下會編譯錯誤。 1 2 3 4 5 6 fun main() { val obj = Outter() // 以下編譯錯誤 obj.info obj.load() } 透過外部類別名，才能取得方法與變數名。 1 2 3 4 fun main() { Outter.load() println(Outter.info) } 載入資訊... info"
  },"/pages/java/annotation/": {
    "title": "Annotation",
    "keywords": "",
    "url": "/pages/java/annotation/",
    "body": "Annotation，中文稱為標註。 Annotation主要用於檢查。 三種Annotation 用 @ 開頭。 @Override 覆寫父類別方法。 @Deprecated 類別或方法已棄用。 @SuppressWarnings 抑制編譯器警告。 @Override @Override錯誤 @Override只能用在方法。 即便不寫@Override，編譯器也會自動判斷是覆寫方法。 寫了@Override，編譯器會去檢查父類別是否有這個方法，如果父類別沒這個方法，是@Override錯誤。 父類別 1 2 3 4 5 6 7 8 class Father { void method1() { System.out.println(\"Father method1\"); } void method2() { System.out.println(\"Father method2\"); } } 子類別 1 2 3 4 5 6 7 8 class Child extends Father { // 此處是@Override錯誤，父類別根本沒有method3() @Override void method3() { this.method2(); System.out.println(this.hobby); } } @Override原始碼 @interface 代表是一個Annotation。 @Target 只能用在方法 METHOD 1 2 3 4 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } @Deprecated 代表已棄用，但不代表不能用，是不推薦使用。 在類別或方法、屬性上面加上@Deprecated 1 2 3 4 5 6 7 8 9 @Deprecated class Test1 { @Deprecated String name; @Deprecated public void method() { } } @Deprecated原始檔 @Documented 可用於Java Doc文件上。 @Target 可用於建構子、屬性、區域變數、方法、package、模組、參數、類型 1 2 3 4 5 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE}) public @interface Deprecated { } @SuppressWarnings 抑制警告 以下紅框的部分就是警告。 加上以下標註，就沒有警告了。 @SuppressWarnings({\"all\"}) ({\"??\"})裡面可以填寫什麼呢？ all，抑制所有警告 boxing，抑制拆箱/裝箱的警告 cast，抑制強制轉型的警告 dep-ann，抑制棄用註釋的警告 deprecation，抑制棄用的警告 fallthrough，抑制與 switch 陳述式中遺漏 break 相關的警告 finally，抑制finally 區塊相關的警告 hiding，抑制與隱藏變數的區域變數相關的警告 incomplete-switch，抑制與 switch 陳述式 (enum case) 中遺漏項目相關的警告 javadoc，抑制與 javadoc 相關的警告 nls，抑制與非 nls 字串文字相關的警告 null，抑制與空值分析相關的警告 rawtypes，抑制raw 類型相關的警告 resource，抑制與使用 Closeable 類型的資源相關的警告 restriction，抑制與使用不建議或禁止參照相關的警告 serial，抑制與序列化相關的警告 static-access，抑制與靜態存取不正確相關的警告 static-method，抑制與可能宣告為 static 的方法相關的警告 super，抑制與置換方法相關但不含 super 呼叫的警告 synthetic-access，抑制與內部類別的存取未最佳化相關的警告 sync-override，抑制因為置換同步方法而遺漏同步化的警告 unchecked，抑制沒有檢查的警告 unqualified-field-access，抑制與欄位存取不合格相關的警告 unused，抑制沒有使用的警告 把滑鼠移到警告的黃色線，會提示Raw use，因為不知道List裝的是什麼類型。 填上rawtypes，警告馬上變成綠色。 把滑鼠移到警告的黃色線，會提示unchecked，沒有檢查類型。 填上unchecked，警告馬上變成綠色。 程式碼 1 2 3 4 5 6 7 8 public class Test { @SuppressWarnings({\"rawtypes\", \"unchecked\"}) public static void main(String[] args) { List list = new ArrayList(); list.add(\"adfd\"); list.add(\"cccc\"); } } SuppressWarnings原始碼 1 2 3 4 @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); // 是陣列，可以傳入rawtypes,unchecked,unused...等等 } 描述標註的標註 @Retention 標註的保留 1 @Retention(RetentionPolicy.SOURCE) RetentionPolicy是列舉enum，有下面三種。 SOURCE 程式碼編譯完，就會清掉程式碼中的標註。 CLASS 編譯完後，程式碼仍保留標註在.class，但執行時，就會清掉。 RUNTIME 執行時，標註仍保留在class物件中，可通過反射找到標註。 下圖中，1與2是標註被清掉的位置。 @Target 標註使用的位置，可以是建構子、屬性、區域變數、方法、package、模組、參數、類型TYPE。 TYPE可以為類別、介面、enum列舉…等等。 1 @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE}) @Documented 可在Java Doc顯示出來標註。"
  },"/pages/java/array/": {
    "title": "陣列",
    "keywords": "",
    "url": "/pages/java/array/",
    "body": "靜態分配 一開始就定義陣列中的值。 1 2 char[] arr1 = {'H', 'e', 'l', 'l', 'o'}; int[] arr2 = {0, 1, 2, 3}; 動態分配 先定義記憶體大小，之後再動態分配陣列的值。 1 2 3 4 int arr[] = new int[3]; arr[0] = 1; arr[1] = 2; arr[2] = 3; []可放在類型後面，也可以放在變數後面，擇一放置。 1 int[] arr = new int[3]; 字元陣列與print 印出字元陣列就是印出字串。 1 2 3 4 5 char arr[] = new char[3]; arr[0] = 'A'; arr[1] = 'B'; arr[2] = 'C'; System.out.println(arr);"
  },"/pages/java/final/": {
    "title": "final",
    "keywords": "",
    "url": "/pages/java/final/",
    "body": "final修飾的範圍 區域中的變數、全域變數、類別、屬性、方法。 不能放在建構子前面。 final 常數 final放在變數前，代表變數的值不能被修改，而且一定要給預設值。 因為值不能被修改，所以不是變數，是常數。 1 2 3 final String msg = \"Test\"; // 下面會編譯錯誤 msg = \"ABC\"; 參數x是final，但下面程式碼不會有錯誤，因為並沒有修改到x。 1 2 3 public int add(final int x) { return x + 1; } 若使用x++就會有錯誤，因為x++就是x = x + 1，是修改x常數，但是final不能被修改。 1 2 3 4 5 public int add(final int x) { // x++; return x + 1; } final與陣列 Prerequisites: 陣列記憶體模型 final對於陣列而言，變數是不能再指向其它陣列。 1 2 3 4 final char[] arr1 = {'H', 'e', 'l', 'l', 'o'}; char[] arr2 = {'W', 'o', 'r', 'l', 'd'}; // 下面會編譯錯誤，arr1不能再指向其它陣列。 arr1 = arr2; 但可以修改陣列裡的內容。 1 2 3 4 5 6 7 final char[] arr1 = {'H', 'e', 'l', 'l', 'o'}; arr1[0] = 'W'; arr1[1] = 'o'; arr1[2] = 'r'; arr1[3] = 'l'; arr1[4] = 'd'; System.out.println(arr1); World 類別中的final 常數 final放在屬性前，就變成常數，因為不能再改變，而且一定要給預設值。 final常數，不能再被修改，繼承的子類別也不能修改final常數，本身類別也不能修改final常數，只被設定一次。 常數名為大寫，用底線作分隔，例如: IMG_PATH 1 2 3 public class Test { public final String IMG_URL = \"http://xxxxxxx\"; } 在下面幾種情況，final可以不設預設值 不是static的final final原本一定要設預設值。 1 public final String IMG_URL = \"http://xxxxxxx\"; 下面的狀況下，可以不用設預設值。 在建構子中會設定final的值，final就可以不設預設值。 1 2 3 4 5 6 7 public class Test { public final String IMG_URL; public Test(String IMG_URL) { this.IMG_URL = IMG_URL; } } 在匿名區塊會設定final的值，final就可以不設預設值。 1 2 3 4 5 6 7 public class Test { public final String IMG_URL; { IMG_URL = \"http://xxxxxx\"; } } final static final static 原本一定要設預設值。 1 public final static String IMG_URL = \"http://xxxxxx\"; 在以下的狀況，可以不用設預設值。 在靜態區塊會設定final static的值，final static就可以不設預設值。 1 2 3 4 5 public class Test { public final static String IMG_URL; static { IMG_URL = \"http://xxxxxx\"; } final + static 不會呼叫靜態區塊 編譯器看到final static 基本型態，就會自動把它的值，取出來進行覆蓋。 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { System.out.println(WebSite.IMG_URL); } } class WebSite { public final static String IMG_URL = \"http://xxxxxx\"; static { System.out.println(\"靜態區塊初始化\"); } } 編譯後，就會變成以下內容，所以執行這段程式碼根本看不到WebSite這個類別。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { // 原本是System.out.println(WebSite.IMG_URL); System.out.println(\"http://xxxxxx\"); } } http://xxxxxx final 類別 為什麼會有final類別呢？有一些基礎的類別，不想再被人繼承，也不想被人覆寫方法。String、Double、Integer…都是final 類別。 不能被繼承 1 2 3 // 父類別不能被繼承 final class Parent { } 子類別繼承final父類別，會編譯錯誤。 1 2 3 // 以下程式碼會編譯錯誤 class Child extends Parent { } 可以建立物件 final Parent 1 2 final class Parent { } 建立Parent物件。 1 2 3 4 5 public class Test { public static void main(String[] args) { Parent parent = new Parent(); } } final類別中的方法不用寫final 因為final類別不能被繼承，不會有子類別，所以不可能有子類別覆寫父類別方法。 以下的寫法畫蛇添足。 1 2 3 4 final class Parent { public final void method() { } } final 方法 不能被子類別覆寫方法，但子類別可以使用父類別的方法。 父類別 1 2 3 4 5 class Parent { public final void method() { System.out.println(\"父類別方法1\"); } } 子類別嘗試覆寫method()，會編譯錯誤。 1 2 3 4 5 6 class Child extends Parent { // 以下程式碼編譯錯誤 public final void method() { System.out.println(\"子類別方法1\"); } } 子類別可以使用父類別方法。 1 2 3 4 5 6 class Child extends Parent { public final void method1() { // 使用父類別方法 super.method(); } }"
  },"/pages/java/sb/": {
    "title": "String Buffer",
    "keywords": "",
    "url": "/pages/java/sb/",
    "body": "Prerequisites: String 字串存放位置 String Buffer繼承AbstractStringBuilder。 字串存放位置是在AbstractStringBuilder中的value變數，不是final，char[]陣列是物件，是存在Heap中。 1 2 3 4 char[] value; AbstractStringBuilder(int capacity) { value = new char[capacity]; } String Buffer vs String String存放字串的位置，是final的，所以更新字串，就是建立新的物件，因為final不能被修改內容。 String Buffer存放字串的位置，不是final，所以更新字串，是更新物件內容，因為不用重新建立物件，所以效率比較快。 建構子 StringBuffer的空建構子，預設建立char[16]的大小。 1 2 3 public StringBuffer() { super(16); } 可自訂char[]大小。 1 StringBuffer stringBuffer = new StringBuffer(100); 使用字串建立StringBuffer。 1 StringBuffer stringBuffer = new StringBuffer(\"Hello World\"); 建立char[字串長度 + 16]的大小。 1 2 3 4 public StringBuffer(String str) { super(str.length() + 16); append(str); } append append傳回值就是StringBuffer。 1 2 StringBuffer sb = new StringBuffer(); StringBuffer sb2 = sb.append(\"abc\"); 會把基本型別，自動轉成字串。 1 2 3 StringBuffer sb = new StringBuffer(); sb.append(true).append(10.5).append(10); System.out.println(sb); true10.510 把boolean轉成字串原始碼。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public AbstractStringBuilder append(boolean b) { ensureCapacityInternal(count + (b ? 4 : 5)); int count = this.count; byte[] val = this.value; if (isLatin1()) { if (b) { val[count++] = 't'; val[count++] = 'r'; val[count++] = 'u'; val[count++] = 'e'; } else { val[count++] = 'f'; val[count++] = 'a'; val[count++] = 'l'; val[count++] = 's'; val[count++] = 'e'; } } StringBuffer轉String 使用toString()或者使用String建構子放入StringBuffer。 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { StringBuffer sb = new StringBuffer(\"Hello World\"); // 使用toString() String str1 = sb.toString(); // 使用String建構子 String str2 = new String(sb); System.out.println(str1); System.out.println(str2); } } Hello World Hello World toString原始碼 重點是 new String()，new String是在heap建立記憶體空間，不是在String pool建立記憶體空間。 1 2 3 4 5 6 7 public synchronized String toString() { if (toStringCache == null) { return toStringCache = new String(this, null); } // 重點是 new String return new String(toStringCache); } StringBuffer常用方法 delete StringBuffer delete(int start, int end) start &lt;= range &lt; end range就是要刪的範圍，不包含end。 1 2 3 4 StringBuffer sb = new StringBuffer(\"Hello world,貓咪\"); // 1 &lt;= x &lt; 4 sb.delete(1,4); System.out.println(sb); Ho world,貓咪 replace 修改可當作replace取代。 StringBuffer replace(int start, int end, String str) start &lt;= range &lt; end range就是要取代的範圍，不包含end。 1 2 3 StringBuffer sb = new StringBuffer(\"貓咪Hello world\"); sb.replace(1, 4, \"狗\"); System.out.println(sb); 貓狗llo world indexOf 第一次找到的位置，由左往右。 1 2 3 StringBuffer sb = new StringBuffer(\"貓咪Hello world\"); int index = sb.indexOf(\"咪\"); System.out.println(index); 1 insert 在指定位置插入字串，原本的位置往後移到插入字串的後面。 1 2 3 StringBuffer sb = new StringBuffer(\"貓咪Hello world\"); sb.insert(1, \"恐龍\"); System.out.println(sb); 貓恐龍咪Hello world length長度 1 2 StringBuffer sb = new StringBuffer(\"貓咪Hello world\"); int len = sb.length(); null 建構子傳null 1 2 3 String str = null; StringBuffer sb = new StringBuffer(str); System.out.println(sb.length()); 在父類別AbstractStringBuilder的建構子中，str.length()會拋出例外，因為str是null。 1 2 3 4 AbstractStringBuilder(String str) { int length = str.length(); // .... } append傳null 先到父類別的appendNull()方法 1 2 3 4 5 6 public AbstractStringBuilder append(String str) { if (str == null) { return appendNull(); } // .... } appendNull，會把null的字串加在字元陣列中。 1 2 3 4 5 6 7 8 9 10 11 12 private AbstractStringBuilder appendNull() { ensureCapacityInternal(count + 4); int count = this.count; byte[] val = this.value; if (isLatin1()) { val[count++] = 'n'; val[count++] = 'u'; val[count++] = 'l'; val[count++] = 'l'; } else { // .... } 以下執行結果為4 1 2 3 4 String str = null; StringBuffer sb = new StringBuffer(); sb.append(str); System.out.println(sb.length()); 4 lastIndexOf與insert進階 lastIndexOf是由最後面往前找，找到就傳回位置。 12345.67 轉成 12,345.67 1 2 3 4 5 6 StringBuffer sb = new StringBuffer(\"12345.67\"); // 找到小數點 int index = sb.lastIndexOf(\".\"); // 小數點前三位逗號 sb.insert(index - 3, \",\"); System.out.println(sb); 12,345.67 那如果前面的數字很長呢？例如:12345678910111213.11 1 2 3 4 5 6 7 StringBuffer sb = new StringBuffer(\"12345678910111213.11\"); // -3要放在初始值。 int index = sb.lastIndexOf(\".\") - 3; for (int i = index; i &gt; 0; i -= 3) { sb.insert(i, \",\"); } System.out.println(sb); 12,345,678,910,111,213.11"
  },"/pages/java/str_buffer_builder/": {
    "title": "StringBuilder vs StringBuffer",
    "keywords": "",
    "url": "/pages/java/str_buffer_builder/",
    "body": "StringBuilder使用方式跟StringBuffer一模一樣。 以下列出不同的地方。 執行緒安全 synchronized StringBuffer有synchronized StringBuffer在append()方法前面有synchronized。 1 2 3 4 5 public synchronized StringBuffer append(String str) { toStringCache = null; super.append(str); return this; } StringBuilder沒synchronized StringBuilder在append()方法前面是沒有synchronized。 1 2 3 4 public StringBuilder append(String str) { super.append(str); return this; } 效率 String String 以下的程式碼，執行到第2行，會產生以下步驟: 變數s與+會呼叫StringBuffer的append()方法。 呼叫toString()方法。 new String()建立物件。 在Heap中建立記憶體空間。 s變數指向Heap的記憶體位址。 String是final char[]陣列，經過步驟5，原本的final char[] value = \"a\"，這個物件就會變成孤兒，等待記憶體回收。 如果以下的程式碼進行2000次就會產生2000個孤兒，所以String的效率最慢。 1 2 String s = \"a\"; s += \"b\"; StringBuffer與StringBuilder StringBuffer與StringBuild不是final。 append、replace、delete，也只是對字元陣列進行修改，不會一直再建立新的物件，所以執行效率比String快。 1 char[] value = \"a\" 由於StringBuffer的append()是synchronized，一次只能被一個thread執行緒執行，其它執行緒們threads只能被卡住Blocked，等待synchronized方法中的執行緒做完，他們之中只有一個才能進入append()方法。 所以效率比Builder差，因為Builder不是執行緒安全。 執行效率程式碼 1秒 = 1000毫秒 0.5秒 = 500毫秒 0.1秒 = 100毫秒 0.001秒 = 1毫秒 請自行換算，以下執行結果是以毫秒為單位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Test2 { public static void main(String[] args) { long startT = System.currentTimeMillis(); String str = \"a\"; for (int i = 0; i &lt; 20000; i++) { str += \"b\"; } long endT = System.currentTimeMillis(); System.out.println(\"String = \" + (endT - startT)); startT = System.currentTimeMillis(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 2000; i++) { sb.append(i); } endT = System.currentTimeMillis(); System.out.println(\"StringBuffer = \" + (endT - startT)); startT = System.currentTimeMillis(); StringBuilder sbder = new StringBuilder(); for (int i = 0; i &lt; 2000; i++) { sbder.append(i); } endT = System.currentTimeMillis(); System.out.println(\"StringBuilder = \" + (endT - startT)); } } String = 92 StringBuffer = 2 StringBuilder = 1 由執行結果可以發現String要執行92毫秒，速度最慢。"
  },"/pages/java/sys_in_out/": {
    "title": "System.in System.out",
    "keywords": "",
    "url": "/pages/java/sys_in_out/",
    "body": "System.in 主要是作為鍵盤輸入串流。 透過getClass()，可以知道System.in的執行類型是BufferedInputStream，Buffered的意思是讀取的位址是在記憶體緩衝區。 1 System.out.println(System.in.getClass()); class java.io.BufferedInputStream Scanner Scanner掃描器，它的建構子參數是System.in鍵盤輸入串流。 1 Scanner scanner = new Scanner(System.in); Scanner會去鍵盤輸入串流中取得資料。 使用next()方法取得字串。 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"Please input:\"); String next = scanner.next(); System.out.println(next); } } 使用nextInt()，取得數字。 1 int next1 = scanner.nextInt(); System.out 執行類型是PrintStream，將資料顯示在螢幕。 1 System.out.println(System.out.getClass()); class java.io.PrintStream PrintStream的write() PrintStream繼承OutputStream，自然會有父類別的write方法。 1 2 3 4 5 6 7 public class Test2 { public static void main(String[] args) throws IOException { PrintStream out = System.out; out.write(\"測試\".getBytes()); out.close(); } } 設定PrintStream輸出文件位置 預設是顯示在顯示器，可以透過建構子，設定輸出的文件位置。 PrintStream(String fileName) 使用System.setOut 1 System.setOut(new PrintStream(\"文件路徑\")); 範例1 1 2 3 4 5 6 7 8 9 public class Test2 { public static void main(String[] args) throws IOException { // 使用System.setOut System.setOut(new PrintStream(\"/Users/cici/testc/print_out\")); PrintStream out = System.out; out.write(\"測試\".getBytes()); out.close(); } } 範例2 1 2 3 4 5 6 public class Test2 { public static void main(String[] args) throws IOException { System.setOut(new PrintStream(\"/Users/cici/testc/print_out\")); System.out.println(\"哈囉哈囉\"); } } PrintWriter 建構子是System.out，輸出到螢幕。 注意!使用時一定要close()，因為close()方法是寫入資料，如果沒呼叫close()，螢幕就不會顯示任何東西。 1 2 3 4 5 6 7 8 public class Test3 { public static void main(String[] args) { PrintWriter writer = new PrintWriter(System.out); writer.println(\"測試測試2\"); // 一定要close writer.close(); } } 建構子是FileWriter，輸出到檔案。 1 2 3 4 5 6 7 8 public class Test3 { public static void main(String[] args) throws IOException { PrintWriter writer = new PrintWriter(new FileWriter(\"/Users/cici/testc/print_out\")); writer.println(\"測試測試2\"); // 一定要close writer.close(); } }"
  },"/pages/java/classloader/": {
    "title": "Classloader類別載入",
    "keywords": "",
    "url": "/pages/java/classloader/",
    "body": "Prerequisites: metadata 什麼時候會載入類別？ 使用到靜態屬性、呼叫靜態方法、使用到靜態區塊、使用new建立物件。 以下程式碼使用到靜態屬性StaticTest.i，就會呼叫Class Loader載入類別到記憶體。 1 2 3 4 5 6 7 8 class StaticTest { static int i = 100; } public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.i); } } 類別載入至記憶體 會在metaspace建立metadata，裡面包含有類別所有屬性、方法、靜態變數…等等 接著在Heap建立一個Class物件，裡面也有屬性、方法、建構子…等等，但實際都是指向metadata的資料。 載入順序 Loading ClassLoader 載入.class ↓ 建立 metadata（Metaspace） 和 java.lang.Class（Heap） ↓ Linking（連接） ├── Verification（驗證） ├── Preparation（配置 static 區域預設值） └── Resolution ↓ Initialization（執行 clinit） → static 區塊與 static 欄位被初始化 Loading 載入類別 載入.class。 建立 metadata（Metaspace)和 java.lang.Class（Heap） Verification 檢查class 檔案格式正確 Preparation準備 把靜態變數預設為原本的值，假設int就是0，String就是null，float就是0.0f。 Resolution 在Preparation時，靜態變數是最原本預設值，int就是0，String就是null。 Resolution階段，把靜態變數變成程式碼中設定的值。 1 2 3 class StaticTest { static int i = 300; } Constatn Pool進行套件名、類別名、常數轉換。 Initialization初始化 執行靜態區塊。 1 2 3 4 5 6 class StaticTest { static { System.out.println(\"進到靜態區塊\"); i = 100; } static int i = 300; JVM會將上面的程式碼，把多餘的程式碼去掉或合併，透過Clinit()函式執行優化後的靜態區塊。 優化後: 1 2 3 4 5 6 class StaticTest { static { System.out.println(\"進到靜態區塊\"); i = 300; } } 若是用new建立物件，此階段也會呼叫匿名區塊與建構子。"
  },"/pages/java/metadata/": {
    "title": "Metadata",
    "keywords": "",
    "url": "/pages/java/metadata/",
    "body": "metadata 類別在ClassLoader載入時，會在Metaspace(Native memory)中，存放metadata，儲存類別的所有資訊，它是屬於C++結構，每一個類別只有一個metadata。 存放靜態值 static field 「value」 就是存靜態變數中的「值」。 以下程式碼，存放的是42。 1 2 3 public class MyClass { static int count = 42; } 靜態區塊 靜態區塊是放在靜態方法中。 Field info 包含類別所有靜態與非靜態屬性名、類型。 以下程式碼，存放的是static int與count屬性名。 1 2 3 public class MyClass { static int count = 42; } Method Info 包含類別中所有方法與建構子。 vtable 只有override的方法。 final方法與靜態方法、private方法不能覆寫，就沒有在裡面。 在多型的文章有vtable。 itable 只有實作介面的方法。 Constant pool Constant pool是存放編譯後，.class 檔案的內容，中所需要的常數資訊。 類別名與package 假設有下面的類別。 1 2 package com.example; public class MyClass {} constant pool儲存為 #1 = \"com/example/MyClass\" package套件名由點.轉成/ static final static 靜態 + final不可修改 + 基本型別，編譯器直接視它為常數，並把常數存在.class檔中，Classloader把類別載入時，就會把常數存到constant pool中。 所以執行下面程式碼，不會呼叫static{}，不會呼叫ClassLoader載入類別。 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { System.out.println(WebSite.IMG_URL); } } class WebSite { public final static String IMG_URL = \"http://xxxxxx\"; static { System.out.println(\"靜態區塊初始化\"); } } 編譯後，就會變成以下內容，不會呼叫WebSite這個類別。 1 2 3 4 5 public class Test { public static void main(String[] args) { System.out.println(\"http://xxxxxx\"); } } constant pool儲存http://xxxxxx #7 = String #25 // \"http://xxxxxx\" #25 = Utf8 http://xxxxxx String 遇到字串常數，編譯器直接視它為常數，並把常數存在.class檔中。 1 String str = \"hello\"; \"hello\"會被編譯後，存放在constant pool中。 類別載入後，當這些字串被使用時，JVM會從constant pool取出”hello”，放進String Pool，String Pool在jdk8以後都放在Heap記憶體區塊。"
  },"/pages/java/codeblock/": {
    "title": "靜態與匿名區塊執行順序",
    "keywords": "",
    "url": "/pages/java/codeblock/",
    "body": "Prerequisites: static 建構子 靜態屬性與靜態區塊的執行順序 靜態屬性與靜態區塊的執行順序根據程式碼的前後順序。 1 2 3 4 5 6 7 8 9 10 class StaticTest { static int i = getValue(); static { System.out.println(\"進到靜態區塊\"); } private static int getValue() { System.out.println(\"static 屬性 初始化\"); return 10; } } 1 2 3 4 5 public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.i); } } static 屬性 初始化 進到靜態區塊 10 靜態區塊使用還未宣告屬性 以下程式碼，靜態區塊先，裡面的i屬性可以不宣告就先使用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class StaticTest { static { System.out.println(\"進到靜態區塊\"); i = 100; } static int i = getValue(); private static int getValue() { System.out.println(\"static 屬性 初始化\"); return 10; } } public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.i); } } 進到靜態區塊 static 屬性 初始化 10 靜態屬性與成員屬性的執行順序 以下程式碼靜態屬性與靜態區塊一定先執行，因為是類別要先載入，靜態屬性與靜態區塊是屬於類別。 類別載入完畢，才會執行物件相關。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class StaticTest { private int i = getValue(); static { System.out.println(\"進到靜態區塊\"); si = 100; } static int si = getSValue(); private static int getSValue() { System.out.println(\"static 屬性 初始化\"); return 10; } private static int getValue() { System.out.println(\"成員 屬性 初始化\"); return 100; } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 進到靜態區塊 static 屬性 初始化 成員 屬性 初始化 建構子與成員屬性執行順序 根據程式碼的前後順序，以下是成員屬性先，建構子後。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class StaticTest { private int i = getValue(); StaticTest() { System.out.println(\"建構子 初始化\"); } private static int getValue() { System.out.println(\"成員 屬性 初始化\"); return 100; } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 成員 屬性 初始化 建構子 初始化 匿名區塊與建構子執行順序 匿名區塊一定優先建構子。 1 2 3 4 5 6 7 8 9 10 11 12 13 class StaticTest { StaticTest() { System.out.println(\"建構子 初始化\"); } { System.out.println(\"匿名區塊 初始化\"); } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 匿名區塊 初始化 建構子 初始化 匿名區塊與成員屬性執行順序 執行順序根據程式碼的前後順序。 成員屬性在前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class StaticTest { private int i = getValue(); StaticTest() { System.out.println(\"建構子 初始化\"); } { System.out.println(\"匿名區塊 初始化\"); } private static int getValue() { System.out.println(\"成員 屬性 初始化\"); return 100; } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 成員 屬性 初始化 匿名區塊 初始化 建構子 初始化 匿名區塊在前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class StaticTest { StaticTest() { System.out.println(\"建構子 初始化\"); } { System.out.println(\"匿名區塊 初始化\"); } private int i = getValue(); private static int getValue() { System.out.println(\"成員 屬性 初始化\"); return 100; } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 匿名區塊 初始化 成員 屬性 初始化 建構子 初始化 靜態與建構子初始化順序 請問以下程式碼執行順序？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class StaticTest { StaticTest() { System.out.println(\"建構子 初始化\"); } { System.out.println(\"匿名區塊 初始化\"); } private int i = getI(); private int getI() { System.out.println(\"成員屬性 初始化\"); return 55; } static int count = getValue(); static { System.out.println(\"靜態 區塊 初始化\"); } private static int getValue() { System.out.println(\"靜態 屬性 初始化\"); return 100; } } public class Test2 { public static void main(String[] args) { new StaticTest(); } } 靜態 屬性 初始化 靜態 區塊 初始化 匿名區塊 初始化 成員屬性 初始化 建構子 初始化 由執行結果可以發現，靜態一定先執行。 只使用靜態屬性，建構子會執行嗎？ 以下程式碼執行結果是什麼？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.count); } } class StaticTest { StaticTest() { System.out.println(\"建構子 初始化\"); } { System.out.println(\"匿名區塊 初始化\"); } private int i = getI(); private int getI() { System.out.println(\"成員屬性 初始化\"); return 55; } static int count = getValue(); static { System.out.println(\"靜態 區塊 初始化\"); } private static int getValue() { System.out.println(\"靜態 屬性 初始化\"); return 100; } } 靜態 屬性 初始化 靜態 區塊 初始化 100 從結果可以發現只有靜態相關的會執行，而建構子與匿名區塊不會執行。 靜態屬性是建構子 以下程式碼，靜態屬性為本身類別的建構子，靜態屬性也是成員屬性，只是儲存靜態屬性的位置是同一個記憶體位址，記憶體位址是共享。 先前提過靜態屬性與靜態區塊的執行順序是根據程式碼前後。 所以以下程式碼會先執行建構子，才執行靜態區塊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class StaticTest { static StaticTest instance = new StaticTest(); public StaticTest() { System.out.println(\"建構子初始化\"); } static { System.out.println(\"靜態區塊初始化\"); } } public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.instance); } } 建構子初始化 靜態區塊初始化 static_.StaticTest@681a9515 靜態屬性與靜態區塊只會被執行一次 以下程式碼，不管執行幾次，建構子與靜態區塊，只有執行一次。 靜態屬性instance的hashCode都是一模一樣的，hashCode代表一個物件的身份證，是根據記憶體位址換算出來的數字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class StaticTest { static StaticTest instance = new StaticTest(); public StaticTest() { System.out.println(\"建構子初始化\"); } static { System.out.println(\"靜態區塊初始化\"); } } public class Test2 { public static void main(String[] args) { System.out.println(StaticTest.instance.hashCode()); System.out.println(StaticTest.instance.hashCode()); System.out.println(StaticTest.instance.hashCode()); System.out.println(StaticTest.instance.hashCode()); } } 建構子初始化 靜態區塊初始化 1746572565 1746572565 1746572565 1746572565 繼承與靜態屬性 父類別有靜態屬性count，靜態區塊。 1 2 3 4 5 6 class Father { static int count = 0; static { System.out.println(\"Father static init\"); } } 子類別有靜態屬性count，靜態區塊。 1 2 3 4 5 6 class Child extends Father{ static int count = 5; static { System.out.println(\"Child static init\"); } } 呼叫子類別的靜態屬性，沒有new，請問靜態區塊如何呼叫嗎？ 1 2 3 4 5 public class Test2 { public static void main(String[] args) { System.out.println(Child.count); } } Father static init Child static init 5 由執行結果可以發現，父類別先呼叫靜態區塊。 接著呼叫子類別靜態區塊。 繼承與子類別方法覆寫。 父類別 1 2 3 4 5 6 7 8 9 10 11 12 13 class Father { int i = getI(); int getI() { System.out.println(\"Father 屬性初始化\"); return 20; } Father() { System.out.println(\"Father建構子初始化\"); } { System.out.println(\"Father 匿名初始化\"); } } 子類別 1 2 3 4 5 6 7 8 9 10 11 12 13 class Child extends Father{ int i = getI(); int getI() { System.out.println(\"Child 屬性初始化\"); return 20; } Child() { System.out.println(\"Child建構子初始化\"); } { System.out.println(\"Child 匿名初始化\"); } } 執行測試 1 2 3 4 5 public class Test2 { public static void main(String[] args) { new Child(); } } Child 屬性初始化 &lt;- 居然先執行？ Father 匿名初始化 Father建構子初始化 Child 屬性初始化 Child 匿名初始化 Child建構子初始化 為什麼是Child 屬性初始化先執行？因為子類覆寫父類別的getI()方法，所以會執行getI()，實際上是呼叫子類別的getI()。 1 2 3 4 5 6 7 class Father { int i = getI(); // 實際上是呼叫子類別的getI int getI() { System.out.println(\"Father 屬性初始化\"); return 20; } } 若程式碼修正如下，執行結果也就如預期正常。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Father { int i = getFI(); int getFI() { System.out.println(\"Father 屬性初始化\"); return 20; } Father() { System.out.println(\"Father建構子初始化\"); } { System.out.println(\"Father 匿名初始化\"); } } class Child extends Father{ int i = getI(); int getI() { System.out.println(\"Child 屬性初始化\"); return 20; } Child() { System.out.println(\"Child建構子初始化\"); } { System.out.println(\"Child 匿名初始化\"); } } Father 屬性初始化 Father 匿名初始化 Father建構子初始化 Child 屬性初始化 Child 匿名初始化 Child建構子初始化 由執行結果可以發現會先執行父類別的屬性-&gt;匿名區塊-&gt;建構子，然後才執行子類別。 建立物件就呼叫匿名區塊 靜態區塊只會執行一次，匿名區塊跟建構子一樣，每建立一次物件就呼叫一次。 1 2 3 4 5 6 7 8 9 10 11 12 13 class StaticTest { public StaticTest() { System.out.println(\"建構子初始化\"); } { System.out.println(\"匿名區塊初始化\"); } static { System.out.println(\"靜態區塊初始化\"); } } 建立二次物件。 1 2 3 4 5 6 public class Test2 { public static void main(String[] args) { new StaticTest(); new StaticTest(); } } 靜態區塊初始化 匿名區塊初始化 建構子初始化 匿名區塊初始化 建構子初始化 由執行結果可以發現，靜態區塊只執行一次，匿名區塊與建構子分別執行二次。 執行順序: 靜態區塊 -&gt; 匿名區塊 -&gt; 建構子"
  },"/pages/java/noun_desc/": {
    "title": "名詞解釋",
    "keywords": "",
    "url": "/pages/java/noun_desc/",
    "body": "「class bytecode」就是指 .class 檔案的內容，也就是 Java 編譯器（javac）將 .java 原始碼編譯後產生的 位元碼檔案。"
  },"/pages/java/enum/": {
    "title": "列舉",
    "keywords": "",
    "url": "/pages/java/enum/",
    "body": "Prerequisites: Static 靜態屬性是建構子 final 建構子 類別作為列舉 以下程式碼是用類別做的enum，需要有以下條件。 建構子全為私有，不可讓其它類別使用new建立。 屬性使用public + final + static + 本身類別 屬性大寫 = new 本身類別建構子(); 建構子的參數都為private，可以提供get，不能提供set。 屬性跟著類別的生命周期，類別被載入時就建立。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Gender { public final static Gender BOY = new Gender(\"男\"); public final static Gender GIRL = new Gender(\"女\"); private String name; private Gender() { } private Gender(String name) { this.name = name; } @Override public String toString() { return name; } } 使用方法 類別.靜態屬性 1 2 3 4 5 6 public class Test { public static void main(String[] args) { System.out.println(Gender.BOY); System.out.println(Gender.GIRL); } } 男 女 Enum 改為enum，把class改為enum。 1 public enum Gender1 {} 把以下這段程式碼。 1 public final static Gender BOY = new Gender(\"男\"); 改為以下程式碼，都是要放在程式碼最前面，二者都是呼叫一個參數的建構子，只是隱藏public + final + static 。 1 2 3 public enum Gender1 { BOY(\"男\"); // 放在最前面 } 若有多個屬性，以逗號,分隔，以分號;結尾。 1 2 3 public enum Gender1 { BOY(\"男\"), GIRL(\"女\"); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public enum Gender1 { BOY(\"男\"), GIRL(\"女\"); private String name; private Gender1() { } private Gender1(String name) { this.name = name; } public String getName() { return name; } @Override public String toString() { return name; } } 使用方法 類別.靜態屬性 1 2 3 4 5 6 public class Test { public static void main(String[] args) { System.out.println(Gender1.BOY); System.out.println(Gender1.GIRL); } } 男 女 無建構子參數 沒有參數就省略圓括號()。 沒有參數就省略私有建構子，會自動產生。 BOY與GIRL都是final靜態屬性，屬性類型就是Gender2。 1 2 3 public enum Gender2 { BOY,GIRL; } 使用時，沒有參數的建構子，會印出靜態屬性名。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { System.out.println(Gender2.BOY); System.out.println(Gender2.GIRL); } } BOY GIRL Enum的toString()與name() 在Object文章有提過印出物件，也是呼叫toString()的方法，但Enum有對toString()改寫。 在程式碼輸入Enum，win使用ctrl + b，mac使用cmd + b，進入原始碼。 預設使用name來toString()，若建構子沒參數，name就是屬性名，如上個程式碼Gender2.BOY，屬性名是BOY。 1 2 3 4 5 6 7 8 9 10 11 12 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Constable, Comparable&lt;E&gt;, Serializable { private final String name; public final String name() { return name; } public String toString() { return name; } } static屬性 使用上一個程式碼，請問建立二個物件，都是使用Gender2.BOY建立的，這二個物件是相等嗎？ 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { Gender2 boy1 = Gender2.BOY; Gender2 boy2 = Gender2.BOY; System.out.println(boy1 == boy2); } } true 由執行結果可以發現，屬性是static，都是指向相同靜態記憶體空間。 ordinal() 印出屬性的順序，預設是從0開始。 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { Gender2 boy = Gender2.BOY; Gender2 girl = Gender2.GIRL; System.out.println(boy.ordinal()); System.out.println(girl.ordinal()); } } 0 1 values() 傳回所有屬性。 1 2 3 public enum Gender2 { BOY,GIRL; } 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { Gender2[] arr = Gender2.values(); for (Gender2 val: arr) { System.out.println(val); } } } BOY GIRL valueOf() 使用字串屬性名，取出靜態屬性物件。 1 2 3 4 5 6 public class Test { public static void main(String[] args) { Gender2 boy = Gender2.valueOf(\"BOY\"); System.out.println(boy); } } BOY 若屬性名亂寫，會拋出Error。 1 Gender2 boy = Gender2.valueOf(\"ABC\"); java.lang.IllegalArgumentException:No enum constant enum1.Gender2.ABC compareTo() Enum原始檔中的compareTo，比較的是ordinal。 1 2 3 4 5 6 7 8 public final int compareTo(E o) { Enum&lt;?&gt; other = o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; // 這行才是重點 } 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { Gender2 boy = Gender2.BOY; // ordinal 0 Gender2 girl = Gender2.GIRL; // ordinal 1 System.out.println(boy.compareTo(girl)); } } -1 Enum與javap反編譯 在Intellij用終端機 輸入javap 檔名.class，以下是反編譯的結果，可以看到Gender2 extends java.lang.Enum % ls Gender.class Gender1.class Gender2.class Hobby.class Test.class % javap Gender2.class Compiled from \"Gender2.java\" public final class enum1.Gender2 extends java.lang.Enum&lt;enum1.Gender2&gt; implements enum1.Hobby { public static final enum1.Gender2 BOY; public static final enum1.Gender2 GIRL; public static enum1.Gender2[] values(); public static enum1.Gender2 valueOf(java.lang.String); public void hobby(); static {}; } Enum與介面 因為Enum類別已經繼承Enum，由上一個javap已經證實。 Enum類別不能再繼承其它類別，只能實作介面。 以下是興趣的介面。 1 2 3 interface Hobby { void hobby(); } 實作Hobby介面。 1 2 3 4 5 6 7 8 9 10 11 12 public enum Gender2 implements Hobby { BOY,GIRL; @Override public void hobby() { if (this.name() == BOY.name()) { System.out.println(\"大部分喜歡玩電動、棒球、運動。\"); } else { System.out.println(\"大部分喜歡購物、追劇。\"); } } } 測試 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { Gender2 boy = Gender2.BOY; Gender2 girl = Gender2.GIRL; boy.hobby(); girl.hobby(); } } 大部分喜歡玩電動、棒球、運動。 大部分喜歡購物、追劇。"
  },"/pages/kotlin/component/": {
    "title": "Component 解構",
    "keywords": "",
    "url": "/pages/kotlin/component/",
    "body": "Kotlin這邊的解構跟C++的解構子完全不同。 這邊的解構是把物件拆成好幾個變數。 類別 語法 class 類別 { operator fun component1() = 屬性 operator fun component2() = 屬性 operator fun component3() = 屬性 operator fun component4() = 屬性 . . . } 物件拆成好幾個變數。 val (屬性1, 屬性2, 屬性3) = 物件 範例 1 2 3 4 5 class Pig(val name:String, val age:Int, val weight:Float) { operator fun component1() = name operator fun component2() = age operator fun component3() = weight } 測試 1 2 3 4 fun main() { val (name, age, weight) = Pig(\"佩佩\", 10, 20.5f) println(\"name = $name, age = $age, weight = $weight\") } name = 佩佩, age = 10, weight = 20.5 底線_ 不想指派屬性值，可以用底線。 1 2 3 4 fun main() { val (name, _ , weight) = Pig(\"佩佩\", 10, 20.5f) println(\"name = $name, weight = $weight\") } name = 佩佩, weight = 20.5 集合 集合也有支援解構，把集合拆成好幾個變數。 1 2 3 4 fun main() { val (name1, name2, name3) = listOf&lt;String&gt;(\"Mary\", \"Bill\", \"Eva\") println(\"name1 = $name1, name2 = $name2, name3 = $name3\") } name1 = Mary, name2 = Bill, name3 = Eva Data Class Data Class 解構 Data Class自動就會寫Componet的語法，不用自己寫。"
  },"/pages/kotlin/enum/": {
    "title": "列舉",
    "keywords": "",
    "url": "/pages/kotlin/enum/",
    "body": "Prerequisites: Java 列舉 什麼是列舉？請詳見Java的列舉。 宣告語法 在kotlin宣告enum，跟Java略有不同，是用enum class 開頭。 enum class 類別名 { } 主要建構式 在Kotlin，主要建構式不能使用name這個變數名。 1 2 3 4 enum class Gender(val title : String) { GIRL(\"女孩\"), BOY(\"男孩\"); } 使用方法 1 2 3 4 fun main() { println(Gender.BOY.title) println(Gender.GIRL.title) } 男孩 女孩 沒有主要建構式 1 2 3 4 enum class Gender { GIRL, BOY; } 印出Enum的靜態屬性，預設印出屬性名，這部分跟Java是相同的。 1 2 3 4 fun main() { println(Gender.BOY) println(Gender.GIRL) } BOY GIRL"
  },"/pages/kotlin/operator_plus/": {
    "title": "plus運算子",
    "keywords": "",
    "url": "/pages/kotlin/operator_plus/",
    "body": "把+運算子的方法覆寫。 1 2 3 4 5 class Emp (val empId: String, val salary: Int){ operator fun plus(other: Emp): Emp { return Emp(\"\", other.salary + this.salary) } } 2個員工薪水相加。 1 2 3 4 5 6 fun main() { val emp1 = Emp(\"001\" , 50000) val emp2 = Emp(\"002\", 30000) val sum = emp1 + emp2 println(sum.salary) } 80000"
  },"/pages/kotlin/seal/": {
    "title": "Seal class",
    "keywords": "",
    "url": "/pages/kotlin/seal/",
    "body": "Prerequisites: Java 靜態內部類別 Kotlin提供Seal class，類似Enum的功能，但看了Java原始碼才發現其實是靜態內部類別。 建立一個密封類別，有三個屬性，全部繼承密封類別。 1 2 3 4 5 sealed class NetworkEvent { object Load: NetworkEvent() data class Success(val code: Int): NetworkEvent() class Error(val errCode:Int, val msg: String) : NetworkEvent() } object 建立一個Singleton物件 1 object Load: NetworkEvent() Kotiln在私下已經建立了Singleton物件。 1 2 3 4 5 class Load private constructor(): NetworkEvent() { companion object { val INSTANCE = Load() } } 使用Seal Class類別名.屬性，就會自動幫Load屬性，建立好Singleton物件。 1 val loading = NetworkEvent.Load 不能這樣寫。 1 val loading = NetworkEvent.Load() Java原始碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // NetworkEvent public abstract class NetworkEvent { // 私有建構子 private NetworkEvent() { } // 公有建構子 public NetworkEvent(DefaultConstructorMarker $constructor_marker) { this(); } // Load是一個靜態內部類別，且不可以再被繼承final // 繼承NetworkEvent public static final class Load extends NetworkEvent { // 靜態final的Singleton物件 @NotNull public static final Load INSTANCE; // 私有建構子 private Load() { // 呼叫父類別的有參數建構子，但傳null進去。 super((DefaultConstructorMarker)null); } // 靜態區塊 static { // 類別載入時，就建立Singleton物件 Load var0 = new Load(); // var0的記憶體位址 指派 給INSTANCE INSTANCE = var0; } } } 密封類別的內部類別 1 2 3 4 sealed class NetworkEvent { data class Success(val code: Int): NetworkEvent() class Error(val errCode:Int, val msg: String) : NetworkEvent() } Success與Error是NetworkEvent的內部類別，而且繼承:NetworkEvent() Java原始碼 Success 因為內部類別Success是Data Class，Data Class本身就會覆寫component、copy、toString、equals等方法，這些方法就先截掉。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public abstract class NetworkEvent { . . . // 靜態內部類別，不可被繼承。 public static final class Success extends NetworkEvent { private final int code; public final int getCode() { return this.code; } // 建構子 public Success(int code) { super((DefaultConstructorMarker)null); this.code = code; } } } Error 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public abstract class NetworkEvent { . . . // 靜態內部類別，不可被繼承。 public static final class Error extends NetworkEvent { // 私有 不可更改 屬性 private final int errCode; @NotNull private final String msg; public final int getErrCode() { return this.errCode; } @NotNull public final String getMsg() { return this.msg; } // 建構子 public Error(int errCode, @NotNull String msg) { Intrinsics.checkNotNullParameter(msg, \"msg\"); super((DefaultConstructorMarker)null); this.errCode = errCode; this.msg = msg; } } } 判斷與使用 使用when作為判斷 1 2 3 4 5 6 7 fun checkStatus(status: NetworkEvent): String { return when(status) { is NetworkEvent.Load -&gt; \"正在載入中\" is NetworkEvent.Success -&gt; \"成功，code = ${status.code}\" is NetworkEvent.Error -&gt; \"失敗, code = ${status.errCode} , msg = ${status.msg}\" } } 測試 1 2 3 4 5 6 7 8 9 10 11 12 fun main() { val loading = NetworkEvent.Load val success = NetworkEvent.Success(200) val error = NetworkEvent.Error(404, \"Page not found\") var result = checkStatus(success) println(result) result = checkStatus(error) println(result) result = checkStatus(loading) println(result) } 成功，code = 200 失敗, code = 404 , msg = Page not found 正在載入中 Java原始碼 判斷的部分。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static final String checkStatus(@NotNull NetworkEvent status) { // 檢查參數是否為null Intrinsics.checkNotNullParameter(status, \"status\"); // 傳回值 String var10000; // 判斷是不是Load類別 if (status instanceof NetworkEvent.Load) { var10000 = \"正在載入中\"; } else if (status instanceof NetworkEvent.Success) { // 判斷是否為Success類別 var10000 = \"成功，code = \" + ((NetworkEvent.Success)status).getCode(); } else { // 判斷是否為Error類別 if (!(status instanceof NetworkEvent.Error)) { throw new NoWhenBranchMatchedException(); } var10000 = \"失敗, code = \" + ((NetworkEvent.Error)status).getErrCode() + \" , msg = \" + ((NetworkEvent.Error)status).getMsg(); } return var10000; } main的部分。 1 2 3 4 5 6 7 8 9 10 11 public static final void main() { NetworkEvent.Load loading = NetworkEvent.Load.INSTANCE; NetworkEvent.Success success = new NetworkEvent.Success(200); NetworkEvent.Error error = new NetworkEvent.Error(404, \"Page not found\"); String result = checkStatus((NetworkEvent)success); System.out.println(result); result = checkStatus((NetworkEvent)error); System.out.println(result); result = checkStatus((NetworkEvent)loading); System.out.println(result); }"
  },"/pages/java/math/": {
    "title": "Math",
    "keywords": "",
    "url": "/pages/java/math/",
    "body": "Math有很多數學方法，以下介紹常用。 abs絕對值 1 System.out.println(Math.abs(-9)); 9 pow次方 2的4次方。 1 System.out.println(Math.pow(2, 4)); 16 ceil 傳回大於或等於參數的「整數」，不是小數。 以下程式碼傳回 &gt;= 3.99的「整數」，ceil回傳值是double。 1 System.out.println(Math.ceil(3.99)); 4.0 floor 傳回小於或等於參數的「整數」，不是小數。 以下程式碼傳回 &lt;= 3.99的「整數」，floor回傳值是double。 1 System.out.println(Math.floor(3.99)); 3.0 round四捨五入 1 2 System.out.println(Math.round(3.99)); System.out.println(Math.round(3.45)); 4 3 強制轉型成int是無條件捨去小數點。 1 2 System.out.println((int) 3.99); System.out.println((int) 3.45); 3 3 sqrt開根號 3 * 3 = 9，9的開根號是3。 1 System.out.println(Math.sqrt(9)); 3 min 二個數字取最小值 二個數字可以放int, float, double 1 System.out.println(Math.min(3.5, 5.6)); 3.5 max 二個數字取最大值 1 System.out.println(Math.max(3.5, 5.6)); 5.6"
  },"/pages/java/rand/": {
    "title": "亂數",
    "keywords": "",
    "url": "/pages/java/rand/",
    "body": "Math.random() 產生介於0到1(不包含1)之間的亂數，0 &lt;= 數字 &lt; 1，最大是0.999999.. 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { // 產生10個亂數 for (int i = 0; i &lt; 10; i++) { System.out.println(Math.random()); } } } 0.6626947146950831 0.8865498402906333 0.9527716033115488 0.4059555335297955 0.24287815701814686 0.10780772812143591 0.005724639017029354 0.41796994366817686 0.8392257800190969 0.736425852792078 傳回值是double random()傳回值是double 1 2 3 public static double random() { return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble(); } 產生0至x亂數 產生0至6的10個亂數。 以下程式碼為何要6 + 1 ? 因為亂數產生的是0至 5.999999，產生的範圍是0 &lt;= x &lt; 6，不會等於6，所以要加1，加1之後的範圍是0至 6.9999999，最大不會超過7。 因為random傳回值是double，要使用int強制轉型，int強制轉型只會去掉小數點，不會四捨五入。 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { System.out.println((int)5.8); for (int i = 0; i &lt; 10; i++) { System.out.println((int)(Math.random() * (6 + 1))); } } } 3 5 3 5 5 4 1 2 0 4 產生2至7之間的亂數 原本的Math.random()只會產生0至x的數字。 要產生2至7的亂數，要先產生0至5的亂數，再加上2，才會符合2至7的亂數。 7 - 2 = 5 但0至5的亂數，只會產生0至4.99999的亂數，所以要再 + 1，這樣才會產生0至5.999999的亂數 7 - 2 = 5 5 + 1 = 6 最後亂數再加2，並且使用強制轉型int，無條件去掉小數點。 公式 (int)(Math.random() * (7 - 2 + 1)) + 2 1 2 3 for (int i = 0; i &lt; 10; i++) { System.out.println((int)(Math.random() * (7 - 2 + 1)) + 2); } 3 3 3 7 7 2 3 3 2 3"
  },"/pages/java/join/": {
    "title": "join 插隊",
    "keywords": "",
    "url": "/pages/java/join/",
    "body": "所謂的join是，當所有執行緒都在同時執行的時候，某個執行緒使用join占用cpu的資源，其它執行緒就休息，待它執行完畢，讓出cpu資源，其它執行緒再繼續執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 class R3 implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName() + \" i = \" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 以下有main執行緒與執行緒1，當main執行緒執行到i == 5，把CPU讓出來給執行緒1，等到執行緒1執行完，main再繼續執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test4 { public static void main(String[] args) throws InterruptedException { R3 r3 = new R3(); Thread t1 = new Thread(r3); t1.setName(\"執行緒1\"); // 啟動 t1.start(); for (int i = 0; i &lt; 10; i++) { if (i == 5) { // 讓執行緒1插隊先執行，main執行緒休息 t1.join(); // 執行緒1執行完，main執行緒再接著執行 } System.out.println(Thread.currentThread().getName() + \" i = \" + i); Thread.sleep(1000); } } } main i = 0 執行緒1 i = 0 main i = 1 執行緒1 i = 1 main i = 2 執行緒1 i = 2 執行緒1 i = 3 main i = 3 main i = 4 執行緒1 i = 4 執行緒1 i = 5 執行緒1 i = 6 執行緒1 i = 7 執行緒1 i = 8 執行緒1 i = 9 main i = 5 main i = 6 main i = 7 main i = 8 main i = 9 從執行結果可以發現，一開始都是同時執行的，到了main i = 4之後，main執行緒暫停，輪到執行緒1執行完，main執行緒才繼續執行。"
  },"/pages/java/sync/": {
    "title": "synchronized",
    "keywords": "",
    "url": "/pages/java/sync/",
    "body": "Prerequisites: 阻斷與同步 同步與非同步 同步synchronous 阻斷與同步 等待上一個動作完成，才可以處理下一個動作。 非同步asynchronous 不用等待上一個動作完成，可以同時做多個動作。 多個流程同時執行或稱多個執行緒(thread)同時執行，不用特別等上一個流程(執行緒)完成，才能進行下一個流程(執行緒)。 synchronized同步鎖 非同步(asynchronous)的流程中，因為多個流程(執行緒thread)同時存取或修改同一個變數，造成變數值不一致，所以需要使用同步鎖(synchronized)，必須把目前的流程(thread)處理完，才輪下一個流程(thread)處理，還原成同步的狀況。 想像一下，只有一個廁所，所有執行緒都在門外排隊，只有一個執行緒能上廁所，上廁所前把門鎖上，上完廁所(執行完)，把廁所門的鎖打開(unlock解鎖)，輪到下一個執行緒去上廁所。 而這個鎖上門的動作，稱為同步鎖(synchronized)。 而只有一個執行緒上廁所，這個一個人獨享上廁所過程，稱為同步(synchronized)方法或同步(synchronized)區塊。 也就是說，如果某個流程只限定只讓一個執行緒使用，就要把這段流程使用同步(synchronized)方法或同步區塊包住。 阻斷Block 只有一個執行緒能上廁所，其它執行緒在外面等待，上完廁所，再輪下一個執行緒上廁所，這個過程叫作阻斷Block。 synchronized 方法 在方法前加上synchronized，代表一次只能一個執行緒執行這個方法，但執行速度會變慢，因為一次只能一個執行緒使用方法，其它執行緒都在方法外等待使用。 使用synchronized，有下面幾點技巧，請follow以下步驟。 1.把要同步的流程，移到synchronized 「新方法」中，不要在run()方法前面加上synchronized，這樣做的話，多個執行緒啟動，只有第1個執行緒啟動。 1 2 public synchronized void run() { } 2.使用flag來離開執行緒。 3.迴圈或Looper留在run()方法中。 1 2 3 4 5 @Override public void run() { while (flag) { } } 4.在synchronized 「新方法」中，要用return，離開方法。 以上步驟完成的結果如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class R1 implements Runnable { private int money = 10000; // 2.使用flag來離開執行緒 private boolean flag = true; // 1.把要同步的流程，移到synchronized 「新方法」中 private synchronized void method1() { if (money &lt;= 0) { // 2.使用flag來離開執行緒 flag = false; // 4.在synchronized 「新方法」中，要用return，離開方法 return; } money = money - 1000; try { // 每秒領一次錢 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } @Override public void run() { // 迴圈或Looper留在run()方法中。 while (flag) { // 呼叫synchronized 「新方法」 method1(); } } } 測試程式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { // 建立Runnable物件 R1 r1 = new R1(); // 建立執行緒 Thread t1 = new Thread(r1); t1.setName(\"執行緒1\"); Thread t2 = new Thread(r1); t2.setName(\"執行緒2\"); // 啟動執行緒 t1.start(); t2.start(); } } 執行緒1 提領 1000 元，剩下 9000 元 執行緒2 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒2 提領 1000 元，剩下 6000 元 執行緒2 提領 1000 元，剩下 5000 元 執行緒2 提領 1000 元，剩下 4000 元 執行緒2 提領 1000 元，剩下 3000 元 執行緒2 提領 1000 元，剩下 2000 元 執行緒2 提領 1000 元，剩下 1000 元 執行緒2 提領 1000 元，剩下 0 元 解鎖 以下狀況都是執行緒在synchronized方法或synchronized區塊之中。 執行緒執行完畢，會解鎖。 執行緒遇到Exception，會解鎖。 執行緒遇到return，或只有一層迴圈的break，會解鎖。 執行緒呼叫wait()，會解鎖。 以下狀況不會解鎖。 執行緒呼叫sleep()、yield()，睡覺sleep與yeild()讓出cpu資源不會解鎖。 synchronized(this)同步區塊 synchronized(this)是鎖住目前物件屬性，使用在非靜態方法。 synchronized(this){}，被花括號{}包住的部分叫同步區塊，比synchronized方法更好的地方在於，只有包住的區塊，只提供一次給一個執行緒執行，未在同步區塊中的程式碼，可被多個執行緒使用。 語法 synchronized(this) { } 改成使用synchronized(this)區塊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class R1 implements Runnable { private int money = 10000; private boolean flag = true; private void method1() { // 使用this同步區塊 synchronized(this) { if (money &lt;= 0) { flag = false; // 離開方法 return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } } synchronized(object)區塊 除了this之外，也可以使用其它物件，只要確認多個執行緒中，使用的object是同一個。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class R1 implements Runnable { private int money = 10000; private boolean flag = true; // 建立Object物件 private Object obj; // 由其它類別設定Object public void setObj(Object obj) { this.obj = obj; } private void method1() { // 使用Object同步區塊 synchronized(obj) { if (money &lt;= 0) { flag = false; // 離開方法 return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } } 測試執行緒。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { // 建立Object Object object = new Object(); // 建立Runnable物件 R1 r1 = new R1(); r1.setObj(object); Thread t1 = new Thread(r1); t1.setName(\"執行緒1\"); Thread t2 = new Thread(r1); t2.setName(\"執行緒2\"); t1.start(); t2.start(); } } 也可以像下面這樣寫，因為擁有相同Runnable物件的多個執行緒，都是使用同一個Runnable物件，所以以下的寫法，也是所有執行共同使用obj物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class R1 implements Runnable { private int money = 10000; private boolean flag = true; // 改成new R1的時候，直接new Object屬性。 private Object obj = new Object(); private void method1() { synchronized (obj) { if (money &lt;= 0) { flag = false; // 離開方法 return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } } synchronized(BankCard物件)區塊 把之前在Thread文章中，使用的BankCard範例按照之前的步驟修改，並使用BankCard物件作為同步區塊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class TestThread extends Thread { private BankCard card; // 2. 使用flag來離開執行緒。 private boolean flag = true; public TestThread(BankCard card) { this.card = card; } // 1. 把要同步的流程，移到「新方法」中 public void method1 () { // synchronized (BankCard物件) synchronized (card) { if (card.getMoney() &lt;= 0) { // 2. 使用flag來離開執行緒。 flag = false; // 4. 在「新方法」中，要用return，離開方法。 return; } card.setMoney(card.getMoney() - 1000); System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + card.getMoney() + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { // 3. 迴圈或Looper留在run()方法中。 while (flag) { // 2. 使用flag來離開執行緒。 method1(); } } } 每個執行緒都使用相同bankCard物件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test { public static void main(String[] args) { // 建立bankCard物件 BankCard bankCard = new BankCard(); // 確保每個執行緒都使用同一個bankCard物件 TestThread t1 = new TestThread(bankCard); t1.setName(\"執行緒1\"); // 確保每個執行緒都使用同一個bankCard物件 TestThread t2 = new TestThread(bankCard); t2.setName(\"執行緒2\"); t1.start(); t2.start(); } } 執行緒1 提領 1000 元，剩下 9000 元 執行緒2 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒1 提領 1000 元，剩下 6000 元 執行緒2 提領 1000 元，剩下 5000 元 執行緒1 提領 1000 元，剩下 4000 元 執行緒2 提領 1000 元，剩下 3000 元 執行緒1 提領 1000 元，剩下 2000 元 執行緒2 提領 1000 元，剩下 1000 元 執行緒1 提領 1000 元，剩下 0 元 以下的程式碼，就不是同步鎖，因為bankCard都不一樣，同步鎖會失效。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { // 每個執行緒的BankCard物件都是不一樣。 TestThread t1 = new TestThread(new BankCard()); t1.setName(\"執行緒1\"); TestThread t2 = new TestThread(new BankCard()); t2.setName(\"執行緒2\"); t1.start(); t2.start(); } } synchronized(類別.class)靜態同步區塊 針對static變數，要使用類別同步鎖，而不是this物件，this鎖的是物件，對類別的變數與類別的方法是沒有用的。 靜態變數與靜態方法，是屬於類別，不是物件，所以要鎖類別。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class TestThread2 extends Thread { private boolean flag = true; // 靜態變數 private static int money = 10000; public void method1() { // 鎖的是類別 synchronized (TestThread2.class) { if (money &lt;= 0) { flag = false; return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } } 測試執行緒 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main(String[] args) { TestThread2 t1 = new TestThread2(); t1.setName(\"執行緒1\"); TestThread2 t2 = new TestThread2(); t2.setName(\"執行緒2\"); TestThread2 t3 = new TestThread2(); t3.setName(\"執行緒3\"); t1.start(); t2.start(); t3.start(); } } 執行緒1 提領 1000 元，剩下 9000 元 執行緒3 提領 1000 元，剩下 8000 元 執行緒2 提領 1000 元，剩下 7000 元 執行緒1 提領 1000 元，剩下 6000 元 執行緒2 提領 1000 元，剩下 5000 元 執行緒3 提領 1000 元，剩下 4000 元 執行緒1 提領 1000 元，剩下 3000 元 執行緒3 提領 1000 元，剩下 2000 元 執行緒2 提領 1000 元，剩下 1000 元 執行緒1 提領 1000 元，剩下 0 元 靜態同步區塊 在靜態方法中，使用靜態同步區塊。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class TestThread2 extends Thread { // 全變成靜態 private static boolean flag = true; private static int money = 10000; // 靜態方法 public static void method1() { synchronized (TestThread2.class) { if (money &lt;= 0) { flag = false; return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } } 靜態同步方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TestThread2 extends Thread { private static boolean flag = true; private static int money = 10000; // synchronized在靜態方法 public synchronized static void method1() { if (money &lt;= 0) { flag = false; return; } money = money - 1000; System.out.println(Thread.currentThread().getName() + \" 提領 1000 元，剩下 \" + money + \" 元\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public void run() { while (flag) { method1(); } } }"
  },"/pages/java/thread_state/": {
    "title": "執行緒狀態",
    "keywords": "",
    "url": "/pages/java/thread_state/",
    "body": "執行緒有七種狀態 NEW(建立), RUNNABLE(執行階段), BLOCKED(阻斷), WAITING(等待), TIMED_WAITING(長時間等待), TERMINATED(結束); Runnable Runnable包含Ready(準備)、Running(執行)。 有可能執行緒執行到一半，cpu資源不足，被強迫讓出yeild cpu資源，就從Running -&gt; Ready。 如果cpu又有資源，執行緒又從 Ready -&gt; Running。 當執行緒呼叫start()方法，狀態從 New -&gt; Ready -&gt; Running。 如果執行緒從sleep()方法中醒來，狀態也會從 TIMED_WAITING -&gt; Ready -&gt; Running。 如果執行緒拿到同步鎖，脫離Blocked阻斷狀態，狀態也會從 BLOCKED -&gt; Ready -&gt; Running。 sleep TimeWaiting Thread.sleep() 當執行緒在休眠時，此時執行緒是TimeWaiting狀態。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class T1 extends Thread{ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName() + \" i = \" + i); try { // 20毫秒休息一次 sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test5 { public static void main(String[] args) throws InterruptedException { T1 t = new T1(); // 設定名字 t.setName(\"thread1\"); System.out.println(t.getName() + \" state = \" + t.getState()); // 啟動執行緒 t.start(); // 判斷執行緒是否結束了 while (t.getState() != Thread.State.TERMINATED) { System.out.println(t.getName() + \" state = \" + t.getState()); // 50毫秒休息一次 Thread.sleep(50); } System.out.println(t.getName() + \" state = \" + t.getState()); } } thread1 state = NEW thread1 state = RUNNABLE thread1 i = 0 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 1 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 2 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 3 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 state = RUNNABLE thread1 i = 4 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 5 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 6 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 7 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 8 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 i = 9 thread1 state = TIMED_WAITING thread1 state = TIMED_WAITING thread1 state = TERMINATED 由執行結果可以發現，thread1從NEW -&gt; RUNNABLE -&gt; TIMED_WAITING -&gt; TERMINATED的過程。 synchronized Blocked 當執行緒在同步(synchronized)區塊或同步方法的「外面」，此時執行緒是阻斷狀態。 join Waiting join 插隊 當有其它執行緒插隊，此時執行緒變成Waiting或TimeWaiting狀態，等待其它執行緒執行完畢，狀態才會變成RUNNABLE。 wait Waiting Thread.wait() 當執行緒在等待wait()，此時執行緒變成Waiting或TimeWaiting狀態。"
  },"/pages/java/uml_sequence/": {
    "title": "順序圖",
    "keywords": "",
    "url": "/pages/java/uml_sequence/",
    "body": "英文是Sequence Diagram，中文有不同翻譯，如:順序圖、序列圖、循序圖、時序圖。 主要是用來表達物件與物件之間交互動作，與物件的生命周期。 物件 物件變數名 冒號: 類型 flowchart LR id1[\"物件變數名:類別\"] 1 Object obj1; flowchart LR id1[\"obj1:Object\"] 生命線 表達物件的Life Cycle destory 代表結束。 有些圖是省略不畫。 呼叫方法 注意！呼叫箭頭指向的物件的方法。 都直接寫方法()，前面不會加上變數名。 1 2 Object obj1; obj1.toString(); 方法執行的時段 有些圖是省略不畫。 呼叫其它物件與傳回值 在start()方法中，呼叫其它類別UserInfo，物件變數名是user，呼叫getName()方法。 傳回的線為虛線。 注意！name是傳回的值，不是呼叫方法()，後面有圓括號()的才是方法()。 由左往右開始 執行順序是由左往右。 下圖中的順序如下 呼叫buy.start() 呼叫user.getName() 取得name 呼叫bankCard.cardNumber() 取得信用卡號 呼叫bankCard.pay() 傳回成功或失敗的代碼，rtnCode。 同一個類別，不同物件 下圖有二個類別，分別為Transfer轉帳與Account帳戶。 下圖中有三個物件，分別為transfer與account1與account2。 下圖中執行的順序如下 呼叫transfer.轉帳() 呼叫account1.檢查餘額() 取得餘額 呼叫account1.提款() 傳回成功或失敗代碼，rtnCode 呼叫account2.轉帳() 傳回成功或失敗代碼，rtnCode 建立匿名物件 匿名物件就是沒有名字的物件。 匿名物件表示方式冒號: 類別。 建立的箭頭為虛線，箭頭非實心，指向匿名物件的方框，箭頭線上的文字&lt;&lt;create&gt;&gt;。 方法可以有參數 語法 方法(參數1, 參數2) 自己呼叫自己 loop 十分簡單的順序圖"
  },"/pages/java/inetaddress/": {
    "title": "InetAddress取得ip",
    "keywords": "",
    "url": "/pages/java/inetaddress/",
    "body": "取得本機ip 1 2 3 4 5 InetAddress inetAddress = InetAddress.getLocalHost(); // 取得IP System.out.println(\"ip = \" + inetAddress.getHostAddress()); // 取得主機名 System.out.println(\"電腦名 = \" + inetAddress.getHostName()); ip = 127.0.0.1 電腦名 = xxxx.local 透過域名取得ip DNS DNS(domain name server)，也稱為域名。 IP太長記不住，網際網路的設計者發明了DNS，DNS可以把伺服器主機名字與IP對映起來，伺服器最少會有一個主機名字。 即便伺服器的IP改變，但伺服器主機名不會改變，還是可以對映到改變後的IP。 語法 1 InetAddress addr = InetAddress.getByName(\"DNS域名\"); 1 2 3 4 InetAddress addr = InetAddress.getByName(\"www.google.com\"); System.out.println(addr); // 取得ip System.out.println(addr.getHostAddress()); www.google.com/142.250.196.196 142.250.196.196"
  },"/pages/java/socket/": {
    "title": "Socket",
    "keywords": "",
    "url": "/pages/java/socket/",
    "body": "Prerequisites: 串流基礎 檔案串流 Socket Socket是用戶端(Client)與伺服器(Server)之間的連線。 用戶端(Client)與伺服器之間的連線透過IO串流傳輸。 flowchart LR Client -- IO串流 --- Server 重要的方法介紹 accept() accept()方法，伺服器會一直監聽有沒有用戶連上port，程序會卡(Block)在這裡，除非有人連上Server。 shutdownOutput() 資料傳輸完成，通知Server接收資料。 Client傳送資料到Server 建立Server Socket 伺服器端操作: 設定埠port number。 accept()監聽有沒有用戶連上port。 用戶連上，取得socket。 socket.getInputStream()讀取傳來的資料。 關閉串流 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Server { public static void main(String[] args) throws IOException { // 1.設定監聽的port number ServerSocket serverSocket = new ServerSocket(9999); // 2.accept會一直等待有人連上 // 3.有人連上會傳回socket物件 Socket socket = serverSocket.accept(); // 4.socket包含客戶端傳送的資料 InputStream is = socket.getInputStream(); // 讀取資料 byte[] buff = new byte[1024]; int len = 0; while((len = is.read(buff)) != -1) { System.out.println(new String(buff, 0, len)); } // 關閉串流 is.close(); socket.close(); serverSocket.close(); } } 建立用戶端Socket 傳送資料步驟如下: 連接伺服器ip與埠port。 連接成功取得socket物件。 取得輸出串流socket.getOutputStream() 寫入資料至輸出串流。 shutdownOutput() 通知Server接收資料。 關閉串流。 關閉socket。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Client { public static void main(String[] args) throws IOException { // 1. 連接伺服器ip與埠port。 // 2. 連接成功取得socket物件。 Socket socket = new Socket(\"127.0.0.1\", 9999); // 3. 取得輸出串流socket.getOutputStream() OutputStream os = socket.getOutputStream(); // 4. 寫入資料至輸出串流。 os.write(\"Hello, socket\".getBytes()); // 5. shutdownOutput() 通知Server接收資料 socket.shutdownOutput(); // 6. 關閉串流。 os.close(); // 7. 關閉socket socket.close(); } } Hello, socket 執行程式 先執行Server 再執行Client Server傳送資料到Client Server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9999); Socket socket = serverSocket.accept(); InputStream is = socket.getInputStream(); byte[] buff = new byte[1024]; int len = 0; while((len = is.read(buff)) != -1) { System.out.println(new String(buff, 0, len)); } // 傳送資料，取得OutputStream OutputStream os = socket.getOutputStream(); // 寫入資料 os.write(\"收到資料\".getBytes()); // 通知Client接收資料 socket.shutdownOutput(); // 關閉串流 os.close(); is.close(); socket.close(); serverSocket.close(); } } Hello, socket Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Client { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\", 9999); OutputStream os = socket.getOutputStream(); os.write(\"Hello, socket\".getBytes()); socket.shutdownOutput(); InputStream is = socket.getInputStream(); // 讀取資料 byte[] buff = new byte[1024]; int len = 0; while((len = is.read(buff)) != -1) { System.out.println(new String(buff, 0, len)); } os.close(); socket.close(); } } 收到資料"
  },"/pages/note/mac/textedit/": {
    "title": "文字編輯器編碼",
    "keywords": "",
    "url": "/pages/note/mac/textedit/",
    "body": "為文件選擇不同的編碼 在 Mac 上的「文字編輯」App 中，選擇「檔案」&gt;「打開」，然後選取檔案（但不要打開）。 按一下視窗左下角的「選項」。 按一下「純文字編碼」彈出式選單，並選擇一種編碼。 若看不到你要的編碼，請選擇「自訂編碼列表」，然後選取你要包含的編碼。 按一下「打開」。"
  },"/pages/java/assign_cast/": {
    "title": "算術運算子與轉型",
    "keywords": "",
    "url": "/pages/java/assign_cast/",
    "body": "int與double轉型 範例1 1 2 double num = 10 / 4; System.out.println(num); 以上程式碼要分二部分，首先是int整數相除與無條件捨去小數點。 1 System.out.println(10 / 4); 執行結果為2 第二部分是把整數2強制轉型成double。 1 double num = 2; 執行結果為2.0 範例2 1 System.out.println(10.0 / 4); 算式中有double(10.0)，就會把int(4)轉成double，變成double的算式。 執行結果為2.5 範例3 1 System.out.println(10 / 4); 二個都為整數，無條件捨去小數點。 執行結果為2。"
  },"/pages/java/mod/": {
    "title": "餘數",
    "keywords": "",
    "url": "/pages/java/mod/",
    "body": "國一學的正負數，取得的餘數都是正的。 負餘數 但在C++與Java，餘數是有負數的。 例子 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { System.out.println(-38 % -6); System.out.println(-38 % 6); System.out.println(38 % -6); } } -2 -2 2 餘數公式 Java與C++的餘數公式如下: a % b = a - (a / b) * b 1 System.out.println(-38 % -6); a % b = a - (a / b) * b -38 % -6 = -38 - (-38 / -6) * -6 答案是-2 參考資料負數乘除 除上小數，餘數是小數 1 2 System.out.println(-10.5 % 3); System.out.println(-10.4 % 3); -1.5 -1.4000000000000004 有疑惑的是第二個，透過公式 a - (a/b) * b -10.4 - (-10.4 / 3) * 3 先分步驟拆解: 1.整數相除，沒有餘數 -10.4 / 3 = 3 2.先乘除，後加減 3 * 3 = 9 3.結果是-1.4 -10.4 - 9 = -1.4 計算結果為-1.4，為什麼程式的執行結果是-1.4000000000000004呢？ 因為電腦不是人，它以為-10.4後面還有小數-10.4x，所以結果會是-1.4000000000000004"
  },"/pages/java/plusplus/": {
    "title": "變數++",
    "keywords": "",
    "url": "/pages/java/plusplus/",
    "body": "++在後面 1 2 3 int k = 8; int j = k++; System.out.println(\"k = \" + k + \", j = \" + j); k = 9, j = 8 1 int j = k++; 等同於 1 2 int j = k; k = k + 1; 會先把k指派給j，然後k才加1。 ++在前面 1 2 3 int k = 8; int j = ++k; System.out.println(\"k = \" + k + \", j = \" + j); k = 9, j = 9 1 int j = ++k; 等同於 1 2 k = k + 1; int j = k; 會先把k加1。 然後指派給j。 ++沒有指派給變數 1 2 3 4 5 int k = 8; ++k; System.out.println(\"k = \" + k); k++; System.out.println(\"k = \" + k); k = 9 k = 10 若沒有指派給變數，以下二句都是一模一樣，都是自增。k = k + 1 1 2 ++k; k++; ++給自己 ++在後面 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { int i = 1; i = i++; System.out.println(\"i = \" + i); } } i = 1 編譯的時候，看到i = i++;，指派給自己，程式碼就會變成如下: 1.會先建立一個暫存變數temp，代表最左邊的i。 int temp = i; 2.自增 i = i + 1; 3.把暫存變數，指派給i i = temp; ++在前面 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { int i = 1; i = ++i; System.out.println(\"i = \" + i); } } i = 2 編譯的時候，看到i = ++i;，指派給自己，程式碼就會變成如下: 1.先自增。 i = i + 1; 2.建立一個暫存變數temp，代表最左邊的i。 int temp = i; 3.把暫存變數，指派給i i = temp; 其它範例 1 2 int i = 66; System.out.println(++i+i); 134 1.先自增。 ++i; ↓ i = i + 1; 此時 i = 67 2.+i ++i的結果為67，此時i是67。 67 + i 67 + 67 134"
  },"/pages/java/socket_file/": {
    "title": "Socket傳送檔案",
    "keywords": "",
    "url": "/pages/java/socket_file/",
    "body": "Prerequisites: 串流基礎 檔案串流 Byte Array串流 Buffered串流 Client傳送檔案 本機檔案(File)寫入到記憶體緩衝區(Byte Array)。 記憶體緩衝區寫入到Socket的OutputStream。 告訴伺服器傳輸完成。 flowchart LR File -- 轉成 --&gt; ByteArray -- 寫入 --&gt; OutputStream InputStream轉成ByteArray 之前在ByteArray串流中有提過，工具類別提供InputStream轉成Byte Array的方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 public class IOUtils { public static byte[] streamToByteArray(InputStream is) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1) { bos.write(buffer, 0, len); } byte[] byteArr = bos.toByteArray(); bos.close(); return byteArr; } } 傳送檔案到Server。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ClientFile { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\", 9999); FileInputStream fis = new FileInputStream(\"/Users/cici/testc/1.png\"); // File 轉成 Byte Array byte[] bytes = IOUtils.streamToByteArray(fis); // 取得OutputStream OutputStream os = socket.getOutputStream(); // Byte Array 寫入 OutputStream os.write(bytes); // 告訴伺服器傳輸完成 socket.shutdownOutput(); // 關閉串流 fis.close(); os.close(); socket.close(); } } Server接收檔案 取得Socket的InputStream InputStream轉成Byte Array。 Byte Array寫入檔案。 flowchart LR InputStream -- 轉成 --&gt; ByteArray -- 寫入 --&gt; File 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ServerFile { public static void main(String[] args) throws IOException { // 設定監聽的port number ServerSocket serverSocket = new ServerSocket(9999); // accept會一直等待有人連上，有人連上會傳回socket物件 Socket socket = serverSocket.accept(); // socket包含用戶端傳送的資料，用InputStream取得 InputStream is = socket.getInputStream(); // InputStream 轉成Byte Array byte[] bytes = IOUtils.streamToByteArray(is); // File OutputStream FileOutputStream fos = new FileOutputStream(\"/Users/cici/testc/copy1.png\"); // 將Byte Array 寫入到檔案 fos.write(bytes); // 關閉串流 fos.close(); is.close(); socket.close(); serverSocket.close(); } } 執行程式 先執行Server 再執行Client"
  },"/pages/java/socket_writer/": {
    "title": "Socket與Writer",
    "keywords": "",
    "url": "/pages/java/socket_writer/",
    "body": "Prerequisites: 串流基礎 轉換串流 Buffered串流 在串流基礎提過，串流有二種，一種是位元組串流，一種是字元串流。 讀取寫入的位置有二種，一種是檔案，一種是記憶體緩衝區。 Socket存取與寫入的位置都是在記憶體緩衝區，而且是位元組串流。 要把Socket位元組串流轉成字元串流，需要使用轉換串流(OutputStreamWriter,InputStreamReader)。 flowchart LR 位元組串流 -- 轉 --&gt; 轉換串流 -- 轉 --&gt; 字元串流 因為Socket存取與寫入的位置都在記憶體，所以需要使用Buffered字元串流(BufferedWriter,BufferedReader)。 重要的方法介紹 flush() 字元串流要使用flush()方法，把記憶體緩衝區的資料送到socket.OutputStream。 Client傳送文字 傳送步驟如下: 取得socket的OutputStream。 透過轉換串流取得BufferedWriter。 寫入文字。 flush，通知伺服器已傳送完成。 關閉串流。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ClientWriter { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\", 9999); OutputStream os = socket.getOutputStream(); // OutputStreamWriter是轉換串流，把位元組串流轉成字元串流 // BufferedWriter 寫入的位置都在記憶體緩衝區 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os)); writer.write(\"哈囉。 Server\"); writer.newLine(); writer.write(\"hi\"); // 告訴Server傳輸完畢 writer.flush(); // 關閉串流 writer.close(); os.close(); socket.close(); } } Server接收文字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ServerReader { public static void main(String[] args) throws IOException { // 設定監聽的port number ServerSocket serverSocket = new ServerSocket(9999); // accept會一直等待有人連上，有人連上會傳回socket物件 Socket socket = serverSocket.accept(); // socket包含客戶端傳送的資料，用InputStream取得 InputStream is = socket.getInputStream(); // InputStreamReader是轉換串流，把位元組串流轉成字元串流 // BufferedReader 讀取的位置都在記憶體緩衝區 BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line = null; while((line = reader.readLine()) != null) { System.out.println(line); } reader.close(); is.close(); socket.close(); serverSocket.close(); } } 執行程式 先執行Server 再執行Client"
  },"/pages/java/udp/": {
    "title": "UDP",
    "keywords": "",
    "url": "/pages/java/udp/",
    "body": "介紹 Java的UDP不可靠傳輸協議是使用DatagramSocket與DatagramPacket完成。 DatagramPacket是封包，在二個DatagramSocket間傳輸。 在DatagramSocket下，沒有一台主機是Server或Client，也沒有accept監聽，只有主機跟主機之間的傳輸，每一個主機都是DatagramSocket，為了簡單的稱呼，傳送資料的稱為傳送方(Sender)，接收資料的稱為接收方(Receiver)。 flowchart LR Sender -- DatagramPacket --- Receiver Port number 傳送方與接收方都要設定埠port number，若傳送方與接收方都在本機，port number要不同。 傳送方 1 2 3 4 5 6 public class UdpSend { public static void main(String[] args) throws IOException { // 設定埠port number DatagramSocket socket = new DatagramSocket(9998); } } 接收方 1 2 3 4 5 6 public class UdpRecv { public static void main(String[] args) throws IOException { // 設定埠port number DatagramSocket socket = new DatagramSocket(9999); } } 建立DatagramPacket封包 傳送方 建立封包，裡面是傳輸的資料、資料大小、接收方的ip、接收方的port。 1 2 3 4 5 6 7 8 9 10 11 public class UdpSend { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9998); // 傳輸的資料 byte[] bytes = \"哈囉哈囉\".getBytes(); // 建立封包 // 參數為傳輸的資料、資料大小、接收方的ip、接收方的port DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(\"127.0.0.1\"), 9999); } } 接收方 建立封包，裡面是記憶體暫存區Byte Array、Byte Array長度。 1 2 3 4 5 6 7 8 9 10 public class UdpRecv { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9999); // 建立封包，大小設為1024 byte[] buff = new byte[1024]; // 建立接收封包 DatagramPacket packet = new DatagramPacket(buff, buff.length); } } 傳送封包send 1 2 3 4 5 6 7 8 9 10 11 public class UdpSend { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9998); byte[] bytes = \"哈囉哈囉\".getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(\"127.0.0.1\"), 9999); // 傳送封包 socket.send(packet); socket.close(); } } 接收封包receive receive()方法是沒有資料會等待，程序停留在那一行，也就是阻斷(Block)。 收到資料才會往下面的程式碼執行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class UdpRecv { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9999); byte[] buff = new byte[1024]; DatagramPacket packet = new DatagramPacket(buff, buff.length); // 接收封包 // 如果沒有資料傳來就會卡住(Block) socket.receive(packet); // 有資料才會往下走 // 取得傳來資料的大小 int realLen = packet.getLength(); // 取得資料 byte[] data = packet.getData(); String str = new String(data, 0, realLen); System.out.println(str); socket.close(); } } getLength() 取得傳來資料的大小。 getData() 取得傳來的資料。 執行 先執行Recv 再執行Send 雙向溝通 雙向溝通指的是，接收方收到資料後，會傳送「已收到」給傳送方。 傳送方發送資料後，接收另一方送來的「已收到」，送印出。 Send傳送方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class UdpSend { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9998); // 送出 byte[] bytes = \"哈囉哈囉\".getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(\"127.0.0.1\"), 9999); socket.send(packet); // 接收 byte[] buff = new byte[1024]; packet = new DatagramPacket(buff, buff.length); // 如果沒有資料傳來就會卡住(Block) socket.receive(packet); // 有資料才會往下走 int realLen = packet.getLength(); byte[] data = packet.getData(); String str = new String(data, 0, realLen); System.out.println(str); socket.close(); } } 已收到資料 Recv接收方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class UdpRecv { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(9999); byte[] buff = new byte[1024]; DatagramPacket packet = new DatagramPacket(buff, buff.length); // 如果沒有資料傳來就會卡住(Block) socket.receive(packet); // 有資料才會往下走 int realLen = packet.getLength(); byte[] data = packet.getData(); String str = new String(data, 0, realLen); System.out.println(str); // 傳送資料 data = \"已收到資料\".getBytes(); packet = new DatagramPacket(data, data.length, InetAddress.getByName(\"127.0.0.1\"), 9998); socket.send(packet); socket.close(); } } 哈囉哈囉"
  },"/pages/math/neg_div/": {
    "title": "負數乘除",
    "keywords": "",
    "url": "/pages/math/neg_div/",
    "body": "規則 正負號與數字分開運算。 數字全當成正數。 接著再處理正負號。 負數除法 範例1 -36 / 6 先處理數字，全當作正數。 36 / 6 = 6 再處理負號。 -36(負) 與 6(正)，負正得負。 答案為 -6 範例2 36 / -6 先處理數字，全當作正數。 36 / 6 = 6 再處理負號。 36(正) 與 -6(負)，正負得負。 答案為 -6 範例3 -36 / -6 先處理數字，全當作正數。 36 / 6 = 6 再處理負號。 -36(負) 與 -6(負)，負負得正。 答案為 6 負數乘法 乘法也是相同道理。 -4 * -2 先處理數字，全當作正數。 4 * 2 = 8 再處理負號。 -4(負) 與 -2(負)，負負得正。 答案為 8 再處理負號。"
  },"/pages/java/bubble_sort/": {
    "title": "Bubble Sort",
    "keywords": "",
    "url": "/pages/java/bubble_sort/",
    "body": "氣泡排序的重點: 陣列中，二個值比較，大的放後面。 第一輪 比5次。 6,5先比較，6比5大，放後面。 6,4比較，6比4大，放後面。 6,3比較，6比3大，放後面。 6,2比較，6比2大，放後面。 6,1比較，6比1大，放後面。 交換的方式如下圖。 準備一個暫存變數temp。 6放在temp。 5放在6的位置。 temp放在5的位置。 把以上的描述用程式寫死。 比5次。 都跟後面1個比，後面比較小進入下個步驟。 跟後面的值交換。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 6, 5, 4, 3, 2, 1 int[] arr = {6, 5, 4, 3, 2, 1}; // 比5次 for (int j = 0; j &lt; 5; j++) { // 2. 都跟後面1個比，後面比較小進入下個步驟。 if (arr[j] &gt; arr[j + 1]) { // 3. 跟後面的值交換。 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); [5, 4, 3, 2, 1, 6] 第2輪 比4次。 5,4先比較，5比4大，放後面。 5,3比較，5比3大，放後面。 5,2比較，5比2大，放後面。 5,1比較，5比1大，放後面。 1 2 3 4 5 6 7 8 9 10 for (int j = 0; j &lt; 4; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); [4, 3, 2, 1, 5, 6] 第3輪 比3次。 4,3比較，4比3大，放後面。 4,2比較，4比2大，放後面。 4,1比較，4比1大，放後面。 比3次 1 2 3 4 5 6 7 8 9 10 11 // 比3次 for (int j = 0; j &lt; 3; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); [3, 2, 1, 4, 5, 6] 第4輪 比2次。 3,2比較，3比2大，放後面。 3,1比較，3比1大，放後面。 1 2 3 4 5 6 7 8 9 10 11 // 比2次 for (int j = 0; j &lt; 2; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); [2, 1, 3, 4, 5, 6] 第5輪 比1次。 2,1比較，2比1大，放後面。 1 2 3 4 5 6 7 8 9 10 11 // 比1次 for (int j = 0; j &lt; 1; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); [1, 2, 3, 4, 5, 6] 重覆的程式碼 以下會出現5次內容一模一樣的程式碼，只有j &lt; ?是有變化的，其它都沒有變化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public class Test { public static void main(String[] args) { int[] arr = {6, 5, 4, 3, 2, 1}; // 比5次 for (int j = 0; j &lt; 5; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); // 比4次 for (int j = 0; j &lt; 4; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); // 比3次 for (int j = 0; j &lt; 3; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); // 比2次 for (int j = 0; j &lt; 2; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); // 比1次 for (int j = 0; j &lt; 1; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); } } 重覆5次的程式碼，一模一樣的程式碼，就由迴圈來省略重覆的程式碼。 j &lt; ?的變化是由5, 4, 3, 2, 1，由大到小遞減。 所以外層迴圈要用由大到小，5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test { public static void main(String[] args) { // 6, 5, 4, 3, 2, 1 int[] arr = {6, 5, 4, 3, 2, 1}; // loop_count迴圈次數 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 int loop_count = 5; for (int i = loop_count; i &gt; 0; i--) { for (int j = 0; j &lt; i; j++) { // 2. 都跟後面1個比。 if (arr[j] &gt; arr[j + 1]) { // 3. 比較大的，放後面 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println(Arrays.toString(arr)); } } } [5, 4, 3, 2, 1, 6] [4, 3, 2, 1, 5, 6] [3, 2, 1, 4, 5, 6] [2, 1, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6] 外層迴圈次數是陣列大小 - 1。 1 int loop_count = arr.length - 1;;"
  },"/pages/java/complement/": {
    "title": "2的補數",
    "keywords": "",
    "url": "/pages/java/complement/",
    "body": "2的補數，把負數變成2進位0和1的方法。 電腦儲存負數也是儲存2的補數。 電腦計算的方式都是用2的補數來計算。 名詞介紹 英文 中文 Sign-and-Magnitude 符號數值表示法 1’s complement 1的補數 2’s complement 2的補數 符號數值表示法 「符號數值表示法」就是有正負號的二進位。 把最左邊的第1個bit當作正負號，1為負號，0為正號，剩下的bit就跟原本二進位一樣。 1的符號數值表示法 = 00000001 -1的符號數值表示法 = 10000001 1的補數 把整數1的二進位00000001，0與1互換，就是1的補數。 00000001 ↓ 11111110 2的補數 1的補數 + 1 = 2的補數 11111110 + 1 ----------- 11111111 11111111 為2的補數。 以上是+1變成-1(2的補數)的過程，電腦負數的計算與儲存，都是存2的補數。 正整數 正整數的二進位與「符號數值表示法」、「1的補數」、「2的補數」都一樣，不用再轉換。 正整數最左邊第1個bit是0。 1 符號數值表示法 = 00000001 1 1的補數 = 00000001 1 2的補數 = 00000001 轉成2的補數 負數就是2的補數，負數不能再轉2的補數。 只有正整數才能轉2的補數。 要把正整數1變成負-1的過程如下: 00000001 ↓ 0與1互換 ↓ 11111110 ↓ 加1 ↓ 11111111 2的補數轉回符號數值表示法 英文是Convert 2’s complement to original binary. 什麼時候要把2的補數轉回「符號數值表示法」？ 若計算結果是負數(最左邊第1個bit是1)，負數本身就是2的補數，但電腦顯示負號是用「符號數值表示法」也就是有正負號的二進位來顯示，不是顯示2的補數。 如何轉回符號數值表示法？ 以下是正整數變成負數(2的補數)的過程: 2進位 -&gt; 0與1互換 -&gt; 加1 -&gt; 2的補數 2的補數轉回符號數值表示法，倒回來計算，以下請注意箭頭方向。 符號數值表示法 &lt;- 最左邊第1個bit不變，其它0與1互換 &lt;- 減1 &lt;- 2的補數 2的補數 11111111 ↓ 減1 ↓ 1111110 ↓ 最左邊第1個bit不變，其它0與1互換 ↓ 10000001 10000001 注意！左邊第1個bit是正負號，0代表正整數，1代表負數。 後面7個bit(0000001)才是代表數值1。 範例1 1 System.out.println(~ 2); 2的2進位 = 00000010 ~ 運算子代表0與1互換。 00000010 ↓ ~ 0與1互換 ↓ 11111101 11111101是一個負數，第1個bit是1，是2的補數。 2的補數要轉回「符號數值表示法」，請注意以下箭頭方向。 符號數值表示法 &lt;- 最左邊第1個bit不變，其它0與1互換 &lt;- 減1 &lt;- 11111101(2的補數) 11111101 ↓ 2的補數減1 ↓ 11111100 ↓ 第1個bit不變，其它0與1互換 ↓ 10000011 程式碼 1 2 3 4 5 public class Test { public static void main(String[] args) { System.out.println(~ 2); } } -3 執行結果就是-3 2的補數變成程式 要如何寫2的補數的程式碼呢？ 前一個例子的2的補數11111101 java程式碼 1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { // 2的補數 byte b = (byte) 0b11111101; // 會自動轉回符號數值表示法 System.out.println(b); } } -3 c++程式碼 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { // 2的補數 int8_t b = 0b11111101; // 會自動轉回符號數值表示法 cout &lt;&lt; (int)b &lt;&lt; endl; return 0; } -3 計算結果為正整數 以下計算結果為正整數，也就是左邊第1個bit是0，不用轉回符號數值表示法，一開始我就有提到正整數的符號數值表示法、1的補數與2的補數都跟二進位一樣，不用再轉換。 1 System.out.println(~ -2); 根據題目，先求出-2，也就是+2的2補數(負數)。 2的二進位 = 00000010 以下是正整數變成負數的過程: 2進位 -&gt; 0與1互換 -&gt; 加1 -&gt; 2的補數 00000010 ↓ 0與1互換 ↓ 11111101 ↓ 加1 ↓ 11111110 得到-2(2的補數) = 11111110 接下來~ 運算子代表0與1互換 11111110 ↓ 0與1互換 ↓ 00000001 00000001已經是正整數二進位，左邊第1個bit是0，不用再轉回符號數值表示法。 程式碼 1 2 3 4 5 public class Test { public static void main(String[] args) { System.out.println(~ -2); } } 1 位元OR運算子計算 |位元OR運算子，有1個為1，才是1。 1 System.out.println(-2 | 3); 11111110 (-2) or 00000011 (3) --------- 11111111 or的計算結果為負數(2的補數)，第1個bit是1。 要把2的補數轉成符號數值表示法，注意以下箭頭方向。 符號數值表示法 &lt;- 最左邊第1個bit不變，其它0與1互換 &lt;- 減1 &lt;- 11111111 11111111 ↓ 減1 ↓ 11111110 ↓ 0與1互換 ↓ 10000001 1 2 3 4 5 public class Test { public static void main(String[] args) { System.out.println(-2 | 3); } } -1 執行結果為-1。 重要公式 正整數二進位變成負數(2的補數)過程: 正整數二進位 ↓ 0與1互換 ↓ 1的補數 ↓ 1的補數 + 1 ↓ 2的補數 負數(2的補數)變成「符號數值表示法」過程，也就是把上面的過程改由「由下往上」執行。 2的補數 ↓ 2的補數減1 ↓ 1的補數 ↓ 最左邊第1個bit不變，其它0與1互換 ↓ 符號數值表示法 1的補數 + 1 = 2的補數 2的補數 - 1 = 1的補數 其它注意事項 0的符號數值表示法，1的補數，2的補數都一樣 0 符號數值表示法 = 00000000 0 1的補數 = 00000000 0 2的補數 = 00000000 8bit的-128 8bit的-128，10000000是2的補數，10000000沒辦法轉回「符號數值表示法」，因為8-bit最大的正整數是127，沒有對映的128正整數。 1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { // -128 byte b = (byte) 0b10000000; System.out.println(b); } } 符號數值表示法、2的補數 以下是有爭議，容易搞混淆的。 10進位 符號數值表示法 正整數二進位 1的補數 2的補數 -1 10000001 00000001 11111110 11111111 -2 10000010 00000010 11111101 11111110 -127 11111111 01111111 10000000 10000001 -128 無法表示 沒有+128 無法表示 10000000 0 00000000 00000000 00000000 00000000 1 00000001 00000001 00000001 00000001 unsinged unsinged的意思是沒有正負號的正整數。 C++有unsinged正整數。 Java的數字都有正負號，沒有unsinged正整數。"
  },"/pages/java/lr_shift_operator/": {
    "title": "右移左移運算子",
    "keywords": "",
    "url": "/pages/java/lr_shift_operator/",
    "body": "右移左移符號 &gt;&gt; 右移1位 &lt;&lt; 左移1位 語法 右移1位 10進位數字 &gt;&gt; 1 5 &gt;&gt; 1 右移2位 10進位數字 &gt;&gt; 2 5 &gt;&gt; 2 左移1位 10進位數字 &lt;&lt; 1 5 &lt;&lt; 1 左移2位 10進位數字 &lt;&lt; 2 5 &lt;&lt; 2 十進位系統左移右移 右移一位除10，左移一位乘10 範例1: 個位數1，往左移一位，乘10。 1 ↓ 左移1位 ↓ 10 範例2: 個位數1，往右移一位，除10。 1 ↓ 右移1位 ↓ 0.1 二進位系統左移右移 右移 二進位系統下，右移1位就是除2，右移2位就是除2再除2，就是除4。 右移1位 1右移1位 = \\(1 \\div 2 = 0\\) 00000001 ↓ 右移1位 ↓ 00000000 程式碼 1 System.out.println(1 &gt;&gt; 1); // 1右移1位 結果為0 15右移1位 = \\(15 \\div 2 = 7\\)，整數相除只取整數，小數位直接去掉。 00001111 ↓ 右移1位 ↓ 00000111 程式碼 1 System.out.println(15 &gt;&gt; 1); //15右移1位 結果為7 右移2位 右移2位就是除2再除2，就是除4，整數相除只取整數，小數位直接去掉。 15右移2位 = \\(15 \\div 2 \\div 2 = 3\\) 00001111 ↓ 右移1位 ↓ 00000111 ↓ 右移1位 ↓ 00000011 程式碼 1 System.out.println(15 &gt;&gt; 2); 結果為3 右移3位 右移3位就是除2再除2、再除2，就是除8。 15右移2位 = \\(15 \\div 2 \\div 2 \\div 2 = 1\\) 00001111 ↓ 右移1位 ↓ 00000111 ↓ 右移1位 ↓ 00000011 ↓ 右移1位 ↓ 00000001 程式碼 1 System.out.println(15 &gt;&gt; 3); 結果為1 左移 左移一位就是乘2，左移二位就是乘4，左移三位就是乘8。 左移1位 1左移1位 = \\(1 \\times 2 = 2\\) 00000001 ↓ 左移1位 ↓ 00000010 程式碼 1 System.out.println(1 &lt;&lt; 1); 結果為2 左移2位 1左移2位 = \\(1 \\times 2 \\times 2 = 4\\) 00000001 ↓ 左移1位 ↓ 00000010 ↓ 左移1位 ↓ 00000100 程式碼 1 System.out.println(1 &lt;&lt; 2); 結果為4"
  },"/pages/java/char/": {
    "title": "char",
    "keywords": "",
    "url": "/pages/java/char/",
    "body": "Java的char與c++的char占據記憶體大小不一樣，Java占據2byte記憶體空間，C++占據1byte記憶體空間。 名稱 byte數 範圍 char 2 byte $-2 ^{15}$ 至 $2 ^{15} - 1$"
  },"/pages/java/float_double/": {
    "title": "float與double",
    "keywords": "",
    "url": "/pages/java/float_double/",
    "body": ""
  },"/pages/java/number/": {
    "title": "整數",
    "keywords": "",
    "url": "/pages/java/number/",
    "body": "Prerequisites: byte與bit介紹 Java的整數有下面4種，Java程式碼是在Java虛擬機上執行，不會有不同作業系統型別會有所不同，但C++的long類型在Win與Linux下是不同的。 為什麼要不同的基本型態，因為記憶體空間有限，不能把任何整數都放在long，這樣是很浪費記憶體空間。 名稱 byte數 範圍 byte 1 byte -128 至 127 short 2 byte $-2 ^{15}$ 至 $2 ^{15} - 1$ int 4 byte $-2 ^{31}$ 至$2 ^{31} - 1$ long 8 byte $-2 ^{63}$ 至$2 ^{63} - 1$ 占據記憶體bit,byte數量 1個Byte由8個bit組成的，下圖為各種基本型態占據記憶體的bit數量。 下圖方格子代表1byte，下圖為各種基本型態占據記憶體的byte數量。 下圖中，各種型態都存入127，127是1byte，但對每一種基本型態的意義是不同的，short存入127，short占據記憶體空間是2byte，int存入127，int占據記憶體空間是4byte，long存入127，long占據記憶體空間是8byte。 不同型態占據記憶體空間大小不一樣，雖然存的值都相同。 1 2 3 4 byte b1 = 127; // 1 byte short s1 = 127; // 2 byte int i1 = 127; // 4 byte long l1 = 127; // 8 byte 不能把4個格子int，存入1個格子byte，記憶體空間大小不一樣，以下程式碼編譯錯誤。 1 2 int i1 = 127; byte b1 = i1; 但反過來把1個格子的值存入4個格子中，是可以，從小房子搬到大房子。 1 2 byte b1 = 127; int i1 = b1; 自動轉型 資料型態小的可以塞入大的資料型態，不用手動轉型，編譯器會自動轉型， byte型態放入int型態。 1 2 byte b1 = 127; int i1 = b1; 強制轉型 資料型態大的塞入小的資料型態，要使用強制轉型，使用圓括號(轉型的型態)，程式設計師要負責轉換後精度遺失或超出資料範圍的問題。 int型態放入byte型態。 1 2 int i1 = 127; byte b1 = (byte) i1; 預設整數常數型態 什麼是常數？等號右邊若為數字或字串，這些就是常數。 1 2 int i = 123; // 123是常數 String s = \"Hello\" // Hello是常數 在程式碼任意輸入數字，預設是int。 以下1234是int。 1 System.out.println(1234); 範圍檢查 整數預設型態是int。 以下程式碼等號右邊是int的「值」，但java編譯器會先檢查範圍，介於範圍之間，就可以設值。 1 2 3 4 5 6 7 8 byte b1 = 127; byte b2 = -128; short s1 = 32767; short s2 = -32768; System.out.println(b1); System.out.println(b2); System.out.println(s1); System.out.println(s2); 127 -128 32767 -32768 但如果不是「值」，而是基本型態，以下程式碼編譯錯誤。 1 2 int i1 = 127; byte b1 = i1; 不能把大的型態塞到小的型態 int是4byte，不能放入short 2byte。 1 2 int i1 = 123; short s1 = i1; byte byte等號右邊的範圍大小就是-128 至 127，超過就會編譯錯誤。 1 2 3 4 byte b1 = 127; System.out.println(b1); byte b2 = -128; System.out.println(b2); 127 -128 以下會產生編譯錯誤。 1 byte b1 = 128; 以下會產生編譯錯誤，不能把大的型態塞入小的型態，int是4byte，byte的1個byte。 1 2 int i1 = 123; byte b1 = i1; short short等號右邊的範圍大小就是-32768 至 32767，超過就會編譯錯誤。 1 2 short s1 = 32767; short s2 = -32768; byte、short計算 byte、short計算結果是int，不能把int塞入byte或short。 以下b1 + s1是int型態。 1 2 3 byte b1 = 1; short s1 = 1; short s2 = b1 + s1; 以下b1 + b2是int型態。 1 2 3 byte b1 = 1; byte b2 = 1; byte b3 = b1 + b2; 以下s1 + s2是int型態。 1 2 3 byte s1 = 1; byte s2 = 1; byte s3 = s1 + s2; long 常數後面要為l或L，代表為long基本型態。 1 2 3 4 long l1 = 10l; long l2 = 10L; System.out.println(l1); System.out.println(l2); 10 10 注意！執行結果為10，不是10.0，不要跟double搞混。 int int最大的數字是2147483647，若存放的數字超過int最大數字，請使用long。 1 int i = 10;"
  },"/pages/math/carry10/": {
    "title": "十進位",
    "keywords": "",
    "url": "/pages/math/carry10/",
    "body": ""
  }}

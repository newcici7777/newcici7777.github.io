{"/pages/c/editor/xcode/": {
    "title": "Xcode",
    "keywords": "",
    "url": "/pages/c/editor/xcode/",
    "body": "輸入Project的名字 選擇要放置的位置，並點選New Folder 輸入新目錄的名稱 要勾不勾git自行決定，按create 點擊main，再按下執行的按鈕"
  },"/pages/jekyll/install/how_to_install_ruby/": {
    "title": "安裝 Ruby on Mac",
    "keywords": "",
    "url": "/pages/jekyll/install/how_to_install_ruby/",
    "body": "打開終端機，輸入下面指令 $brew install ruby 檢查安裝路徑 $brew list ruby homebrew安裝ruby的路徑列表，注意版號是否為3.0以上，目前是3.3.0。 /usr/local/Cellar/ruby/3.3.0/bin/bundle /usr/local/Cellar/ruby/3.3.0/bin/bundler /usr/local/Cellar/ruby/3.3.0/bin/erb /usr/local/Cellar/ruby/3.3.0/bin/gem /usr/local/Cellar/ruby/3.3.0/bin/irb /usr/local/Cellar/ruby/3.3.0/bin/racc /usr/local/Cellar/ruby/3.3.0/bin/rake /usr/local/Cellar/ruby/3.3.0/bin/rbs /usr/local/Cellar/ruby/3.3.0/bin/rdbg /usr/local/Cellar/ruby/3.3.0/bin/rdoc /usr/local/Cellar/ruby/3.3.0/bin/ri /usr/local/Cellar/ruby/3.3.0/bin/ruby /usr/local/Cellar/ruby/3.3.0/bin/syntax_suggest /usr/local/Cellar/ruby/3.3.0/bin/typeprof /usr/local/Cellar/ruby/3.3.0/include/ruby-3.3.0/ (191 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.3.3.dylib /usr/local/Cellar/ruby/3.3.0/lib/pkgconfig/ruby-3.3.pc /usr/local/Cellar/ruby/3.3.0/lib/ruby/ (4276 files) /usr/local/Cellar/ruby/3.3.0/lib/libruby.dylib /usr/local/Cellar/ruby/3.3.0/libexec/gembin/ (2 files) /usr/local/Cellar/ruby/3.3.0/share/emacs/site-lisp/ruby/ruby-style.el /usr/local/Cellar/ruby/3.3.0/share/man/ (4 files) /usr/local/Cellar/ruby/3.3.0/share/ri/ (15158 files) 檢查本機ruby的安裝的位置是否與homebrew一致。 $which ruby 我的mac顯示的位置是∶ /usr/bin/ruby 顯然是不一樣，修改環境變數。 $vi ~/.zshrc 添加homebrew 安裝ruby的路徑，注意!以下的位置是你的brew list ruby的路徑，不能直接拷貝我的。 export PATH=\"/usr/local/Cellar/ruby/3.3.0/bin:$PATH\" 修改完.zshrc檔案，在終端機執行以下指令。 $source ~/.zshrc 檢查ruby的路徑是否為homebrew安裝的路徑。 $which ruby"
  },"/pages/c/basic/charType/": {
    "title": "char字元",
    "keywords": "",
    "url": "/pages/c/basic/charType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long char char是正整數，雖然顯示是字元，但實際存放在記憶體位置的資料型態是整數。 char所對映的整數是顯示在瑩幕上的ASCII碼。https://zh.wikipedia.org/zh-tw/ASCII 若輸入單引號''包住的字元，編譯器會自動把單引號包住的字元轉成整數。 比如'a'，記憶體位址存放的十進位值是97，二進制是01100001 整數型態 占用Byte數量 數值範圍 格式符 輸出格式 char 1 0~127 %c 字元 char 1 0~127 %d 整數 字元變數設為數字。 程式碼 1 2 3 char c = 97; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 第一行，直接給整數到c變數。 執行結果 97 a 印出char可用%c格式字串或%d格式字串 1 2 3 char c = 'a'; printf(\"%d\\n\", c); printf(\"%c\\n\", c); 執行結果 97 a int變數設為字元。 在c++中，可以直接給int變數賦值單引號''包住的字元 1 2 3 4 5 int main() { int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; c1 &lt;&lt; endl; return 0; } 執行結果 65 int轉型字元 想印出字元，就把int轉型成char 1 2 int c1 = 'A'; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 執行結果 A 字元運算 也可字元加整數做運算。 1 2 int c1 = 'A' + 2; cout &lt;&lt; \"c1=\" &lt;&lt; (char)c1 &lt;&lt; endl; 第一行，字元+2。 執行結果 c1=C 跳脫字元 重要有以下幾種 Ascii碼 跳脫字元 描述 0 \\0 空，字元變數可設定0 9 \\t TAB鍵對齊 10 \\n 換行 13 \\r 移動到最前面 設定空字元 1 2 char c4 = 0; cout &lt;&lt; \"c4=\" &lt;&lt; c4 &lt;&lt; endl; 執行結果 c4= 關於斜線 因為\"與'與\\，被編譯器作為以下用途。 \"\"，把字串包起來。 ''，把字元包起來。 \\，換行\\n 所以不能直接使用\"與'與\\，必須加上\\“與\\‘與\\\\。 雙引號 1 2 3 char c2 = '\"'; cout &lt;&lt; \"c2=\" &lt;&lt; c2 &lt;&lt; endl; cout &lt;&lt; \"我說，\\\"跑!\\\"\" &lt;&lt; endl; 第1行，當作字元的雙引號，前面不用加斜線'\\\"'，直接寫雙引號就可以'\"'。 第3行，當作字串中的的雙引號，前面要加斜線。 執行結果 c2=\" 我說，\"跑!\" 單引號 1 2 3 char c3 = '\\''; cout &lt;&lt; \"c3=\" &lt;&lt; c3 &lt;&lt; endl; cout &lt;&lt; \"我說，'跑!'\" &lt;&lt; endl; 第1行，當作字元的單引號，前面要加斜線'\\''。 第3行，當作字串中的的單引號，前面不用加斜線。 執行結果 c3=' 我說，'跑!'"
  },"/pages/c/basic/printformat/": {
    "title": "整數與浮點數",
    "keywords": "",
    "url": "/pages/c/basic/printformat/",
    "body": "整數 整數資料型態 整數型態 占用Byte數量 格式字串 取值範圍 int 4 %d -2,147,483,648 至 2,147,483,647 unsinged int 4 %u 0 到 4,294,967,295 short 2 %hd -32,768 至 32,767 unsinged short 2 %hu 0 到 65,535 long 4 %ld -2,147,483,648 至 2,147,483,647 unsinged long 4 %ud 0 到 18,446,744,073,709,551,615 long long 8 %lld -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 unsinged long long 8 %llu 0 到 18,446,744,073,709,551,615 整數相除，去掉小數點，只留正數，不會四捨五入 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; 8/5 &lt;&lt; endl; 執行結果 8/5 = 1 運算式中有低資料型態與高資料型態，低資料型態會自動轉成高資料型態，不需要強制轉型。 1 2 3 4 char c7 = 97; int i1 = 25; long long llong1 = 150000000000; cout &lt;&lt; \"97 + 25 + 150000000000 = \" &lt;&lt; c7 + i1 + llong1 &lt;&lt; endl; 執行結果 97 + 25 + 150000000000 = 150000000122 等號(=)左邊是高資料型態，右邊是低資料型態，低資料型態會自動轉成高資料型態，不需要強制轉型。 1 2 3 char c7 = 97; int i2 = c7; cout &lt;&lt; \"i2 = \" &lt;&lt; i2 &lt;&lt; endl; 執行結果 i2 = 97 等號(=)左邊是整數，右邊是浮點數，浮點數小數點直接去掉，轉換成整數。 1 2 int i3 = 23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 等號(=)右邊超出範圍。 unsigned int最大的值是4294967295。 1 2 3 4 5 6 unsigned int ui1 = 4294967295; unsigned int ui2 = 4294967295 + 1; unsigned int ui3 = 4294967295 + 2; cout &lt;&lt; \"ui1 = \" &lt;&lt; ui1 &lt;&lt; endl; cout &lt;&lt; \"ui2 = \" &lt;&lt; ui2 &lt;&lt; endl; cout &lt;&lt; \"ui3 = \" &lt;&lt; ui3 &lt;&lt; endl; 執行結果 ui1 = 4294967295 ui2 = 0 ui3 = 1 unsigned int最大的值是4294967295，若超出的二進制會被去掉。 超出的二進制 二進制 十進制 輸出結果   11111111 11111111 11111111 11111111 4294967295 4294967295 00000001 00000000 00000000 00000000 00000000 4294967295 + 1 0 00000001 00000000 00000000 00000000 00000001 4294967295 + 2 1 強制轉型 使用強制轉型編譯器不會出現警告。 語法 (資料型態)值、變數、常數、運算式 1 2 int i3 = (int)23.9999999; cout &lt;&lt; \"i3 = \" &lt;&lt; i3 &lt;&lt; endl; 執行結果 i3 = 23 1 cout &lt;&lt; \"(double)8/5 = \" &lt;&lt; (double)8/5 &lt;&lt; endl; 執行結果 (double)8/5 = 1.6 括號的優先級別比較高 1 cout &lt;&lt; \"8/5 = \" &lt;&lt; (double)(8/5) &lt;&lt; endl; 執行結果 8/5 = 1 以上程式碼先執行(8/5)，也就是整數相除會直接去掉小數點，變成1，1再轉成double資料型態。 整數資料型態都可以使用%d印出，只是印出的精準度不同。 浮點數 浮點數資料型態 有效數字是指準確度的數字，例如float，有7位數字會是正確的，超過7位以上，第8位以後就會不正確。 有效數字範圍:包含小數點前面與後面的所有數字。 浮點數型態 占用Byte數量 格式字串 有效數字範圍 float 4 %f 7位有效數字 double 8 %lf 15-16位有效數字 long double 不少於double %Lf 不少於double 數字有小數點就視為double資料型態 1 2 cout &lt;&lt; \"size of int = \" &lt;&lt; sizeof(8) &lt;&lt; endl; cout &lt;&lt; \"size of double = \" &lt;&lt; sizeof(8.0) &lt;&lt; endl; 執行結果 size of int = 4 size of double = 8 數字最後面有f視作float資料型態 1 cout &lt;&lt; \"size of float = \" &lt;&lt; sizeof(8.0f) &lt;&lt; endl; 執行結果 size of float = 4 float格式字串輸出 1 2 3 float f1 = 3.8f; printf(\"f1 = %f \\n\", f1); printf(\"f1 = %.2f \\n\", f1); 執行結果 f1 = 3.800000 f1 = 3.80 double格式字串輸出 1 2 3 4 float f1 = 3.8; double d1 = 3.8; printf(\"f1 = %f , d1 = %f , d1 = %lf\\n\", f1, d1, d1); printf(\"f1 = %.2f , d1 = %.2f , d1 = %.2lf\\n\", f1, d1, d1); 執行結果 f1 = 3.800000 , d1 = 3.800000 , d1 = 3.800000 f1 = 3.80 , d1 = 3.80 , d1 = 3.80 運算式中有浮點數，其它整數會自動轉型浮點數，不需要強制轉型。 1 cout &lt;&lt; \"8.0/5 = \" &lt;&lt; 8.0/5 &lt;&lt; endl; 執行結果 8/5 = 1.6 有效位數 float有效位數 1 2 float f1 = 123456789.123f;//float 有效數字範圍為7位 printf(\"f1 = %f \\n\", f1); 執行結果 f1 = 123456792.000000 從執行結果可以發現第8位以後數字就不正確。 double有效位數 1 2 double d1 = 123456789.123456789; printf(\"d1 = %lf \\n\", d1); 執行結果 d1 = 123456789.123457 從執行結果可以發現小數點第6位以後數字就不正確。 long dobule有效位數 1 2 long double Ld1 = 123456789.123456789; printf(\"Ld1 = %Lf \\n\", Ld1); 執行結果 Ld1 = 123456789.123457 從執行結果可以發現跟double的結果相同，long double取決於系統是Linux/Mac/Windows，會呈現不同結果。"
  },"/pages/c/basic/scope/": {
    "title": "變數可見範圍與生命週期",
    "keywords": "",
    "url": "/pages/c/basic/scope/",
    "body": "可見範圍(Scope)與生命週期(Lifetime) 區域變數 一對花括號{}包起來的就是程式碼區塊(block)或函式主體(Body)。程式碼區塊可以是if(){}或while(){}的程式碼區塊，但這篇要探討的是只有花括號{}包起來的程式碼區塊。 1 2 3 4 5 6 7 8 9 int main() { int var11 = 100; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 outer var11 = 100 第3行至第6行 在程式碼區塊中{}，所定義的變數都是區域變數，離開{}區塊就不能再讀取了，因為{}區塊中的區域變數已經被系統回收掉。可以想像{}就像是函式一樣。在函式中，函式中定義的變數都是區域變數，離開函式就不能被外部讀取區域變數，因為區域變數已經被系統回收了。 外部變數 在{}區塊中，可以讀取外部變數 1 2 3 4 5 6 7 8 9 10 11 12 int main() { int var11 = 100; int var12 = 200; { int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; //在`{}`區塊中，可以讀取外部變數 cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; } cout &lt;&lt; \"outer var11 = \" &lt;&lt; var11 &lt;&lt; endl; return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 在程式區塊中{}無法讀取同名的外部變數 因為在{}區塊中，同名的外部變數會先被暫時隱藏，直到程式執行時離開{}區塊，區塊內的區域變數被系統回收掉，同名的變數就會將記憶體位置指向外部變數。 程式區塊中{}讀取跟區域變數同名的全域變數 使用::可以讀取全域變數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //定義全域變數var11 int var11 = 100; int main() { //定義區域變數var11 int var12 = 200; { //印出區域變數var11 int var11 = 10; cout &lt;&lt; \"inner var11 = \" &lt;&lt; var11 &lt;&lt; endl; cout &lt;&lt; \"inner var12 = \" &lt;&lt; var12 &lt;&lt; endl; //印出全域變數var11 cout &lt;&lt; \"outer var11 = \" &lt;&lt; ::var11 &lt;&lt; endl; } return 0; } 執行結果 inner var11 = 10 inner var12 = 200 outer var11 = 100 for程式區塊中的區域變數 變數i的有效範圍，只有在{}程式區塊中，離開{}程式區塊，區域變數i就無法在外部讀取。 1 2 3 for(int i = 0; i &lt; 10; i++) { } 若要變數i也可以在外部使用，可把變數i放在外部。 1 2 3 4 int i = 0; for(; i &lt; 10; i++) { } cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; 執行結果 i = 10 虛擬碼 可以在程式區塊寫虛擬碼，進行驗證，作為之後正式的函式使用。 以下程式碼是在寫參數為指標，將指標宣告記憶體空間。 1 2 3 4 5 6 7 8 9 10 11 12 int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 { int** pp = &amp;p;//存放指標的位址，要用雙指標 *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } //印出p指標的位址，去p指標的記憶體位址取值，並印出來 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第6行，去雙指標pp的記憶體位址取值，取出來是p的指標記憶體位址，使用new來分配動態配置記憶體空間，並且設值”3”，動態配置完成會回傳記憶體位址，由指標去存位址。 執行結果 p=0x60000000c000,*p=3 虛擬碼執行成功後，將{}程式碼區塊移到main()函式之外，並宣告成函式。 1 2 3 4 5 6 7 8 9 10 11 void initMemory(int** pp) //存放指標的位址，要用雙指標 { *pp = new int(3);//雙指標取值，並動態配置記憶體空間 } int main() { //宣告指標 int* p = 0;//0就是nullptr 代表沒有指向任何記憶空間 initMemory(&amp;p);//指標的位址傳入函式。 cout &lt;&lt; \"p=\" &lt;&lt; p &lt;&lt; \",*p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 p=0x600000008030,*p=3"
  },"/pages/c/editor/cmake/": {
    "title": "Cmake on Mac",
    "keywords": "",
    "url": "/pages/c/editor/cmake/",
    "body": "前往下載Cmake 解壓好放在應用程式中 打開CMAKE 按照下圖，選擇Tool-&gt;How to Install For Command Line Use 將以下紅框的部分複製，打開終端機，貼上 貼上後再輸入以下指令 $which cmake 再輸入以下指令 $cmake --version 切記，把版本資訊記起來，如我的版本資訊是cmake version 3.27.5 在你所在.cpp的目錄下建立build目錄 跟build目錄同階層建立CMakeLists.txt的文件 在CMakeLists.txt的文件中輸入以下內容 //VERSION編號是之前查詢的 cmake_minimum_required(VERSION 3.27.5) //第一參數為Project名稱 //Project的版本是1.0.0 project(CPPLessons VERSION 1.0.0) //第一個參數是Project名稱 第二個參數為所使用的cpp add_executable(CPPLessons test.cpp Student.cpp) 建立檔案，依xcode為例，在工作列按滑鼠右鍵，選”New File” 依照下圖建立頭文件 再來建立cpp文件 記得不要勾選要建立頭文件 在test.cpp輸入以下內容 1 2 3 4 5 6 7 8 9 #include &lt;stdio.h&gt; #include \"test.h\" int main() { int a[] = {1,2,3,4}; printf(\"cmake test\"); int b[] = {7,8,9,100}; printf(\"cmake test2\"); return 0; } 打開終端機，進入build的目錄 輸入以下內容(要在build的目錄下做喔) cmake .. 產生以下資訊 輸入make make 輸入./CPPLessons 測試成功"
  },"/pages/c/editor/supportc11/": {
    "title": "Xcode支援C++11以上",
    "keywords": "",
    "url": "/pages/c/editor/supportc11/",
    "body": "選擇專案名 選擇Build Settings 選擇Apple Clang 選擇C++ Language Dialect"
  },"/pages/c/editor/vscode/": {
    "title": "VS Code on Mac",
    "keywords": "",
    "url": "/pages/c/editor/vscode/",
    "body": "可以參考其它人的影音檔。 https://www.youtube.com/watch?v=iIPST6HQgSc 參考文章 Visual Studio Code on macOS Using Clang in Visual Studio Code 若code .沒反應 “code .” is not working in on the command line for Visual Studio Code on OS X/Mac"
  },"/pages/c/template/classTemplate/": {
    "title": "類別模板",
    "keywords": "",
    "url": "/pages/c/template/classTemplate/",
    "body": "語法 宣告模板 宣告資料型態參數 資料型態參數名 逗號 template &lt; class T1 , class T2&gt; 宣告模板從關鍵字template開始，後接資料型態參數列表（template parameter list），資料型態參數是以class開頭，後接資料型態參數名(T1)。資料型態參數列表是用尖括號括住的一個資料型態參數或者多個資料型態參數，資料型態參數之間以逗號分隔。class也可以用typename互相替換。 宣告類別模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template &lt;class K, class V&gt; class MyMap{ public: MyMap(){} MyMap(K key1, V value1):key(key1),value(value1){} K getKey(){ return key; } V getValue(){ return value; } private: K key; V value; }; 第1行，template為類別模板宣告，&lt;class K, class V&gt;資料型態參數宣告(type parameter)。 第2行，類別模板的名稱為MyMap。 第5行，建構式，初始私有成員key與value。 第6行，取得私有成員key。 第9行，取得私有成員value。 第13行，私有成員key。 第14行，私有成員value。 使用類別模板 1 2 3 4 5 6 7 8 9 10 int main() { MyMap&lt;int,string&gt; myMap(3, \"test\"); cout &lt;&lt; \"myMap key=\" &lt;&lt; myMap.getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap value=\" &lt;&lt; myMap.getValue() &lt;&lt; endl; MyMap&lt;string, string&gt; *myMap_P1 = new MyMap&lt;string,string&gt;(\"abc\",\"def\"); cout &lt;&lt; \"myMap_P1 key=\" &lt;&lt; myMap_P1-&gt;getKey() &lt;&lt; endl; cout &lt;&lt; \"myMap_P1 value=\" &lt;&lt; myMap_P1-&gt;getValue() &lt;&lt; endl; return 0; } 第2行，建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為int，V的資料型態為string，呼叫二個參數的建構式。 第3行，印出值。 第4行，印出值。 第6行，動態配置建立物件，用尖括號&lt;K,V&gt; 指定參數資料型態，K的資料型態為string，V的資料型態為string，使用new動態配置建立物件，( “abc”,”def”)呼叫二個參數的建構式。 第7行，使用-&gt;印出值。 第8行，使用-&gt;印出值。"
  },"/pages/c/template/funTemplate/": {
    "title": "函式模板",
    "keywords": "",
    "url": "/pages/c/template/funTemplate/",
    "body": "模板定義 宣告模板 宣告資料型態參數 資料型態參數名字 逗號 template &lt; class T1 , class T2&gt;"
  },"/pages/c/template/stackTemplate/": {
    "title": "Stack實作(int Array)",
    "keywords": "",
    "url": "/pages/c/template/stackTemplate/",
    "body": "Stack int陣列實作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Stack{ private: int *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new int[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const int&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(int&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; 第3行，私有成員屬性items，資料型態為int指標，指向int陣列的第0筆位址。 第4行，私有成員屬性stacksize，資料型態為int，存放stack最大的容量。 第5行，私有成員屬性top，資料型態為int，記錄目前stack最頂端的index位置。 第8行，建構式，初始化成員stacksize與top。 第10行，動態配置int陣列。 第12行，解構式。 第13行，從記憶體回收items的空間。 第14行，將回收的空間指向null。 第20行，若top位置在0，表示為空。 第25行，若top位置在stacksize代表空間已滿。 第31行，函式是將item推入stack，參數為參考資料型態。 第33行，目前stack最頂端的index位置小於stack最大容量就做if的區塊。 第34行，先做items[top] = item的動作，再做top++的動作。 第42行，參數為參考資料型態，stack彈出頂端的值暫時放置的變數。 第44行，先將top–的動作，再做items[top]的動作。 使用Stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } 第2行，建立stack物件，最大存放數量為5。 第3~7行，依序塞入1~5。 第8行，宣告暫時存放變數item。 第9行，若stack不為空就進入循環。 第10行，將stack的頂端拿出來，放在變數item。 第11行，印出item。 執行結果 item = 5 item = 4 item = 3 item = 2 item = 1 Stack typedef實作 將上面的程式修改成自定義資料型態DataType。以下有黃色的部分是有變更的程式碼。 typedef int DataType; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); DataType item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; } Stack 模板實作 將上面的程式再修改成模板，以下有黃色的部分是有變更的程式碼。 template &lt;class DataType&gt; class Stack{ private: DataType *items; //陣列指標 int stacksize;//stack大小 int top;//目前stack的數量(stack 頂端) public: //建構式，初始化成員stacksize與top Stack(int size):stacksize(size),top(0) { //建立int陣列指標 items = new DataType[stacksize]; } ~Stack() { delete [] items;//刪除陣列指標 items = nullptr;//指向null } /** 判斷是否為空 */ bool isEmpty() const { return top == 0; } /** 判斷是否已滿 */ bool isfull() { return top == stacksize; } /** push stack */ bool push(const DataType&amp; item) { //如果stack數量 小於 stacksize if(top &lt; stacksize) { items[top++] = item;//把item加入 return true; } return false; } /** pop stack */ bool pop(DataType&amp; item) { if(top &gt; 0) { item = items[--top]; return true; } return false; } }; int main() { Stack&lt;int&gt; myStack(5); myStack.push(1); myStack.push(2); myStack.push(3); myStack.push(4); myStack.push(5); int item; while(myStack.isEmpty() == false) { myStack.pop(item); cout &lt;&lt; \"item = \" &lt;&lt; item &lt;&lt; endl; } return 0; }"
  },"/pages/c/basic/typicalRange/": {
    "title": "資料型態範圍",
    "keywords": "",
    "url": "/pages/c/basic/typicalRange/",
    "body": "記憶體的最小單位為bit，每一個bit可以存0或1，32位元電腦的cpu有32個bit(4byte)的存放區塊可以存放記憶體位址。 位元bit與位元組byte bit正整數範圍 以下列出1到8個bit可以存放的最大正整數值與正整數範圍。 bit 組合 最大正整數(2進制) 最大正整數(10進制) 可以存放的正整數範圍 1 0/1 1 \\(2^1-1 = 1\\) 0-1 2 00/01/10/11 11 \\(2^2-1 = 3\\) 0-3 3 000/001/010/100/110/101/111 111 \\(2^3-1 = 7\\) 0-7 4 0000/0001/0010…1111 1111 \\(2^4-1 = 15\\) 0-15 5 00000/00001/…11111 11111 \\(2^5-1 = 31\\) 0-31 6 000000/000001/…111111 111111 \\(2^6-1 = 63\\) 0-63 7 0000000/0000001/…1111111 1111111 \\(2^7-1 = 127\\) 0-127 8 00000000/00000001/…11111111 11111111 \\(2^8-1 = 255\\) 0-255 byte正整數範圍 由上表可以推斷，1個byte由8個bit組成，可存放最大正整數為255，可以存放的正整數範圍從0-255，共256個數字。 以下列出1byte到4byte最大可存放的數字。 byte bit 最大正整數(10進制) 1byte 11111111 255 2byte 11111111 11111111 65535 3byte 11111111 11111111 11111111 16777216 4byte 11111111 11111111 11111111 11111111 4294967295 科學記號法顯示 byte bit 科學記號法 1byte 11111111 $2^8-1$ 2byte 11111111 11111111 $2^8 * 2^8 -1= 2^{8+8}-1 = 2 ^{16}-1 $ 3byte 11111111 11111111 11111111 $2^8 * 2^8 * 2^8-1 = 2^{8+8+8}-1$ 4byte 11111111 11111111 11111111 11111111 $2^8 * 2^8 * 2^8 * 2^8-1 = 2^{8+8+8+8}-1 = 2 ^{32}-1 $ 正負數 若資料型態是包含正負數，會將最大整數減半，一半分給正數，一半分給負數。最左邊的第1個bit就會變成正負號，0為正數，1為負數。負數的二進制顯示方式為把正數的二進制0和1互換，最後再加1。 正負數 二進位 正負數 01111111 127 10000001 -127 01111111 11111111 32767 10000000 00000001 -32768 01111111 11111111 11111111 8388607 10000000 00000000 00000001 -8388608 01111111 11111111 11111111 11111111 2147483647 10000000 00000000 00000000 00000001 -2147483648 正負數範圍 占用Byte數量 正負數範圍 1byte -128~127 2byte -32768~32767 3byte -8388608~8388607 4byte -2147483648~2147483647 unsinged正整數 unsigned代表沒有符號，所以只有正整數，不會有負號。 占用Byte數量 正數範圍 1byte 0~255 2byte 0~65535 3byte 0~16777216 4byte 0~4294967295"
  },"/pages/c/basic/boolType/": {
    "title": "bool",
    "keywords": "",
    "url": "/pages/c/basic/boolType/",
    "body": "整數 整數包含char, bool, short, unsinged short, int, unsinged int, long, unsinged long 整數型態 占用Byte數量 數值範圍 格式字串 輸出格式 bool 1 0 1 %d 整數 0是false，非0為true。 1 2 3 bool b3 = '0'; bool b4 = 0; cout &lt;&lt; \"b3=\" &lt;&lt; b3 &lt;&lt; \",b4=\" &lt;&lt; b4 &lt;&lt; endl; 執行結果 b3=1,b4=0 可使用true跟false設定bool變數 編譯器會自動把true翻譯成整數1，false翻譯成整數0。 1 2 bool b1 = true, b2 = false; cout &lt;&lt; \"b1=\" &lt;&lt; b1 &lt;&lt; \",b2=\" &lt;&lt; b2 &lt;&lt; endl; 執行結果 b1=1,b2=0 bool整數運算 因為bool是整數，所以bool能做整數運算。但bool顯示出來只會是0或1，即便設的值是2，顯示出來的值仍是1。 1 2 3 4 bool b5 = 1; bool b6 = 2; cout &lt;&lt; \"b5 = \" &lt;&lt; b5 &lt;&lt; \", b6 = \" &lt;&lt; b6 &lt;&lt; endl; cout &lt;&lt; \"b5 + b6 = \" &lt;&lt; b5 + b6 &lt;&lt; endl; 執行結果 b5 = 1, b6 = 1 b5 + b6 = 2 cin只能輸0或1，不能輸入true或false 1 2 3 bool b7; cin &gt;&gt; b7; cout &lt;&lt; \"b7 = \" &lt;&lt; b7 &lt;&lt; endl; 執行結果 1 b7 = 1 執行結果 true b7 = 0 證明bool為整數 1 2 3 4 bool b8 = false; char* c5 = (char*)&amp;b8; *c5 = 8; cout &lt;&lt; \"b8 = \" &lt;&lt; b8 &lt;&lt; endl;"
  },"/pages/c/dynamicMemory/memoryLayout/": {
    "title": "記憶體配置",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/memoryLayout/",
    "body": "記憶體起始與結束位址。 記憶體開始位址由下表最下方開始，記憶體結束位址在最上方。 開始與結束 位址高低 位址 結束 高 0xFFFFFFFF 0xFFFFFFFE 0xFFFFFFFD 0xFFFFFFFC &#8593; ...... ...... ...... ...... 低 0x00000004 0x00000002 0x00000001 開始0x00000000 記憶體區段 記憶體區段根據位址由高到低分別為Kernel, Stack, 尚位使用區域, Heap, bass, data, code。 位址高低 記憶體區塊 位址成長方向 儲存項目 高 Kernel 作業系統核心 &#8593; Stack &#8595; 區域變數 尚未使用區域 Heap &#8593; 動態配置記憶體 bss segmen 未初始化全域變數, 靜態變數 data segmen 已初始化全域變數, 靜態變數 低 code segment 常數與程式執行檔 作業系統核心 處理cpu記憶體Devices與應用程式運作。 stack(堆疊) 儲存區域變數的記憶體區塊 儲存區域變數與函式參數與函式傳回值，記憶體大小只有8M，記憶體位址成長的方向是向下成長。 Heap(堆積) 儲存動態配置變數的記憶體區塊 儲存由動態配置(new與malloc)產生的變數，記憶體大小取決電腦實體記憶體大小(可能8GB或更大)，記憶體位址成長的方向是向上成長。 bss segmen 記憶體區塊 儲存未初始化全域變數與靜態變數。 data segmen 記憶體區塊 儲存已初始化全域變數與靜態變數。 code segment 記憶體區塊 儲存常數與程式執行檔。 變數記憶體位址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;stdio.h&gt; const int global_x = 1; // 儲存於 code segment(常數) int global_y = 1; // 儲存於 data segmen(已初始化全域變數） int global_z; // 儲存於 bss(未初始全域變數) int fun1(int param1) { // 儲存於 stack (函式參數) return param1; // 儲存於 stack (函式傳回值) } int main() { const static int x = 1; // 儲存於 code segment(常數) static int y = 1; // 儲存於 data segmen(已初始化靜態變數） static int z; // 儲存於 bss(未初始靜態變數) int w = 1; // 儲存於 stack (區域變數) fun1(w); // 儲存於 heap (動態分配指標) char *buf = (char*) malloc(sizeof(char) * 100); // ... free(buf); int* p = new int(3); // 儲存於 heap (動態分配指標) delete p; return 0; } Stack 儲存在Stack的變數，變數離開有效範圍(Scope)後，會由系統自動回收記憶體位址。 Stack記憶體容量8M。 記憶體位址向下成長。 不會memory leak。 以下程式碼在函式中建立三個變數，並觀察三個變數的記憶體位址是由大至小遞減。證明記憶體位址向下成長。 1 2 3 4 5 6 7 8 void funcMemoryLocation() { int var1 = 10; int var2 = 20; int var3 = 30; cout &lt;&lt; \"va1 = \" &lt;&lt; (long long)&amp;var1 &lt;&lt; endl; cout &lt;&lt; \"va2 = \" &lt;&lt; (long long)&amp;var2 &lt;&lt; endl; cout &lt;&lt; \"va3 = \" &lt;&lt; (long long)&amp;var3 &lt;&lt; endl; } 執行結果 va1 = 140702053822444 va2 = 140702053822440 va3 = 140702053822436 Heap 儲存動態配置(new與malloc)產生的變數，由程式設計師手動回收記憶體位址，或待主程式生命周期結束後被系統回收記憶體位址。 Heap記憶體容量取決於電腦的記憶體大小。 記憶體位址向上遞增。 會memory leak。 以下程式碼動態分配建立三個變數，並觀察三個變數的記憶體位址是由小至大增長。證明動態分配記憶體位址向上成長。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { int* p1 = new int(10); int* p2 = new int(20); int* p3 = new int(30); cout &lt;&lt; \"p1 address = \" &lt;&lt; (long long)p1 &lt;&lt; endl; cout &lt;&lt; \"p2 address = \" &lt;&lt; (long long)p2 &lt;&lt; endl; cout &lt;&lt; \"p3 address = \" &lt;&lt; (long long)p3 &lt;&lt; endl; delete p1; delete p2; delete p3; p1 = nullptr; p2 = nullptr; p3 = nullptr; return 0; } 執行結果 p1 address = 105553116315664 p2 address = 105553116315680 p3 address = 105553116315696 尚未使用區域 變數在Stack記憶體區塊，位址增長的方向是向下，變數在Heap記憶體區塊，位址增長的方向是向上，未避免Stack與Heap的記憶體位址成長時互相交疊，中間有一個區域是分隔Stack與Heap。"
  },"/pages/c/conversion/explicit/": {
    "title": "強制轉型",
    "keywords": "",
    "url": "/pages/c/conversion/explicit/",
    "body": "將等號(=)右邊的值強制轉型，明確告訴編譯器等號(=)右邊的值的資料型態。 1 int a = (int)8.3; 另一種強制轉型的方式，將值放在括號中()。 1 int a = int(8.3);"
  },"/pages/c/conversion/implicit/": {
    "title": "自動轉型",
    "keywords": "",
    "url": "/pages/c/conversion/implicit/",
    "body": "編譯器根據等號(=)左邊的變數資料型態，決定調用那個轉型函式。 1 int a = 8.3; 等號(=)左邊的變數資料型態是int，等號(=)右邊的值是double，編譯器根據等號(=)左邊的變數資料型態int，把等號(=)右邊的資料型態double轉成int。"
  },"/pages/c/pointer/pointer/": {
    "title": "指標基本觀念",
    "keywords": "",
    "url": "/pages/c/pointer/pointer/",
    "body": "變數位址 每個變數系統會分配”一塊”記憶體位址存放變數，位址通常是用16進制表示。 變數占用的記憶體大小，根據變數的資料型態決定。 假設有一個int資料型態的變數i，占用記憶體4 byte，變數i占的開始位址0x00000008至結束位址0x0000000B，總共占4Byte。 int i = 55; 記憶體開始與結束記憶體位址占用記憶體位址範圍 結束0xFFFFFFFF &#8593;...... 0x0000000E 0x0000000D 0x0000000C 0x0000000Bint i = 55; 0x0000000A 0x00000009 0x00000008 0x00000007 0x00000006 0x00000005 0x00000004 0x00000003 0x00000002 0x00000001 開始0x00000000 取出變數的開始記憶體位址 取位址運算子&amp; &amp;變數 在變數前面加上&amp;可以取出變數的開始記憶體位址，如上一個表格中的例子，變數i的開始位址是0x00000008。 1 2 3 4 5 6 7 int main() { int a = 0; double b = 10.5; cout &lt;&lt; \"變數a位址 = \" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; \"變數b位址 = \" &lt;&lt; &amp;b &lt;&lt; endl; return 0; } 執行結果 變數a位址 = 0x7ff7bfeff468 變數b位址 = 0x7ff7bfeff460 指標是一種變數，存放的內容是位址。 以下為宣告一個i1的整數變數，初始值為10。 1 int i1 = 10; 指標變數存放的內容是位址，以下為宣告一個p1的指標變數，存放i1的開始位址。 1 int* p1 = &amp;i1; 指標的大小8byte 指標變數的大小8byte，使用sizeof(指標變數)可以取得指標的大小，不管是什麼資料型態的指標，佔用記憶體的大小全部為8byte。 1 cout &lt;&lt; sizeof(p1) &lt;&lt; endl; 執行結果 8 位址放入指標變數 指標存放的內容是位址，所以要先取得變數的開始位址，再放入指標變數中，使用&amp;可以取得變數開始位址。 1 2 3 4 5 6 7 int main() { int i1 = 10; int* p1 = &amp;i1; cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; return 0; } 第2行，宣告i1整型變數。 第3行，宣告p1整型指標變數，使用取位址運算子&amp;，取出i1變數的記憶體開始位址，將位址放入p1指標。 第4行，印出i1的位址。 第5行，印出p1所存放的內容。 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 從執行結果可以發現，印出的結果是一樣。 宣告指標的各種寫法 宣告指標可以把*放置在變數前面或資料型態後面或資料型態與變數中間，以下都是正確的。 一行宣告一個指標 1 2 3 4 5 6 7 8 9 10 11 int main() { int i1 = 10; int *p1 = &amp;i1; //*在變數前面 int* p2 = &amp;i1; //*在資料型態後面 int * p3 = &amp;i1; //*在資料型態與變數中間 cout &lt;&lt; \"i1的位址=\" &lt;&lt; &amp;i1 &lt;&lt; endl; cout &lt;&lt; \"p1存放的位址 =\" &lt;&lt; p1 &lt;&lt; endl; cout &lt;&lt; \"p2存放的位址 =\" &lt;&lt; p2 &lt;&lt; endl; cout &lt;&lt; \"p3存放的位址 =\" &lt;&lt; p3 &lt;&lt; endl; return 0; } 執行結果 i1的位址=0x7ff7bfeff468 p1存放的位址 =0x7ff7bfeff468 p2存放的位址 =0x7ff7bfeff468 p3存放的位址 =0x7ff7bfeff468 一行同時宣告多個指標 1 2 3 4 5 6 7 #include &lt;iostream&gt; using namespace std; int main() { char* ptr1,* ptr2,* ptr3; char *ptr4, *ptr5, *ptr6; return 0; } 一行同時宣告指標與整數變數(容易搞混淆的宣告) 1 2 3 4 5 6 7 8 int* p4, num3; //p4是指標 p4 = &amp;ii; //num3為int資料型態的變數 num3 = 20; cout &lt;&lt; \"p4 位址=\" &lt;&lt; p4 &lt;&lt; endl; cout &lt;&lt; \"p4 值=\" &lt;&lt; *p4 &lt;&lt; endl; cout &lt;&lt; \"num3 值=\" &lt;&lt; num3 &lt;&lt; endl; 執行結果 p4 位址=0x7ff7bfdff274 p4 值=10 num3 值=20 取值運算子* 取值運算子*是取得位址中存放的值。指標存放位址，指標也就等於位址。 *指標 以上語法為，取出位址中存放的值，而指標就是位址。 1 2 3 4 5 6 int main() { int i1 = 10; int *p1 = &amp;i1; //將i1變數的位址存到p1指標變數 cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; //取出位址存放的值。 return 0; } 執行結果 取出p1位址的值 = 10 修改位址存放的值* *指標 = 修改的內容 把*放在指標變數前面，就可以在等於(=)後面放入要修改的內容。 1 2 3 4 5 6 7 8 9 10 int main() { int i1 = 10; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; int *p1 = &amp;i1; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; *p1 = 20; cout &lt;&lt; \"取出p1位址的值 = \" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; \"取出i1的值 = \" &lt;&lt; i1 &lt;&lt; endl; return 0; } 第6行，把*放在指標變數p1前面，等於(=)後面放入要修改的內容20。 執行結果 取出i1的值 = 10 取出p1位址的值 = 10 取出p1位址的值 = 20 指標資料型態要與值一致 指標是存放位址，不能存放不是位址的值，會編譯錯誤。 1 2 3 4 5 int main() { int i1 = 10; int *p1 = i1; return 0; } 第2行，i1變數是整數10。 第3行，把10塞入指標，因為指標是存放位址，不能放10這個整數，產生編譯錯誤。 印出位址 十六進制 以下的方式印不出char變數的位址。 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; &amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = a 使用(void*)就可以印出16進制的位址 (void*)指標變數 1 2 3 4 5 int main() { char c = 'a'; cout &lt;&lt; \"變數c位址 = \" &lt;&lt; (void*)&amp;c &lt;&lt; endl; return 0; } 執行結果 變數c位址 = 0x7ff7bfeff46b 十進制 (long long)指標變數 因為int只有4byte，位址轉成int整數會超出範圍，使用long long 8byte，就不會有超出數值範圍的問題。 c語言 printf(\"%#x\",指標變數); 使用%#x格式字串就可印出16進制的記憶體位址。 程式碼範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int i1 = 10; int *p1 = &amp;i1; cout &lt;&lt; \"16進制 &amp;i1 = \" &lt;&lt; (void*)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"16進制 p1 = \" &lt;&lt; (void*)p1 &lt;&lt; endl; cout &lt;&lt; \"10進制 &amp;i1 = \" &lt;&lt; (long long)&amp;i1 &lt;&lt; endl; cout &lt;&lt; \"10進制 p1 = \" &lt;&lt; (long long)p1 &lt;&lt; endl; printf(\"c語言 &amp;i1 = %#x \\n\",&amp;i1); printf(\"c語言 p1 = %#x \\n\",p1); return 0; } 執行結果 16進制 &amp;i1 = 0x7ff7bfeff468 16進制 p1 = 0x7ff7bfeff468 10進制 &amp;i1 = 140702053823592 10進制 p1 = 140702053823592 c語言 &amp;i1 = 0xbfeff468 c語言 p1 = 0xbfeff468 指標資料型態 指標的資料型態要與記憶體位址中的內容相符。 1 2 3 4 int i = 10; int* p1 = &amp;i; double d = 15.5; double* p2 = &amp;d;"
  },"/pages/c/pointer/pointerConst/": {
    "title": "const與指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerConst/",
    "body": "以下二種十分容易混淆，而且十分難記。 Pointer to Const (const*) const右邊是星號* 代表指標位址中的內容是常數，常數不能修改，以下語法不能使用。 *指標 = 修改的內容 1 2 3 4 5 6 7 int main() { int var1 = 10; int const * p = &amp;var1; //*p = 11; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，變數名var1。 第3行，將var1的位址給指標變數p。 第4行，p指標位址中的內容是常數，常數不能修改，所以不能使用*指標 = 修改的內容，此行必須註解，因為會產生編譯錯誤。 第6行，印出var1的值與p指標位址中的值。 執行結果 var1=10,p=10 int const * p可以更改成const int* p，二者為一樣的意思，只要記得const右邊若先出現星號*而不是變數名，代表指標位址中的內容是常數，常數沒有辦法修改。 1 2 3 4 5 6 int main() { int var1 = 10; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第3行，int const * p可以更改成const int* p。 可以修改指標指向的記憶體位址 1 2 3 4 5 6 7 8 9 int main() { int var1 = 10; int var2 = 20; const int* p = &amp;var1; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; p = &amp;var2; cout &lt;&lt; \"var2=\" &lt;&lt; var2 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，第3行，建立二個變數名var1與var2。 第4行，將var1的位址給指標p。 第6行，將var2的位址給指標p。 執行結果 var1=10,p=10 var2=20,p=20 Const Pointer (const 指標名) const右邊是指標名 代表指標名是常數，需要初始化常數名(初始化設位址)，不能再更改指標指向的記憶體位址。 1 2 3 4 5 6 7 8 int main() { int var1 = 10; int var2 = 11; int* const p = &amp;var1; //p = &amp;var2; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 第2行，第3行，建立二個變數名var1與var2。 第4行，const右邊是指標名p，代表指標名p是常數，常數需要初始化，不能是nullptr，將var1的位址給指標p。 第5行，將var2的位址給指標p，會編譯失敗，因為指標p是常數，不能被修改位址。 可以修改內容 可使用*指標 = 修改的內容修改指標位址的值，因為只有指標名是常數，不能變更初始位址，但指標位址中的內容並非常數，所以可以改變指標位址中的內容。 1 2 3 4 5 6 7 int main() { int var1 = 10; int* const p = &amp;var1; *p = 55; cout &lt;&lt; \"var1=\" &lt;&lt; var1 &lt;&lt; \",p=\" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 var1=55,p=55"
  },"/pages/c/pointer/pointerParam/": {
    "title": "函式參數為指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerParam/",
    "body": "引數與參數 引數 Argument 傳給函式的變數。 1 2 3 4 5 6 int main() { int var1 = 10; //將var1傳到func1()函式中，而var1就是引數Argument func1(var1); return 0; } 參數 Parameter 函式接收到的變數。 1 2 3 4 //函式接收到來自外面傳進來的變數，變數名param1，而param1就是參數 void func1(int param1) { cout &lt;&lt; \"param1=\" &lt;&lt; param1 &lt;&lt; endl; } 修改傳進來的參數 指標參數 函式的參數是指標，代表參數是位址。指標參數語法為資料型態* 參數名 void func1(int* param1) { } 取值運算子，取出指標參數的內容。 當函式的參數為指標，指標就是位址，代表可以透過取值運算子*,取出位址存放的內容。 *param1 1 2 3 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } 執行結果 param1=10 修改指標(位址)的內容 使用*指標 = 修改內容，修改指標的內容。 *param1 = 20; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //函式的參數是指標，代表參數是位址 void func1(int* param1) { //透過取值運算子*,取出位址存放的內容 cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; //使用`*指標 = 修改內容`，修改指標的內容 *param1 = 20; } int main() { int var1 = 10; cout &lt;&lt; \"修改前 var1 =\" &lt;&lt; var1 &lt;&lt; endl; //使用取位址運算子&amp;，取出var1變數的記憶體開始位址，將位址作為引數Argument傳進函式fun1() func1(&amp;var1); cout &lt;&lt; \"修改後 var1 =\" &lt;&lt; var1 &lt;&lt; endl; return 0; } 執行結果 修改前 var1 =10 param1=10 修改後 var1 =20 引數為指標變數 上一個程式是把位址&amp;var1傳進函式，下面的程式碼是先將位址&amp;var放入int*指標變數，再把指標變數傳入函式。 1 2 3 4 5 6 7 8 9 void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int var1 = 10; int* p = &amp;var1; func1(p); return 0; } 執行結果 param1=10 作為函式傳回值 如果有一個功能要求函式返回多個值，只有一個函式傳回值根本不夠用，可以把參數作為傳回值。 以下程式是在一群學生數學/英文/歷史成績中，分別找出各科數學/英文/歷史最大的分數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include &lt;iostream&gt; using namespace std; //宣告Student類別 class Student { public: //Student建構式，將參數設給私有成員name, mathScore, engScore, historyScore Student(string name, double mathScore, double engScore, double historyScore) :name(name),mathScore(mathScore),engScore(engScore),historyScore(historyScore){} //取出name, mathScore, engScore, historyScore公有方法 string getName(){ return name; } double getMathScore(){ return mathScore; } double getEngScore(){ return engScore; } double getHistoryScore(){ return historyScore; } private: //私有成員屬性 string name; double mathScore; double engScore; double historyScore; }; //宣告函式，參數為Student陣列，陣列大小，maxMax指標,engMax指標,historyMax指標 void getMax(Student studentArr[], int arrSize, double* mathMax, double* engMax, double* historyMax){ for(int i = 0; i &lt; arrSize; i++) { //找出數學 英文 歷史最大的分數 if(studentArr[i].getMathScore() &gt; *mathMax) *mathMax = studentArr[i].getMathScore(); if(studentArr[i].getEngScore() &gt; *engMax) *engMax = studentArr[i].getEngScore(); if(studentArr[i].getHistoryScore() &gt; *historyMax) *historyMax = studentArr[i].getHistoryScore(); } } int main() { //建立3個學生物件，利用名字,數學英文歷史成績建立物件 Student studentArr[] = {Student(\"Mary\", 50, 30, 100), Student(\"Bill\", 70, 80, 90), Student(\"Lisa\", 20, 99, 10)}; //宣告三個存最大數學 英文 歷史成績的指標 double* mathMax = new double(0); double* engMax = new double(0); double* historyMax = new double(0); //將Student陣列，陣列大小，最大數學 英文 歷史成績的指標傳入getMax函式 compare(studentArr, 3, mathMax, engMax, historyMax); //印出各科最大分數 cout &lt;&lt; \"mathMax = \" &lt;&lt; *mathMax &lt;&lt; endl; cout &lt;&lt; \"mathEng = \" &lt;&lt; *engMax &lt;&lt; endl; cout &lt;&lt; \"mathHistory = \" &lt;&lt; *historyMax &lt;&lt; endl; return 0; } 執行結果 mathMax = 70 mathEng = 99 mathHistory = 100 減少記憶體空間的使用 每呼叫一次函式，就會為函式參數分配記憶體空間，使用指標作為參數，指標占記憶體空間固定8 byte，若參數為char[100]則會占100 byte的記憶體空間，相比之下指標可以節省更多記憶體空間。"
  },"/pages/c/basic/simpleTraditionC/": {
    "title": "台陸指標相關名詞差異",
    "keywords": "",
    "url": "/pages/c/basic/simpleTraditionC/",
    "body": "文件相關 英文 台灣 大陸 head file 標頭檔案 頭文件 cpp file 原始檔案 源代碼 STL 函式庫 標準庫 資料型態相關 英文 台灣 大陸 Data 資料 數據 Data Type 資料型態 數據類型 typedef 型別定義 別名 int 整數 整型 char 字元 字符 string 字串 字符串 Byte 位元組 字節 bit 位元 位 %d %s 格式化字串或格式化數值輸出 占位符 escape sequence 跳脫字元或逸出字元 轉義字符 運算式相關 英文 台灣 大陸 Operator 運算子 運算符 For Loop 巢狀 嵌套 Expression 運算式 表達式 assign = 指定或指派或設為 賦值 變數相關 英文 台灣 大陸 Variable 變數 變量 Constant 常數 常量 scope 生命周期，可見性，有效範圍 作用域 L-value 等號左邊 左值 R-value 等號右邊 右值 Local Variable 區域變數 局部變量 Global Variable 全域變數，外部變數 全局變量 Parameter 參數 形參 Argument 引數 實參 define 宣告 聲明 #define 前置指令 宏 Preprocessor 前置處理器 預處理器 default 預設值 缺省 conversion 轉型 轉換 explicit conversion 強制轉型 顯示轉換或手動轉換 implicit conversion 自動轉型 隱式轉換 Temp Variable 臨時變數 臨時變量 陣列相關 英文 台灣 大陸 Array 陣列 數組 index 索引 下標 row 列 行 column 行 列 函式相關 英文 台灣 大陸 Function 函式 函數 callback 回呼函式 回調函數 return 函式傳回值 函數返回值 Functor 物件函式 仿函數 指標相關 英文 台灣 大陸 Pointer 指標 指針 pointer to pointer** 指標的指標，雙重指標，指指標 二級指針 Wild pointers   野指針 Dangling pointers   懸空指針 Pointer to Const   常量指針 Const Pointer   指針常量 *dereferences a pointer 取值運算子或間接運算子(indirection) 解引用運算符 &amp; 取位址運算子 取址運算符 &amp;reference variable 參考 引用 call by value 傳值 傳值 call by pointer 傳址 傳地址 call by reference 傳參考 傳引用 記憶體相關 英文 台灣 大陸 Memory 記憶體 內存 Dynamic memory allocation 動態配置記憶體 動態內存分配 free 記憶體回收 記憶體釋放 Stack 堆疊 棧 Heap 堆積 堆 物件相關 英文 台灣 大陸 Template 樣板 模板 constructor 建構式或建構子 構造方法 deconstructor 解構式或解構子 析構方法或析構函數"
  },"/pages/c/dynamicMemory/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會回傳記憶體占用的開始位址。 資料型態* 指標變數 = new 資料型態(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"位址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"位址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 位址是 = 0x600000004010 位址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行回收，否則會產生memory leak，記憶體一直沒被回收，記憶體愈占愈多，最後就會當機。 回收記憶體位址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何位址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/newDelete/": {
    "title": "new/delete",
    "keywords": "",
    "url": "/pages/c/pointer/newDelete/",
    "body": "new 宣告指標變數，使用new在Heap區段申請記憶體空間，申請成功會回傳記憶體占用的開始位址。 資料型態* 指標變數 = new 資料型態(初始值); 1 2 3 4 5 6 int main() { int* p = new int(30); cout &lt;&lt; \"位址是 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"位址中的內容是 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 執行結果 位址是 = 0x600000004010 位址中的內容是 = 30 delete 在Heap區段申請記憶體空間，不用時需使用delete對記憶體進行回收，否則會產生memory leak，記憶體一直沒被回收，記憶體愈占愈多，最後就會當機。 回收記憶體位址語法如下，delete後要把指標變數設為nullptr(也可以設0)，代表沒有指向任何位址的意思。 delete 指標變數; 指標變數 = nullptr; 1 2 3 4 5 6 int main() { int* p = new int(30); delete p; p = nullptr; return 0; }"
  },"/pages/c/pointer/nullptr/": {
    "title": "0 == nullptr == NULL",
    "keywords": "",
    "url": "/pages/c/pointer/nullptr/",
    "body": "nullptr代表沒有指向任何位址 如果對沒有指向任何位址的指標，也就是指標 = nullptr，對這個指標使用*取值運算子，試圖取出位址中的內容，編譯可以通過，但執行時將會出現錯誤。 1 2 3 4 5 6 7 8 9 10 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第7行，宣告指標p，沒有指向任何位址。 第8行，將指標p傳入函式。 第4行，將指標p使用*取值運算子試圖取出位址中的內容，但由於指標沒有指向任何位址，執行時會產生錯誤。 檢查nullptr 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; void func1(int* param1) { if(param1 == nullptr) return; cout &lt;&lt; \"param1=\" &lt;&lt; *param1 &lt;&lt; endl; } int main() { int* p = nullptr; func1(p); return 0; } 第4行，判斷指標是不是沒有指向任何位址，若沒有指向任何位址，函式直接返回，不再往下執行。 delete nullptr delete nullptr 不會有編譯錯誤與執行錯誤，以下程式不會有任何錯誤。 1 2 3 4 5 int main() { int* p = nullptr; delete p; return 0; } NULL 在c的標準函式庫中stddef.h定義了常數NULL就是0與nullptr。 1 2 3 #define NULL 0 //since C++11 #define NULL nullptr 第1行定義常數NULL的值為0，代表沒有指向任何記憶空間 第3行，c++11以後，定義常數NULL為nullptr，代表沒有指向任何記憶空間 0 0，代表沒有指向任何記憶空間 以下為同名函式，但參數不同，一個為int資料型態，一個為int指標，呼叫函式(0)，呼叫的是參數為整數資料型態的函式。 1 2 3 4 5 6 7 8 9 10 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); return 0; } 執行結果 n = 0 轉型 把指標參數設為NULL，呼叫參數為指標的函式，以下這樣寫會出錯。 1 func3(NULL);//指標參數設為NULL 因為編譯不知道你的NULL是整數指標資料型態的NULL，轉型就可以編譯成功，以下三行都可以。 1 2 3 func3(nullptr); func3((int *)nullptr); func3(static_cast&lt;int *&gt;(nullptr)); 第1行，nullptr代表所有資料型態的NULL。 第2行，轉型int指標。 第3行，使用static_cast轉型成int指標，與上一行意思相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 void func3(int n) { printf(\"n = %d\\n\",n);//印出值 } void func3(int* p) { printf(\"位址 = %#x\\n\",p);//印出位址 } int main() { func3(0); func3((int *)NULL); func3(static_cast&lt;int *&gt;(NULL)); func3(nullptr); return 0; } 執行結果 n = 0 位址 = 0 位址 = 0 位址 = 0 nullptr位址為0 以下程式碼印出nullptr指標的位址，會印出0。 1 2 3 4 5 6 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; delete p; return 0; } 執行結果 0x0 nullptr記憶體位址 0x00000000-0x0000FFFF記憶體位址區間是放置nullptr指標，無法讀取這段記憶體位址區間。 原文 Each process’ virtual address space is split into partitions. On x86 32-Bit Windows, the partition of 0x00000000 - 0x0000FFFF (inclusive) is called NULL-Pointer Assignment Partition. This partition is set aside to help programmers catch NULL-pointer assignments. If a thread in your aprocess attempts to read from or write to a memory address in this partition, an access violoation is raised. 容易混淆寫法 1 2 3 4 int a = 0 ; int * p1 = 0 ; //right int * p2 = NULL ; //right int * p3 = a;//error 第1行定義整數資料型態的a變數，值為0 第2行定義p1指標沒有指向任何記憶體空間 第3行定義p2指標沒有指向任何記憶體空間 第4行錯誤，指標是存放位址，而不是值，不能把整數值0放進指標"
  },"/pages/c/pointer/pointerVoid/": {
    "title": "void*任何資料型態的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerVoid/",
    "body": "函式的參數為void*指標(位址) 函式的參數為void*指標，表示任何資料型態的指標(位址)都可以傳進函式，而且不需要轉型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //宣告printAddr的函式，參數資料型態為void*指標 void printAddr(void* p) { //印出位址 cout &lt;&lt; p &lt;&lt; endl; } int main() { int i = 10; //將整數i變數的位址傳入 printAddr(&amp;i); char c = 'a'; //將字元c變數的位址傳入 printAddr(&amp;c); double d = 150.222; //將浮點數d變數的位址傳入 printAddr(&amp;d); return 0; } 執行結果 0x7ff7bfeff468 0x7ff7bfeff467 0x7ff7bfeff458 函式傳回值為void*指標 表示可以回傳任何資料型態的指標(位址)，可以轉型成任何資料型態指標。 以下為malloc的回傳資料型態void指標(位址)，void指標可以轉成任何資料型態指標，參數size_t __size代表設定空間大小。 1 void* malloc(size_t __size) 使用方式 在heap區段，建立10 byte的記憶體空間，將回傳的位址轉成char資料型態的指標。 1 char *name = (char *)malloc(10);//10byte 在heap區段，建立1mb的記憶體空間，將回傳的位址轉成int資料型態的指標。 1 int *num = (int *)malloc(1 * 1024 * 1024);//1byte*1024 = 1kb -&gt;1kb*1024=1mb 不能對void*指標使用取值運算子* 不能對void*指標使用取值運算子*，需要轉換成其它資料型態的指標才可以使用取值運算子* 1 2 3 4 void printAddr(void* p) { //編譯失敗，不能對p指標使用取值運算子*，因為它是void*指標資料型態，必須轉型後才能對指標取出內容 cout &lt;&lt; *p &lt;&lt; endl; } 1 2 3 4 5 6 7 8 9 void printAddr(void* p) { //先將p指標轉型成char*指標，接著使用`取值運算子*`取出指標位址中的內容 cout &lt;&lt; *(char*)p &lt;&lt; endl; } int main() { char c = 'a'; printAddr(&amp;c); return 0; } 執行結果 a 函式的參數為void 函式的參數為void，代表不接受任何參數。 rand()產生亂數，以下為rand函式的定義，不接受任何參數，回傳int 1 int rand (void); 產生0-100的亂數 1 2 int num = rand()%100; printf(\"rand = %d \\n\", num);"
  },"/pages/c/pointer/wildPointer/": {
    "title": "指標位址是無效內容",
    "keywords": "",
    "url": "/pages/c/pointer/wildPointer/",
    "body": "回收記憶體後的指標 回收指標記憶體位址中的內容，但指標仍指在原本的位址上。 1 2 3 4 5 6 7 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x600000004060 記憶體回收後的位址 = 0x600000004060 如果對已經被回收(清空)的位址進行讀取，讀取的內容不知道是什麼。 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; return 0; } 第7行，讀取已回收記憶體的位址中的內容。 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x60000000c010 讀取位址內容 = -559038448 為避免上面的情況，回收完記憶體，要把記憶體位址設為nullptr 1 2 3 4 5 6 7 8 9 int main() { int* p = new int(10); cout &lt;&lt; \"記憶體回收前的位址 = \" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; \"記憶體回收前的位址讀取位址內容 = \" &lt;&lt; *p &lt;&lt; endl; delete p; p = nullptr; cout &lt;&lt; \"記憶體回收後的位址 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 記憶體回收前的位址 = 0x60000000c010 記憶體回收前的位址讀取位址內容 = 10 記憶體回收後的位址 = 0x0 未初始化的指標 1 2 3 4 5 int main() { int* p; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告未初始化的指標。 第3行,印出位址，印出不知道何處的位址。 執行結果 0x1e 建議把宣告指標要設初始值。 1 2 3 4 5 int main() { int* p = nullptr; cout &lt;&lt; p &lt;&lt; endl; return 0; } 第2行,宣告指標，初始化nullptr。 第3行,印出位址，印出0。 執行結果 0x0 函式返回區域變數位址 1 2 3 4 5 6 7 8 9 10 int* func() { int i = 10; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", &amp;i = \" &lt;&lt; &amp;i &lt;&lt; endl; return &amp;i; } int main() { int* p = func(); cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; \", p = \" &lt;&lt; p &lt;&lt; endl; return 0; } 第1行,宣告函式，返回指標。 第3行,印出區域變數i的值與位址。 第4行,返回變數i的位址。 第7行,宣告指標p，取得函式返回的位址。 第8行,印出函式返回的位址中的值，與位址。 執行結果 i = 10, &amp;i = 0x7ff7bfeff44c *p = 32760, p = 0x7ff7bfeff44c 由以上執行結果可以發現區域變數i的位址與返回的位址不同，而且值也不一樣。"
  },"/pages/c/pointer/functionPointer/": {
    "title": "函式指標",
    "keywords": "",
    "url": "/pages/c/pointer/functionPointer/",
    "body": "函式指標指向函式的記憶體位址，通過函式指標使用函式。 函式資料型態 函式資料型態是由函式的傳回值資料型態/參數資料型態/參數的數量所組成。 如果多個函式的傳回值資料型態/參數資料型態/參數的數量都一樣，代表這些函式是同一個資料型態。 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式都是相同資料型態，傳回值資料型態/參數資料型態/參數的數量都一樣。 bool func4(string param1); bool func5(string msg); bool func6(string name); 以下二個函式不是相同資料型態。 int func1(int code, string msg); bool func4(string param1); 以下三個函式的函式資料型態為 int (*pf1)(int,string)，其中pf1為函式指標的變數名，可以為任意名稱，名稱前面要有星號*，要用括號()包起來，int為傳回值資料型態，(int,string)為函式參數資料型態與參數數量。 int func1(int code, string msg); int func2(int age, string name); int func3(int userId, string userName); 以下三個函式的函式資料型態為 bool (*pf2)(string)，其中pf2為函式指標的變數名，可以為任意名稱。 bool func4(string param1); bool func5(string msg); bool func6(string name); 宣告函式指標 1 2 3 4 5 6 7 8 9 10 int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { int (*pf1)(int,string); //宣告函式指標變數pf1 pf1 = func1; //將func1函式設給pf1函式指標變數 pf1(404, \"Page not found.\"); //使用函式指標pf1呼叫函式 return 0; } 第1行,宣告函式。 第6行,宣告函式指標變數pf1。 第7行,將func1函式設給pf1函式指標變數。 第8行,使用函式指標pf1呼叫函式。 執行結果 Err code = 404, msg = Page not found. typedef 自定義函式指標資料型態 語法 typedef 回傳值(*自定義資料型態名)(參數1,參數2,參數3 ...); 將前一個宣告函式指標的程式碼 1 int (*pf1)(int,string); 改成下方的程式碼，前面添加typedef，並把pf1改成Func1，Func1可以為任意名字，並放在程式的開頭。 1 typedef int (*Func1)(int,string); 修改完的程式碼如下 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; typedef int (*Func1)(int,string); int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { Func1 pf1; //宣告函式指標變數pf1 pf1 = func1; //函式指標變數pf1設定函式 pf1(404, \"Page not found.\");//使用函式指標pf1呼叫函式 return 0; } 第3行,宣告自定義函式指標資料型態Func1。 第9行,宣告指標變數pf1為Func1資料型態(自定義資料型態)。 執行結果 Err code = 404, msg = Page not found. 函式參數是函式指標 宣告函式print404Msg()，第一個參數為函式指標，函式的資料型態是傳回值為int，函式指標名為pf1，2個參數資料型態分別為int跟string。 1 2 3 void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } 第1行,宣告函式print404Msg()，第一個參數為函式指標，第二個參數為string資料型態。 第2行,使用函式指標pf1呼叫函式，並把404整數與msg的參數傳進函式。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; void print404Msg(int (*pf1)(int,string), string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 執行結果 Err code = 404, msg = Page not Found 函式參數是typedef，自定義函式指標資料型態 也可以使用typedef，自定義函式指標資料型態。 1 2 3 4 typedef int (*Func1)(int,string); void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } 第1行,宣告自定義函式指標資料型態Func1。 第2行,宣告函式print404Msg()，第一個參數資料型態為Func1(自定義資料型態)，第二個參數資料型態為string 第3行,使用函式指標呼叫函式，並把第二個參數msg傳入。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; typedef int (*Func1)(int,string); void print404Msg(Func1 pf1, string msg) { pf1(404, msg); } int func1(int code, string msg) { cout &lt;&lt; \"Err code = \" &lt;&lt; code &lt;&lt; \", msg = \" &lt;&lt; msg &lt;&lt; endl; return code; } int main() { print404Msg(func1, \"Page not Found\"); return 0; } 函式指標應用 自定義二個函式指標資料型態 1 2 typedef void (*Success)(char*); typedef void (*Failure)(int, char*); 第1行,宣告自定義函式資料型態，函式的資料型態是傳回值為void，函式指標名為Success，參數資料型態char*指標。 第2行,宣告自定義函式資料型態，函式的資料型態是傳回值為void，函式指標名為Failure，第1個參數資料型態int，第2個參數資料型態char*指標。 1 2 3 4 5 6 void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } 第1行,宣告函式，傳回值與參數資料型態都符合自定義函式資料型態Success 第4行,宣告函式，傳回值與參數資料型態都符合自定義函式資料型態Failure 1 2 3 4 5 6 7 8 9 10 11 12 void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 第1行,宣告函式，第1個參數資料型態int，第2個參數自定義函式指標資料型態Success，第3個參數自定義函式指標資料型態Failure。 第3行,使用函式指標Success呼叫函式。 第5行,使用函式指標Failure呼叫函式，並傳入參數。 第9行,呼叫http函式，並把函式傳回值參數與自定義Success函式資料型態一樣的httpOk函式傳入。 第10行,呼叫http函式，並把函式傳回值參數與自定義Failure函式資料型態一樣的httpFailure函式傳入。 完整程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; typedef void (*Success)(char*); typedef void (*Failure)(int, char*); void httpOk(char* msg) { printf(\"成功，結果:%s\\n\", msg); } void httpFailure(int code, char* msg) { printf(\"失敗%d，原因:%s\\n\", code, msg); } void http(int res, Success success, Failure failure) { if(res == 1) { success(\"取得資料成功\"); } else { failure(505,\"網路連線有問題\"); } } int main() { http(1,httpOk,httpFailure); http(0,httpOk,httpFailure); return 0; } 執行結果 成功，結果:取得資料成功 失敗505，原因:網路連線有問題"
  },"/pages/c/array/array/": {
    "title": "陣列",
    "keywords": "",
    "url": "/pages/c/array/array/",
    "body": "初始化值 資料型態 陣列名[長度] = {值1, 值2, 值3 …}; 若值的數量比長度小，沒有在括號{}中的值預設為0。 1 2 3 4 5 6 7 int main() { int arr[10] = {0,1,2,3}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 資料型態 陣列名[] = {值1, 值2, 值3 …}; 陣列長度 陣列的長度可以用常數、運算式。 常數 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; //使用常數 const int ARR_MAX = 10; int main() { int arr[ARR_MAX] = {0,1,2,3}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 運算式 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { double d = 10; //使用運算式設定陣列長度 int arr[sizeof(d)/2] = {0,1,2,3}; int size = sizeof(arr)/sizeof(int); cout &lt;&lt; \"arr size = \" &lt;&lt; size &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } arr size = 4 arr[0] = 0 arr[1] = 1 arr[2] = 2 arr[3] = 3 陣列中有多少元素？ sizeof(陣列名) / sizeof(陣列資料型態) = 元素個數 sizeof(陣列名) 是取得這個陣列占記憶體的大小。 sizeof(資料型態) 是取得資料資料型態占的記憶體大小，如int占4byte，double占8byte，char占1byte。 陣列中每一個值都初始化為整數0 以下二種寫法都是一樣，初始化為整數0。 資料型態 陣列名[長度] = {0}; 資料型態 陣列名[長度] = {}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {0}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } int arr1[10] = {}; for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 arr1[0] = 0 arr1[1] = 0 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0 memset() 陣列中每個元素設為整數0 void* memset(void *s, int c, size_t n); 參數1 : 陣列名 參數2 : 整數0 參數3 : 陣列記憶體大小 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int arr[10] = {1,2,3,4,5,6,7,8,9}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } memset(arr, 0, sizeof(arr)); for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } return 0; } 執行結果 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 0 arr[0] = 0 arr[1] = 0 arr[2] = 0 arr[3] = 0 arr[4] = 0 arr[5] = 0 arr[6] = 0 arr[7] = 0 arr[8] = 0 arr[9] = 0 memcpy() 複製陣列，記憶體內容複製 複製全部元素 陣列中全部的元素(來源陣列)複製到另一個大小相同的陣列(目標陣列)。 需要引入函式庫#include void* memcpy(void* dest, const void* src, size_t n) 參數1 : 目標陣列 參數2 : 來源陣列 參數3 : 陣列記憶體大小，或使用者自行定義要複製的byte。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 int arr1[sizeof(arr) / sizeof(int)]; memcpy(arr1, arr, sizeof(arr)); for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 arr1[4] = 5 arr1[5] = 6 arr1[6] = 7 arr1[7] = 8 arr1[8] = 9 arr1[9] = 10 複製部分元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; using namespace std; int main() { //來源陣列 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; for(int i = 0; i &lt; sizeof(arr)/sizeof(int); i++) { cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr[i] &lt;&lt; endl; } //目標陣列 //元素全初始化為整數0 int arr1[sizeof(arr) / sizeof(int)] = {0}; //只複製arr陣列8byte的元素 //(8byte/每個元素是4byte)=2，只複製2個元素 memcpy(arr1, arr, 8); for(int i = 0; i &lt; sizeof(arr1)/sizeof(int); i++) { cout &lt;&lt; \"arr1[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; arr1[i] &lt;&lt; endl; } return 0; } arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr1[0] = 1 arr1[1] = 2 arr1[2] = 0 arr1[3] = 0 arr1[4] = 0 arr1[5] = 0 arr1[6] = 0 arr1[7] = 0 arr1[8] = 0 arr1[9] = 0"
  },"/pages/c/array/pointerToArray/": {
    "title": "一維陣列與指標",
    "keywords": "",
    "url": "/pages/c/array/pointerToArray/",
    "body": "陣列的記憶體位址是連續的。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; (long long) &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; (long long) &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; (long long) &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; (long long) &amp;array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4]地址 = \" &lt;&lt; (long long) &amp;array[4] &lt;&lt; endl; return 0; } 執行結果 array[0]地址 = 140702053823568 array[1]地址 = 140702053823572 array[2]地址 = 140702053823576 array[3]地址 = 140702053823580 array[4]地址 = 140702053823584 從以上的執行結果可以知道每個位址差距4byte，而且是連續的。 陣列名就是陣列第0個元素的記憶體位址 C++將陣列名視為陣列第0個元素的記憶體位址。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 從以上的執行結果可以知道印出陣列名與使用&amp;取址運算子+陣列名與印出陣列第0個元素位址的結果是一樣的。 陣列運算 陣列名 + 1 陣列名 + 1，位址移動的範圍取決於陣列的資料型態。 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 從以上的執行結果可以知道每次陣列名 + n，移動的位址n * 4byte(陣列的資料型態為int)。 陣列第n個元素的記憶體位址 = 陣列名 + n (&amp;陣列名 + 1) 若是(&amp;陣列名+1)，移動的是整個陣列的記憶體位置。 1 2 3 4 5 6 7 8 9 int main() { int arr[10]; cout &lt;&lt; \"arr位址=\" &lt;&lt; (long long)arr &lt;&lt; endl; //印出arr+1的位址 cout &lt;&lt; \"arr+1位址=\" &lt;&lt; (long long)(arr + 1) &lt;&lt; endl; //印出&amp;arr + 1的位址 cout &lt;&lt; \"&amp;arr + 1位址=\" &lt;&lt; (long long)(&amp;arr + 1) &lt;&lt; endl; return 0; } arr位址=140702053823552 arr+1位址=140702053823556 &amp;arr + 1位址=140702053823592 arr+1是從 arr的記憶體位址(140702053823552)移動4byte，移到140702053823556。 (&amp;arr+1)是移動陣列長度10*4byte = 40 byte，從140702053823552移到140702053823592。 陣列名[索引] 等同 *(陣列名 + 索引) 透過*取值運算子，可以取出記憶體位址存放的內容。 C++編譯器將陣列名[索引] 解釋為 *(陣列名 + 索引) arr[0]與*(arr + 0)是相同的意思，都是對陣列第0個元素的記憶體位址取出存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[] = {10, 100, 200}; //印出arr[0]的地址 cout &lt;&lt; \"arr地址=\" &lt;&lt; arr &lt;&lt; endl; //印出arr[0]的地址 cout &lt;&lt; \"arr+0地址=\" &lt;&lt; arr+0 &lt;&lt; endl; //印出arr[1]的地址 cout &lt;&lt; \"arr+1地址=\" &lt;&lt; arr+1 &lt;&lt; endl; //印出arr[2]的地址 cout &lt;&lt; \"arr+2地址=\" &lt;&lt; arr+2 &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr值=\" &lt;&lt; *(arr) &lt;&lt; endl; //印出arr[0]的值 cout &lt;&lt; \"arr+0值=\" &lt;&lt; *(arr+0) &lt;&lt; endl; //印出arr[1]的值 cout &lt;&lt; \"arr+1值=\" &lt;&lt; *(arr+1) &lt;&lt; endl; //印出arr[2]的值 cout &lt;&lt; \"arr+2值=\" &lt;&lt; *(arr+2) &lt;&lt; endl; 執行結果 arr地址=0x7ff7bfeff45c arr+0地址=0x7ff7bfeff45c arr+1地址=0x7ff7bfeff460 arr+2地址=0x7ff7bfeff464 arr值=10 arr+0值=10 arr+1值=100 arr+2值=200 指標指向陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //印出指標變數p，也就是印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; return 0; } 執行結果 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 p指標內容 = 0x7ff7bfeff450 p指標內容為陣列名的地址。 指標運算與陣列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; using namespace std; int main() { int array[5]; cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //指標變數p + 0，印出第0個元素記憶體位址 cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //指標變數p + 1，印出第1個元素記憶體位址 cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //指標變數p + 2，印出第2個元素記憶體位址 cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //指標變數p + 3，印出第3個元素記憶體位址 cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 陣列名 = 0x7ff7bfeff450 陣列名地址 = 0x7ff7bfeff450 array[0]地址 = 0x7ff7bfeff450 array[1]地址 = 0x7ff7bfeff454 array[2]地址 = 0x7ff7bfeff458 array[3]地址 = 0x7ff7bfeff45c p指標內容 = 0x7ff7bfeff450 p指標+0 = 0x7ff7bfeff450 p指標+1 = 0x7ff7bfeff454 p指標+2 = 0x7ff7bfeff458 p指標+3 = 0x7ff7bfeff45c 由以上的結果可知，指標 + 1 與 &amp;array[1]的結果是一樣的。 指標運算取值 透過*取值運算子，可以取出記憶體位址存放的內容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; //指標變數p使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; //指標變數p + 0使用取值運算子，取出第0個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; //指標變數p + 1使用取值運算子，取出第1個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; //指標變數p + 2使用取值運算子，取出第2個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; //指標變數p + 3使用取值運算子，取出第3個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; //指標變數p + 4使用取值運算子，取出第4個元素記憶體位址中的值 cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 *(指標 + 索引) 等同 指標[索引] C++編譯器將指標[索引] 解釋為 *(指標 + 索引) 指標就是存放記憶體位址，陣列名就是陣列第0個元素的記憶體位址，陣列名也是記憶體位址，所以陣列名[索引]等同記憶體位址[索引]，而指標是記憶體位址，等同記憶體位址[索引]，二者是相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; int* p = array; cout &lt;&lt; \"*p指標 = \" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; \"*p指標+0 = \" &lt;&lt; *(p + 0) &lt;&lt; endl; cout &lt;&lt; \"*p指標+1 = \" &lt;&lt; *(p + 1) &lt;&lt; endl; cout &lt;&lt; \"*p指標+2 = \" &lt;&lt; *(p + 2) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 3) &lt;&lt; endl; cout &lt;&lt; \"*p指標+3 = \" &lt;&lt; *(p + 4) &lt;&lt; endl; //使用指標[索引]的方式，把記憶體位址存放的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引3] = \" &lt;&lt; p[3] &lt;&lt; endl; cout &lt;&lt; \"p指標[索引4] = \" &lt;&lt; p[4] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 1 *p指標+0 = 1 *p指標+1 = 2 *p指標+2 = 3 *p指標+3 = 4 *p指標+3 = 5 p指標[索引0] = 1 p指標[索引1] = 2 p指標[索引2] = 3 p指標[索引3] = 4 p指標[索引4] = 5 記憶體位址[索引] 等同 *(記憶體位址 + 索引) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; cout &lt;&lt; \"array[0] = \" &lt;&lt; array[0] &lt;&lt; endl; cout &lt;&lt; \"array[1] = \" &lt;&lt; array[1] &lt;&lt; endl; cout &lt;&lt; \"array[2] = \" &lt;&lt; array[2] &lt;&lt; endl; cout &lt;&lt; \"array[3] = \" &lt;&lt; array[3] &lt;&lt; endl; cout &lt;&lt; \"array[4] = \" &lt;&lt; array[4] &lt;&lt; endl; //印出陣列名[索引2]的記憶體位址 cout &lt;&lt; \"記憶體位址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; //&amp;陣列名[索引2]，代表取出陣列名[索引2]的記憶體位址，使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址 = \" &lt;&lt; *(&amp;array[2]) &lt;&lt; endl; //&amp;陣列名[索引2]+0，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+0 = \" &lt;&lt; *(&amp;array[2] + 0) &lt;&lt; endl; //&amp;陣列名[索引2]+1，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+1 = \" &lt;&lt; *(&amp;array[2] + 1) &lt;&lt; endl; //&amp;陣列名[索引2]+2，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"*記憶體位址+2 = \" &lt;&lt; *(&amp;array[2] + 2) &lt;&lt; endl; //(&amp;陣列名[索引2])[0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引0] = \" &lt;&lt; (&amp;array[2])[0] &lt;&lt; endl; //(&amp;陣列名[索引2])[1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引1] = \" &lt;&lt; (&amp;array[2])[1] &lt;&lt; endl; //(&amp;陣列名[索引2])[2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並使用\\*取值運算子把記憶體位址存的值取出來 cout &lt;&lt; \"記憶體位址[索引2] = \" &lt;&lt; (&amp;array[2])[2] &lt;&lt; endl; //取出陣列名[索引2]的記憶體位址指派給指標變數p int* p = &amp;array[2]; //指標[索引0]，記憶體位址往後移動0byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引0] = \" &lt;&lt; p[0] &lt;&lt; endl; //指標[索引1]，記憶體位址往後移動4byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引1] = \" &lt;&lt; p[1] &lt;&lt; endl; //指標[索引2]，記憶體位址往後移動8byte(取決於記憶體位址的資料型態，目前的資料型態是int)，並把記憶體位址存的值取出來 cout &lt;&lt; \"p指標[索引2] = \" &lt;&lt; p[2] &lt;&lt; endl; return 0; } 執行結果 array[0] = 1 array[1] = 2 array[2] = 3 array[3] = 4 array[4] = 5 *p指標 = 3 *p指標+0 = 3 *p指標+1 = 4 *p指標+2 = 5 記憶體位址[索引0] = 3 記憶體位址[索引1] = 4 記憶體位址[索引2] = 5 p指標[索引0] = 3 p指標[索引1] = 4 p指標[索引2] = 5 陣列與指標與迴圈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); for(int i = 0; i &lt; size; i++) { //印出array[i]記憶體位址 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 記憶體位址 = \" &lt;&lt; &amp;array[i] &lt;&lt; endl; //印出array + i記憶體位址 cout &lt;&lt; \"array+\"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; array + i &lt;&lt; endl; //印出array[i]的值 cout &lt;&lt; \"array[\"&lt;&lt; i &lt;&lt; \"] 的值 = \" &lt;&lt; array[i] &lt;&lt; endl; //印出*(array + i)的值 cout &lt;&lt; \"*(array+\"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(array + i) &lt;&lt; endl; } //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for(int i = 0; i &lt; size; i++) { //印出p + i的記憶體位址 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; p + i &lt;&lt; endl; //印出*(p + i)記憶體位址存放的值 cout &lt;&lt; \"*(p + \"&lt;&lt; i &lt;&lt; \") 的值 = \" &lt;&lt; *(p + i) &lt;&lt; endl; } return 0; } 執行結果 array[0] 記憶體位址 = 0x7ff7bfeff450 array+0 記憶體位址 = 0x7ff7bfeff450 array[0] 的值 = 1 *(array+0) 的值 = 1 array[1] 記憶體位址 = 0x7ff7bfeff454 array+1 記憶體位址 = 0x7ff7bfeff454 array[1] 的值 = 2 *(array+1) 的值 = 2 array[2] 記憶體位址 = 0x7ff7bfeff458 array+2 記憶體位址 = 0x7ff7bfeff458 array[2] 的值 = 3 *(array+2) 的值 = 3 array[3] 記憶體位址 = 0x7ff7bfeff45c array+3 記憶體位址 = 0x7ff7bfeff45c array[3] 的值 = 4 *(array+3) 的值 = 4 array[4] 記憶體位址 = 0x7ff7bfeff460 array+4 記憶體位址 = 0x7ff7bfeff460 array[4] 的值 = 5 *(array+4) 的值 = 5 p + 0 記憶體位址 = 0x7ff7bfeff450 *(p + 0) 的值 = 1 p + 1 記憶體位址 = 0x7ff7bfeff454 *(p + 1) 的值 = 2 p + 2 記憶體位址 = 0x7ff7bfeff458 *(p + 2) 的值 = 3 p + 3 記憶體位址 = 0x7ff7bfeff45c *(p + 3) 的值 = 4 p + 4 記憶體位址 = 0x7ff7bfeff460 *(p + 4) 的值 = 5 陣列與指標遞增遞減 指標++ int array[5] = {1,2,3,4,5}; int* p = array; 將陣列第0個元素的記憶體位址指定至指標變數p。 指標運算 記憶體位址 記憶體位址存放的值 p + 0 140702053823568 1 p + 1 140702053823572 2 p + 2 140702053823576 3 p + 3 140702053823580 4 p + 4 140702053823584 5 指標變數p指向的是一個整數資料型態(4byte)的地址，每一次p + 1，指標變數p就會移動4byte。 p++也就是等於 p = p + 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; int main() { int array[5] = {1,2,3,4,5}; int size = sizeof(array) / sizeof(int); //將陣列名(也就是陣列第0個元素的記憶體位址)指定至指標變數p int* p = array; for(int i = 0; i &lt; size; i++) { //印出指標變數p的內容(指標存放的內容是記憶體位址) cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 記憶體位址 = \" &lt;&lt; (long long)p &lt;&lt; endl; //印出指標變數p記憶體位址存放的值 cout &lt;&lt; \"p + \"&lt;&lt; i &lt;&lt; \" 的值 = \" &lt;&lt; *p &lt;&lt; endl; //p = p + 1，指標變數移動4byte，將移動後的記憶體位址指派給指標變數p p++; } return 0; } 執行結果 p + 0 記憶體位址 = 140702053823568 p + 0 的值 = 1 p + 1 記憶體位址 = 140702053823572 p + 1 的值 = 2 p + 2 記憶體位址 = 140702053823576 p + 2 的值 = 3 p + 3 記憶體位址 = 140702053823580 p + 3 的值 = 4 p + 4 記憶體位址 = 140702053823584 p + 4 的值 = 5 *ptr++ 指標先取出記憶體位址存放的值，再往下一個位址移動。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for(int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*ptr++); } 執行結果 值= 10 值= 100 值= 200 *++ptr 指標先往下一個記憶體位址移動，再取出記憶體位址存放的值。 1 2 3 4 5 6 7 8 //宣告一個陣列 int arr[] = {10, 100, 200}; //將arr的第一個值(10)的位址傳給ptr指標 //ptr是整數型態4byte的指標 int *ptr = arr; for(int i = 0; i &lt; 3; i++) { printf(\"值= %d\\n\",*++ptr); } 執行結果 值= 100 值= 200 值= 0 ptr--指標遞減 將指標指向前一個記憶體位址 1 2 3 4 5 6 7 8 9 int arr[] = {10, 100, 200}; //取得陣列中最後一個值的記憶體位址 int *ptr = &amp;arr[2]; for(int i = 3; i &gt; 0; i--) { printf(\"arr[%d]:記憶體位址= %#x\\n\",i ,ptr); printf(\"arr[%d]:值= %d\\n\",i ,*ptr); //將指標指向前一個記憶體位址 ptr--; } 執行結果 arr[3]:記憶體位址= 0xbfdff37c arr[3]:值= 200 arr[2]:記憶體位址= 0xbfdff378 arr[2]:值= 100 arr[1]:記憶體位址= 0xbfdff374 arr[1]:值= 10 陣列名是常數，不可修改 指標變數p可以設為其它記憶體位址。 p = p + 1; p++; 陣列名無法再設為其它記憶體位址，以下的語法無法編譯成功。 array = array + 1; array++; 記憶體位址轉型 以下程式碼將字元陣列轉型成整數陣列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //宣告字元陣列 大小20byte char array[20]; //將字元陣列的記憶體空間轉型成整數資料型態的記憶體空間 //把轉型成整數型態的陣列[0]位址，指派給整數型態的指標變數p int* p = (int*)array; //sizeof(陣列名)取得陣列全部記憶體大小為20byte //再除以整數資料型態的大小sizeof(int) = 4byte int size = sizeof(array)/sizeof(int); cout &lt;&lt; \"size = \" &lt;&lt; size &lt;&lt; endl; for(int i = 0; i &lt; size; i++) { p[i] = i;//修改記憶體位址中存放的值 //上面的寫法與下面的寫法是相同意思 //*(p + i) = i; } for(int i = 0; i &lt; size; i++) { //印出記憶體位址存放的值 cout &lt;&lt;\"*(p + \"&lt;&lt; i &lt;&lt;\") = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } 執行結果 *(p + 0) = 0 *(p + 1) = 1 *(p + 2) = 2 *(p + 3) = 3 *(p + 4) = 4 函式的參數為指向陣列的指標 參數的寫法有下面二種，因為傳入的參數是指標，對指標用sizeof(指標)，只會得到8byte，所以一定要傳入陣列的長度，或者把陣列的長度設為常數。 void func(int* arr, int len); 參數1，指標變數名arr。 參數2，陣列長度。 void func(int arr[], int len); 參數1，指標變數名arr[]，使用陣列表示法不代表是陣列，而是指標。 參數2，陣列長度。 以下程式碼為傳陣列給函式的寫法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; void func(int arr[], int len) { cout &lt;&lt; \"arr指標大小 = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; for(int i = 0; i &lt; len; i++) { //使用*(陣列名 + 索引)印出陣列元素，也可以使用陣列名[索引]的方式印出陣列元素 cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; *(arr + i) &lt;&lt; endl; } } int main() { int array[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; //參數1傳入陣列名，陣列名為陣列第0個元素的記憶體位址，參數2傳入陣列大小 func(array,sizeof(array)/sizeof(int)); } 執行結果 arr指標大小 = 8 arr[0] = 1 arr[1] = 2 arr[2] = 3 arr[3] = 4 arr[4] = 5 arr[5] = 6 arr[6] = 7 arr[7] = 8 arr[8] = 9 arr[9] = 10 arr[10] = 11 arr[11] = 12 arr[12] = 13 arr[13] = 14 arr[14] = 15"
  },"/pages/c/pointer/pointerArithmetic/": {
    "title": "指標運算",
    "keywords": "",
    "url": "/pages/c/pointer/pointerArithmetic/",
    "body": "指標 + 1，位址增減取決於記憶體位址中存放內容的資料型態。 為了方便看出來差異，以下的位址全轉型成long long長整數。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; using namespace std; int main() { char c; //印出char的大小 cout &lt;&lt; \"sizeof(char) = \" &lt;&lt; sizeof(c) &lt;&lt; endl; //印出變數c的位址 cout &lt;&lt; \"c的地址 = \" &lt;&lt; (long long)&amp;c &lt;&lt; endl; //印出變數c的地址往後移動一格的位址，與變數c的位址相差為1byte cout &lt;&lt; \"c的地址 + 1 = \" &lt;&lt; (long long)(&amp;c + 1) &lt;&lt; endl; int i; //印出int的大小 cout &lt;&lt; \"sizeof(int) = \" &lt;&lt; sizeof(i) &lt;&lt; endl; //印出變數i的位址 cout &lt;&lt; \"i的地址 = \" &lt;&lt; (long long)&amp;i &lt;&lt; endl; //印出變數i的地址往後移動一格的位址與變數i的位址相差為4byte cout &lt;&lt; \"i的地址 + 1 = \" &lt;&lt; (long long)(&amp;i + 1) &lt;&lt; endl; double d; //印出double的大小 cout &lt;&lt; \"sizeof(double) = \" &lt;&lt; sizeof(d) &lt;&lt; endl; //印出變數d位址 cout &lt;&lt; \"d的地址 = \" &lt;&lt; (long long)&amp;d &lt;&lt; endl; //印出變數d的地址往後移動一格的位址，與變數d的位址相差為8byte cout &lt;&lt; \"d的地址 + 1 = \" &lt;&lt; (long long)(&amp;d + 1) &lt;&lt; endl; return 0; } 執行結果 sizeof(char) = 1 c的地址 = 140702053823595 c的地址 + 1 = 140702053823596 sizeof(int) = 4 i的地址 = 140702053823588 i的地址 + 1 = 140702053823592 sizeof(double) = 8 d的地址 = 140702053823576 d的地址 + 1 = 140702053823584"
  },"/pages/c/pointer/pointerToPointer/": {
    "title": "指標的指標",
    "keywords": "",
    "url": "/pages/c/pointer/pointerToPointer/",
    "body": "Prerequisites: 引數 指標的指標，意思是指標的記憶體位址。 指標的位址 1 2 3 4 5 6 7 8 9 10 int main() { int i = 40; cout &lt;&lt; \"i的值 = \" &lt;&lt; i &lt;&lt; \"，i的位址 = \" &lt;&lt; &amp;i &lt;&lt; endl; int *p = &amp;i; cout &lt;&lt; \"指標p指向的位址 = \" &lt;&lt; p &lt;&lt; \"，指標p的位址 = \" &lt;&lt; &amp;p &lt;&lt; \"，指標p指向位址的值=\" &lt;&lt; *p &lt;&lt; endl; int **pp = &amp;p; cout &lt;&lt; \"指標pp指向的位址 = \" &lt;&lt; pp &lt;&lt; \"，指標pp的位址 = \" &lt;&lt; &amp;pp &lt;&lt; \"，指標pp指向的位址(p)指向的位址(i)=\" &lt;&lt; *pp &lt;&lt; endl; cout &lt;&lt; \"指標pp指向的位址(p)指向的位址(i)的值=\" &lt;&lt; **pp &lt;&lt; endl; return 0; } i的值 = 40，i的位址 = 0x7ff7bfeff468 指標p指向的位址 = 0x7ff7bfeff468，指標p的位址 = 0x7ff7bfeff460，指標p指向位址的值=40 指標pp指向的位址 = 0x7ff7bfeff460，指標pp的位址 = 0x7ff7bfeff458，指標pp指向的位址(p)指向的位址(i)=0x7ff7bfeff468 指標pp指向的位址(p)指向的位址(i)的值=40 其它程式碼解釋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { int i4 = 40; //宣告一個指標存i4的位址 int *p2 = &amp;i4; //將p2指標的位址傳給pp2 int **pp2 = &amp;p2; //1.把pp2存放的位址，使用取值運算子*，也就是指標p2的位址 //*pp2; //2.再把p2位址，使用取值運算子*，也就是40 //**pp2 printf(\"解出pp2的值:%d\\n\",**pp2); return 0; } 執行結果 解出pp2的值:40 函式參數為指標的指標 在函式中若要修改指標所指向的記憶體位址，就要用到指標的指標。 引數為指標的位址，函式參數宣告為指標資料型態** 指標變數，這樣才可以接收指標的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函數並嘗試對其進行修改，則對指標所做的更改不會反映回該函數外部。這是因為僅將指標的副本傳遞給函數。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函數內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變量，而原始指標保持不變。 函式語法 回傳型態 函式名(指標資料型態** 指標) { *指標 = 其它記憶體位址 } 呼叫函式語法 函式(&amp;指標位址) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &amp;global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &amp;var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 指標的指標與new 參考文章 參考指向指標與new new會返回動態配置記憶體的開始位址，將p_to_p使用*取值運算子修改p指向的位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 指標是p_to_p，指向外部指標的位址 void initAddress(int** p_to_p){ //印出指向外部指標p的記憶體位址 cout &lt;&lt; \"Before p address = \" &lt;&lt; *p_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 //使用*取值運算子修改指標p指向的位址 *p_to_p = new int(10); //印出指向外部指標的記憶體位址與值 cout &lt;&lt; \"After p address= \" &lt;&lt; *p_to_p &lt;&lt; \",After p value = \" &lt;&lt; **p_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p的位址 initAddress(&amp;p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before p address = 0x0 After p address= 0x60000000c010,After p value = 10 == outside == outside pointer address = 0x60000000c010，outside pointer value = 10"
  },"/pages/c/array/dynamicArrays/": {
    "title": "陣列與動態配置記憶體",
    "keywords": "",
    "url": "/pages/c/array/dynamicArrays/",
    "body": "參考文件 new/delete 建立陣列記憶體位址 資料型態 *陣列名 = new 資料型態[長度]; new回傳值是陣列第0筆元素記憶體位址，由指標(*陣列名)接收回傳的記憶體位址。 記憶體回收 delete[] 指標變數; 不能使用sizeof() 因為陣列名是指標，使用sizeof(陣列名)只會回傳8btye 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int main() { //分配連續100個int的記憶體空間 int *arr_p = new int[100]; cout &lt;&lt; \"使用陣列索引:\" &lt;&lt; endl; //使用索引修改陣列的元素 for(int i = 0; i &lt; 100; i++) { arr_p[i] = i; } //使用索引印出陣列的元素 for(int i = 0; i &lt; 100; i++) { cout &lt;&lt; arr_p[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; cout &lt;&lt; \"使用指標:\" &lt;&lt; endl; //使用指標修改陣列的元素 for(int i = 0; i &lt; 100; i++) { *(arr_p + i) = i + 100; } //使用指標印出陣列的元素 for(int i = 0; i &lt; 100; i++) { cout &lt;&lt; *(arr_p + i) &lt;&lt; \",\"; } cout &lt;&lt; endl; //陣列記憶體回收 delete[] arr_p; //指標設為nullptr代表不指向任何記憶體位址 arr_p = nullptr; return 0; } 執行結果 使用陣列索引: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99, 使用指標: 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199, 陣列其它用法 全設為0 int *arr_p1 = new int[3](); 設定初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; using namespace std; int main() { //全設0 int *arr_p1 = new int[3](); // 0,0,0 //設初始值 int *arr_p2 = new int[3]{1,2,3}; //1,2,3 //用索引取值 cout &lt;&lt; arr_p1[0] &lt;&lt; \",\" &lt;&lt; arr_p1[1] &lt;&lt; \",\" &lt;&lt; arr_p1[2] &lt;&lt; endl; //用指標取值 cout &lt;&lt; *(arr_p2 + 0) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 1) &lt;&lt; \",\" &lt;&lt; *(arr_p2 + 2) &lt;&lt; endl; //記憶體回收 delete [] arr_p1; delete [] arr_p2; //指標設為不指向任何記憶體位址 arr_p1 = nullptr; arr_p2 = nullptr; return 0; } 執行結果 0,0,0 1,2,3"
  },"/pages/c/array/charArray/": {
    "title": "char 字串",
    "keywords": "",
    "url": "/pages/c/array/charArray/",
    "body": "空字元(null character) char字串必須以’\\0’做結尾，若不是’\\0’做結尾則稱為char陣列。 宣告字串，必須留1個字元，放結尾\\0，以下宣告最多可以放5個字元，而第6個字元則是放\\0。 char str[6]; 以下二種宣告是完全不同，一個是字串，一個是陣列。 1 2 3 4 5 6 7 8 //char字串 // \\0 代表結尾 char str1[6] = {'h','e','l','l','o','\\0'}; cout &lt;&lt; \"str1 長度 = \" &lt;&lt; strlen(str1) &lt;&lt; \",內容 = \" &lt;&lt; str1 &lt;&lt; endl; //char 陣列 char arr[6] = {'h','e','l','l','o','o'}; cout &lt;&lt; \"arr 長度 = \" &lt;&lt; strlen(arr) &lt;&lt; \",內容 = \" &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; \"arr sizeof = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; 執行結果 str1 長度 = 5,內容 = hello arr 長度 = 11,內容 = helloohello arr sizeof = 6 字串常數 注意!以下”“雙引號包住的字串是常數，常數代表不可以修改，編譯器會自動加上’\\0’作結尾，不用手動加’\\0’。 1 2 //字串常數 char str1[] = \"hello\" 字串常數宣告 以下程式碼，cstr1沒有初始化字串常數，執行程式時會從cstr1的記憶體位址開始輸出值，直到遇到記憶體位址的值為\\0(空字元)才會停止輸出，不會因為超過宣告字串的長度而停止印出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; int main() { char cstr1[21];//cstr1沒有初始化字串常數 //遇到記憶體位址的值為\\0(空字元)才會停止輸出 cout &lt;&lt; \"cstr1 長度 = \" &lt;&lt; strlen(cstr1) &lt;&lt; \",內容 = \" &lt;&lt; cstr1 &lt;&lt; endl; //以下結尾編譯器會自動加上\\0 char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; char cstr3[6] = \"hello\"; cout &lt;&lt; \"cstr3 長度 = \" &lt;&lt; strlen(cstr3) &lt;&lt; \",內容 = \" &lt;&lt; cstr3 &lt;&lt; endl; char cstr4[] = {\"hello\"}; cout &lt;&lt; \"cstr4 長度 = \" &lt;&lt; strlen(cstr4) &lt;&lt; \",內容 = \" &lt;&lt; cstr4 &lt;&lt; endl; char cstr5[6] = {\"hello\"}; cout &lt;&lt; \"cstr5 長度 = \" &lt;&lt; strlen(cstr5) &lt;&lt; \",內容 = \" &lt;&lt; cstr5 &lt;&lt; endl; char cstr6[6] {\"hello\"}; cout &lt;&lt; \"cstr6 長度 = \" &lt;&lt; strlen(cstr6) &lt;&lt; \",內容 = \" &lt;&lt; cstr6 &lt;&lt; endl; //設為nullptr char cstr7[6] = {0}; cout &lt;&lt; \"cstr7 長度 = \" &lt;&lt; strlen(cstr7) &lt;&lt; \",內容 = \" &lt;&lt; cstr7 &lt;&lt; endl; return 0; } 執行結果 cstr1 長度 = 6,內容 = p\\364\\357\\277\\367 cstr2 長度 = 5,內容 = hello cstr3 長度 = 5,內容 = hello cstr4 長度 = 5,內容 = hello cstr5 長度 = 5,內容 = hello cstr6 長度 = 5,內容 = hello cstr7 長度 = 0,內容 = 二維陣列字串 參考 二維陣列 以下的例子是建立二維的字串，總共有7個字串，每個字串最大長度為10，Wednesday是最長字串，長度為9，加上\\0就等於10。 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; for(int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } Sunday Monday Tuesday Wednesday Thursday Friday Saturday 字串全設為\\0 使用memset，第二個參數設為0，代表把字串的記憶體位址的值全設為\\0。 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; int main() { char cstr2[] = \"hello\"; cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; memset(cstr2,0,sizeof(cstr2)); cout &lt;&lt; \"cstr2 長度 = \" &lt;&lt; strlen(cstr2) &lt;&lt; \",內容 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } 執行結果 cstr2 長度 = 5,內容 = hello cstr2 長度 = 0,內容 = 字串拷貝 strcpy char * strcpy ( char * destination, const char * source ); 要從來源的字串，拷貝到目標的字串。 參數1:目標(拷貝到那裡？) 參數2:要拷貝的字串(src) 拷貝完成後，會自動在目標字串最後面加上\\0。 1 2 3 4 char c_str1[6] = {'h','e','l','\\0'}; char c_str4[20] = {'t','e'}; strcpy(c_str4, c_str1); cout &lt;&lt; \"c_str4:\" &lt;&lt; c_str4 &lt;&lt; endl; 執行結果 c_str4:hel 字元個數拷貝 strncpy char *strncpy(char *string1, const char *string2, size_t count); 參數1:目標字串(拷貝到那裡？) 參數2:要拷貝的字串(src) 參數3:要拷貝多少個字元 若參數3(拷貝多少個字元)比參數2(來源字串長度)小，拷貝完成後，不會在參數1(目標字串)的結尾加上\\0。 1 2 3 4 5 6 7 8 9 10 11 12 13 char c_str4[10]; //拷貝2個字元至c_str4 strncpy(c_str4,\"hello\",2); cout &lt;&lt; \"c_str4[0] = \" &lt;&lt; c_str4[0] &lt;&lt; endl; cout &lt;&lt; \"c_str4[1] = \" &lt;&lt; c_str4[1] &lt;&lt; endl; cout &lt;&lt; \"c_str4[2] = \" &lt;&lt; c_str4[2] &lt;&lt; endl; cout &lt;&lt; \"c_str4[3] = \" &lt;&lt; c_str4[3] &lt;&lt; endl; cout &lt;&lt; \"c_str4[4] = \" &lt;&lt; c_str4[4] &lt;&lt; endl; cout &lt;&lt; \"c_str4[5] = \" &lt;&lt; c_str4[5] &lt;&lt; endl; cout &lt;&lt; \"c_str4[6] = \" &lt;&lt; c_str4[6] &lt;&lt; endl; cout &lt;&lt; \"c_str4[7] = \" &lt;&lt; c_str4[7] &lt;&lt; endl; cout &lt;&lt; \"c_str4[8] = \" &lt;&lt; c_str4[8] &lt;&lt; endl; cout &lt;&lt; \"c_str4[9] = \" &lt;&lt; c_str4[9] &lt;&lt; endl; 以下XCode可以正常執行，會在第2個字元以後補上\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = \u001e c_str4[3] = VS Code執行時，不會在第2個字元以後自動補\\0(也就是ascii code = 0，也稱 null character) c_str4[0] = h c_str4[1] = e c_str4[2] = &amp; c_str4[3] = x00 c_str4[4] = x00 c_str4[5] = x00 c_str4[6] = x00 c_str4[7] = x00 c_str4[8] = x00 c_str4[9] = x00 若一開始把字串的記憶體位址的值全設為ascii code 0，就不會出現上述問題。 1 2 char c_str4[10] = {0}; strncpy(c_str4,\"hello\",2); 字串長度 strlen strlen()是計算字串中有幾個字元，不包含字串結尾\\0。 sizeof()是計算字串變數全部記憶體大小。 1 2 3 4 5 6 int main() { char c_str4[10] = \"hello!\"; cout &lt;&lt; \"c_str4 size:\" &lt;&lt; sizeof(c_str4) &lt;&lt; endl; cout &lt;&lt; \"c_str4長度:\" &lt;&lt; strlen(c_str4) &lt;&lt; endl; return 0; } c_str4 size:10 c_str4長度:6 字串連接 strcat 1 2 3 4 5 6 7 char c_str1[6] = {'h','e','l','\\0'}; //[]可為空 char c_str2[] = {'h','e','l','l','o','\\0'}; char c_str3[10]; char c_str4[20] = {'t','e'}; strcpy(c_str3, c_str1); cout &lt;&lt; \"c_str3 + c_str4 = \" &lt;&lt; strcat(c_str3,c_str4) &lt;&lt; endl; 執行結果 c_str3 + c_str4 = helte"
  },"/pages/c/array/qsort/": {
    "title": "qsort排序",
    "keywords": "",
    "url": "/pages/c/array/qsort/",
    "body": "qsort使用方法 void qsort ( void * base , size_t nitems , size_t size , int (* compar )( const void *, const void *)) 參數1，陣列名。 參數2，陣列大小。 參數3，陣列中每個元素的大小。 參數4，callback函式，判斷比大小的函式。 int compar( const void *p1, const void *p2) * 傳回值為int整數。 * 傳回值 &gt; 0 * p1會排在p2前面 * 傳回值 == 0 * p1與p2相等 * 傳回值 &lt; 0 * p1會排在p2後面 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; using namespace std; int compare(const void* p1, const void* p2) { //void*指標代表接收任何資料型態的參數 //把void*指標轉成int*指標 int* pi1 = (int*) p1; int* pi2 = (int*) p2; //把pi1指標使用*取值運算子，取出pi1記憶體位址存放的值 //把pi2指標使用*取值運算子，取出pi2記憶體位址存放的值 //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回-1 if(*pi1 &lt; *pi2) return -1; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回0 else if(*pi1 == *pi2) return 0; //pi1記憶體位址的值 小於 pi2記憶體位址的值，傳回1 //else if(*pi1 &gt; *pi2) else return 1; } int main() { //宣告大小為10的整數陣列 int arr[10] = {8,1,7,2,6,3,5,5,1,10}; //陣列大小 int size = sizeof(arr)/sizeof(int); //排序 qsort(arr, size, sizeof(int), compare); for(int i = 0; i &lt; size; i++) { //印出每個元素 cout &lt;&lt; arr[i] &lt;&lt; \",\"; } cout &lt;&lt; endl; return 0; } 執行結果 1,1,2,3,5,5,6,7,8,10,"
  },"/pages/c/basic/typedef/": {
    "title": "typedef 型別定義",
    "keywords": "",
    "url": "/pages/c/basic/typedef/",
    "body": "int16_t int32_t int64_t C++建立不同作業系統(跨平台)可以支援的資料型態。 語法如下 typedef 資料型態 型別定義 作業系統 short int long long long Linux 2byte 4byte 8byte 8byte Windows 2byte 4byte 4byte 8byte 由上表可以發現，Linux與Windows在long資料型態占用記憶體大小不同。 Windows 1 2 3 4 //windows typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long long int64_t;//64位元整數 Linux 1 2 3 4 //Linux typedef short int16_t;//16位元整數 typedef int int32_t;//32位元整數 typedef long int64_t;//64位元整數 在寫程式時，資料型態使用int16_t與int32_t與int64_t，不再使用基本資料型態int，short，long，long long。 size_t 無符號整數型態 電腦 整數 byte數 範圍大小 32位元 unsigned int 4byte 0~4294967295 64位元 unsigned long long 8byte 0 到 18,446,744,073,709,551,615 由上表可以發現不同位元的電腦，C++顯示的整數型態不一樣。 32位元定義的size_t 1 typedef unsigned int size_t; 64位元定義的size_t 1 typedef unsigned long long size_t;"
  },"/pages/c/dynamicMemory/nothrow/": {
    "title": "記憶體不足",
    "keywords": "",
    "url": "/pages/c/dynamicMemory/nothrow/",
    "body": "std::nothrow 可以判斷若記憶體太小導致記憶體空間分配失數，會回傳nullptr。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; using namespace std; int main() { int *arr = new (std::nothrow)int[10000000000000001]; if(arr == nullptr){ cout &lt;&lt; \"記憶體配置失敗\"; } else { arr[10000000000000001] = 100; delete[] arr; arr = nullptr; } return 0; } 執行結果 記憶體配置失敗"
  },"/pages/c/array/array2dimen/": {
    "title": "二維陣列",
    "keywords": "",
    "url": "/pages/c/array/array2dimen/",
    "body": "初始化 初始化方法1 1 2 3 4 5 6 7 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 初始化方法2 1 2 3 4 5 6 7 int arr[2][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; 初始化方法3 第1個[]中不用寫長度，第2個[]中要寫長度。 1 2 3 4 5 6 7 int arr[][3] = {1,2,3,4,5,6}; cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; C11之後不用有等號 1 int arr[][3]{1,2,3,4,5,6}; 以上印出結果都是一樣。 sizeof sizeof在二維陣列的使用方式是取出陣列占記憶體全部的byte。 以下的例子二維陣列有6個元素，每個元素是整數4byte，所以陣列占的記憶體大小為6*4 = 24 1 2 int arr[][3] {1,2,3,4,5,6}; cout &lt;&lt; \"arr size = \" &lt;&lt; sizeof(arr) &lt;&lt; endl; arr size = 24 二維陣列轉成一維陣列 2維陣列記憶體位址是連續 把陣列名指派給指標，是把陣列[0][0]的記憶體位址指派給指標 使用指標把連續的記憶體位址中的值印出來。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;iostream&gt; using namespace std; int main() { //宣告陣列長度，初始化陣列全部元素為整數0 int arr[2][3] = {0}; //指派值到二維陣列 arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; //印出值 cout &lt;&lt; \"arr[0][0] = \" &lt;&lt; arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1] = \" &lt;&lt; arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2] = \" &lt;&lt; arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0] = \" &lt;&lt; arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1] = \" &lt;&lt; arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2] = \" &lt;&lt; arr[1][2] &lt;&lt; endl; //記憶體位址是連續 cout &lt;&lt; \"arr[0][0]位址 = \" &lt;&lt; (long long)&amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"arr[0][1]位址 = \" &lt;&lt; (long long)&amp;arr[0][1] &lt;&lt; endl; cout &lt;&lt; \"arr[0][2]位址 = \" &lt;&lt; (long long)&amp;arr[0][2] &lt;&lt; endl; cout &lt;&lt; \"arr[1][0]位址 = \" &lt;&lt; (long long)&amp;arr[1][0] &lt;&lt; endl; cout &lt;&lt; \"arr[1][1]位址 = \" &lt;&lt; (long long)&amp;arr[1][1] &lt;&lt; endl; cout &lt;&lt; \"arr[1][2]位址 = \" &lt;&lt; (long long)&amp;arr[1][2] &lt;&lt; endl; //因為記憶體位址都是連續的，把二維陣列[0][0]記憶體位址指派給指標p int* p = (int*)arr; //取得arr變數記憶體大小 int size = sizeof(arr) / sizeof(int); for(int i = 0; i &lt; size; i++) { //使用指標運算印出每個元素的值 cout &lt;&lt; \"*(p + \" &lt;&lt; i &lt;&lt; \") = \" &lt;&lt; *(p+i) &lt;&lt; \",\"; //使用索引方式印出值 cout &lt;&lt; \" [\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i] &lt;&lt; endl; } return 0; } arr[0][0] = 1 arr[0][1] = 2 arr[0][2] = 3 arr[1][0] = 4 arr[1][1] = 5 arr[1][2] = 6 arr[0][0]位址 = 140702053823568 arr[0][1]位址 = 140702053823572 arr[0][2]位址 = 140702053823576 arr[1][0]位址 = 140702053823580 arr[1][1]位址 = 140702053823584 arr[1][2]位址 = 140702053823588 *(p + 0) = 1, [0] = 1 *(p + 1) = 2, [1] = 2 *(p + 2) = 3, [2] = 3 *(p + 3) = 4, [3] = 4 *(p + 4) = 5, [4] = 5 *(p + 5) = 6, [5] = 6 從以上結果可以發現，記憶體位址的差距為4byte，而且是連續的。 可以使用指標把二維陣列轉成一維指標陣列，印出值。 指標指向二維陣列 二維陣列可以解釋為，一維陣列，裡面每一個元素又指向一維陣列。 宣告方式 資料類型 (*指標變數)[二維陣列每個元素所指向的一維陣列大小] = 二維陣列變數名; 使用二維陣列指標一定要把*指標變數用括號()包起來，因為有運算子優先順序的問題。 1 2 3 4 5 6 7 int main() { //[3]代表二維陣列每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; //[3]代表二維陣列每個元素是大小為3的一維陣列。 int (*p)[3] = arr; return 0; } 上一個程式碼例子 ，指標是指向二維陣列int[2][3]，無法轉成指向一維陣列的指標int*，所以要強制轉型成指向一維陣列的指標(int*)二維陣列變數名 以下程式碼原本指向一維陣列的指標，指向二維陣列會編譯錯誤。 //二維陣列 int arr[2][3] = {0}; //原本指向一維陣列的指標，直接指向二維陣列會編譯錯誤 int* p = arr; Cannot initialize a variable of type ‘int *’ with an lvalue of type ‘int[2][3]’ 二維陣列先轉成一維陣列，使用(int*)，再讓指標指向轉型成一維的陣列。 int arr[2][3] = {0}; int* p = (int*)arr; 二維陣列傳函式 方法有二種 指標方式 void func(int (*p)[3], int len); 陣列方式 void func(int p[][3], int len); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; void func(int (*p)[3], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; 3; j++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; p[i][j] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } } int main() { //[3]代表每個元素是大小為3的一維陣列。 int arr[2][3] = { {1,2,3},{4,5,6} }; func(arr, 2); return 0; } p[0][0] = 1 p[0][0] = 2 p[0][0] = 3 p[1][1] = 4 p[1][1] = 5 p[1][1] = 6 指標指向三維陣列 宣告方式 資料類型 (*指標變數)[陣列個數][元素個數] = 三維陣列變數名; 三維陣列傳函式的方法有二種 指標方式 void func(int (*p)[2][3], int len); 陣列方式 void func(int p[][2][3], int len); 印出陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; using namespace std; void func(int (*p)[2][3], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; 2; j++) { for(int k = 0; k &lt; 3; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } } int main() { int arr[2][2][3] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; func(arr, 2); return 0; } p[0][0][0] = 1 p[0][0][1] = 2 p[0][0][2] = 3 p[0][1][0] = 4 p[0][1][1] = 5 p[0][1][2] = 6 p[1][0][0] = 7 p[1][0][1] = 8 p[1][0][2] = 9 p[1][1][0] = 10 p[1][1][1] = 11 p[1][1][2] = 12 修改陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &lt;iostream&gt; using namespace std; const int firstMax = 2; const int secondMax = 2; const int thirdMax = 3; void modifyArr(int p[][secondMax][thirdMax], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; secondMax; j++) { for(int k = 0; k &lt; thirdMax; k++) { //修改指標記憶體位址的值 p[i][j][k] += 10; } }// end of j }// end of i } void printArr(int (*p)[secondMax][thirdMax], int len) { for(int i = 0; i &lt; len; i++) { for(int j = 0; j &lt; secondMax; j++) { for(int k = 0; k &lt; thirdMax; k++) { cout &lt;&lt; \"p[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"][\" &lt;&lt; k &lt;&lt; \"] = \" &lt;&lt; p[i][j][k] &lt;&lt; \"\\t\"; } cout &lt;&lt; endl; }// end of j cout &lt;&lt; endl; }//end of i } int main() { int arr[firstMax][secondMax][thirdMax] = { { {1,2,3}, {4,5,6} }, { {7,8,9}, {10,11,12} } }; modifyArr(arr, firstMax); printArr(arr, firstMax); return 0; } p[0][0][0] = 11 p[0][0][1] = 12 p[0][0][2] = 13 p[0][1][0] = 14 p[0][1][1] = 15 p[0][1][2] = 16 p[1][0][0] = 17 p[1][0][1] = 18 p[1][0][2] = 19 p[1][1][0] = 20 p[1][1][1] = 21 p[1][1][2] = 22"
  },"/pages/c/array/arrayOfPointers/": {
    "title": "指標陣列存放多個記憶體位址",
    "keywords": "",
    "url": "/pages/c/array/arrayOfPointers/",
    "body": "指標陣列 1 2 3 4 5 int i1 = 10; int i2 = 20; int i3 = 30; //宣告指標陣列存放3個記憶體位址 int *p_array[3] = {&amp;i1, &amp;i2, &amp;i3}; 取址與取值 方式有二種 指標方式 使用指標+i迴圈印出，用取值運算子*(p_array + i)取出記憶體位址，再把取出的記憶體位址再次使用*取值運算子，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i= %d的位置%#x, 值為%d\\n\",i, *(p_array + i), *(*(p_array + i))); } i= 0的位置0xbfeff3fc, 值為100 i= 1的位置0xbfeff3cc, 值為20 i= 2的位置0xbfeff3c8, 值為30 陣列方式 使用[索引]取出陣列存放的記憶體位址，再對記憶體位址使用取值運算子*，取出記憶體位址存放的內容。 1 2 3 for (int i = 0; i &lt; 3; ++i) { printf(\"i=%d的位置%#x, 值為%d\\n\",i, p_array[i], *p_array[i]); } 指標陣列存放多個字串常數位址 參考 指標陣列存放多個字串常數位址"
  },"/pages/c/array/pointerCharArr/": {
    "title": "char字串指標",
    "keywords": "",
    "url": "/pages/c/array/pointerCharArr/",
    "body": "字串常數 字串常數是包在二個雙引號之間”” \"http://www.google.com\" 以下皆為字串常數 例1 s指標指向字串常數，常數占在記憶體唯讀空間，常數是放在code segment 記憶體區塊，只能讀取，無法修改。 1 char * s = \"http://www.google.com\"; 例2 程式碼中的”abcdefg”是字串常數。 1 2 3 4 5 6 7 8 //使用new動態配置記憶體空間，new會傳回char陣列記憶體區塊的開始記憶體位址。 char* message = new char[100]; //把字串常數abcdefg拷貝至char陣列 strcpy(message, \"abcdefg\"); //記憶體回收 delete[] message; //將指標指向null，代表不指向任何記憶體位址 message = nullptr; 無法透過*取值運算子，把字串常數指派給指標 無法透過*取值運算子，把字串常數指派給指標，以下會編譯錯誤，只能使狦strcpy複製字串常數。 1 2 char* message = new char[100]; *message = \"abcdefg\";//編輯錯誤 字串常數記憶體大小 因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小，注意！strlen不包含結尾\\0的大小，所以計算記憶體空間要再+1，加上結尾\\0的大小 1 2 3 char* s = \"http://www.google.com\";//21個字元(不含結尾\\0) //因為常數非動態記憶空間，所以要透過strlen來計算記憶體空間大小 size_t s_size = strlen(s) + 1;//strlen不包含結尾\\0的大小 字元陣列不是常數 字元陣列不是常數，以下寫法不是常數，是有占stack堆疊的記憶體空間 1 2 3 char s1[] = \"http://www.google.com\"; cout &lt;&lt; \"s1堆疊記憶體大小=\" &lt;&lt; sizeof(s1) &lt;&lt; endl; cout &lt;&lt; \"s1長度=\" &lt;&lt; strlen(s1) &lt;&lt; endl; s1記憶體大小=22 s1長度=21 指向字串常數的指標 參考 字串常數宣告 指標陣列++ 陣列名是常數，不可修改 以下程式分別為字串陣列與指標初始化字串常數，不可以使用字串陣列名++，因為陣列名是指向陣列記憶體的開始位址，到程式結束前都不會改變，陣列名是常數，就像我們不可能寫成7++的意思是一樣的，而指標是變數，變數就是可以改變值(在這裡是改變存放的記憶體位址)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; int main() { //cstr1陣列名是記憶體起始位址 char cstr1[] = \"Hello World!\"; //cstr2是指標變數，指向字串常數\"Hello World!\" //常數是放在code segment 記憶體區塊，不可以使用指標指向常數記憶體位址 char* cstr2 = \"Hello World!\"; cout &lt;&lt; \"cstr1 = \" &lt;&lt; cstr1 &lt;&lt; endl; cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; //cstr1陣列名是記憶體起始位址，是常數，不可以++ //cstr1++; //指標是變數，可以修改 //指標原本指向起始位址\"H\"，++移動1byte，指標指向\"e\"的記憶體位址 cstr2++; //印出ello World!，直到遇到\\0結尾字元，就停止輸出 cout &lt;&lt; \"cstr2 = \" &lt;&lt; cstr2 &lt;&lt; endl; return 0; } cstr1 = Hello World! cstr2 = Hello World! cstr2 = ello World! 字串指標與函式 參考 空字元 strlen *ptr++ size_t 寫一個傳進指標的函式，函式是把來源字串(src)拷貝到目標字串(desc)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* *desc = *src; desc++;//指標往下一個位址移動，移動1byte src++;//指標往下一個位址移動，移動1byte } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的來源字串 char* src = \"Hello World!\"; //+1是為了加上結尾空字元\\0，strlen預設是不含\\0 size_t len = strlen(src) + 1; //拷貝的目標字串 char* desc = new char[len]; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; //記憶體釋放陣列 delete[] desc; //desc指標不指向任何記憶體位址 desc = nullptr; return 0; } desc = Hello World! 另一種寫法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; using namespace std; void copystr(char* desc, char* src) { //若指標指向的記憶體位址的值是\\0就離開while //若指標指向的記憶體位址的值不是\\0就進入while while(*src) { //取出src指標指向的記憶體位址的內容 //使用*取值運算子修改desc指向記憶體位址的* //desc與src指標往下一個位址移動，移動1byte *desc++ = *src++; } //目標字串放上結尾字元，代表字串結束 *desc = '\\0'; } int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; copystr(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } 指標字串拷貝 參考 字串拷貝-strcpy const右邊是星號 char * strcpy ( char * destination, const char * source ); 使用函式庫strcpy來進行字串拷貝，參數2指標前面有const，代表strcpy()函式不能修改source指標所指向的字元，因為指向的字元是常數，但可以改變指標src指向的位址。 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; using namespace std; int main() { //拷貝的目標字串 char desc[100]; //拷貝的來源字串 char* src = \"Hello World!\"; strcpy(desc, src); cout &lt;&lt; \"desc = \" &lt;&lt; desc &lt;&lt; endl; return 0; } desc = Hello World! 指標陣列存放多個字串常數位址 參考 指標陣列存放多個記憶體位址 二維陣列字串 之前二維陣列字串的範例中，定義陣列的大小是7個字串陣列，每個字串固定10byte，記憶體空間就會是70byte，但每個字母有長有短，就會造成記憶體空間上的浪費。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //字串數，7個字串 const int MAX = 10; // 每個字串最大長度，包含\\0 int main() { char str[DAYS][MAX] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; //印出二維陣列字串的記憶體大小 //7個字串 * 每個字串最大長度10byte cout &lt;&lt; \"str size = \" &lt;&lt; sizeof(str) &lt;&lt; endl; for(int i = 0; i &lt; DAYS; i++) { //印出字串 cout &lt;&lt; str[i] &lt;&lt; endl; } return 0; } str size = 70 Sunday Monday Tuesday Wednesday Thursday Friday Saturday 使用指標陣列，存放多個字串常數的記憶體位址，每個字串常數都有起始記憶體位址，即字串常數的第一個字元的位址，就不用定義二維陣列大小去存放字元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; using namespace std; const int DAYS = 7; //陣列裡的指標個數 int main() { //陣列存放7個指標，每個指標指向字串常數的第一個字元的位址 char *arr_ptrs[DAYS] = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"};//字串指標陣列 //指標的固定大小是8byte，指標陣列存放7個指標，總共大小為8byte*7 cout &lt;&lt; \"arr_ptrs size = \" &lt;&lt; sizeof(arr_ptrs) &lt;&lt; endl; for(int i = 0; i &lt; DAYS; i++) cout &lt;&lt; arr_ptrs[i] &lt;&lt; endl; return 0; } arr_ptrs size = 56 Sunday Monday Tuesday Wednesday Thursday Friday Saturday"
  },"/pages/c/reference/callByRef/": {
    "title": "傳參考",
    "keywords": "",
    "url": "/pages/c/reference/callByRef/",
    "body": "參考文件 函式參數為指標 傳值與傳參考的程式碼幾乎一模一樣，差別只在於，傳值無法修改傳入的參數，傳值的意義在於不要讓函式修改傳入的參數，而傳參考是允許函式存取傳入的參數。 宣告 語法 函式回傳資料型態 函式名(資料型態&amp; 別名, ...); void callByRef(int&amp; param1, int&amp; param2); 參數宣告為資料型態&amp;，參數就變成別名，引數 就變成原始變數。 傳值 1 2 3 4 5 6 7 8 9 10 11 12 void callByValue(int param1, int param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByValue(i,j); cout &lt;&lt; \"callByValue:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByValue: i = 10, j = 20 傳參考 呼叫函式時，引數不用加&amp; callByRef(i,j); 1 2 3 4 5 6 7 8 9 10 11 12 void callByRef(int&amp; param1, int&amp; param2){ param1 = 100; param2 = 200; } int main() { int i = 10; int j = 20; callByRef(i,j); cout &lt;&lt; \"callByReference:\" &lt;&lt; endl; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; return 0; } callByReference: i = 100, j = 200 傳值與傳參考的差別 二者只有參數不同。 傳值 void callByValue(int param1, int param2) 傳參考 void callByRef(int&amp; param1, int&amp; param2)"
  },"/pages/c/reference/refToPointer/": {
    "title": "參考指向指標",
    "keywords": "",
    "url": "/pages/c/reference/refToPointer/",
    "body": "Prerequisites: 指標的指標 引數 參考指向指標，代表參考可以像指標一樣，使用*取值運算子，取出原指標指向的記憶體位址中的值，也可以修改原指標指向的記憶體位址中的值，或更改原指標指向的記憶體位址。 宣告參考 資料型態*&amp; 別名 = 原指標; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int i = 10; cout &lt;&lt; \"i address:\" &lt;&lt; &amp;i &lt;&lt; endl; int j = 100; cout &lt;&lt; \"j address:\" &lt;&lt; &amp;j &lt;&lt; endl; //宣告指標 int* ptr_i = &amp;i; //宣告參考 // 原指標指派給參考 int*&amp; ptr_ref = ptr_i; cout &lt;&lt; \"== Change value ==\" &lt;&lt; endl; cout &lt;&lt; \"Before i value:\" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"Before value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; //修改原指標指向的記憶體位址中的值 *ptr_ref = 20; cout &lt;&lt; \"After i value:\" &lt;&lt; i &lt;&lt; endl; //取出原指標指向的記憶體位址中的值 cout &lt;&lt; \"After value:\" &lt;&lt; *ptr_ref &lt;&lt; endl; cout &lt;&lt; \"== Change address ==\" &lt;&lt; endl; cout &lt;&lt; \"Before address:\" &lt;&lt; ptr_ref &lt;&lt; endl; //更改原指標指向的記憶體位址 ptr_ref = &amp;j; cout &lt;&lt; \"after address:\" &lt;&lt; ptr_ref &lt;&lt; endl; return 0; i address:0x7ff7bfeff468 j address:0x7ff7bfeff464 == Change value == Before i value:10 Before value:10 After i value:20 After value:20 == Change address == Before address:0x7ff7bfeff468 after address:0x7ff7bfeff464 參考以下文章 https://www.geeksforgeeks.org/different-ways-to-use-const-with-reference-to-a-pointer-in-c/?ref=ml_lbp References to pointers is a modifiable value that’s used same as a normal pointer. (google翻譯)對指標的參考是一個可修改的值，其使用方式與普通指標相同。 函式參數為指向指標的參考 如果要在函式中修改指標指向的記憶體位址，就需要使用指標的指標，也可以使用參考。 引數為指標，函式參數宣告為指標資料型態*&amp; 別名，這樣才可以修改指標指向的記憶體位址。 參考以下文章 https://www.geeksforgeeks.org/passing-reference-to-a-pointer-in-c/ If a pointer is passed to a function as a parameter and tried to be modified then the changes made to the pointer does not reflects back outside that function. This is because only a copy of the pointer is passed to the function. It can be said that “pass by pointer” is passing a pointer by value. In most cases, this does not present a problem. But the problem comes when you modify the pointer inside the function. Instead of modifying the variable, you are only modifying a copy of the pointer and the original pointer remains unmodified. (google翻譯)如果將指標作為參數傳遞給函數並嘗試對其進行修改，則對指標所做的更改不會反映回該函數外部。這是因為僅將指標的副本傳遞給函數。可以說「透過指標傳遞」就是按值傳遞指標。在大多數情況下，這不會出現問題。但當你修改函數內部的指標時，問題就來了。您只是修改指標的副本，而不是修改變量，而原始指標保持不變。 語法 函式語法 回傳型態 函式名(資料型態*&amp; 別名) { 別名 = 其它記憶體位址 } 呼叫函式語法 函式(指標) 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &amp;global_var; } int main() { int var = 1; int* pointer_to_var = &amp;var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } Before:1 After:100 函式參數指標的指標與指標的別名程式差異 指標的別名 int global_var = 100; // a function with “Reference to pointer” parameter void changeReferenceValue(int*&amp; ptr_ptr){ ptr_ptr = &global_var; } int main() { int var = 1; int* pointer_to_var = &var; cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //把指標變數名傳進函式中 changeReferenceValue(pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 指標的指標 int global_var = 100; void changePointerValue(int** ptr_ptr){ *ptr_ptr = &global_var; //改為指向global_var } int main() { int var = 1; int* pointer_to_var = &var; //指向var cout &lt;&lt; \"Before:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; //passing the address of the pointer //把指標的位址傳進函式中 changePointerValue(&amp;pointer_to_var); cout &lt;&lt; \"After:\" &lt;&lt; *pointer_to_var &lt;&lt; endl; return 0; } 參考指向指標與new 參考文章 指標的指標與new new會返回動態配置記憶體的開始位址，將別名指向new返回的新位址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; using namespace std; //宣告一個函式initAddress() 別名是ref_to_p，指向外部傳入的指標 void initAddress(int*&amp; ref_to_p){ //印出別名指向的記憶體位址 cout &lt;&lt; \"Before address = \" &lt;&lt; ref_to_p &lt;&lt; endl; //動態配置記憶體位址，位址存放的內容為10，使用new會返回動態配置記憶體的開始位址。 ref_to_p = new int(10); //印出別名指向的記憶體位址 cout &lt;&lt; \"After address= \" &lt;&lt; ref_to_p &lt;&lt; \",After value = \" &lt;&lt; *ref_to_p &lt;&lt; endl; } int main() { //宣告指標p，初始化為nullptr，也就是沒有指向任何位址 int* p = nullptr; //呼叫函式initAddress，引數為指標p initAddress(p); //印出指標p的位址，印出指標p指向的位址，對指向的位址取出內容。 cout &lt;&lt; \"== outside == \" &lt;&lt; endl; cout &lt;&lt; \"outside pointer address = \" &lt;&lt; p &lt;&lt; \"，outside pointer value = \" &lt;&lt; *p &lt;&lt; endl; return 0; } Before address = 0x0 After address= 0x600000004010,After value = 10 == outside == outside pointer address = 0x600000004010，outside pointer value = 10"
  },"/pages/c/reference/reference/": {
    "title": "參考",
    "keywords": "",
    "url": "/pages/c/reference/reference/",
    "body": "宣告方法 資料型態&amp; 參考別名 = 原始變數; 注意事項 宣告參考別名時，要初始化原始變數。 初始化後不可改變原始變數。 別名可以存取原始變數，參考別名與原始變數都是指向相同記憶體位址。 宣告 1 2 3 4 5 int i = 10;//原始變數 //宣告參考 int&amp; ref = i;//初始化原始變數，ref是i的別名 cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 由執行結果可知，i跟ref的記憶體位址相同，值也相同。 一定要初始化 以下的程式寫法會編譯錯誤，因為ref參考別名沒有初始化。 1 2 3 int i = 10;//原始變數 //宣告參考 int&amp; ref; 參考別名跟原始變數功能一樣，可以修改跟讀取記憶體內容。 參考別名跟原始變數都指向相同記憶體位址，所以可以做一樣的操作。 1 2 3 4 5 6 7 8 9 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; ref = 30; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 i的記憶體位址 = 0x7ff7bfeff468, i = 30 ref的記憶體位址 = 0x7ff7bfeff468, ref = 30 由執行結果可以發現修改ref參考別名，就等於修改變數i，i跟ref的值都變成30。 一個變數可以多個參考別名 1 2 3 4 5 6 7 8 9 10 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int&amp; ref2 = i; cout &lt;&lt; \"ref2的記憶體位址 = \" &lt;&lt; &amp;ref2 &lt;&lt; \", ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; int&amp; ref3 = i; cout &lt;&lt; \"ref3的記憶體位址 = \" &lt;&lt; &amp;ref3 &lt;&lt; \", ref3 = \" &lt;&lt; ref3 &lt;&lt; endl; i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 ref2的記憶體位址 = 0x7ff7bfeff468, ref2 = 10 ref3的記憶體位址 = 0x7ff7bfeff468, ref3 = 10 各種寫法 &amp;只要介於資料型態與參考別名之間就可以，以下的宣告別名的方式都可以。 1 2 3 4 5 6 int i = 10;//原始變數 //宣告參考別名 int&amp;ref = i; int &amp;ref2 = i; int &amp; ref3 = i; int&amp; ref4 = i; 資料型態要一致，參考別名無強制轉型 以下是錯誤的參考別名宣告 1 2 3 int i = 10;//原始變數 //宣告參考別名 double&amp; ref = i; 原始變數i是int，無法轉成double的資料型態，也沒辦法像指標有強制轉型的功能。 初始化後不可改變原始變數 1 2 3 4 5 6 7 8 9 10 11 int i = 10;//原始變數 //宣告參考 int&amp; ref = i; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", ref = \" &lt;&lt; ref &lt;&lt; endl; int j = 20; ref = j; //將j變數 指派給 ref別名 cout &lt;&lt; \"j的記憶體位址 = \" &lt;&lt; &amp;j &lt;&lt; \", j = \" &lt;&lt; j &lt;&lt; endl; cout &lt;&lt; \"ref的記憶體位址 = \" &lt;&lt; &amp;ref &lt;&lt; \", i = \" &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; \"i的記憶體位址 = \" &lt;&lt; &amp;i &lt;&lt; \", i = \" &lt;&lt; i &lt;&lt; endl; 上方的程式碼 int j = 20; ref = j; //將j變數的值 指派給 ref參考別名 以上意思並非把原始變數設為j，實際上是變數i修改成20，ref是變數i的參考別名，就等同於變數i，所以上述程式碼可以看成i = 20; 執行結果 i的記憶體位址 = 0x7ff7bfeff468, i = 10 ref的記憶體位址 = 0x7ff7bfeff468, ref = 10 j的記憶體位址 = 0x7ff7bfeff45c, j = 20 ref的記憶體位址 = 0x7ff7bfeff468, i = 20 i的記憶體位址 = 0x7ff7bfeff468, i = 20 由執行結果可以發現，執行ref = j;參考別名j的記憶體位址跟i相同，但j的值變成20，i的值也變成20，修改ref就等同於修改i，所謂的參考別名就是給變數i另一個假名ref，但指向的都是相同記憶體位址。"
  },"/pages/c/basic/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/basic/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; }"
  },"/pages/c/basic/lvalue/": {
    "title": "等號左邊lvalue",
    "keywords": "",
    "url": "/pages/c/basic/lvalue/",
    "body": "等號左邊(lavlue)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 常數可以是字串常數、表達式。"
  },"/pages/c/reference/l_r_value/": {
    "title": "l-value與r-value",
    "keywords": "",
    "url": "/pages/c/reference/l_r_value/",
    "body": "l-value = r-value; 在等號左邊的叫l-value，在等號右邊的叫r-value。 l-value lvalue simply means an object that has an identifiable location in memory 可以放在等號左邊，並且可以被指派值都是l-value。 等號左邊(l-value)，也就是一個能夠擺在等號左邊的東西∶一個變數，而非常數。 等號左邊可以是變數、陣列元素、結構、參考、取值運算子。 以下都是lavlue: 有定義資料型態(int, double, float, char, long long …)的變數，可以指派值。 1 2 3 4 // i is l-value int i; //j is l-value int j = 10; // 10 is r-value 有定義資料型態(int, double, float, char, long long …)的指標，可以指向記憶體位址。 Prerequisites: 指標基本觀念 1 2 3 4 //p1 is l-value int* p1; //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value 可以用*取值運算子修改指標指向的記憶體位址的內容 1 2 3 4 5 6 7 8 //j is l-value int j = 10; // 10 is r-value //p2 is l-value int* p2 = &amp;j; //&amp;j is r-value //*p2 is lavlue *p2 = 100; //100 is r-value 可以將變數或指標，指派給&amp;參考 Prerequisites: 參考 參考指向指標 參考變數 1 2 3 4 // i is l-value int i = 10; // 10 is r-value // ref is l-value int&amp; ref = i; 參考指標 1 2 3 4 5 6 7 8 9 10 11 // i is l-value int i = 10; // 10 is r-value //宣告指標 // ptr_i is l-value int* ptr_i = &amp;i; // &amp;i is r-value //宣告參考 // 指標指派給參考 // ref_to_ptr is l-value int*&amp; ref_to_ptr = ptr_i; // ptr_i is l-value 陣列 Prerequisites: 陣列 1 2 // arr is l-value int arr[] = {0,1,2,3}; // 0,1,2,3 is r-value 陣列元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; // str[0] is l-value str[0] = 'H'; // H is r-value // str[1] is l-value str[1] = 'e'; // e is r-value // str[2] is l-value str[2] = 'l'; // l is r-value // str[3] is l-value str[3] = 'l'; // l is r-value // str[4] is l-value str[4] = 'o'; // o is r-value // str[5] is l-value str[5] = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } Hello *(陣列名 + 索引) Prerequisites: 一維陣列與指標 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { // str is l-value char str[6]; //*(str + 0) is l-value *(str + 0) = 'H'; // H is r-value //*(str + 1) is l-value *(str + 1) = 'E'; // E is r-value //*(str + 2) is l-value *(str + 2) = 'L'; // L is r-value //*(str + 3) is l-value *(str + 3) = 'L'; // L is r-value //*(str + 4) is l-value *(str + 4) = 'O'; // O is r-value //*(str + 5) is l-value *(str + 5) = '\\0'; // \\0 is r-value cout &lt;&lt; str &lt;&lt; endl; return 0; } HELLO 指標指向陣列 Prerequisites: 一維陣列與指標 1 2 3 4 // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value const與指標 Prerequisites: const與指標 1 2 3 4 //var1 is l-value int var1 = 10; // 10 is r-value // p is l-value const int* p = &amp;var1; // &amp;var1 is r-value r-value r-value” refers to data value that is stored at some address in memory. 等號右邊的東西可以是字串常數、表達式。 以下是r-value: 字串常數 Prerequisites: char字串 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { // cstr2 is l-value char cstr2[] = \"hello\"; // hello is r-value //cstr3 is l-value char cstr3[6] = \"hello\";// hello is r-value //cstr4 is l-value char cstr4[] = {\"hello\"};// hello is r-value //cstr5 is l-value char cstr5[6] = {\"hello\"};// hello is r-value //cstr6 is l-value char cstr6[6] {\"hello\"};// hello is r-value return 0; } &amp;陣列 與 &amp;陣列[索引] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // array is l-value cout &lt;&lt; \"陣列名 = \" &lt;&lt; array &lt;&lt; endl; // &amp;array is r-value cout &lt;&lt; \"陣列名地址 = \" &lt;&lt; &amp;array &lt;&lt; endl; // &amp;array[0] is r-value cout &lt;&lt; \"array[0]地址 = \" &lt;&lt; &amp;array[0] &lt;&lt; endl; // &amp;array[1] is r-value cout &lt;&lt; \"array[1]地址 = \" &lt;&lt; &amp;array[1] &lt;&lt; endl; // &amp;array[2] is r-value cout &lt;&lt; \"array[2]地址 = \" &lt;&lt; &amp;array[2] &lt;&lt; endl; // &amp;array[3] is r-value cout &lt;&lt; \"array[3]地址 = \" &lt;&lt; &amp;array[3] &lt;&lt; endl; return 0; } 指標 + 整數(0,1,2,3 …) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value cout &lt;&lt; \"p指標內容 = \" &lt;&lt; p &lt;&lt; endl; //p + 0 is r-value cout &lt;&lt; \"p指標+0 = \" &lt;&lt; p + 0 &lt;&lt; endl; //p + 1 is r-value cout &lt;&lt; \"p指標+1 = \" &lt;&lt; p + 1 &lt;&lt; endl; //p + 2 is r-value cout &lt;&lt; \"p指標+2 = \" &lt;&lt; p + 2 &lt;&lt; endl; //p + 3 is r-value cout &lt;&lt; \"p指標+3 = \" &lt;&lt; p + 3 &lt;&lt; endl; return 0; } 1 2 3 4 5 6 7 8 9 int main() { // array is l-value int array[5]; // p is l-value int* p = array; // array is l-value // p is l-value p = p + 1; // p + 1 is r-value return 0; }"
  },"/pages/c/reference/constRef/": {
    "title": "const與參考",
    "keywords": "",
    "url": "/pages/c/reference/constRef/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 const參考與r-value 下方程式可以指派常數100到常數參考ref1。 const int&amp; ref1 = 100; 如果常數指派到參考，卻沒加上const修飾子，就會編譯錯誤，因為參考不支援常數。 Non-const lvalue reference to type ‘int’ cannot bind to a temporary of type ‘int’ int&amp; ref1 = 100; 若使用const參考，編譯器會產生一個臨時變數temp，把常數100指派到臨時變數中，再把臨時變數指派給參考。 int temp = 100; const int&amp; ref = temp; const參考與自動轉型 當引數為常數給函式，除了r-value參考可以接收常數，const參考也可以接收常數，二者功能相同。 const參考會自動轉型，下面例子將’C’自動轉型為int 1 2 3 4 5 6 7 int main() { const int&amp; ref1 = 100; cout &lt;&lt; \"ref1 = \" &lt;&lt; ref1 &lt;&lt; endl; const int&amp; ref2 = 'C'; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; return 0; } ref1 = 100 ref2 = 67 函式參數為const參考 1 2 3 4 5 6 7 8 void func(const int&amp; ref) { cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; } int main() { func(100); // 常數 100 , 100 is r-value func('A'); // 常數 'A' , A is r-value return 0; } ref = 100 ref = 65"
  },"/pages/c/reference/l_r_ref/": {
    "title": "l-value參考與r-value參考",
    "keywords": "",
    "url": "/pages/c/reference/l_r_ref/",
    "body": "Prerequisites: l-value與r-value l-value參考 l-value參考指向變數 1 2 3 4 5 6 7 8 9 int main() { int i = 10; int&amp; l_ref = i; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; l_ref = 55; cout &lt;&lt; \"l-value ref = \" &lt;&lt; l_ref &lt;&lt; endl; return 0; } l-value ref = 10 === modify ref === l-value ref = 55 r-value參考 r-value參考指向數字 1 2 3 4 5 6 7 8 int main() { int&amp;&amp; r_ref = 100; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; cout &lt;&lt; \"=== modify ref === \" &lt;&lt; endl; r_ref = 1000; cout &lt;&lt; \"r-value ref = \" &lt;&lt; r_ref &lt;&lt; endl; return 0; } r-value ref = 100 === modify ref === r-value ref = 1000 函式參數為l-value參考 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; using namespace std; void func(int&amp; l_ref) { l_ref = 20; } int main() { int i = 10; cout &lt;&lt; \"before i = \" &lt;&lt; i &lt;&lt; endl; func(i); cout &lt;&lt; \"after i = \" &lt;&lt; i &lt;&lt; endl; return 0; } before i = 10 after i = 20 函式參數為r-value參考 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; using namespace std; void func(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func(1000); return 0; } r-value = 1000 引數與參數r-value參考資料型態不同 引數與參數的資料型態不同，若自動轉型可以轉成功，也可以使用r-value參考。 1 2 3 4 5 6 7 void func1(int&amp;&amp; r_ref) { cout &lt;&lt; \"r-value = \" &lt;&lt; r_ref &lt;&lt; endl; } int main() { func1('B'); return 0; } r-value = 66"
  },"/pages/c/reference/callByValue/": {
    "title": "函式傳值與回傳值",
    "keywords": "",
    "url": "/pages/c/reference/callByValue/",
    "body": "Prerequisites: 引數 函式傳遞值 Call by value 函式會建立新的變數將引數拷貝到新的變數，將新的變數作為參數，所以在函式對參數做的任何操作，實際上是對新的變數做操作，而不是對引數做操作。 以下程式碼是將引數x傳遞給函式setX()，將引數x拷貝到參數r，對參數r進行修改，並不會影嚮x引數。 1 2 3 4 5 6 7 8 9 10 11 12 //r為參數 void setX(int r){ r = 1000; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x為引數 setX(x); cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 10 函式傳回值是值 函式會將傳回值拷貝到暫存器或stack中，然後再傳回拷貝到暫存器或stack中的值，接下來再把函式中區域變數記憶體釋放。 1 2 3 4 5 6 7 8 9 int getValue(){ int r = 1000; return r; } int main() { int r = getValue(); cout &lt;&lt; \"r = \" &lt;&lt; r &lt;&lt; endl; return 0; } r = 1000"
  },"/pages/c/reference/func_return_ref/": {
    "title": "函式傳回值是參考",
    "keywords": "",
    "url": "/pages/c/reference/func_return_ref/",
    "body": "Prerequisites: 傳參考 函式傳回值是值 若傳回值是參考別名，將不會拷貝傳回值到暫存器或stack。 函式宣告語法 資料型態&amp; 函式名(資料型態&amp; 參考別名) int&amp; getValue(int&amp; z); 函式呼叫方式 y是原始變數的參考別名。 資料型態&amp; 參考別名 = 函式(原始變數); int&amp; y = getValue(原始變數); 以下程式碼z與y都是x(原始變數)的參考別名，z與y與x三者都指向相同記憶體位址。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/reference/l_ref_func/": {
    "title": "等號左邊的函式",
    "keywords": "",
    "url": "/pages/c/reference/l_ref_func/",
    "body": "Prerequisites: l-value與r-value l-value參考與r-value參考 引數 函式傳回值是參考 函式傳回值是參考別名 以下程式碼是將全域變數x的參考別名作為傳回值。 1 2 3 4 5 6 //全域變數 int x = 10; //返回全域變數x的參考別名 int&amp; setX(){ return x; } 將setX() = 99可以視作為int&amp; x_ref = 99; 二者是相同意思。 1 setX() = 99; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 //全域變數 int x = 10; //返回全域變數x的參考 int&amp; setX(){ return x; } int main() { cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //將x全域變數參考，設值成99 setX() = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 不能傳回區域變數的參考 以下程式碼會出錯，因為區域變數x在函式結束的時候就會被系統記憶體釋放，無法作為參考。 1 2 3 4 int&amp; setX(){ int x = 10; return x; } 引數作為參考 以下程式碼將main()函式中的x變數傳進setX()的函式，並回傳x變數的匿名參考別名。 將x的參考設值99。 1 2 3 4 5 6 7 8 9 10 11 12 13 //回傳值為參考別名 //參數r為x的參考別名 int&amp; setX(int&amp; r){ return r; } int main() { int x = 10; cout &lt;&lt; \"Before x = \" &lt;&lt; x &lt;&lt; endl; //x傳入函式，回傳x的參考 setX(x) = 99; cout &lt;&lt; \"After x = \" &lt;&lt; x &lt;&lt; endl; return 0; } Before x = 10 After x = 99 函式不想放在等號左邊 若不想被人修改傳回值，可將傳回值設為const，但函式呼叫者也需要加上const。 函式語法 const 資料型態&amp; 函式名(資料型態&amp; 原始變數); const int&amp; getValue(int&amp; z); 函式呼叫者 const 資料型態&amp; 別名 = 函式名(原始變數); const int&amp; y = getValue(x); 以下程式碼將編譯錯誤，函式無法放在等號左邊。 getValue(x) = 100; 以下為完整程式碼 1 2 3 4 5 6 7 8 9 10 11 const int&amp; getValue(int&amp; z){ z++; return z; } int main() { int x = 10; const int&amp; y = getValue(x); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; return 0; } x = 11 y = 11"
  },"/pages/c/struct/struct_def/": {
    "title": "定義結構",
    "keywords": "",
    "url": "/pages/c/struct/struct_def/",
    "body": "結構是變數的集合，變數可以不是不同型態，例如有的是int，有的是float，結構中每一個變數都是該結構的成員。 定義結構有以下三種方式 方式1 宣告結構 關鍵字struct宣告，緊號於struct後的是結構名稱，變數的宣告都在大括號{}內，大括號{}結尾一定要加上分號; struct 結構名{ 變數宣告 }; 1 2 3 4 5 6 struct Student{ //學生姓名 char* name; //學號 int id; }; 結構放置位置 放在main()上面，或者放在標頭檔。 定義結構變數 結構可想像成一種新的資料型態，int也是一種資料型態，定義結構變數會在記憶體配置空間。 結構名 變數名; 1 2 3 4 int main() { Student student; return 0; } 存取結構成員 使用點運算子(dot operator)存取結構成員。 1 2 3 Student student; student.name = \"Mary\"; student.id = 1; cout讀取結構成員。 1 2 cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } Mary 1 方式2 同時宣告結構與定義結構變數 在大括號的結尾輸入結構變數，在main()函數不用定義結構變數，直接使用結構變數。 struct 結構名{ 變數宣告 }結構變數; 1 2 3 4 5 6 struct Student{ //學生姓名 char* name; //學號 int id; }student; 存取結構成員 在main()函數不用定義結構變數，直接使用結構變數。 1 2 3 4 5 6 7 int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; using namespace std; struct Student{ //學生姓名 char* name; //學號 int id; }student; int main() { student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; } 方式3 宣告結構 使用typedef(型別定義)關鍵字，後面緊跟著struct關鍵字，再來是大括號{}，變數的宣告在大括號{}中，結構名放在大括號結尾，最後加上分號;結束。 typedef struct{ 變數宣告 }結構名; 1 2 3 4 5 6 typedef struct{ //學生姓名 char* name; //學號 int id; }Student; 定義結構變數 結構名 變數名; 1 Student student; 存取結構成員 與方式一相同。 完整程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; using namespace std; typedef struct{ //學生姓名 char* name; //學號 int id; }Student; int main() { Student student; student.name = \"Mary\"; student.id = 1; cout &lt;&lt; student.name &lt;&lt; endl; cout &lt;&lt; student.id &lt;&lt; endl; return 0; }"
  }}
